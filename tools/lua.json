{
    "Load scene": {
        "prefix": "LoadScene",
        "body": [
            "SceneManager.LoadScene('$1')"
        ],
        "description": "Load scene"
    },
    "Log info": {
        "prefix": "logInfo",
        "body": [
            "logInfo('$1')"
        ],
        "description": "logInfo"
    },
    "Log debug": {
        "prefix": "logDebug",
        "body": [
            "logDebug('$1')"
        ],
        "description": "logDebug"
    },
    "Log warn": {
        "prefix": "logWarn",
        "body": [
            "logWarn('$1')"
        ],
        "description": "logWarn"
    },
    "Log error": {
        "prefix": "logError",
        "body": [
            "logError('$1')"
        ],
        "description": "logError"
    },
    "AndroidInput.secondaryTouchEnabled": {
        "prefix": "AndroidInput.secondaryTouchEnabled",
        "body": [
            "secondaryTouchEnabled"
        ],
        "description": "return:static bool des: Property indicating whether the system provides secondary touch input."
    },
    "AndroidInput.secondaryTouchHeight": {
        "prefix": "AndroidInput.secondaryTouchHeight",
        "body": [
            "secondaryTouchHeight"
        ],
        "description": "return:static int des: Property indicating the height of the secondary touchpad."
    },
    "AndroidInput.secondaryTouchWidth": {
        "prefix": "AndroidInput.secondaryTouchWidth",
        "body": [
            "secondaryTouchWidth"
        ],
        "description": "return:static int des: Property indicating the width of the secondary touchpad."
    },
    "AndroidInput.touchCountSecondary": {
        "prefix": "AndroidInput.touchCountSecondary",
        "body": [
            "touchCountSecondary"
        ],
        "description": "return:static int des: Number of secondary touches. Guaranteed not to change throughout the frame. (Read Only)."
    },
    "AndroidJNIHelper.debug": {
        "prefix": "AndroidJNIHelper.debug",
        "body": [
            "debug"
        ],
        "description": "return:static bool des: Set debug to true to log calls through the AndroidJNIHelper."
    },
    "Application.absoluteURL": {
        "prefix": "Application.absoluteURL",
        "body": [
            "absoluteURL"
        ],
        "description": "return:static string des: The URL of the document (what is shown in a browser's address bar) for WebGL (Read Only)."
    },
    "Application.backgroundLoadingPriority": {
        "prefix": "Application.backgroundLoadingPriority",
        "body": [
            "backgroundLoadingPriority"
        ],
        "description": "return:static ThreadPriority des: Priority of background loading thread."
    },
    "Application.buildGUID": {
        "prefix": "Application.buildGUID",
        "body": [
            "buildGUID"
        ],
        "description": "return:static string des: Returns a GUID for this build (Read Only)."
    },
    "Application.cloudProjectId": {
        "prefix": "Application.cloudProjectId",
        "body": [
            "cloudProjectId"
        ],
        "description": "return:static string des: A unique cloud project identifier. It is unique for every project (Read Only)."
    },
    "Application.companyName": {
        "prefix": "Application.companyName",
        "body": [
            "companyName"
        ],
        "description": "return:static string des: Return application company name (Read Only)."
    },
    "Application.dataPath": {
        "prefix": "Application.dataPath",
        "body": [
            "dataPath"
        ],
        "description": "return:static string des: Contains the path to the game data folder (Read Only)."
    },
    "Application.genuine": {
        "prefix": "Application.genuine",
        "body": [
            "genuine"
        ],
        "description": "return:static bool des: Returns false if application is altered in any way after it was built."
    },
    "Application.genuineCheckAvailable": {
        "prefix": "Application.genuineCheckAvailable",
        "body": [
            "genuineCheckAvailable"
        ],
        "description": "return:static bool des: Returns true if application integrity can be confirmed."
    },
    "Application.identifier": {
        "prefix": "Application.identifier",
        "body": [
            "identifier"
        ],
        "description": "return:static string des: Returns application identifier at runtime. On Apple platforms this is the 'bundleIdentifier' saved in the info.plist file, on Android it's the 'package' from the AndroidManifest.xml."
    },
    "Application.installerName": {
        "prefix": "Application.installerName",
        "body": [
            "installerName"
        ],
        "description": "return:static string des: Returns the name of the store or package that installed the application (Read Only)."
    },
    "Application.installMode": {
        "prefix": "Application.installMode",
        "body": [
            "installMode"
        ],
        "description": "return:static ApplicationInstallMode des: Returns application install mode (Read Only)."
    },
    "Application.internetReachability": {
        "prefix": "Application.internetReachability",
        "body": [
            "internetReachability"
        ],
        "description": "return:static NetworkReachability des: Returns the type of Internet reachability currently possible on the device."
    },
    "Application.isBatchMode": {
        "prefix": "Application.isBatchMode",
        "body": [
            "isBatchMode"
        ],
        "description": "return:static bool des: Returns true when Unity is launched with the -batchmode flag from the command line (Read Only)."
    },
    "Application.isConsolePlatform": {
        "prefix": "Application.isConsolePlatform",
        "body": [
            "isConsolePlatform"
        ],
        "description": "return:static bool des: Is the current Runtime platform a known console platform."
    },
    "Application.isEditor": {
        "prefix": "Application.isEditor",
        "body": [
            "isEditor"
        ],
        "description": "return:static bool des: Are we running inside the Unity editor? (Read Only)"
    },
    "Application.isFocused": {
        "prefix": "Application.isFocused",
        "body": [
            "isFocused"
        ],
        "description": "return:static bool des: Whether the player currently has focus. Read-only."
    },
    "Application.isMobilePlatform": {
        "prefix": "Application.isMobilePlatform",
        "body": [
            "isMobilePlatform"
        ],
        "description": "return:static bool des: Is the current Runtime platform a known mobile platform."
    },
    "Application.isPlaying": {
        "prefix": "Application.isPlaying",
        "body": [
            "isPlaying"
        ],
        "description": "return:static bool des: Returns true when in any kind of player is active.(Read Only)."
    },
    "Application.persistentDataPath": {
        "prefix": "Application.persistentDataPath",
        "body": [
            "persistentDataPath"
        ],
        "description": "return:static string des: Contains the path to a persistent data directory (Read Only)."
    },
    "Application.platform": {
        "prefix": "Application.platform",
        "body": [
            "platform"
        ],
        "description": "return:static RuntimePlatform des: Returns the platform the game is running on (Read Only)."
    },
    "Application.productName": {
        "prefix": "Application.productName",
        "body": [
            "productName"
        ],
        "description": "return:static string des: Returns application product name (Read Only)."
    },
    "Application.runInBackground": {
        "prefix": "Application.runInBackground",
        "body": [
            "runInBackground"
        ],
        "description": "return:static bool des: Should the player be running when the application is in the background?"
    },
    "Application.sandboxType": {
        "prefix": "Application.sandboxType",
        "body": [
            "sandboxType"
        ],
        "description": "return:static ApplicationSandboxType des: Returns application running in sandbox (Read Only)."
    },
    "Application.streamingAssetsPath": {
        "prefix": "Application.streamingAssetsPath",
        "body": [
            "streamingAssetsPath"
        ],
        "description": "return:static string des: Contains the path to the StreamingAssets folder (Read Only)."
    },
    "Application.systemLanguage": {
        "prefix": "Application.systemLanguage",
        "body": [
            "systemLanguage"
        ],
        "description": "return:static SystemLanguage des: The language the user's operating system is running in."
    },
    "Application.targetFrameRate": {
        "prefix": "Application.targetFrameRate",
        "body": [
            "targetFrameRate"
        ],
        "description": "return:static int des: Instructs game to try to render at a specified frame rate."
    },
    "Application.temporaryCachePath": {
        "prefix": "Application.temporaryCachePath",
        "body": [
            "temporaryCachePath"
        ],
        "description": "return:static string des: Contains the path to a temporary data / cache directory (Read Only)."
    },
    "Application.unityVersion": {
        "prefix": "Application.unityVersion",
        "body": [
            "unityVersion"
        ],
        "description": "return:static string des: The version of the Unity runtime used to play the content."
    },
    "Application.version": {
        "prefix": "Application.version",
        "body": [
            "version"
        ],
        "description": "return:static string des: Returns application version number (Read Only)."
    },
    "AudioListener.pause": {
        "prefix": "AudioListener.pause",
        "body": [
            "pause"
        ],
        "description": "return:static bool des: The paused state of the audio system."
    },
    "AudioListener.volume": {
        "prefix": "AudioListener.volume",
        "body": [
            "volume"
        ],
        "description": "return:static float des: Controls the game sound volume (0.0 to 1.0)."
    },
    "AudioSettings.driverCapabilities": {
        "prefix": "AudioSettings.driverCapabilities",
        "body": [
            "driverCapabilities"
        ],
        "description": "return:static AudioSpeakerMode des: Returns the speaker mode capability of the current audio driver. (Read Only)"
    },
    "AudioSettings.dspTime": {
        "prefix": "AudioSettings.dspTime",
        "body": [
            "dspTime"
        ],
        "description": "return:static double des: Returns the current time of the audio system."
    },
    "AudioSettings.outputSampleRate": {
        "prefix": "AudioSettings.outputSampleRate",
        "body": [
            "outputSampleRate"
        ],
        "description": "return:static int des: Get the mixer's current output rate."
    },
    "AudioSettings.speakerMode": {
        "prefix": "AudioSettings.speakerMode",
        "body": [
            "speakerMode"
        ],
        "description": "return:static AudioSpeakerMode des: Gets the current speaker mode. Default is 2 channel stereo."
    },
    "Caching.cacheCount": {
        "prefix": "Caching.cacheCount",
        "body": [
            "cacheCount"
        ],
        "description": "return:static int des: Returns the cache count in the cache list."
    },
    "Caching.compressionEnabled": {
        "prefix": "Caching.compressionEnabled",
        "body": [
            "compressionEnabled"
        ],
        "description": "return:static bool des: Controls compression of cache data. Enabled by default."
    },
    "Caching.currentCacheForWriting": {
        "prefix": "Caching.currentCacheForWriting",
        "body": [
            "currentCacheForWriting"
        ],
        "description": "return:static Cache des: Gets or sets the current cache in which AssetBundles should be cached."
    },
    "Caching.defaultCache": {
        "prefix": "Caching.defaultCache",
        "body": [
            "defaultCache"
        ],
        "description": "return:static Cache des: Returns the default cache which is added by Unity internally."
    },
    "Caching.ready": {
        "prefix": "Caching.ready",
        "body": [
            "ready"
        ],
        "description": "return:static bool des: Returns true if Caching system is ready for use."
    },
    "Camera.allCameras": {
        "prefix": "Camera.allCameras",
        "body": [
            "allCameras"
        ],
        "description": "return:static Camera[] des: Returns all enabled cameras in the Scene."
    },
    "Camera.allCamerasCount": {
        "prefix": "Camera.allCamerasCount",
        "body": [
            "allCamerasCount"
        ],
        "description": "return:static int des: The number of cameras in the current Scene."
    },
    "Camera.current": {
        "prefix": "Camera.current",
        "body": [
            "current"
        ],
        "description": "return:static Camera des: The camera we are currently rendering with, for low-level render control only (Read Only)."
    },
    "Camera.main": {
        "prefix": "Camera.main",
        "body": [
            "main"
        ],
        "description": "return:static Camera des: The first enabled camera tagged \"MainCamera\" (Read Only)."
    },
    "Camera.onPostRender": {
        "prefix": "Camera.onPostRender",
        "body": [
            "onPostRender"
        ],
        "description": "return:static Camera.CameraCallback des: Event that is fired after any camera finishes rendering."
    },
    "Camera.onPreCull": {
        "prefix": "Camera.onPreCull",
        "body": [
            "onPreCull"
        ],
        "description": "return:static Camera.CameraCallback des: Event that is fired before any camera starts culling."
    },
    "Camera.onPreRender": {
        "prefix": "Camera.onPreRender",
        "body": [
            "onPreRender"
        ],
        "description": "return:static Camera.CameraCallback des: Event that is fired before any camera starts rendering."
    },
    "ClusterNetwork.isDisconnected": {
        "prefix": "ClusterNetwork.isDisconnected",
        "body": [
            "isDisconnected"
        ],
        "description": "return:static bool des: Check whether the current instance is disconnected from the cluster network."
    },
    "ClusterNetwork.isMasterOfCluster": {
        "prefix": "ClusterNetwork.isMasterOfCluster",
        "body": [
            "isMasterOfCluster"
        ],
        "description": "return:static bool des: Check whether the current instance is a master node in the cluster network."
    },
    "ClusterNetwork.nodeIndex": {
        "prefix": "ClusterNetwork.nodeIndex",
        "body": [
            "nodeIndex"
        ],
        "description": "return:static int des: To acquire or set the node index of the current machine from the cluster network."
    },
    "Color.black": {
        "prefix": "Color.black",
        "body": [
            "black"
        ],
        "description": "return:static Color des: Solid black. RGBA is (0, 0, 0, 1)."
    },
    "Color.blue": {
        "prefix": "Color.blue",
        "body": [
            "blue"
        ],
        "description": "return:static Color des: Solid blue. RGBA is (0, 0, 1, 1)."
    },
    "Color.clear": {
        "prefix": "Color.clear",
        "body": [
            "clear"
        ],
        "description": "return:static Color des: Completely transparent. RGBA is (0, 0, 0, 0)."
    },
    "Color.cyan": {
        "prefix": "Color.cyan",
        "body": [
            "cyan"
        ],
        "description": "return:static Color des: Cyan. RGBA is (0, 1, 1, 1)."
    },
    "Color.gray": {
        "prefix": "Color.gray",
        "body": [
            "gray"
        ],
        "description": "return:static Color des: Gray. RGBA is (0.5, 0.5, 0.5, 1)."
    },
    "Color.green": {
        "prefix": "Color.green",
        "body": [
            "green"
        ],
        "description": "return:static Color des: Solid green. RGBA is (0, 1, 0, 1)."
    },
    "Color.grey": {
        "prefix": "Color.grey",
        "body": [
            "grey"
        ],
        "description": "return:static Color des: English spelling for gray. RGBA is the same (0.5, 0.5, 0.5, 1)."
    },
    "Color.magenta": {
        "prefix": "Color.magenta",
        "body": [
            "magenta"
        ],
        "description": "return:static Color des: Magenta. RGBA is (1, 0, 1, 1)."
    },
    "Color.red": {
        "prefix": "Color.red",
        "body": [
            "red"
        ],
        "description": "return:static Color des: Solid red. RGBA is (1, 0, 0, 1)."
    },
    "Color.white": {
        "prefix": "Color.white",
        "body": [
            "white"
        ],
        "description": "return:static Color des: Solid white. RGBA is (1, 1, 1, 1)."
    },
    "Color.yellow": {
        "prefix": "Color.yellow",
        "body": [
            "yellow"
        ],
        "description": "return:static Color des: Yellow. RGBA is (1, 0.92, 0.016, 1), but the color is nice to look at!"
    },
    "CrashReport.lastReport": {
        "prefix": "CrashReport.lastReport",
        "body": [
            "lastReport"
        ],
        "description": "return:static CrashReport des: Returns last crash report, or null if no reports are available."
    },
    "CrashReport.reports": {
        "prefix": "CrashReport.reports",
        "body": [
            "reports"
        ],
        "description": "return:static CrashReport[] des: Returns all currently available reports in a new array."
    },
    "Cubemap.currentTextureMemory": {
        "prefix": "Cubemap.currentTextureMemory",
        "body": [
            "currentTextureMemory"
        ],
        "description": "return:static ulong des: The amount of memory currently being used by textures."
    },
    "Cubemap.desiredTextureMemory": {
        "prefix": "Cubemap.desiredTextureMemory",
        "body": [
            "desiredTextureMemory"
        ],
        "description": "return:static ulong des: This amount of texture memory would be used before the texture streaming budget is applied."
    },
    "Cubemap.nonStreamingTextureCount": {
        "prefix": "Cubemap.nonStreamingTextureCount",
        "body": [
            "nonStreamingTextureCount"
        ],
        "description": "return:static ulong des: Number of non-streaming textures."
    },
    "Cubemap.nonStreamingTextureMemory": {
        "prefix": "Cubemap.nonStreamingTextureMemory",
        "body": [
            "nonStreamingTextureMemory"
        ],
        "description": "return:static ulong des: Total amount of memory being used by non-streaming textures."
    },
    "Cubemap.streamingMipmapUploadCount": {
        "prefix": "Cubemap.streamingMipmapUploadCount",
        "body": [
            "streamingMipmapUploadCount"
        ],
        "description": "return:static ulong des: How many times has a texture been uploaded due to texture mipmap streaming."
    },
    "Cubemap.streamingRendererCount": {
        "prefix": "Cubemap.streamingRendererCount",
        "body": [
            "streamingRendererCount"
        ],
        "description": "return:static ulong des: Number of renderers registered with the texture streaming system."
    },
    "Cubemap.streamingTextureCount": {
        "prefix": "Cubemap.streamingTextureCount",
        "body": [
            "streamingTextureCount"
        ],
        "description": "return:static ulong des: Number of streaming textures."
    },
    "Cubemap.streamingTextureDiscardUnusedMips": {
        "prefix": "Cubemap.streamingTextureDiscardUnusedMips",
        "body": [
            "streamingTextureDiscardUnusedMips"
        ],
        "description": "return:static bool des: Force the streaming texture system to discard all unused mipmaps immediately, rather than caching them until the texture memory budget is exceeded."
    },
    "Cubemap.streamingTextureForceLoadAll": {
        "prefix": "Cubemap.streamingTextureForceLoadAll",
        "body": [
            "streamingTextureForceLoadAll"
        ],
        "description": "return:static bool des: Force streaming textures to load all mipmap levels."
    },
    "Cubemap.streamingTextureLoadingCount": {
        "prefix": "Cubemap.streamingTextureLoadingCount",
        "body": [
            "streamingTextureLoadingCount"
        ],
        "description": "return:static ulong des: Number of streaming textures with mipmaps currently loading."
    },
    "Cubemap.streamingTexturePendingLoadCount": {
        "prefix": "Cubemap.streamingTexturePendingLoadCount",
        "body": [
            "streamingTexturePendingLoadCount"
        ],
        "description": "return:static ulong des: Number of streaming textures with outstanding mipmaps to be loaded."
    },
    "Cubemap.targetTextureMemory": {
        "prefix": "Cubemap.targetTextureMemory",
        "body": [
            "targetTextureMemory"
        ],
        "description": "return:static ulong des: The amount of memory used by textures after the mipmap streaming and budget are applied and loading is complete."
    },
    "Cubemap.totalTextureMemory": {
        "prefix": "Cubemap.totalTextureMemory",
        "body": [
            "totalTextureMemory"
        ],
        "description": "return:static ulong des: The total amount of memory that would be used by all textures at mipmap level 0."
    },
    "CubemapArray.currentTextureMemory": {
        "prefix": "CubemapArray.currentTextureMemory",
        "body": [
            "currentTextureMemory"
        ],
        "description": "return:static ulong des: The amount of memory currently being used by textures."
    },
    "CubemapArray.desiredTextureMemory": {
        "prefix": "CubemapArray.desiredTextureMemory",
        "body": [
            "desiredTextureMemory"
        ],
        "description": "return:static ulong des: This amount of texture memory would be used before the texture streaming budget is applied."
    },
    "CubemapArray.nonStreamingTextureCount": {
        "prefix": "CubemapArray.nonStreamingTextureCount",
        "body": [
            "nonStreamingTextureCount"
        ],
        "description": "return:static ulong des: Number of non-streaming textures."
    },
    "CubemapArray.nonStreamingTextureMemory": {
        "prefix": "CubemapArray.nonStreamingTextureMemory",
        "body": [
            "nonStreamingTextureMemory"
        ],
        "description": "return:static ulong des: Total amount of memory being used by non-streaming textures."
    },
    "CubemapArray.streamingMipmapUploadCount": {
        "prefix": "CubemapArray.streamingMipmapUploadCount",
        "body": [
            "streamingMipmapUploadCount"
        ],
        "description": "return:static ulong des: How many times has a texture been uploaded due to texture mipmap streaming."
    },
    "CubemapArray.streamingRendererCount": {
        "prefix": "CubemapArray.streamingRendererCount",
        "body": [
            "streamingRendererCount"
        ],
        "description": "return:static ulong des: Number of renderers registered with the texture streaming system."
    },
    "CubemapArray.streamingTextureCount": {
        "prefix": "CubemapArray.streamingTextureCount",
        "body": [
            "streamingTextureCount"
        ],
        "description": "return:static ulong des: Number of streaming textures."
    },
    "CubemapArray.streamingTextureDiscardUnusedMips": {
        "prefix": "CubemapArray.streamingTextureDiscardUnusedMips",
        "body": [
            "streamingTextureDiscardUnusedMips"
        ],
        "description": "return:static bool des: Force the streaming texture system to discard all unused mipmaps immediately, rather than caching them until the texture memory budget is exceeded."
    },
    "CubemapArray.streamingTextureForceLoadAll": {
        "prefix": "CubemapArray.streamingTextureForceLoadAll",
        "body": [
            "streamingTextureForceLoadAll"
        ],
        "description": "return:static bool des: Force streaming textures to load all mipmap levels."
    },
    "CubemapArray.streamingTextureLoadingCount": {
        "prefix": "CubemapArray.streamingTextureLoadingCount",
        "body": [
            "streamingTextureLoadingCount"
        ],
        "description": "return:static ulong des: Number of streaming textures with mipmaps currently loading."
    },
    "CubemapArray.streamingTexturePendingLoadCount": {
        "prefix": "CubemapArray.streamingTexturePendingLoadCount",
        "body": [
            "streamingTexturePendingLoadCount"
        ],
        "description": "return:static ulong des: Number of streaming textures with outstanding mipmaps to be loaded."
    },
    "CubemapArray.targetTextureMemory": {
        "prefix": "CubemapArray.targetTextureMemory",
        "body": [
            "targetTextureMemory"
        ],
        "description": "return:static ulong des: The amount of memory used by textures after the mipmap streaming and budget are applied and loading is complete."
    },
    "CubemapArray.totalTextureMemory": {
        "prefix": "CubemapArray.totalTextureMemory",
        "body": [
            "totalTextureMemory"
        ],
        "description": "return:static ulong des: The total amount of memory that would be used by all textures at mipmap level 0."
    },
    "Cursor.lockState": {
        "prefix": "Cursor.lockState",
        "body": [
            "lockState"
        ],
        "description": "return:static CursorLockMode des: Determines whether the hardware pointer is locked to the center of the view, constrained to the window, or not constrained at all."
    },
    "Cursor.visible": {
        "prefix": "Cursor.visible",
        "body": [
            "visible"
        ],
        "description": "return:static bool des: Determines whether the hardware pointer is visible or not."
    },
    "CustomRenderTexture.active": {
        "prefix": "CustomRenderTexture.active",
        "body": [
            "active"
        ],
        "description": "return:static RenderTexture des: Currently active render texture."
    },
    "CustomRenderTexture.currentTextureMemory": {
        "prefix": "CustomRenderTexture.currentTextureMemory",
        "body": [
            "currentTextureMemory"
        ],
        "description": "return:static ulong des: The amount of memory currently being used by textures."
    },
    "CustomRenderTexture.desiredTextureMemory": {
        "prefix": "CustomRenderTexture.desiredTextureMemory",
        "body": [
            "desiredTextureMemory"
        ],
        "description": "return:static ulong des: This amount of texture memory would be used before the texture streaming budget is applied."
    },
    "CustomRenderTexture.nonStreamingTextureCount": {
        "prefix": "CustomRenderTexture.nonStreamingTextureCount",
        "body": [
            "nonStreamingTextureCount"
        ],
        "description": "return:static ulong des: Number of non-streaming textures."
    },
    "CustomRenderTexture.nonStreamingTextureMemory": {
        "prefix": "CustomRenderTexture.nonStreamingTextureMemory",
        "body": [
            "nonStreamingTextureMemory"
        ],
        "description": "return:static ulong des: Total amount of memory being used by non-streaming textures."
    },
    "CustomRenderTexture.streamingMipmapUploadCount": {
        "prefix": "CustomRenderTexture.streamingMipmapUploadCount",
        "body": [
            "streamingMipmapUploadCount"
        ],
        "description": "return:static ulong des: How many times has a texture been uploaded due to texture mipmap streaming."
    },
    "CustomRenderTexture.streamingRendererCount": {
        "prefix": "CustomRenderTexture.streamingRendererCount",
        "body": [
            "streamingRendererCount"
        ],
        "description": "return:static ulong des: Number of renderers registered with the texture streaming system."
    },
    "CustomRenderTexture.streamingTextureCount": {
        "prefix": "CustomRenderTexture.streamingTextureCount",
        "body": [
            "streamingTextureCount"
        ],
        "description": "return:static ulong des: Number of streaming textures."
    },
    "CustomRenderTexture.streamingTextureDiscardUnusedMips": {
        "prefix": "CustomRenderTexture.streamingTextureDiscardUnusedMips",
        "body": [
            "streamingTextureDiscardUnusedMips"
        ],
        "description": "return:static bool des: Force the streaming texture system to discard all unused mipmaps immediately, rather than caching them until the texture memory budget is exceeded."
    },
    "CustomRenderTexture.streamingTextureForceLoadAll": {
        "prefix": "CustomRenderTexture.streamingTextureForceLoadAll",
        "body": [
            "streamingTextureForceLoadAll"
        ],
        "description": "return:static bool des: Force streaming textures to load all mipmap levels."
    },
    "CustomRenderTexture.streamingTextureLoadingCount": {
        "prefix": "CustomRenderTexture.streamingTextureLoadingCount",
        "body": [
            "streamingTextureLoadingCount"
        ],
        "description": "return:static ulong des: Number of streaming textures with mipmaps currently loading."
    },
    "CustomRenderTexture.streamingTexturePendingLoadCount": {
        "prefix": "CustomRenderTexture.streamingTexturePendingLoadCount",
        "body": [
            "streamingTexturePendingLoadCount"
        ],
        "description": "return:static ulong des: Number of streaming textures with outstanding mipmaps to be loaded."
    },
    "CustomRenderTexture.targetTextureMemory": {
        "prefix": "CustomRenderTexture.targetTextureMemory",
        "body": [
            "targetTextureMemory"
        ],
        "description": "return:static ulong des: The amount of memory used by textures after the mipmap streaming and budget are applied and loading is complete."
    },
    "CustomRenderTexture.totalTextureMemory": {
        "prefix": "CustomRenderTexture.totalTextureMemory",
        "body": [
            "totalTextureMemory"
        ],
        "description": "return:static ulong des: The total amount of memory that would be used by all textures at mipmap level 0."
    },
    "Debug.developerConsoleVisible": {
        "prefix": "Debug.developerConsoleVisible",
        "body": [
            "developerConsoleVisible"
        ],
        "description": "return:static bool des: Reports whether the development console is visible. The development console cannot be made to appear using:"
    },
    "Debug.isDebugBuild": {
        "prefix": "Debug.isDebugBuild",
        "body": [
            "isDebugBuild"
        ],
        "description": "return:static bool des: In the Build Settings dialog there is a check box called \"Development Build\"."
    },
    "Debug.unityLogger": {
        "prefix": "Debug.unityLogger",
        "body": [
            "unityLogger"
        ],
        "description": "return:static ILogger des: Get default debug logger."
    },
    "Display.displays": {
        "prefix": "Display.displays",
        "body": [
            "displays"
        ],
        "description": "return:static Display[] des: The list of currently connected Displays. Contains at least one (main) display."
    },
    "Display.main": {
        "prefix": "Display.main",
        "body": [
            "main"
        ],
        "description": "return:static Display des: Main Display."
    },
    "DynamicGI.indirectScale": {
        "prefix": "DynamicGI.indirectScale",
        "body": [
            "indirectScale"
        ],
        "description": "return:static float des: Allows for scaling the contribution coming from realtime & static lightmaps."
    },
    "DynamicGI.isConverged": {
        "prefix": "DynamicGI.isConverged",
        "body": [
            "isConverged"
        ],
        "description": "return:static bool des: Is precomputed realtime Global Illumination output converged?"
    },
    "DynamicGI.synchronousMode": {
        "prefix": "DynamicGI.synchronousMode",
        "body": [
            "synchronousMode"
        ],
        "description": "return:static bool des: When enabled, new dynamic Global Illumination output is shown in each frame."
    },
    "DynamicGI.updateThreshold": {
        "prefix": "DynamicGI.updateThreshold",
        "body": [
            "updateThreshold"
        ],
        "description": "return:static float des: Threshold for limiting updates of realtime GI. The unit of measurement is \"percentage intensity change\"."
    },
    "Event.current": {
        "prefix": "Event.current",
        "body": [
            "current"
        ],
        "description": "return:static Event des: The current event that's being processed right now."
    },
    "Gizmos.color": {
        "prefix": "Gizmos.color",
        "body": [
            "color"
        ],
        "description": "return:static Color des: Sets the color for the gizmos that will be drawn next."
    },
    "Gizmos.matrix": {
        "prefix": "Gizmos.matrix",
        "body": [
            "matrix"
        ],
        "description": "return:static Matrix4x4 des: Set the gizmo matrix used to draw all gizmos."
    },
    "GL.invertCulling": {
        "prefix": "GL.invertCulling",
        "body": [
            "invertCulling"
        ],
        "description": "return:static bool des: Select whether to invert the backface culling (true) or not (false)."
    },
    "GL.LINE_STRIP": {
        "prefix": "GL.LINE_STRIP",
        "body": [
            "LINE_STRIP"
        ],
        "description": "return:static int des: Mode for Begin: draw line strip."
    },
    "GL.LINES": {
        "prefix": "GL.LINES",
        "body": [
            "LINES"
        ],
        "description": "return:static int des: Mode for Begin: draw lines."
    },
    "GL.modelview": {
        "prefix": "GL.modelview",
        "body": [
            "modelview"
        ],
        "description": "return:static Matrix4x4 des: The current modelview matrix."
    },
    "GL.QUADS": {
        "prefix": "GL.QUADS",
        "body": [
            "QUADS"
        ],
        "description": "return:static int des: Mode for Begin: draw quads."
    },
    "GL.sRGBWrite": {
        "prefix": "GL.sRGBWrite",
        "body": [
            "sRGBWrite"
        ],
        "description": "return:static bool des: Controls whether Linear-to-sRGB color conversion is performed while rendering."
    },
    "GL.TRIANGLE_STRIP": {
        "prefix": "GL.TRIANGLE_STRIP",
        "body": [
            "TRIANGLE_STRIP"
        ],
        "description": "return:static int des: Mode for Begin: draw triangle strip."
    },
    "GL.TRIANGLES": {
        "prefix": "GL.TRIANGLES",
        "body": [
            "TRIANGLES"
        ],
        "description": "return:static int des: Mode for Begin: draw triangles."
    },
    "GL.wireframe": {
        "prefix": "GL.wireframe",
        "body": [
            "wireframe"
        ],
        "description": "return:static bool des: Should rendering be done in wireframe?"
    },
    "Graphics.activeColorBuffer": {
        "prefix": "Graphics.activeColorBuffer",
        "body": [
            "activeColorBuffer"
        ],
        "description": "return:static RenderBuffer des: Currently active color buffer (Read Only)."
    },
    "Graphics.activeColorGamut": {
        "prefix": "Graphics.activeColorGamut",
        "body": [
            "activeColorGamut"
        ],
        "description": "return:static ColorGamut des: Returns the currently active color gamut."
    },
    "Graphics.activeDepthBuffer": {
        "prefix": "Graphics.activeDepthBuffer",
        "body": [
            "activeDepthBuffer"
        ],
        "description": "return:static RenderBuffer des: Currently active depth/stencil buffer (Read Only)."
    },
    "Graphics.activeTier": {
        "prefix": "Graphics.activeTier",
        "body": [
            "activeTier"
        ],
        "description": "return:static Rendering.GraphicsTier des: Graphics Tier classification for current device. Changing this value affects any subsequently loaded shaders. Initially this value is auto-detected from the hardware in use."
    },
    "GUI.backgroundColor": {
        "prefix": "GUI.backgroundColor",
        "body": [
            "backgroundColor"
        ],
        "description": "return:static Color des: Global tinting color for all background elements rendered by the GUI."
    },
    "GUI.changed": {
        "prefix": "GUI.changed",
        "body": [
            "changed"
        ],
        "description": "return:static bool des: Returns true if any controls changed the value of the input data."
    },
    "GUI.color": {
        "prefix": "GUI.color",
        "body": [
            "color"
        ],
        "description": "return:static Color des: Global tinting color for the GUI."
    },
    "GUI.contentColor": {
        "prefix": "GUI.contentColor",
        "body": [
            "contentColor"
        ],
        "description": "return:static Color des: Tinting color for all text rendered by the GUI."
    },
    "GUI.depth": {
        "prefix": "GUI.depth",
        "body": [
            "depth"
        ],
        "description": "return:static int des: The sorting depth of the currently executing GUI behaviour."
    },
    "GUI.enabled": {
        "prefix": "GUI.enabled",
        "body": [
            "enabled"
        ],
        "description": "return:static bool des: Is the GUI enabled?"
    },
    "GUI.matrix": {
        "prefix": "GUI.matrix",
        "body": [
            "matrix"
        ],
        "description": "return:static Matrix4x4 des: The GUI transform matrix."
    },
    "GUI.skin": {
        "prefix": "GUI.skin",
        "body": [
            "skin"
        ],
        "description": "return:static GUISkin des: The global skin to use."
    },
    "GUI.tooltip": {
        "prefix": "GUI.tooltip",
        "body": [
            "tooltip"
        ],
        "description": "return:static string des: The tooltip of the control the mouse is currently over, or which has keyboard focus. (Read Only)."
    },
    "GUIContent.none": {
        "prefix": "GUIContent.none",
        "body": [
            "none"
        ],
        "description": "return:static GUIContent des: Shorthand for empty content."
    },
    "GUIStyle.none": {
        "prefix": "GUIStyle.none",
        "body": [
            "none"
        ],
        "description": "return:static GUIStyle des: Shortcut for an empty GUIStyle."
    },
    "GUIUtility.hasModalWindow": {
        "prefix": "GUIUtility.hasModalWindow",
        "body": [
            "hasModalWindow"
        ],
        "description": "return:static bool des: A global property, which is true if a ModalWindow is being displayed, false otherwise."
    },
    "GUIUtility.hotControl": {
        "prefix": "GUIUtility.hotControl",
        "body": [
            "hotControl"
        ],
        "description": "return:static int des: The controlID of the current hot control."
    },
    "GUIUtility.keyboardControl": {
        "prefix": "GUIUtility.keyboardControl",
        "body": [
            "keyboardControl"
        ],
        "description": "return:static int des: The controlID of the control that has keyboard focus."
    },
    "GUIUtility.systemCopyBuffer": {
        "prefix": "GUIUtility.systemCopyBuffer",
        "body": [
            "systemCopyBuffer"
        ],
        "description": "return:static string des: Get access to the system-wide clipboard."
    },
    "HumanTrait.BoneCount": {
        "prefix": "HumanTrait.BoneCount",
        "body": [
            "BoneCount"
        ],
        "description": "return:static int des: The number of human bone types defined by Mecanim."
    },
    "HumanTrait.BoneName": {
        "prefix": "HumanTrait.BoneName",
        "body": [
            "BoneName"
        ],
        "description": "return:static string[] des: Array of the names of all human bone types defined by Mecanim."
    },
    "HumanTrait.MuscleCount": {
        "prefix": "HumanTrait.MuscleCount",
        "body": [
            "MuscleCount"
        ],
        "description": "return:static int des: The number of human muscle types defined by Mecanim."
    },
    "HumanTrait.MuscleName": {
        "prefix": "HumanTrait.MuscleName",
        "body": [
            "MuscleName"
        ],
        "description": "return:static string[] des: Array of the names of all human muscle types defined by Mecanim."
    },
    "HumanTrait.RequiredBoneCount": {
        "prefix": "HumanTrait.RequiredBoneCount",
        "body": [
            "RequiredBoneCount"
        ],
        "description": "return:static int des: The number of bone types that are required by Mecanim for any human model."
    },
    "Input.acceleration": {
        "prefix": "Input.acceleration",
        "body": [
            "acceleration"
        ],
        "description": "return:static Vector3 des: Last measured linear acceleration of a device in three-dimensional space. (Read Only)"
    },
    "Input.accelerationEventCount": {
        "prefix": "Input.accelerationEventCount",
        "body": [
            "accelerationEventCount"
        ],
        "description": "return:static int des: Number of acceleration measurements which occurred during last frame."
    },
    "Input.accelerationEvents": {
        "prefix": "Input.accelerationEvents",
        "body": [
            "accelerationEvents"
        ],
        "description": "return:static AccelerationEvent[] des: Returns list of acceleration measurements which occurred during the last frame. (Read Only) (Allocates temporary variables)."
    },
    "Input.anyKey": {
        "prefix": "Input.anyKey",
        "body": [
            "anyKey"
        ],
        "description": "return:static bool des: Is any key or mouse button currently held down? (Read Only)"
    },
    "Input.anyKeyDown": {
        "prefix": "Input.anyKeyDown",
        "body": [
            "anyKeyDown"
        ],
        "description": "return:static bool des: Returns true the first frame the user hits any key or mouse button. (Read Only)"
    },
    "Input.backButtonLeavesApp": {
        "prefix": "Input.backButtonLeavesApp",
        "body": [
            "backButtonLeavesApp"
        ],
        "description": "return:static bool des: Should Back button quit the application?"
    },
    "Input.compass": {
        "prefix": "Input.compass",
        "body": [
            "compass"
        ],
        "description": "return:static Compass des: Property for accessing compass (handheld devices only). (Read Only)"
    },
    "Input.compensateSensors": {
        "prefix": "Input.compensateSensors",
        "body": [
            "compensateSensors"
        ],
        "description": "return:static bool des: This property controls if input sensors should be compensated for screen orientation."
    },
    "Input.compositionCursorPos": {
        "prefix": "Input.compositionCursorPos",
        "body": [
            "compositionCursorPos"
        ],
        "description": "return:static Vector2 des: The current text input position used by IMEs to open windows."
    },
    "Input.compositionString": {
        "prefix": "Input.compositionString",
        "body": [
            "compositionString"
        ],
        "description": "return:static string des: The current IME composition string being typed by the user."
    },
    "Input.deviceOrientation": {
        "prefix": "Input.deviceOrientation",
        "body": [
            "deviceOrientation"
        ],
        "description": "return:static DeviceOrientation des: Device physical orientation as reported by OS. (Read Only)"
    },
    "Input.gyro": {
        "prefix": "Input.gyro",
        "body": [
            "gyro"
        ],
        "description": "return:static Gyroscope des: Returns default gyroscope."
    },
    "Input.imeCompositionMode": {
        "prefix": "Input.imeCompositionMode",
        "body": [
            "imeCompositionMode"
        ],
        "description": "return:static IMECompositionMode des: Controls enabling and disabling of IME input composition."
    },
    "Input.imeIsSelected": {
        "prefix": "Input.imeIsSelected",
        "body": [
            "imeIsSelected"
        ],
        "description": "return:static bool des: Does the user have an IME keyboard input source selected?"
    },
    "Input.inputString": {
        "prefix": "Input.inputString",
        "body": [
            "inputString"
        ],
        "description": "return:static string des: Returns the keyboard input entered this frame. (Read Only)"
    },
    "Input.location": {
        "prefix": "Input.location",
        "body": [
            "location"
        ],
        "description": "return:static LocationService des: Property for accessing device location (handheld devices only). (Read Only)"
    },
    "Input.mousePosition": {
        "prefix": "Input.mousePosition",
        "body": [
            "mousePosition"
        ],
        "description": "return:static Vector3 des: The current mouse position in pixel coordinates. (Read Only)"
    },
    "Input.mousePresent": {
        "prefix": "Input.mousePresent",
        "body": [
            "mousePresent"
        ],
        "description": "return:static bool des: Indicates if a mouse device is detected."
    },
    "Input.mouseScrollDelta": {
        "prefix": "Input.mouseScrollDelta",
        "body": [
            "mouseScrollDelta"
        ],
        "description": "return:static Vector2 des: The current mouse scroll delta. (Read Only)"
    },
    "Input.multiTouchEnabled": {
        "prefix": "Input.multiTouchEnabled",
        "body": [
            "multiTouchEnabled"
        ],
        "description": "return:static bool des: Property indicating whether the system handles multiple touches."
    },
    "Input.simulateMouseWithTouches": {
        "prefix": "Input.simulateMouseWithTouches",
        "body": [
            "simulateMouseWithTouches"
        ],
        "description": "return:static bool des: Enables/Disables mouse simulation with touches. By default this option is enabled."
    },
    "Input.stylusTouchSupported": {
        "prefix": "Input.stylusTouchSupported",
        "body": [
            "stylusTouchSupported"
        ],
        "description": "return:static bool des: Returns true when Stylus Touch is supported by a device or platform."
    },
    "Input.touchCount": {
        "prefix": "Input.touchCount",
        "body": [
            "touchCount"
        ],
        "description": "return:static int des: Number of touches. Guaranteed not to change throughout the frame. (Read Only)"
    },
    "Input.touches": {
        "prefix": "Input.touches",
        "body": [
            "touches"
        ],
        "description": "return:static Touch[] des: Returns list of objects representing status of all touches during last frame. (Read Only) (Allocates temporary variables)."
    },
    "Input.touchPressureSupported": {
        "prefix": "Input.touchPressureSupported",
        "body": [
            "touchPressureSupported"
        ],
        "description": "return:static bool des: Bool value which let's users check if touch pressure is supported."
    },
    "Input.touchSupported": {
        "prefix": "Input.touchSupported",
        "body": [
            "touchSupported"
        ],
        "description": "return:static bool des: Returns whether the device on which application is currently running supports touch input."
    },
    "LightmapSettings.lightmaps": {
        "prefix": "LightmapSettings.lightmaps",
        "body": [
            "lightmaps"
        ],
        "description": "return:static LightmapData[] des: Lightmap array."
    },
    "LightmapSettings.lightmapsMode": {
        "prefix": "LightmapSettings.lightmapsMode",
        "body": [
            "lightmapsMode"
        ],
        "description": "return:static LightmapsMode des: NonDirectional or CombinedDirectional Specular lightmaps rendering mode."
    },
    "LightmapSettings.lightProbes": {
        "prefix": "LightmapSettings.lightProbes",
        "body": [
            "lightProbes"
        ],
        "description": "return:static LightProbes des: Holds all data needed by the light probes."
    },
    "LightProbeProxyVolume.isFeatureSupported": {
        "prefix": "LightProbeProxyVolume.isFeatureSupported",
        "body": [
            "isFeatureSupported"
        ],
        "description": "return:static bool des: Checks if Light Probe Proxy Volumes are supported."
    },
    "LODGroup.crossFadeAnimationDuration": {
        "prefix": "LODGroup.crossFadeAnimationDuration",
        "body": [
            "crossFadeAnimationDuration"
        ],
        "description": "return:static float des: The cross-fading animation duration in seconds. ArgumentException will be thrown if it is set to zero or a negative value."
    },
    "Mathf.Deg2Rad": {
        "prefix": "Mathf.Deg2Rad",
        "body": [
            "Deg2Rad"
        ],
        "description": "return:static float des: Degrees-to-radians conversion constant (Read Only)."
    },
    "Mathf.Epsilon": {
        "prefix": "Mathf.Epsilon",
        "body": [
            "Epsilon"
        ],
        "description": "return:static float des: A tiny floating point value (Read Only)."
    },
    "Mathf.Infinity": {
        "prefix": "Mathf.Infinity",
        "body": [
            "Infinity"
        ],
        "description": "return:static float des: A representation of positive infinity (Read Only)."
    },
    "Mathf.NegativeInfinity": {
        "prefix": "Mathf.NegativeInfinity",
        "body": [
            "NegativeInfinity"
        ],
        "description": "return:static float des: A representation of negative infinity (Read Only)."
    },
    "Mathf.PI": {
        "prefix": "Mathf.PI",
        "body": [
            "PI"
        ],
        "description": "return:static float des: The well-known 3.14159265358979... value (Read Only)."
    },
    "Mathf.Rad2Deg": {
        "prefix": "Mathf.Rad2Deg",
        "body": [
            "Rad2Deg"
        ],
        "description": "return:static float des: Radians-to-degrees conversion constant (Read Only)."
    },
    "Matrix4x4.identity": {
        "prefix": "Matrix4x4.identity",
        "body": [
            "identity"
        ],
        "description": "return:static Matrix4x4 des: Returns the identity matrix (Read Only)."
    },
    "Matrix4x4.zero": {
        "prefix": "Matrix4x4.zero",
        "body": [
            "zero"
        ],
        "description": "return:static Matrix4x4 des: Returns a matrix with all elements set to zero (Read Only)."
    },
    "Microphone.devices": {
        "prefix": "Microphone.devices",
        "body": [
            "devices"
        ],
        "description": "return:static string[] des: A list of available microphone devices, identified by name."
    },
    "MovieTexture.currentTextureMemory": {
        "prefix": "MovieTexture.currentTextureMemory",
        "body": [
            "currentTextureMemory"
        ],
        "description": "return:static ulong des: The amount of memory currently being used by textures."
    },
    "MovieTexture.desiredTextureMemory": {
        "prefix": "MovieTexture.desiredTextureMemory",
        "body": [
            "desiredTextureMemory"
        ],
        "description": "return:static ulong des: This amount of texture memory would be used before the texture streaming budget is applied."
    },
    "MovieTexture.nonStreamingTextureCount": {
        "prefix": "MovieTexture.nonStreamingTextureCount",
        "body": [
            "nonStreamingTextureCount"
        ],
        "description": "return:static ulong des: Number of non-streaming textures."
    },
    "MovieTexture.nonStreamingTextureMemory": {
        "prefix": "MovieTexture.nonStreamingTextureMemory",
        "body": [
            "nonStreamingTextureMemory"
        ],
        "description": "return:static ulong des: Total amount of memory being used by non-streaming textures."
    },
    "MovieTexture.streamingMipmapUploadCount": {
        "prefix": "MovieTexture.streamingMipmapUploadCount",
        "body": [
            "streamingMipmapUploadCount"
        ],
        "description": "return:static ulong des: How many times has a texture been uploaded due to texture mipmap streaming."
    },
    "MovieTexture.streamingRendererCount": {
        "prefix": "MovieTexture.streamingRendererCount",
        "body": [
            "streamingRendererCount"
        ],
        "description": "return:static ulong des: Number of renderers registered with the texture streaming system."
    },
    "MovieTexture.streamingTextureCount": {
        "prefix": "MovieTexture.streamingTextureCount",
        "body": [
            "streamingTextureCount"
        ],
        "description": "return:static ulong des: Number of streaming textures."
    },
    "MovieTexture.streamingTextureDiscardUnusedMips": {
        "prefix": "MovieTexture.streamingTextureDiscardUnusedMips",
        "body": [
            "streamingTextureDiscardUnusedMips"
        ],
        "description": "return:static bool des: Force the streaming texture system to discard all unused mipmaps immediately, rather than caching them until the texture memory budget is exceeded."
    },
    "MovieTexture.streamingTextureForceLoadAll": {
        "prefix": "MovieTexture.streamingTextureForceLoadAll",
        "body": [
            "streamingTextureForceLoadAll"
        ],
        "description": "return:static bool des: Force streaming textures to load all mipmap levels."
    },
    "MovieTexture.streamingTextureLoadingCount": {
        "prefix": "MovieTexture.streamingTextureLoadingCount",
        "body": [
            "streamingTextureLoadingCount"
        ],
        "description": "return:static ulong des: Number of streaming textures with mipmaps currently loading."
    },
    "MovieTexture.streamingTexturePendingLoadCount": {
        "prefix": "MovieTexture.streamingTexturePendingLoadCount",
        "body": [
            "streamingTexturePendingLoadCount"
        ],
        "description": "return:static ulong des: Number of streaming textures with outstanding mipmaps to be loaded."
    },
    "MovieTexture.targetTextureMemory": {
        "prefix": "MovieTexture.targetTextureMemory",
        "body": [
            "targetTextureMemory"
        ],
        "description": "return:static ulong des: The amount of memory used by textures after the mipmap streaming and budget are applied and loading is complete."
    },
    "MovieTexture.totalTextureMemory": {
        "prefix": "MovieTexture.totalTextureMemory",
        "body": [
            "totalTextureMemory"
        ],
        "description": "return:static ulong des: The total amount of memory that would be used by all textures at mipmap level 0."
    },
    "Physics.AllLayers": {
        "prefix": "Physics.AllLayers",
        "body": [
            "AllLayers"
        ],
        "description": "return:static int des: Layer mask constant to select all layers."
    },
    "Physics.autoSimulation": {
        "prefix": "Physics.autoSimulation",
        "body": [
            "autoSimulation"
        ],
        "description": "return:static bool des: Sets whether the physics should be simulated automatically or not."
    },
    "Physics.autoSyncTransforms": {
        "prefix": "Physics.autoSyncTransforms",
        "body": [
            "autoSyncTransforms"
        ],
        "description": "return:static bool des: Whether or not to automatically sync transform changes with the physics system whenever a Transform component changes."
    },
    "Physics.bounceThreshold": {
        "prefix": "Physics.bounceThreshold",
        "body": [
            "bounceThreshold"
        ],
        "description": "return:static float des: Two colliding objects with a relative velocity below this will not bounce (default 2). Must be positive."
    },
    "Physics.defaultContactOffset": {
        "prefix": "Physics.defaultContactOffset",
        "body": [
            "defaultContactOffset"
        ],
        "description": "return:static float des: The default contact offset of the newly created colliders."
    },
    "Physics.DefaultRaycastLayers": {
        "prefix": "Physics.DefaultRaycastLayers",
        "body": [
            "DefaultRaycastLayers"
        ],
        "description": "return:static int des: Layer mask constant to select default raycast layers."
    },
    "Physics.defaultSolverIterations": {
        "prefix": "Physics.defaultSolverIterations",
        "body": [
            "defaultSolverIterations"
        ],
        "description": "return:static int des: The defaultSolverIterations determines how accurately Rigidbody joints and collision contacts are resolved. (default 6). Must be positive."
    },
    "Physics.defaultSolverVelocityIterations": {
        "prefix": "Physics.defaultSolverVelocityIterations",
        "body": [
            "defaultSolverVelocityIterations"
        ],
        "description": "return:static int des: The defaultSolverVelocityIterations affects how accurately the Rigidbody joints and collision contacts are resolved. (default 1). Must be positive."
    },
    "Physics.gravity": {
        "prefix": "Physics.gravity",
        "body": [
            "gravity"
        ],
        "description": "return:static Vector3 des: The gravity applied to all rigid bodies in the scene."
    },
    "Physics.IgnoreRaycastLayer": {
        "prefix": "Physics.IgnoreRaycastLayer",
        "body": [
            "IgnoreRaycastLayer"
        ],
        "description": "return:static int des: Layer mask constant to select ignore raycast layer."
    },
    "Physics.interCollisionDistance": {
        "prefix": "Physics.interCollisionDistance",
        "body": [
            "interCollisionDistance"
        ],
        "description": "return:static float des: Sets the minimum separation distance for cloth inter-collision."
    },
    "Physics.interCollisionStiffness": {
        "prefix": "Physics.interCollisionStiffness",
        "body": [
            "interCollisionStiffness"
        ],
        "description": "return:static float des: Sets the cloth inter-collision stiffness."
    },
    "Physics.queriesHitBackfaces": {
        "prefix": "Physics.queriesHitBackfaces",
        "body": [
            "queriesHitBackfaces"
        ],
        "description": "return:static bool des: Whether physics queries should hit back-face triangles."
    },
    "Physics.queriesHitTriggers": {
        "prefix": "Physics.queriesHitTriggers",
        "body": [
            "queriesHitTriggers"
        ],
        "description": "return:static bool des: Specifies whether queries (raycasts, spherecasts, overlap tests, etc.) hit Triggers by default."
    },
    "Physics.sleepThreshold": {
        "prefix": "Physics.sleepThreshold",
        "body": [
            "sleepThreshold"
        ],
        "description": "return:static float des: The mass-normalized energy threshold, below which objects start going to sleep."
    },
    "Physics2D.AllLayers": {
        "prefix": "Physics2D.AllLayers",
        "body": [
            "AllLayers"
        ],
        "description": "return:static int des: Layer mask constant that includes all layers."
    },
    "Physics2D.alwaysShowColliders": {
        "prefix": "Physics2D.alwaysShowColliders",
        "body": [
            "alwaysShowColliders"
        ],
        "description": "return:static bool des: Should the collider gizmos always be shown even when they are not selected?"
    },
    "Physics2D.angularSleepTolerance": {
        "prefix": "Physics2D.angularSleepTolerance",
        "body": [
            "angularSleepTolerance"
        ],
        "description": "return:static float des: A rigid-body cannot sleep if its angular velocity is above this tolerance."
    },
    "Physics2D.autoSimulation": {
        "prefix": "Physics2D.autoSimulation",
        "body": [
            "autoSimulation"
        ],
        "description": "return:static bool des: Sets whether the physics should be simulated automatically or not."
    },
    "Physics2D.autoSyncTransforms": {
        "prefix": "Physics2D.autoSyncTransforms",
        "body": [
            "autoSyncTransforms"
        ],
        "description": "return:static bool des: Whether or not to automatically sync transform changes with the physics system whenever a Transform component changes."
    },
    "Physics2D.baumgarteScale": {
        "prefix": "Physics2D.baumgarteScale",
        "body": [
            "baumgarteScale"
        ],
        "description": "return:static float des: The scale factor that controls how fast overlaps are resolved."
    },
    "Physics2D.baumgarteTOIScale": {
        "prefix": "Physics2D.baumgarteTOIScale",
        "body": [
            "baumgarteTOIScale"
        ],
        "description": "return:static float des: The scale factor that controls how fast TOI overlaps are resolved."
    },
    "Physics2D.callbacksOnDisable": {
        "prefix": "Physics2D.callbacksOnDisable",
        "body": [
            "callbacksOnDisable"
        ],
        "description": "return:static bool des: Use this to control whether or not the appropriate OnCollisionExit2D or OnTriggerExit2D callbacks should be called when a Collider2D is disabled."
    },
    "Physics2D.colliderAABBColor": {
        "prefix": "Physics2D.colliderAABBColor",
        "body": [
            "colliderAABBColor"
        ],
        "description": "return:static Color des: Sets the color used by the gizmos to show all Collider axis-aligned bounding boxes (AABBs)."
    },
    "Physics2D.colliderAsleepColor": {
        "prefix": "Physics2D.colliderAsleepColor",
        "body": [
            "colliderAsleepColor"
        ],
        "description": "return:static Color des: The color used by the gizmos to show all asleep colliders (collider is asleep when the body is asleep)."
    },
    "Physics2D.colliderAwakeColor": {
        "prefix": "Physics2D.colliderAwakeColor",
        "body": [
            "colliderAwakeColor"
        ],
        "description": "return:static Color des: The color used by the gizmos to show all awake colliders (collider is awake when the body is awake)."
    },
    "Physics2D.colliderContactColor": {
        "prefix": "Physics2D.colliderContactColor",
        "body": [
            "colliderContactColor"
        ],
        "description": "return:static Color des: The color used by the gizmos to show all collider contacts."
    },
    "Physics2D.contactArrowScale": {
        "prefix": "Physics2D.contactArrowScale",
        "body": [
            "contactArrowScale"
        ],
        "description": "return:static float des: The scale of the contact arrow used by the collider gizmos."
    },
    "Physics2D.defaultContactOffset": {
        "prefix": "Physics2D.defaultContactOffset",
        "body": [
            "defaultContactOffset"
        ],
        "description": "return:static float des: The default contact offset of the newly created colliders."
    },
    "Physics2D.DefaultRaycastLayers": {
        "prefix": "Physics2D.DefaultRaycastLayers",
        "body": [
            "DefaultRaycastLayers"
        ],
        "description": "return:static int des: Layer mask constant that includes all layers participating in raycasts by default."
    },
    "Physics2D.gravity": {
        "prefix": "Physics2D.gravity",
        "body": [
            "gravity"
        ],
        "description": "return:static Vector2 des: Acceleration due to gravity."
    },
    "Physics2D.IgnoreRaycastLayer": {
        "prefix": "Physics2D.IgnoreRaycastLayer",
        "body": [
            "IgnoreRaycastLayer"
        ],
        "description": "return:static int des: Layer mask constant for the default layer that ignores raycasts."
    },
    "Physics2D.jobOptions": {
        "prefix": "Physics2D.jobOptions",
        "body": [
            "jobOptions"
        ],
        "description": "return:static PhysicsJobOptions2D des: A set of options that control how physics operates when using the job system to multithread the physics simulation."
    },
    "Physics2D.linearSleepTolerance": {
        "prefix": "Physics2D.linearSleepTolerance",
        "body": [
            "linearSleepTolerance"
        ],
        "description": "return:static float des: A rigid-body cannot sleep if its linear velocity is above this tolerance."
    },
    "Physics2D.maxAngularCorrection": {
        "prefix": "Physics2D.maxAngularCorrection",
        "body": [
            "maxAngularCorrection"
        ],
        "description": "return:static float des: The maximum angular position correction used when solving constraints. This helps to prevent overshoot."
    },
    "Physics2D.maxLinearCorrection": {
        "prefix": "Physics2D.maxLinearCorrection",
        "body": [
            "maxLinearCorrection"
        ],
        "description": "return:static float des: The maximum linear position correction used when solving constraints. This helps to prevent overshoot."
    },
    "Physics2D.maxRotationSpeed": {
        "prefix": "Physics2D.maxRotationSpeed",
        "body": [
            "maxRotationSpeed"
        ],
        "description": "return:static float des: The maximum angular speed of a rigid-body per physics update. Increasing this can cause numerical problems."
    },
    "Physics2D.maxTranslationSpeed": {
        "prefix": "Physics2D.maxTranslationSpeed",
        "body": [
            "maxTranslationSpeed"
        ],
        "description": "return:static float des: The maximum linear speed of a rigid-body per physics update. Increasing this can cause numerical problems."
    },
    "Physics2D.positionIterations": {
        "prefix": "Physics2D.positionIterations",
        "body": [
            "positionIterations"
        ],
        "description": "return:static int des: The number of iterations of the physics solver when considering objects' positions."
    },
    "Physics2D.queriesHitTriggers": {
        "prefix": "Physics2D.queriesHitTriggers",
        "body": [
            "queriesHitTriggers"
        ],
        "description": "return:static bool des: Do raycasts detect Colliders configured as triggers?"
    },
    "Physics2D.queriesStartInColliders": {
        "prefix": "Physics2D.queriesStartInColliders",
        "body": [
            "queriesStartInColliders"
        ],
        "description": "return:static bool des: Sets the raycasts or linecasts that start inside Colliders to detect or not detect those Colliders."
    },
    "Physics2D.showColliderAABB": {
        "prefix": "Physics2D.showColliderAABB",
        "body": [
            "showColliderAABB"
        ],
        "description": "return:static bool des: Should the collider gizmos show the AABBs for each collider?"
    },
    "Physics2D.showColliderContacts": {
        "prefix": "Physics2D.showColliderContacts",
        "body": [
            "showColliderContacts"
        ],
        "description": "return:static bool des: Should the collider gizmos show current contacts for each collider?"
    },
    "Physics2D.showColliderSleep": {
        "prefix": "Physics2D.showColliderSleep",
        "body": [
            "showColliderSleep"
        ],
        "description": "return:static bool des: Should the collider gizmos show the sleep-state for each collider?"
    },
    "Physics2D.timeToSleep": {
        "prefix": "Physics2D.timeToSleep",
        "body": [
            "timeToSleep"
        ],
        "description": "return:static float des: The time in seconds that a rigid-body must be still before it will go to sleep."
    },
    "Physics2D.velocityIterations": {
        "prefix": "Physics2D.velocityIterations",
        "body": [
            "velocityIterations"
        ],
        "description": "return:static int des: The number of iterations of the physics solver when considering objects' velocities."
    },
    "Physics2D.velocityThreshold": {
        "prefix": "Physics2D.velocityThreshold",
        "body": [
            "velocityThreshold"
        ],
        "description": "return:static float des: Any collisions with a relative linear velocity below this threshold will be treated as inelastic."
    },
    "Pose.identity": {
        "prefix": "Pose.identity",
        "body": [
            "identity"
        ],
        "description": "return:static Pose des: Shorthand for pose which represents zero position, and an identity rotation."
    },
    "ProceduralTexture.currentTextureMemory": {
        "prefix": "ProceduralTexture.currentTextureMemory",
        "body": [
            "currentTextureMemory"
        ],
        "description": "return:static ulong des: The amount of memory currently being used by textures."
    },
    "ProceduralTexture.desiredTextureMemory": {
        "prefix": "ProceduralTexture.desiredTextureMemory",
        "body": [
            "desiredTextureMemory"
        ],
        "description": "return:static ulong des: This amount of texture memory would be used before the texture streaming budget is applied."
    },
    "ProceduralTexture.nonStreamingTextureCount": {
        "prefix": "ProceduralTexture.nonStreamingTextureCount",
        "body": [
            "nonStreamingTextureCount"
        ],
        "description": "return:static ulong des: Number of non-streaming textures."
    },
    "ProceduralTexture.nonStreamingTextureMemory": {
        "prefix": "ProceduralTexture.nonStreamingTextureMemory",
        "body": [
            "nonStreamingTextureMemory"
        ],
        "description": "return:static ulong des: Total amount of memory being used by non-streaming textures."
    },
    "ProceduralTexture.streamingMipmapUploadCount": {
        "prefix": "ProceduralTexture.streamingMipmapUploadCount",
        "body": [
            "streamingMipmapUploadCount"
        ],
        "description": "return:static ulong des: How many times has a texture been uploaded due to texture mipmap streaming."
    },
    "ProceduralTexture.streamingRendererCount": {
        "prefix": "ProceduralTexture.streamingRendererCount",
        "body": [
            "streamingRendererCount"
        ],
        "description": "return:static ulong des: Number of renderers registered with the texture streaming system."
    },
    "ProceduralTexture.streamingTextureCount": {
        "prefix": "ProceduralTexture.streamingTextureCount",
        "body": [
            "streamingTextureCount"
        ],
        "description": "return:static ulong des: Number of streaming textures."
    },
    "ProceduralTexture.streamingTextureDiscardUnusedMips": {
        "prefix": "ProceduralTexture.streamingTextureDiscardUnusedMips",
        "body": [
            "streamingTextureDiscardUnusedMips"
        ],
        "description": "return:static bool des: Force the streaming texture system to discard all unused mipmaps immediately, rather than caching them until the texture memory budget is exceeded."
    },
    "ProceduralTexture.streamingTextureForceLoadAll": {
        "prefix": "ProceduralTexture.streamingTextureForceLoadAll",
        "body": [
            "streamingTextureForceLoadAll"
        ],
        "description": "return:static bool des: Force streaming textures to load all mipmap levels."
    },
    "ProceduralTexture.streamingTextureLoadingCount": {
        "prefix": "ProceduralTexture.streamingTextureLoadingCount",
        "body": [
            "streamingTextureLoadingCount"
        ],
        "description": "return:static ulong des: Number of streaming textures with mipmaps currently loading."
    },
    "ProceduralTexture.streamingTexturePendingLoadCount": {
        "prefix": "ProceduralTexture.streamingTexturePendingLoadCount",
        "body": [
            "streamingTexturePendingLoadCount"
        ],
        "description": "return:static ulong des: Number of streaming textures with outstanding mipmaps to be loaded."
    },
    "ProceduralTexture.targetTextureMemory": {
        "prefix": "ProceduralTexture.targetTextureMemory",
        "body": [
            "targetTextureMemory"
        ],
        "description": "return:static ulong des: The amount of memory used by textures after the mipmap streaming and budget are applied and loading is complete."
    },
    "ProceduralTexture.totalTextureMemory": {
        "prefix": "ProceduralTexture.totalTextureMemory",
        "body": [
            "totalTextureMemory"
        ],
        "description": "return:static ulong des: The total amount of memory that would be used by all textures at mipmap level 0."
    },
    "QualitySettings.activeColorSpace": {
        "prefix": "QualitySettings.activeColorSpace",
        "body": [
            "activeColorSpace"
        ],
        "description": "return:static ColorSpace des: Active color space (Read Only)."
    },
    "QualitySettings.anisotropicFiltering": {
        "prefix": "QualitySettings.anisotropicFiltering",
        "body": [
            "anisotropicFiltering"
        ],
        "description": "return:static AnisotropicFiltering des: Global anisotropic filtering mode."
    },
    "QualitySettings.antiAliasing": {
        "prefix": "QualitySettings.antiAliasing",
        "body": [
            "antiAliasing"
        ],
        "description": "return:static int des: Set The AA Filtering option."
    },
    "QualitySettings.asyncUploadBufferSize": {
        "prefix": "QualitySettings.asyncUploadBufferSize",
        "body": [
            "asyncUploadBufferSize"
        ],
        "description": "return:static int des: Async texture upload provides timesliced async texture upload on the render thread with tight control over memory and timeslicing. There are no allocations except for the ones which driver has to do. To read data and upload texture data a ringbuffer whose size can be controlled is re-used."
    },
    "QualitySettings.asyncUploadTimeSlice": {
        "prefix": "QualitySettings.asyncUploadTimeSlice",
        "body": [
            "asyncUploadTimeSlice"
        ],
        "description": "return:static int des: Async texture upload provides timesliced async texture upload on the render thread with tight control over memory and timeslicing. There are no allocations except for the ones which driver has to do. To read data and upload texture data a ringbuffer whose size can be controlled is re-used."
    },
    "QualitySettings.billboardsFaceCameraPosition": {
        "prefix": "QualitySettings.billboardsFaceCameraPosition",
        "body": [
            "billboardsFaceCameraPosition"
        ],
        "description": "return:static bool des: If enabled, billboards will face towards camera position rather than camera orientation."
    },
    "QualitySettings.blendWeights": {
        "prefix": "QualitySettings.blendWeights",
        "body": [
            "blendWeights"
        ],
        "description": "return:static BlendWeights des: Blend weights."
    },
    "QualitySettings.desiredColorSpace": {
        "prefix": "QualitySettings.desiredColorSpace",
        "body": [
            "desiredColorSpace"
        ],
        "description": "return:static ColorSpace des: Desired color space (Read Only)."
    },
    "QualitySettings.lodBias": {
        "prefix": "QualitySettings.lodBias",
        "body": [
            "lodBias"
        ],
        "description": "return:static float des: Global multiplier for the LOD's switching distance."
    },
    "QualitySettings.masterTextureLimit": {
        "prefix": "QualitySettings.masterTextureLimit",
        "body": [
            "masterTextureLimit"
        ],
        "description": "return:static int des: A texture size limit applied to all textures."
    },
    "QualitySettings.maximumLODLevel": {
        "prefix": "QualitySettings.maximumLODLevel",
        "body": [
            "maximumLODLevel"
        ],
        "description": "return:static int des: A maximum LOD level. All LOD groups."
    },
    "QualitySettings.maxQueuedFrames": {
        "prefix": "QualitySettings.maxQueuedFrames",
        "body": [
            "maxQueuedFrames"
        ],
        "description": "return:static int des: Maximum number of frames queued up by graphics driver."
    },
    "QualitySettings.names": {
        "prefix": "QualitySettings.names",
        "body": [
            "names"
        ],
        "description": "return:static string[] des: The indexed list of available Quality Settings."
    },
    "QualitySettings.particleRaycastBudget": {
        "prefix": "QualitySettings.particleRaycastBudget",
        "body": [
            "particleRaycastBudget"
        ],
        "description": "return:static int des: Budget for how many ray casts can be performed per frame for approximate collision testing."
    },
    "QualitySettings.pixelLightCount": {
        "prefix": "QualitySettings.pixelLightCount",
        "body": [
            "pixelLightCount"
        ],
        "description": "return:static int des: The maximum number of pixel lights that should affect any object."
    },
    "QualitySettings.realtimeReflectionProbes": {
        "prefix": "QualitySettings.realtimeReflectionProbes",
        "body": [
            "realtimeReflectionProbes"
        ],
        "description": "return:static bool des: Enables realtime reflection probes."
    },
    "QualitySettings.resolutionScalingFixedDPIFactor": {
        "prefix": "QualitySettings.resolutionScalingFixedDPIFactor",
        "body": [
            "resolutionScalingFixedDPIFactor"
        ],
        "description": "return:static float des: In resolution scaling mode, this factor is used to multiply with the target Fixed DPI specified to get the actual Fixed DPI to use for this quality setting."
    },
    "QualitySettings.shadowCascade2Split": {
        "prefix": "QualitySettings.shadowCascade2Split",
        "body": [
            "shadowCascade2Split"
        ],
        "description": "return:static float des: The normalized cascade distribution for a 2 cascade setup. The value defines the position of the cascade with respect to Zero."
    },
    "QualitySettings.shadowCascade4Split": {
        "prefix": "QualitySettings.shadowCascade4Split",
        "body": [
            "shadowCascade4Split"
        ],
        "description": "return:static Vector3 des: The normalized cascade start position for a 4 cascade setup. Each member of the vector defines the normalized position of the coresponding cascade with respect to Zero."
    },
    "QualitySettings.shadowCascades": {
        "prefix": "QualitySettings.shadowCascades",
        "body": [
            "shadowCascades"
        ],
        "description": "return:static int des: Number of cascades to use for directional light shadows."
    },
    "QualitySettings.shadowDistance": {
        "prefix": "QualitySettings.shadowDistance",
        "body": [
            "shadowDistance"
        ],
        "description": "return:static float des: Shadow drawing distance."
    },
    "QualitySettings.shadowmaskMode": {
        "prefix": "QualitySettings.shadowmaskMode",
        "body": [
            "shadowmaskMode"
        ],
        "description": "return:static ShadowmaskMode des: The rendering mode of Shadowmask."
    },
    "QualitySettings.shadowNearPlaneOffset": {
        "prefix": "QualitySettings.shadowNearPlaneOffset",
        "body": [
            "shadowNearPlaneOffset"
        ],
        "description": "return:static float des: Offset shadow frustum near plane."
    },
    "QualitySettings.shadowProjection": {
        "prefix": "QualitySettings.shadowProjection",
        "body": [
            "shadowProjection"
        ],
        "description": "return:static ShadowProjection des: Directional light shadow projection."
    },
    "QualitySettings.shadowResolution": {
        "prefix": "QualitySettings.shadowResolution",
        "body": [
            "shadowResolution"
        ],
        "description": "return:static ShadowResolution des: The default resolution of the shadow maps."
    },
    "QualitySettings.shadows": {
        "prefix": "QualitySettings.shadows",
        "body": [
            "shadows"
        ],
        "description": "return:static ShadowQuality des: Realtime Shadows type to be used."
    },
    "QualitySettings.softParticles": {
        "prefix": "QualitySettings.softParticles",
        "body": [
            "softParticles"
        ],
        "description": "return:static bool des: Should soft blending be used for particles?"
    },
    "QualitySettings.softVegetation": {
        "prefix": "QualitySettings.softVegetation",
        "body": [
            "softVegetation"
        ],
        "description": "return:static bool des: Use a two-pass shader for the vegetation in the terrain engine."
    },
    "QualitySettings.streamingMipmapsActive": {
        "prefix": "QualitySettings.streamingMipmapsActive",
        "body": [
            "streamingMipmapsActive"
        ],
        "description": "return:static bool des: Enable automatic streaming of texture mipmap levels based on their distance from all active cameras."
    },
    "QualitySettings.streamingMipmapsAddAllCameras": {
        "prefix": "QualitySettings.streamingMipmapsAddAllCameras",
        "body": [
            "streamingMipmapsAddAllCameras"
        ],
        "description": "return:static bool des: Process all enabled Cameras for texture streaming (rather than just those with StreamingController components)."
    },
    "QualitySettings.streamingMipmapsMaxFileIORequests": {
        "prefix": "QualitySettings.streamingMipmapsMaxFileIORequests",
        "body": [
            "streamingMipmapsMaxFileIORequests"
        ],
        "description": "return:static int des: The maximum number of active texture file IO requests from the texture streaming system."
    },
    "QualitySettings.streamingMipmapsMaxLevelReduction": {
        "prefix": "QualitySettings.streamingMipmapsMaxLevelReduction",
        "body": [
            "streamingMipmapsMaxLevelReduction"
        ],
        "description": "return:static int des: The maximum number of mipmap levels to discard for each texture."
    },
    "QualitySettings.streamingMipmapsMemoryBudget": {
        "prefix": "QualitySettings.streamingMipmapsMemoryBudget",
        "body": [
            "streamingMipmapsMemoryBudget"
        ],
        "description": "return:static float des: The total amount of memory to be used by streaming and non-streaming textures."
    },
    "QualitySettings.streamingMipmapsRenderersPerFrame": {
        "prefix": "QualitySettings.streamingMipmapsRenderersPerFrame",
        "body": [
            "streamingMipmapsRenderersPerFrame"
        ],
        "description": "return:static int des: Number of renderers used to process each frame during the calculation of desired mipmap levels for the associated textures."
    },
    "QualitySettings.vSyncCount": {
        "prefix": "QualitySettings.vSyncCount",
        "body": [
            "vSyncCount"
        ],
        "description": "return:static int des: The VSync Count."
    },
    "Quaternion.identity": {
        "prefix": "Quaternion.identity",
        "body": [
            "identity"
        ],
        "description": "return:static Quaternion des: The identity rotation (Read Only)."
    },
    "Random.insideUnitCircle": {
        "prefix": "Random.insideUnitCircle",
        "body": [
            "insideUnitCircle"
        ],
        "description": "return:static Vector2 des: Returns a random point inside a circle with radius 1 (Read Only)."
    },
    "Random.insideUnitSphere": {
        "prefix": "Random.insideUnitSphere",
        "body": [
            "insideUnitSphere"
        ],
        "description": "return:static Vector3 des: Returns a random point inside a sphere with radius 1 (Read Only)."
    },
    "Random.onUnitSphere": {
        "prefix": "Random.onUnitSphere",
        "body": [
            "onUnitSphere"
        ],
        "description": "return:static Vector3 des: Returns a random point on the surface of a sphere with radius 1 (Read Only)."
    },
    "Random.rotation": {
        "prefix": "Random.rotation",
        "body": [
            "rotation"
        ],
        "description": "return:static Quaternion des: Returns a random rotation (Read Only)."
    },
    "Random.rotationUniform": {
        "prefix": "Random.rotationUniform",
        "body": [
            "rotationUniform"
        ],
        "description": "return:static Quaternion des: Returns a random rotation with uniform distribution (Read Only)."
    },
    "Random.state": {
        "prefix": "Random.state",
        "body": [
            "state"
        ],
        "description": "return:static Random.State des: Gets/Sets the full internal state of the random number generator."
    },
    "Random.value": {
        "prefix": "Random.value",
        "body": [
            "value"
        ],
        "description": "return:static float des: Returns a random number between 0.0 [inclusive] and 1.0 [inclusive] (Read Only)."
    },
    "Rect.zero": {
        "prefix": "Rect.zero",
        "body": [
            "zero"
        ],
        "description": "return:static Rect des: Shorthand for writing new Rect(0,0,0,0)."
    },
    "ReflectionProbe.defaultTexture": {
        "prefix": "ReflectionProbe.defaultTexture",
        "body": [
            "defaultTexture"
        ],
        "description": "return:static Texture des: Texture which is used outside of all reflection probes (Read Only)."
    },
    "ReflectionProbe.defaultTextureHDRDecodeValues": {
        "prefix": "ReflectionProbe.defaultTextureHDRDecodeValues",
        "body": [
            "defaultTextureHDRDecodeValues"
        ],
        "description": "return:static Vector4 des: HDR decode values of the default reflection probe texture."
    },
    "RenderSettings.ambientEquatorColor": {
        "prefix": "RenderSettings.ambientEquatorColor",
        "body": [
            "ambientEquatorColor"
        ],
        "description": "return:static Color des: Ambient lighting coming from the sides."
    },
    "RenderSettings.ambientGroundColor": {
        "prefix": "RenderSettings.ambientGroundColor",
        "body": [
            "ambientGroundColor"
        ],
        "description": "return:static Color des: Ambient lighting coming from below."
    },
    "RenderSettings.ambientIntensity": {
        "prefix": "RenderSettings.ambientIntensity",
        "body": [
            "ambientIntensity"
        ],
        "description": "return:static float des: How much the light from the Ambient Source affects the scene."
    },
    "RenderSettings.ambientLight": {
        "prefix": "RenderSettings.ambientLight",
        "body": [
            "ambientLight"
        ],
        "description": "return:static Color des: Flat ambient lighting color."
    },
    "RenderSettings.ambientMode": {
        "prefix": "RenderSettings.ambientMode",
        "body": [
            "ambientMode"
        ],
        "description": "return:static Rendering.AmbientMode des: Ambient lighting mode."
    },
    "RenderSettings.ambientProbe": {
        "prefix": "RenderSettings.ambientProbe",
        "body": [
            "ambientProbe"
        ],
        "description": "return:static Rendering.SphericalHarmonicsL2 des: Custom or skybox ambient lighting data."
    },
    "RenderSettings.ambientSkyColor": {
        "prefix": "RenderSettings.ambientSkyColor",
        "body": [
            "ambientSkyColor"
        ],
        "description": "return:static Color des: Ambient lighting coming from above."
    },
    "RenderSettings.customReflection": {
        "prefix": "RenderSettings.customReflection",
        "body": [
            "customReflection"
        ],
        "description": "return:static Cubemap des: Custom specular reflection cubemap."
    },
    "RenderSettings.defaultReflectionMode": {
        "prefix": "RenderSettings.defaultReflectionMode",
        "body": [
            "defaultReflectionMode"
        ],
        "description": "return:static Rendering.DefaultReflectionMode des: Default reflection mode."
    },
    "RenderSettings.defaultReflectionResolution": {
        "prefix": "RenderSettings.defaultReflectionResolution",
        "body": [
            "defaultReflectionResolution"
        ],
        "description": "return:static int des: Cubemap resolution for default reflection."
    },
    "RenderSettings.flareFadeSpeed": {
        "prefix": "RenderSettings.flareFadeSpeed",
        "body": [
            "flareFadeSpeed"
        ],
        "description": "return:static float des: The fade speed of all flares in the scene."
    },
    "RenderSettings.flareStrength": {
        "prefix": "RenderSettings.flareStrength",
        "body": [
            "flareStrength"
        ],
        "description": "return:static float des: The intensity of all flares in the scene."
    },
    "RenderSettings.fog": {
        "prefix": "RenderSettings.fog",
        "body": [
            "fog"
        ],
        "description": "return:static bool des: Is fog enabled?"
    },
    "RenderSettings.fogColor": {
        "prefix": "RenderSettings.fogColor",
        "body": [
            "fogColor"
        ],
        "description": "return:static Color des: The color of the fog."
    },
    "RenderSettings.fogDensity": {
        "prefix": "RenderSettings.fogDensity",
        "body": [
            "fogDensity"
        ],
        "description": "return:static float des: The density of the exponential fog."
    },
    "RenderSettings.fogEndDistance": {
        "prefix": "RenderSettings.fogEndDistance",
        "body": [
            "fogEndDistance"
        ],
        "description": "return:static float des: The ending distance of linear fog."
    },
    "RenderSettings.fogMode": {
        "prefix": "RenderSettings.fogMode",
        "body": [
            "fogMode"
        ],
        "description": "return:static FogMode des: Fog mode to use."
    },
    "RenderSettings.fogStartDistance": {
        "prefix": "RenderSettings.fogStartDistance",
        "body": [
            "fogStartDistance"
        ],
        "description": "return:static float des: The starting distance of linear fog."
    },
    "RenderSettings.haloStrength": {
        "prefix": "RenderSettings.haloStrength",
        "body": [
            "haloStrength"
        ],
        "description": "return:static float des: Size of the Light halos."
    },
    "RenderSettings.reflectionBounces": {
        "prefix": "RenderSettings.reflectionBounces",
        "body": [
            "reflectionBounces"
        ],
        "description": "return:static int des: The number of times a reflection includes other reflections."
    },
    "RenderSettings.reflectionIntensity": {
        "prefix": "RenderSettings.reflectionIntensity",
        "body": [
            "reflectionIntensity"
        ],
        "description": "return:static float des: How much the skybox / custom cubemap reflection affects the scene."
    },
    "RenderSettings.skybox": {
        "prefix": "RenderSettings.skybox",
        "body": [
            "skybox"
        ],
        "description": "return:static Material des: The global skybox to use."
    },
    "RenderSettings.subtractiveShadowColor": {
        "prefix": "RenderSettings.subtractiveShadowColor",
        "body": [
            "subtractiveShadowColor"
        ],
        "description": "return:static Color des: The color used for the sun shadows in the Subtractive lightmode."
    },
    "RenderSettings.sun": {
        "prefix": "RenderSettings.sun",
        "body": [
            "sun"
        ],
        "description": "return:static Light des: The light used by the procedural skybox."
    },
    "RenderTexture.active": {
        "prefix": "RenderTexture.active",
        "body": [
            "active"
        ],
        "description": "return:static RenderTexture des: Currently active render texture."
    },
    "RenderTexture.currentTextureMemory": {
        "prefix": "RenderTexture.currentTextureMemory",
        "body": [
            "currentTextureMemory"
        ],
        "description": "return:static ulong des: The amount of memory currently being used by textures."
    },
    "RenderTexture.desiredTextureMemory": {
        "prefix": "RenderTexture.desiredTextureMemory",
        "body": [
            "desiredTextureMemory"
        ],
        "description": "return:static ulong des: This amount of texture memory would be used before the texture streaming budget is applied."
    },
    "RenderTexture.nonStreamingTextureCount": {
        "prefix": "RenderTexture.nonStreamingTextureCount",
        "body": [
            "nonStreamingTextureCount"
        ],
        "description": "return:static ulong des: Number of non-streaming textures."
    },
    "RenderTexture.nonStreamingTextureMemory": {
        "prefix": "RenderTexture.nonStreamingTextureMemory",
        "body": [
            "nonStreamingTextureMemory"
        ],
        "description": "return:static ulong des: Total amount of memory being used by non-streaming textures."
    },
    "RenderTexture.streamingMipmapUploadCount": {
        "prefix": "RenderTexture.streamingMipmapUploadCount",
        "body": [
            "streamingMipmapUploadCount"
        ],
        "description": "return:static ulong des: How many times has a texture been uploaded due to texture mipmap streaming."
    },
    "RenderTexture.streamingRendererCount": {
        "prefix": "RenderTexture.streamingRendererCount",
        "body": [
            "streamingRendererCount"
        ],
        "description": "return:static ulong des: Number of renderers registered with the texture streaming system."
    },
    "RenderTexture.streamingTextureCount": {
        "prefix": "RenderTexture.streamingTextureCount",
        "body": [
            "streamingTextureCount"
        ],
        "description": "return:static ulong des: Number of streaming textures."
    },
    "RenderTexture.streamingTextureDiscardUnusedMips": {
        "prefix": "RenderTexture.streamingTextureDiscardUnusedMips",
        "body": [
            "streamingTextureDiscardUnusedMips"
        ],
        "description": "return:static bool des: Force the streaming texture system to discard all unused mipmaps immediately, rather than caching them until the texture memory budget is exceeded."
    },
    "RenderTexture.streamingTextureForceLoadAll": {
        "prefix": "RenderTexture.streamingTextureForceLoadAll",
        "body": [
            "streamingTextureForceLoadAll"
        ],
        "description": "return:static bool des: Force streaming textures to load all mipmap levels."
    },
    "RenderTexture.streamingTextureLoadingCount": {
        "prefix": "RenderTexture.streamingTextureLoadingCount",
        "body": [
            "streamingTextureLoadingCount"
        ],
        "description": "return:static ulong des: Number of streaming textures with mipmaps currently loading."
    },
    "RenderTexture.streamingTexturePendingLoadCount": {
        "prefix": "RenderTexture.streamingTexturePendingLoadCount",
        "body": [
            "streamingTexturePendingLoadCount"
        ],
        "description": "return:static ulong des: Number of streaming textures with outstanding mipmaps to be loaded."
    },
    "RenderTexture.targetTextureMemory": {
        "prefix": "RenderTexture.targetTextureMemory",
        "body": [
            "targetTextureMemory"
        ],
        "description": "return:static ulong des: The amount of memory used by textures after the mipmap streaming and budget are applied and loading is complete."
    },
    "RenderTexture.totalTextureMemory": {
        "prefix": "RenderTexture.totalTextureMemory",
        "body": [
            "totalTextureMemory"
        ],
        "description": "return:static ulong des: The total amount of memory that would be used by all textures at mipmap level 0."
    },
    "ScalableBufferManager.heightScaleFactor": {
        "prefix": "ScalableBufferManager.heightScaleFactor",
        "body": [
            "heightScaleFactor"
        ],
        "description": "return:static float des: Height scale factor to control dynamic resolution."
    },
    "ScalableBufferManager.widthScaleFactor": {
        "prefix": "ScalableBufferManager.widthScaleFactor",
        "body": [
            "widthScaleFactor"
        ],
        "description": "return:static float des: Width scale factor to control dynamic resolution."
    },
    "Screen.autorotateToLandscapeLeft": {
        "prefix": "Screen.autorotateToLandscapeLeft",
        "body": [
            "autorotateToLandscapeLeft"
        ],
        "description": "return:static bool des: Allow auto-rotation to landscape left?"
    },
    "Screen.autorotateToLandscapeRight": {
        "prefix": "Screen.autorotateToLandscapeRight",
        "body": [
            "autorotateToLandscapeRight"
        ],
        "description": "return:static bool des: Allow auto-rotation to landscape right?"
    },
    "Screen.autorotateToPortrait": {
        "prefix": "Screen.autorotateToPortrait",
        "body": [
            "autorotateToPortrait"
        ],
        "description": "return:static bool des: Allow auto-rotation to portrait?"
    },
    "Screen.autorotateToPortraitUpsideDown": {
        "prefix": "Screen.autorotateToPortraitUpsideDown",
        "body": [
            "autorotateToPortraitUpsideDown"
        ],
        "description": "return:static bool des: Allow auto-rotation to portrait, upside down?"
    },
    "Screen.currentResolution": {
        "prefix": "Screen.currentResolution",
        "body": [
            "currentResolution"
        ],
        "description": "return:static Resolution des: The current screen resolution (Read Only)."
    },
    "Screen.dpi": {
        "prefix": "Screen.dpi",
        "body": [
            "dpi"
        ],
        "description": "return:static float des: The current DPI of the screen / device (Read Only)."
    },
    "Screen.fullScreen": {
        "prefix": "Screen.fullScreen",
        "body": [
            "fullScreen"
        ],
        "description": "return:static bool des: Is the game running full-screen?"
    },
    "Screen.fullScreenMode": {
        "prefix": "Screen.fullScreenMode",
        "body": [
            "fullScreenMode"
        ],
        "description": "return:static FullScreenMode des: Set this property to one of the values in FullScreenMode to change the display mode of your application."
    },
    "Screen.height": {
        "prefix": "Screen.height",
        "body": [
            "height"
        ],
        "description": "return:static int des: The current height of the screen window in pixels (Read Only)."
    },
    "Screen.orientation": {
        "prefix": "Screen.orientation",
        "body": [
            "orientation"
        ],
        "description": "return:static ScreenOrientation des: Specifies logical orientation of the screen."
    },
    "Screen.resolutions": {
        "prefix": "Screen.resolutions",
        "body": [
            "resolutions"
        ],
        "description": "return:static Resolution[] des: All full-screen resolutions supported by the monitor (Read Only)."
    },
    "Screen.safeArea": {
        "prefix": "Screen.safeArea",
        "body": [
            "safeArea"
        ],
        "description": "return:static Rect des: Returns the safe area of the screen in pixels (Read Only)."
    },
    "Screen.sleepTimeout": {
        "prefix": "Screen.sleepTimeout",
        "body": [
            "sleepTimeout"
        ],
        "description": "return:static int des: A power saving setting, allowing the screen to dim some time after the last active user interaction."
    },
    "Screen.width": {
        "prefix": "Screen.width",
        "body": [
            "width"
        ],
        "description": "return:static int des: The current width of the screen window in pixels (Read Only)."
    },
    "Shader.globalMaximumLOD": {
        "prefix": "Shader.globalMaximumLOD",
        "body": [
            "globalMaximumLOD"
        ],
        "description": "return:static int des: Shader LOD level for all shaders."
    },
    "Shader.globalRenderPipeline": {
        "prefix": "Shader.globalRenderPipeline",
        "body": [
            "globalRenderPipeline"
        ],
        "description": "return:static string des: Render pipeline currently in use."
    },
    "SleepTimeout.NeverSleep": {
        "prefix": "SleepTimeout.NeverSleep",
        "body": [
            "NeverSleep"
        ],
        "description": "return:static int des: Prevent screen dimming."
    },
    "SleepTimeout.SystemSetting": {
        "prefix": "SleepTimeout.SystemSetting",
        "body": [
            "SystemSetting"
        ],
        "description": "return:static int des: Set the sleep timeout to whatever the user has specified in the system settings."
    },
    "Social.Active": {
        "prefix": "Social.Active",
        "body": [
            "Active"
        ],
        "description": "return:static SocialPlatforms.ISocialPlatform des: This is the currently active social platform."
    },
    "Social.localUser": {
        "prefix": "Social.localUser",
        "body": [
            "localUser"
        ],
        "description": "return:static SocialPlatforms.ILocalUser des: The local user (potentially not logged in)."
    },
    "SortingLayer.layers": {
        "prefix": "SortingLayer.layers",
        "body": [
            "layers"
        ],
        "description": "return:static SortingLayer[] des: Returns all the layers defined in this project."
    },
    "SparseTexture.currentTextureMemory": {
        "prefix": "SparseTexture.currentTextureMemory",
        "body": [
            "currentTextureMemory"
        ],
        "description": "return:static ulong des: The amount of memory currently being used by textures."
    },
    "SparseTexture.desiredTextureMemory": {
        "prefix": "SparseTexture.desiredTextureMemory",
        "body": [
            "desiredTextureMemory"
        ],
        "description": "return:static ulong des: This amount of texture memory would be used before the texture streaming budget is applied."
    },
    "SparseTexture.nonStreamingTextureCount": {
        "prefix": "SparseTexture.nonStreamingTextureCount",
        "body": [
            "nonStreamingTextureCount"
        ],
        "description": "return:static ulong des: Number of non-streaming textures."
    },
    "SparseTexture.nonStreamingTextureMemory": {
        "prefix": "SparseTexture.nonStreamingTextureMemory",
        "body": [
            "nonStreamingTextureMemory"
        ],
        "description": "return:static ulong des: Total amount of memory being used by non-streaming textures."
    },
    "SparseTexture.streamingMipmapUploadCount": {
        "prefix": "SparseTexture.streamingMipmapUploadCount",
        "body": [
            "streamingMipmapUploadCount"
        ],
        "description": "return:static ulong des: How many times has a texture been uploaded due to texture mipmap streaming."
    },
    "SparseTexture.streamingRendererCount": {
        "prefix": "SparseTexture.streamingRendererCount",
        "body": [
            "streamingRendererCount"
        ],
        "description": "return:static ulong des: Number of renderers registered with the texture streaming system."
    },
    "SparseTexture.streamingTextureCount": {
        "prefix": "SparseTexture.streamingTextureCount",
        "body": [
            "streamingTextureCount"
        ],
        "description": "return:static ulong des: Number of streaming textures."
    },
    "SparseTexture.streamingTextureDiscardUnusedMips": {
        "prefix": "SparseTexture.streamingTextureDiscardUnusedMips",
        "body": [
            "streamingTextureDiscardUnusedMips"
        ],
        "description": "return:static bool des: Force the streaming texture system to discard all unused mipmaps immediately, rather than caching them until the texture memory budget is exceeded."
    },
    "SparseTexture.streamingTextureForceLoadAll": {
        "prefix": "SparseTexture.streamingTextureForceLoadAll",
        "body": [
            "streamingTextureForceLoadAll"
        ],
        "description": "return:static bool des: Force streaming textures to load all mipmap levels."
    },
    "SparseTexture.streamingTextureLoadingCount": {
        "prefix": "SparseTexture.streamingTextureLoadingCount",
        "body": [
            "streamingTextureLoadingCount"
        ],
        "description": "return:static ulong des: Number of streaming textures with mipmaps currently loading."
    },
    "SparseTexture.streamingTexturePendingLoadCount": {
        "prefix": "SparseTexture.streamingTexturePendingLoadCount",
        "body": [
            "streamingTexturePendingLoadCount"
        ],
        "description": "return:static ulong des: Number of streaming textures with outstanding mipmaps to be loaded."
    },
    "SparseTexture.targetTextureMemory": {
        "prefix": "SparseTexture.targetTextureMemory",
        "body": [
            "targetTextureMemory"
        ],
        "description": "return:static ulong des: The amount of memory used by textures after the mipmap streaming and budget are applied and loading is complete."
    },
    "SparseTexture.totalTextureMemory": {
        "prefix": "SparseTexture.totalTextureMemory",
        "body": [
            "totalTextureMemory"
        ],
        "description": "return:static ulong des: The total amount of memory that would be used by all textures at mipmap level 0."
    },
    "SystemInfo.batteryLevel": {
        "prefix": "SystemInfo.batteryLevel",
        "body": [
            "batteryLevel"
        ],
        "description": "return:static float des: The current battery level (Read Only)."
    },
    "SystemInfo.batteryStatus": {
        "prefix": "SystemInfo.batteryStatus",
        "body": [
            "batteryStatus"
        ],
        "description": "return:static BatteryStatus des: Returns the current status of the device's battery (Read Only)."
    },
    "SystemInfo.copyTextureSupport": {
        "prefix": "SystemInfo.copyTextureSupport",
        "body": [
            "copyTextureSupport"
        ],
        "description": "return:static Rendering.CopyTextureSupport des: Support for various Graphics.CopyTexture cases (Read Only)."
    },
    "SystemInfo.deviceModel": {
        "prefix": "SystemInfo.deviceModel",
        "body": [
            "deviceModel"
        ],
        "description": "return:static string des: The model of the device (Read Only)."
    },
    "SystemInfo.deviceName": {
        "prefix": "SystemInfo.deviceName",
        "body": [
            "deviceName"
        ],
        "description": "return:static string des: The user defined name of the device (Read Only)."
    },
    "SystemInfo.deviceType": {
        "prefix": "SystemInfo.deviceType",
        "body": [
            "deviceType"
        ],
        "description": "return:static DeviceType des: Returns the kind of device the application is running on (Read Only)."
    },
    "SystemInfo.deviceUniqueIdentifier": {
        "prefix": "SystemInfo.deviceUniqueIdentifier",
        "body": [
            "deviceUniqueIdentifier"
        ],
        "description": "return:static string des: A unique device identifier. It is guaranteed to be unique for every device (Read Only)."
    },
    "SystemInfo.graphicsDeviceID": {
        "prefix": "SystemInfo.graphicsDeviceID",
        "body": [
            "graphicsDeviceID"
        ],
        "description": "return:static int des: The identifier code of the graphics device (Read Only)."
    },
    "SystemInfo.graphicsDeviceName": {
        "prefix": "SystemInfo.graphicsDeviceName",
        "body": [
            "graphicsDeviceName"
        ],
        "description": "return:static string des: The name of the graphics device (Read Only)."
    },
    "SystemInfo.graphicsDeviceType": {
        "prefix": "SystemInfo.graphicsDeviceType",
        "body": [
            "graphicsDeviceType"
        ],
        "description": "return:static Rendering.GraphicsDeviceType des: The graphics API type used by the graphics device (Read Only)."
    },
    "SystemInfo.graphicsDeviceVendor": {
        "prefix": "SystemInfo.graphicsDeviceVendor",
        "body": [
            "graphicsDeviceVendor"
        ],
        "description": "return:static string des: The vendor of the graphics device (Read Only)."
    },
    "SystemInfo.graphicsDeviceVendorID": {
        "prefix": "SystemInfo.graphicsDeviceVendorID",
        "body": [
            "graphicsDeviceVendorID"
        ],
        "description": "return:static int des: The identifier code of the graphics device vendor (Read Only)."
    },
    "SystemInfo.graphicsDeviceVersion": {
        "prefix": "SystemInfo.graphicsDeviceVersion",
        "body": [
            "graphicsDeviceVersion"
        ],
        "description": "return:static string des: The graphics API type and driver version used by the graphics device (Read Only)."
    },
    "SystemInfo.graphicsMemorySize": {
        "prefix": "SystemInfo.graphicsMemorySize",
        "body": [
            "graphicsMemorySize"
        ],
        "description": "return:static int des: Amount of video memory present (Read Only)."
    },
    "SystemInfo.graphicsMultiThreaded": {
        "prefix": "SystemInfo.graphicsMultiThreaded",
        "body": [
            "graphicsMultiThreaded"
        ],
        "description": "return:static bool des: Is graphics device using multi-threaded rendering (Read Only)?"
    },
    "SystemInfo.graphicsShaderLevel": {
        "prefix": "SystemInfo.graphicsShaderLevel",
        "body": [
            "graphicsShaderLevel"
        ],
        "description": "return:static int des: Graphics device shader capability level (Read Only)."
    },
    "SystemInfo.graphicsUVStartsAtTop": {
        "prefix": "SystemInfo.graphicsUVStartsAtTop",
        "body": [
            "graphicsUVStartsAtTop"
        ],
        "description": "return:static bool des: Returns true if the texture UV coordinate convention for this platform has Y starting at the top of the image."
    },
    "SystemInfo.maxCubemapSize": {
        "prefix": "SystemInfo.maxCubemapSize",
        "body": [
            "maxCubemapSize"
        ],
        "description": "return:static int des: Maximum Cubemap texture size (Read Only)."
    },
    "SystemInfo.maxTextureSize": {
        "prefix": "SystemInfo.maxTextureSize",
        "body": [
            "maxTextureSize"
        ],
        "description": "return:static int des: Maximum texture size (Read Only)."
    },
    "SystemInfo.npotSupport": {
        "prefix": "SystemInfo.npotSupport",
        "body": [
            "npotSupport"
        ],
        "description": "return:static NPOTSupport des: What NPOT (non-power of two size) texture support does the GPU provide? (Read Only)"
    },
    "SystemInfo.operatingSystem": {
        "prefix": "SystemInfo.operatingSystem",
        "body": [
            "operatingSystem"
        ],
        "description": "return:static string des: Operating system name with version (Read Only)."
    },
    "SystemInfo.operatingSystemFamily": {
        "prefix": "SystemInfo.operatingSystemFamily",
        "body": [
            "operatingSystemFamily"
        ],
        "description": "return:static OperatingSystemFamily des: Returns the operating system family the game is running on (Read Only)."
    },
    "SystemInfo.processorCount": {
        "prefix": "SystemInfo.processorCount",
        "body": [
            "processorCount"
        ],
        "description": "return:static int des: Number of processors present (Read Only)."
    },
    "SystemInfo.processorFrequency": {
        "prefix": "SystemInfo.processorFrequency",
        "body": [
            "processorFrequency"
        ],
        "description": "return:static int des: Processor frequency in MHz (Read Only)."
    },
    "SystemInfo.processorType": {
        "prefix": "SystemInfo.processorType",
        "body": [
            "processorType"
        ],
        "description": "return:static string des: Processor name (Read Only)."
    },
    "SystemInfo.supportedRenderTargetCount": {
        "prefix": "SystemInfo.supportedRenderTargetCount",
        "body": [
            "supportedRenderTargetCount"
        ],
        "description": "return:static int des: How many simultaneous render targets (MRTs) are supported? (Read Only)"
    },
    "SystemInfo.supports2DArrayTextures": {
        "prefix": "SystemInfo.supports2DArrayTextures",
        "body": [
            "supports2DArrayTextures"
        ],
        "description": "return:static bool des: Are 2D Array textures supported? (Read Only)"
    },
    "SystemInfo.supports32bitsIndexBuffer": {
        "prefix": "SystemInfo.supports32bitsIndexBuffer",
        "body": [
            "supports32bitsIndexBuffer"
        ],
        "description": "return:static bool des: Are 32-bit index buffers supported? (Read Only)"
    },
    "SystemInfo.supports3DRenderTextures": {
        "prefix": "SystemInfo.supports3DRenderTextures",
        "body": [
            "supports3DRenderTextures"
        ],
        "description": "return:static bool des: Are 3D (volume) RenderTextures supported? (Read Only)"
    },
    "SystemInfo.supports3DTextures": {
        "prefix": "SystemInfo.supports3DTextures",
        "body": [
            "supports3DTextures"
        ],
        "description": "return:static bool des: Are 3D (volume) textures supported? (Read Only)"
    },
    "SystemInfo.supportsAccelerometer": {
        "prefix": "SystemInfo.supportsAccelerometer",
        "body": [
            "supportsAccelerometer"
        ],
        "description": "return:static bool des: Is an accelerometer available on the device?"
    },
    "SystemInfo.supportsAsyncCompute": {
        "prefix": "SystemInfo.supportsAsyncCompute",
        "body": [
            "supportsAsyncCompute"
        ],
        "description": "return:static bool des: Returns true when the platform supports asynchronous compute queues and false if otherwise."
    },
    "SystemInfo.supportsAsyncGPUReadback": {
        "prefix": "SystemInfo.supportsAsyncGPUReadback",
        "body": [
            "supportsAsyncGPUReadback"
        ],
        "description": "return:static bool des: Returns true if asynchronous readback of GPU data is available for this device and false otherwise."
    },
    "SystemInfo.supportsAudio": {
        "prefix": "SystemInfo.supportsAudio",
        "body": [
            "supportsAudio"
        ],
        "description": "return:static bool des: Is there an Audio device available for playback?"
    },
    "SystemInfo.supportsComputeShaders": {
        "prefix": "SystemInfo.supportsComputeShaders",
        "body": [
            "supportsComputeShaders"
        ],
        "description": "return:static bool des: Are compute shaders supported? (Read Only)"
    },
    "SystemInfo.supportsCubemapArrayTextures": {
        "prefix": "SystemInfo.supportsCubemapArrayTextures",
        "body": [
            "supportsCubemapArrayTextures"
        ],
        "description": "return:static bool des: Are Cubemap Array textures supported? (Read Only)"
    },
    "SystemInfo.supportsGPUFence": {
        "prefix": "SystemInfo.supportsGPUFence",
        "body": [
            "supportsGPUFence"
        ],
        "description": "return:static bool des: Returns true when the platform supports GPUFences and false if otherwise."
    },
    "SystemInfo.supportsGyroscope": {
        "prefix": "SystemInfo.supportsGyroscope",
        "body": [
            "supportsGyroscope"
        ],
        "description": "return:static bool des: Is a gyroscope available on the device?"
    },
    "SystemInfo.supportsHardwareQuadTopology": {
        "prefix": "SystemInfo.supportsHardwareQuadTopology",
        "body": [
            "supportsHardwareQuadTopology"
        ],
        "description": "return:static bool des: Does the hardware support quad topology? (Read Only)"
    },
    "SystemInfo.supportsImageEffects": {
        "prefix": "SystemInfo.supportsImageEffects",
        "body": [
            "supportsImageEffects"
        ],
        "description": "return:static bool des: Are image effects supported? (Read Only)"
    },
    "SystemInfo.supportsInstancing": {
        "prefix": "SystemInfo.supportsInstancing",
        "body": [
            "supportsInstancing"
        ],
        "description": "return:static bool des: Is GPU draw call instancing supported? (Read Only)"
    },
    "SystemInfo.supportsLocationService": {
        "prefix": "SystemInfo.supportsLocationService",
        "body": [
            "supportsLocationService"
        ],
        "description": "return:static bool des: Is the device capable of reporting its location?"
    },
    "SystemInfo.supportsMipStreaming": {
        "prefix": "SystemInfo.supportsMipStreaming",
        "body": [
            "supportsMipStreaming"
        ],
        "description": "return:static bool des: Is streaming of texture mip maps supported? (Read Only)"
    },
    "SystemInfo.supportsMotionVectors": {
        "prefix": "SystemInfo.supportsMotionVectors",
        "body": [
            "supportsMotionVectors"
        ],
        "description": "return:static bool des: Whether motion vectors are supported on this platform."
    },
    "SystemInfo.supportsMultisampleAutoResolve": {
        "prefix": "SystemInfo.supportsMultisampleAutoResolve",
        "body": [
            "supportsMultisampleAutoResolve"
        ],
        "description": "return:static bool des: Returns true if multisampled textures are resolved automatically"
    },
    "SystemInfo.supportsMultisampledTextures": {
        "prefix": "SystemInfo.supportsMultisampledTextures",
        "body": [
            "supportsMultisampledTextures"
        ],
        "description": "return:static int des: Are multisampled textures supported? (Read Only)"
    },
    "SystemInfo.supportsRawShadowDepthSampling": {
        "prefix": "SystemInfo.supportsRawShadowDepthSampling",
        "body": [
            "supportsRawShadowDepthSampling"
        ],
        "description": "return:static bool des: Is sampling raw depth from shadowmaps supported? (Read Only)"
    },
    "SystemInfo.supportsRenderToCubemap": {
        "prefix": "SystemInfo.supportsRenderToCubemap",
        "body": [
            "supportsRenderToCubemap"
        ],
        "description": "return:static bool des: Are cubemap render textures supported? (Read Only)"
    },
    "SystemInfo.supportsShadows": {
        "prefix": "SystemInfo.supportsShadows",
        "body": [
            "supportsShadows"
        ],
        "description": "return:static bool des: Are built-in shadows supported? (Read Only)"
    },
    "SystemInfo.supportsSparseTextures": {
        "prefix": "SystemInfo.supportsSparseTextures",
        "body": [
            "supportsSparseTextures"
        ],
        "description": "return:static bool des: Are sparse textures supported? (Read Only)"
    },
    "SystemInfo.supportsTextureWrapMirrorOnce": {
        "prefix": "SystemInfo.supportsTextureWrapMirrorOnce",
        "body": [
            "supportsTextureWrapMirrorOnce"
        ],
        "description": "return:static int des: Returns true if the 'Mirror Once' texture wrap mode is supported. (Read Only)"
    },
    "SystemInfo.supportsVibration": {
        "prefix": "SystemInfo.supportsVibration",
        "body": [
            "supportsVibration"
        ],
        "description": "return:static bool des: Is the device capable of providing the user haptic feedback by vibration?"
    },
    "SystemInfo.systemMemorySize": {
        "prefix": "SystemInfo.systemMemorySize",
        "body": [
            "systemMemorySize"
        ],
        "description": "return:static int des: Amount of system memory present (Read Only)."
    },
    "SystemInfo.unsupportedIdentifier": {
        "prefix": "SystemInfo.unsupportedIdentifier",
        "body": [
            "unsupportedIdentifier"
        ],
        "description": "return:static string des: Value returned by SystemInfo string properties which are not supported on the current platform."
    },
    "SystemInfo.usesReversedZBuffer": {
        "prefix": "SystemInfo.usesReversedZBuffer",
        "body": [
            "usesReversedZBuffer"
        ],
        "description": "return:static bool des: This property is true if the current platform uses a reversed depth buffer (where values range from 1 at the near plane and 0 at far plane), and false if the depth buffer is normal (0 is near, 1 is far). (Read Only)"
    },
    "Terrain.activeTerrain": {
        "prefix": "Terrain.activeTerrain",
        "body": [
            "activeTerrain"
        ],
        "description": "return:static Terrain des: The active terrain. This is a convenience function to get to the main terrain in the scene."
    },
    "Terrain.activeTerrains": {
        "prefix": "Terrain.activeTerrains",
        "body": [
            "activeTerrains"
        ],
        "description": "return:static Terrain[] des: The active terrains in the scene."
    },
    "Texture.currentTextureMemory": {
        "prefix": "Texture.currentTextureMemory",
        "body": [
            "currentTextureMemory"
        ],
        "description": "return:static ulong des: The amount of memory currently being used by textures."
    },
    "Texture.desiredTextureMemory": {
        "prefix": "Texture.desiredTextureMemory",
        "body": [
            "desiredTextureMemory"
        ],
        "description": "return:static ulong des: This amount of texture memory would be used before the texture streaming budget is applied."
    },
    "Texture.nonStreamingTextureCount": {
        "prefix": "Texture.nonStreamingTextureCount",
        "body": [
            "nonStreamingTextureCount"
        ],
        "description": "return:static ulong des: Number of non-streaming textures."
    },
    "Texture.nonStreamingTextureMemory": {
        "prefix": "Texture.nonStreamingTextureMemory",
        "body": [
            "nonStreamingTextureMemory"
        ],
        "description": "return:static ulong des: Total amount of memory being used by non-streaming textures."
    },
    "Texture.streamingMipmapUploadCount": {
        "prefix": "Texture.streamingMipmapUploadCount",
        "body": [
            "streamingMipmapUploadCount"
        ],
        "description": "return:static ulong des: How many times has a texture been uploaded due to texture mipmap streaming."
    },
    "Texture.streamingRendererCount": {
        "prefix": "Texture.streamingRendererCount",
        "body": [
            "streamingRendererCount"
        ],
        "description": "return:static ulong des: Number of renderers registered with the texture streaming system."
    },
    "Texture.streamingTextureCount": {
        "prefix": "Texture.streamingTextureCount",
        "body": [
            "streamingTextureCount"
        ],
        "description": "return:static ulong des: Number of streaming textures."
    },
    "Texture.streamingTextureDiscardUnusedMips": {
        "prefix": "Texture.streamingTextureDiscardUnusedMips",
        "body": [
            "streamingTextureDiscardUnusedMips"
        ],
        "description": "return:static bool des: Force the streaming texture system to discard all unused mipmaps immediately, rather than caching them until the texture memory budget is exceeded."
    },
    "Texture.streamingTextureForceLoadAll": {
        "prefix": "Texture.streamingTextureForceLoadAll",
        "body": [
            "streamingTextureForceLoadAll"
        ],
        "description": "return:static bool des: Force streaming textures to load all mipmap levels."
    },
    "Texture.streamingTextureLoadingCount": {
        "prefix": "Texture.streamingTextureLoadingCount",
        "body": [
            "streamingTextureLoadingCount"
        ],
        "description": "return:static ulong des: Number of streaming textures with mipmaps currently loading."
    },
    "Texture.streamingTexturePendingLoadCount": {
        "prefix": "Texture.streamingTexturePendingLoadCount",
        "body": [
            "streamingTexturePendingLoadCount"
        ],
        "description": "return:static ulong des: Number of streaming textures with outstanding mipmaps to be loaded."
    },
    "Texture.targetTextureMemory": {
        "prefix": "Texture.targetTextureMemory",
        "body": [
            "targetTextureMemory"
        ],
        "description": "return:static ulong des: The amount of memory used by textures after the mipmap streaming and budget are applied and loading is complete."
    },
    "Texture.totalTextureMemory": {
        "prefix": "Texture.totalTextureMemory",
        "body": [
            "totalTextureMemory"
        ],
        "description": "return:static ulong des: The total amount of memory that would be used by all textures at mipmap level 0."
    },
    "Texture2D.blackTexture": {
        "prefix": "Texture2D.blackTexture",
        "body": [
            "blackTexture"
        ],
        "description": "return:static Texture2D des: Get a small texture with all black pixels."
    },
    "Texture2D.whiteTexture": {
        "prefix": "Texture2D.whiteTexture",
        "body": [
            "whiteTexture"
        ],
        "description": "return:static Texture2D des: Get a small texture with all white pixels."
    },
    "Texture2D.currentTextureMemory": {
        "prefix": "Texture2D.currentTextureMemory",
        "body": [
            "currentTextureMemory"
        ],
        "description": "return:static ulong des: The amount of memory currently being used by textures."
    },
    "Texture2D.desiredTextureMemory": {
        "prefix": "Texture2D.desiredTextureMemory",
        "body": [
            "desiredTextureMemory"
        ],
        "description": "return:static ulong des: This amount of texture memory would be used before the texture streaming budget is applied."
    },
    "Texture2D.nonStreamingTextureCount": {
        "prefix": "Texture2D.nonStreamingTextureCount",
        "body": [
            "nonStreamingTextureCount"
        ],
        "description": "return:static ulong des: Number of non-streaming textures."
    },
    "Texture2D.nonStreamingTextureMemory": {
        "prefix": "Texture2D.nonStreamingTextureMemory",
        "body": [
            "nonStreamingTextureMemory"
        ],
        "description": "return:static ulong des: Total amount of memory being used by non-streaming textures."
    },
    "Texture2D.streamingMipmapUploadCount": {
        "prefix": "Texture2D.streamingMipmapUploadCount",
        "body": [
            "streamingMipmapUploadCount"
        ],
        "description": "return:static ulong des: How many times has a texture been uploaded due to texture mipmap streaming."
    },
    "Texture2D.streamingRendererCount": {
        "prefix": "Texture2D.streamingRendererCount",
        "body": [
            "streamingRendererCount"
        ],
        "description": "return:static ulong des: Number of renderers registered with the texture streaming system."
    },
    "Texture2D.streamingTextureCount": {
        "prefix": "Texture2D.streamingTextureCount",
        "body": [
            "streamingTextureCount"
        ],
        "description": "return:static ulong des: Number of streaming textures."
    },
    "Texture2D.streamingTextureDiscardUnusedMips": {
        "prefix": "Texture2D.streamingTextureDiscardUnusedMips",
        "body": [
            "streamingTextureDiscardUnusedMips"
        ],
        "description": "return:static bool des: Force the streaming texture system to discard all unused mipmaps immediately, rather than caching them until the texture memory budget is exceeded."
    },
    "Texture2D.streamingTextureForceLoadAll": {
        "prefix": "Texture2D.streamingTextureForceLoadAll",
        "body": [
            "streamingTextureForceLoadAll"
        ],
        "description": "return:static bool des: Force streaming textures to load all mipmap levels."
    },
    "Texture2D.streamingTextureLoadingCount": {
        "prefix": "Texture2D.streamingTextureLoadingCount",
        "body": [
            "streamingTextureLoadingCount"
        ],
        "description": "return:static ulong des: Number of streaming textures with mipmaps currently loading."
    },
    "Texture2D.streamingTexturePendingLoadCount": {
        "prefix": "Texture2D.streamingTexturePendingLoadCount",
        "body": [
            "streamingTexturePendingLoadCount"
        ],
        "description": "return:static ulong des: Number of streaming textures with outstanding mipmaps to be loaded."
    },
    "Texture2D.targetTextureMemory": {
        "prefix": "Texture2D.targetTextureMemory",
        "body": [
            "targetTextureMemory"
        ],
        "description": "return:static ulong des: The amount of memory used by textures after the mipmap streaming and budget are applied and loading is complete."
    },
    "Texture2D.totalTextureMemory": {
        "prefix": "Texture2D.totalTextureMemory",
        "body": [
            "totalTextureMemory"
        ],
        "description": "return:static ulong des: The total amount of memory that would be used by all textures at mipmap level 0."
    },
    "Texture2DArray.currentTextureMemory": {
        "prefix": "Texture2DArray.currentTextureMemory",
        "body": [
            "currentTextureMemory"
        ],
        "description": "return:static ulong des: The amount of memory currently being used by textures."
    },
    "Texture2DArray.desiredTextureMemory": {
        "prefix": "Texture2DArray.desiredTextureMemory",
        "body": [
            "desiredTextureMemory"
        ],
        "description": "return:static ulong des: This amount of texture memory would be used before the texture streaming budget is applied."
    },
    "Texture2DArray.nonStreamingTextureCount": {
        "prefix": "Texture2DArray.nonStreamingTextureCount",
        "body": [
            "nonStreamingTextureCount"
        ],
        "description": "return:static ulong des: Number of non-streaming textures."
    },
    "Texture2DArray.nonStreamingTextureMemory": {
        "prefix": "Texture2DArray.nonStreamingTextureMemory",
        "body": [
            "nonStreamingTextureMemory"
        ],
        "description": "return:static ulong des: Total amount of memory being used by non-streaming textures."
    },
    "Texture2DArray.streamingMipmapUploadCount": {
        "prefix": "Texture2DArray.streamingMipmapUploadCount",
        "body": [
            "streamingMipmapUploadCount"
        ],
        "description": "return:static ulong des: How many times has a texture been uploaded due to texture mipmap streaming."
    },
    "Texture2DArray.streamingRendererCount": {
        "prefix": "Texture2DArray.streamingRendererCount",
        "body": [
            "streamingRendererCount"
        ],
        "description": "return:static ulong des: Number of renderers registered with the texture streaming system."
    },
    "Texture2DArray.streamingTextureCount": {
        "prefix": "Texture2DArray.streamingTextureCount",
        "body": [
            "streamingTextureCount"
        ],
        "description": "return:static ulong des: Number of streaming textures."
    },
    "Texture2DArray.streamingTextureDiscardUnusedMips": {
        "prefix": "Texture2DArray.streamingTextureDiscardUnusedMips",
        "body": [
            "streamingTextureDiscardUnusedMips"
        ],
        "description": "return:static bool des: Force the streaming texture system to discard all unused mipmaps immediately, rather than caching them until the texture memory budget is exceeded."
    },
    "Texture2DArray.streamingTextureForceLoadAll": {
        "prefix": "Texture2DArray.streamingTextureForceLoadAll",
        "body": [
            "streamingTextureForceLoadAll"
        ],
        "description": "return:static bool des: Force streaming textures to load all mipmap levels."
    },
    "Texture2DArray.streamingTextureLoadingCount": {
        "prefix": "Texture2DArray.streamingTextureLoadingCount",
        "body": [
            "streamingTextureLoadingCount"
        ],
        "description": "return:static ulong des: Number of streaming textures with mipmaps currently loading."
    },
    "Texture2DArray.streamingTexturePendingLoadCount": {
        "prefix": "Texture2DArray.streamingTexturePendingLoadCount",
        "body": [
            "streamingTexturePendingLoadCount"
        ],
        "description": "return:static ulong des: Number of streaming textures with outstanding mipmaps to be loaded."
    },
    "Texture2DArray.targetTextureMemory": {
        "prefix": "Texture2DArray.targetTextureMemory",
        "body": [
            "targetTextureMemory"
        ],
        "description": "return:static ulong des: The amount of memory used by textures after the mipmap streaming and budget are applied and loading is complete."
    },
    "Texture2DArray.totalTextureMemory": {
        "prefix": "Texture2DArray.totalTextureMemory",
        "body": [
            "totalTextureMemory"
        ],
        "description": "return:static ulong des: The total amount of memory that would be used by all textures at mipmap level 0."
    },
    "Texture3D.currentTextureMemory": {
        "prefix": "Texture3D.currentTextureMemory",
        "body": [
            "currentTextureMemory"
        ],
        "description": "return:static ulong des: The amount of memory currently being used by textures."
    },
    "Texture3D.desiredTextureMemory": {
        "prefix": "Texture3D.desiredTextureMemory",
        "body": [
            "desiredTextureMemory"
        ],
        "description": "return:static ulong des: This amount of texture memory would be used before the texture streaming budget is applied."
    },
    "Texture3D.nonStreamingTextureCount": {
        "prefix": "Texture3D.nonStreamingTextureCount",
        "body": [
            "nonStreamingTextureCount"
        ],
        "description": "return:static ulong des: Number of non-streaming textures."
    },
    "Texture3D.nonStreamingTextureMemory": {
        "prefix": "Texture3D.nonStreamingTextureMemory",
        "body": [
            "nonStreamingTextureMemory"
        ],
        "description": "return:static ulong des: Total amount of memory being used by non-streaming textures."
    },
    "Texture3D.streamingMipmapUploadCount": {
        "prefix": "Texture3D.streamingMipmapUploadCount",
        "body": [
            "streamingMipmapUploadCount"
        ],
        "description": "return:static ulong des: How many times has a texture been uploaded due to texture mipmap streaming."
    },
    "Texture3D.streamingRendererCount": {
        "prefix": "Texture3D.streamingRendererCount",
        "body": [
            "streamingRendererCount"
        ],
        "description": "return:static ulong des: Number of renderers registered with the texture streaming system."
    },
    "Texture3D.streamingTextureCount": {
        "prefix": "Texture3D.streamingTextureCount",
        "body": [
            "streamingTextureCount"
        ],
        "description": "return:static ulong des: Number of streaming textures."
    },
    "Texture3D.streamingTextureDiscardUnusedMips": {
        "prefix": "Texture3D.streamingTextureDiscardUnusedMips",
        "body": [
            "streamingTextureDiscardUnusedMips"
        ],
        "description": "return:static bool des: Force the streaming texture system to discard all unused mipmaps immediately, rather than caching them until the texture memory budget is exceeded."
    },
    "Texture3D.streamingTextureForceLoadAll": {
        "prefix": "Texture3D.streamingTextureForceLoadAll",
        "body": [
            "streamingTextureForceLoadAll"
        ],
        "description": "return:static bool des: Force streaming textures to load all mipmap levels."
    },
    "Texture3D.streamingTextureLoadingCount": {
        "prefix": "Texture3D.streamingTextureLoadingCount",
        "body": [
            "streamingTextureLoadingCount"
        ],
        "description": "return:static ulong des: Number of streaming textures with mipmaps currently loading."
    },
    "Texture3D.streamingTexturePendingLoadCount": {
        "prefix": "Texture3D.streamingTexturePendingLoadCount",
        "body": [
            "streamingTexturePendingLoadCount"
        ],
        "description": "return:static ulong des: Number of streaming textures with outstanding mipmaps to be loaded."
    },
    "Texture3D.targetTextureMemory": {
        "prefix": "Texture3D.targetTextureMemory",
        "body": [
            "targetTextureMemory"
        ],
        "description": "return:static ulong des: The amount of memory used by textures after the mipmap streaming and budget are applied and loading is complete."
    },
    "Texture3D.totalTextureMemory": {
        "prefix": "Texture3D.totalTextureMemory",
        "body": [
            "totalTextureMemory"
        ],
        "description": "return:static ulong des: The total amount of memory that would be used by all textures at mipmap level 0."
    },
    "Time.captureFramerate": {
        "prefix": "Time.captureFramerate",
        "body": [
            "captureFramerate"
        ],
        "description": "return:static int des: Slows game playback time to allow screenshots to be saved between frames."
    },
    "Time.deltaTime": {
        "prefix": "Time.deltaTime",
        "body": [
            "deltaTime"
        ],
        "description": "return:static float des: The time in seconds it took to complete the last frame (Read Only)."
    },
    "Time.fixedDeltaTime": {
        "prefix": "Time.fixedDeltaTime",
        "body": [
            "fixedDeltaTime"
        ],
        "description": "return:static float des: The interval in seconds at which physics and other fixed frame rate updates (like MonoBehaviour's FixedUpdate) are performed."
    },
    "Time.fixedTime": {
        "prefix": "Time.fixedTime",
        "body": [
            "fixedTime"
        ],
        "description": "return:static float des: The time the latest FixedUpdate has started (Read Only). This is the time in seconds since the start of the game."
    },
    "Time.fixedUnscaledDeltaTime": {
        "prefix": "Time.fixedUnscaledDeltaTime",
        "body": [
            "fixedUnscaledDeltaTime"
        ],
        "description": "return:static float des: The timeScale-independent interval in seconds from the last fixed frame to the current one (Read Only)."
    },
    "Time.fixedUnscaledTime": {
        "prefix": "Time.fixedUnscaledTime",
        "body": [
            "fixedUnscaledTime"
        ],
        "description": "return:static float des: The TimeScale-independant time the latest FixedUpdate has started (Read Only). This is the time in seconds since the start of the game."
    },
    "Time.frameCount": {
        "prefix": "Time.frameCount",
        "body": [
            "frameCount"
        ],
        "description": "return:static int des: The total number of frames that have passed (Read Only)."
    },
    "Time.inFixedTimeStep": {
        "prefix": "Time.inFixedTimeStep",
        "body": [
            "inFixedTimeStep"
        ],
        "description": "return:static bool des: Returns true if called inside a fixed time step callback (like MonoBehaviour's FixedUpdate), otherwise returns false."
    },
    "Time.maximumDeltaTime": {
        "prefix": "Time.maximumDeltaTime",
        "body": [
            "maximumDeltaTime"
        ],
        "description": "return:static float des: The maximum time a frame can take. Physics and other fixed frame rate updates (like MonoBehaviour's FixedUpdate) will be performed only for this duration of time per frame."
    },
    "Time.maximumParticleDeltaTime": {
        "prefix": "Time.maximumParticleDeltaTime",
        "body": [
            "maximumParticleDeltaTime"
        ],
        "description": "return:static float des: The maximum time a frame can spend on particle updates. If the frame takes longer than this, then updates are split into multiple smaller updates."
    },
    "Time.realtimeSinceStartup": {
        "prefix": "Time.realtimeSinceStartup",
        "body": [
            "realtimeSinceStartup"
        ],
        "description": "return:static float des: The real time in seconds since the game started (Read Only)."
    },
    "Time.smoothDeltaTime": {
        "prefix": "Time.smoothDeltaTime",
        "body": [
            "smoothDeltaTime"
        ],
        "description": "return:static float des: A smoothed out Time.deltaTime (Read Only)."
    },
    "Time.time": {
        "prefix": "Time.time",
        "body": [
            "time"
        ],
        "description": "return:static float des: The time at the beginning of this frame (Read Only). This is the time in seconds since the start of the game."
    },
    "Time.timeScale": {
        "prefix": "Time.timeScale",
        "body": [
            "timeScale"
        ],
        "description": "return:static float des: The scale at which the time is passing. This can be used for slow motion effects."
    },
    "Time.timeSinceLevelLoad": {
        "prefix": "Time.timeSinceLevelLoad",
        "body": [
            "timeSinceLevelLoad"
        ],
        "description": "return:static float des: The time this frame has started (Read Only). This is the time in seconds since the last level has been loaded."
    },
    "Time.unscaledDeltaTime": {
        "prefix": "Time.unscaledDeltaTime",
        "body": [
            "unscaledDeltaTime"
        ],
        "description": "return:static float des: The timeScale-independent interval in seconds from the last frame to the current one (Read Only)."
    },
    "Time.unscaledTime": {
        "prefix": "Time.unscaledTime",
        "body": [
            "unscaledTime"
        ],
        "description": "return:static float des: The timeScale-independant time for this frame (Read Only). This is the time in seconds since the start of the game."
    },
    "TouchScreenKeyboard.area": {
        "prefix": "TouchScreenKeyboard.area",
        "body": [
            "area"
        ],
        "description": "return:static Rect des: Returns portion of the screen which is covered by the keyboard."
    },
    "TouchScreenKeyboard.hideInput": {
        "prefix": "TouchScreenKeyboard.hideInput",
        "body": [
            "hideInput"
        ],
        "description": "return:static bool des: Will text input field above the keyboard be hidden when the keyboard is on screen?"
    },
    "TouchScreenKeyboard.isSupported": {
        "prefix": "TouchScreenKeyboard.isSupported",
        "body": [
            "isSupported"
        ],
        "description": "return:static bool des: Is touch screen keyboard supported."
    },
    "TouchScreenKeyboard.visible": {
        "prefix": "TouchScreenKeyboard.visible",
        "body": [
            "visible"
        ],
        "description": "return:static bool des: Returns true whenever any keyboard is completely visible on the screen."
    },
    "UIVertex.simpleVert": {
        "prefix": "UIVertex.simpleVert",
        "body": [
            "simpleVert"
        ],
        "description": "return:static UIVertex des: Simple UIVertex with sensible settings for use in the UI system."
    },
    "Vector2.down": {
        "prefix": "Vector2.down",
        "body": [
            "down"
        ],
        "description": "return:static Vector2 des: Shorthand for writing Vector2(0, -1)."
    },
    "Vector2.left": {
        "prefix": "Vector2.left",
        "body": [
            "left"
        ],
        "description": "return:static Vector2 des: Shorthand for writing Vector2(-1, 0)."
    },
    "Vector2.negativeInfinity": {
        "prefix": "Vector2.negativeInfinity",
        "body": [
            "negativeInfinity"
        ],
        "description": "return:static Vector2 des: Shorthand for writing Vector2(float.NegativeInfinity, float.NegativeInfinity)."
    },
    "Vector2.one": {
        "prefix": "Vector2.one",
        "body": [
            "one"
        ],
        "description": "return:static Vector2 des: Shorthand for writing Vector2(1, 1)."
    },
    "Vector2.positiveInfinity": {
        "prefix": "Vector2.positiveInfinity",
        "body": [
            "positiveInfinity"
        ],
        "description": "return:static Vector2 des: Shorthand for writing Vector2(float.PositiveInfinity, float.PositiveInfinity)."
    },
    "Vector2.right": {
        "prefix": "Vector2.right",
        "body": [
            "right"
        ],
        "description": "return:static Vector2 des: Shorthand for writing Vector2(1, 0)."
    },
    "Vector2.up": {
        "prefix": "Vector2.up",
        "body": [
            "up"
        ],
        "description": "return:static Vector2 des: Shorthand for writing Vector2(0, 1)."
    },
    "Vector2.zero": {
        "prefix": "Vector2.zero",
        "body": [
            "zero"
        ],
        "description": "return:static Vector2 des: Shorthand for writing Vector2(0, 0)."
    },
    "Vector2Int.down": {
        "prefix": "Vector2Int.down",
        "body": [
            "down"
        ],
        "description": "return:static Vector2Int des: Shorthand for writing Vector2Int (0, -1)."
    },
    "Vector2Int.left": {
        "prefix": "Vector2Int.left",
        "body": [
            "left"
        ],
        "description": "return:static Vector2Int des: Shorthand for writing Vector2Int (-1, 0)."
    },
    "Vector2Int.one": {
        "prefix": "Vector2Int.one",
        "body": [
            "one"
        ],
        "description": "return:static Vector2Int des: Shorthand for writing Vector2Int (1, 1)."
    },
    "Vector2Int.right": {
        "prefix": "Vector2Int.right",
        "body": [
            "right"
        ],
        "description": "return:static Vector2Int des: Shorthand for writing Vector2Int (1, 0)."
    },
    "Vector2Int.up": {
        "prefix": "Vector2Int.up",
        "body": [
            "up"
        ],
        "description": "return:static Vector2Int des: Shorthand for writing Vector2Int (0, 1)."
    },
    "Vector2Int.zero": {
        "prefix": "Vector2Int.zero",
        "body": [
            "zero"
        ],
        "description": "return:static Vector2Int des: Shorthand for writing Vector2Int (0, 0)."
    },
    "Vector3.back": {
        "prefix": "Vector3.back",
        "body": [
            "back"
        ],
        "description": "return:static Vector3 des: Shorthand for writing Vector3(0, 0, -1)."
    },
    "Vector3.down": {
        "prefix": "Vector3.down",
        "body": [
            "down"
        ],
        "description": "return:static Vector3 des: Shorthand for writing Vector3(0, -1, 0)."
    },
    "Vector3.forward": {
        "prefix": "Vector3.forward",
        "body": [
            "forward"
        ],
        "description": "return:static Vector3 des: Shorthand for writing Vector3(0, 0, 1)."
    },
    "Vector3.left": {
        "prefix": "Vector3.left",
        "body": [
            "left"
        ],
        "description": "return:static Vector3 des: Shorthand for writing Vector3(-1, 0, 0)."
    },
    "Vector3.negativeInfinity": {
        "prefix": "Vector3.negativeInfinity",
        "body": [
            "negativeInfinity"
        ],
        "description": "return:static Vector3 des: Shorthand for writing Vector3(float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity)."
    },
    "Vector3.one": {
        "prefix": "Vector3.one",
        "body": [
            "one"
        ],
        "description": "return:static Vector3 des: Shorthand for writing Vector3(1, 1, 1)."
    },
    "Vector3.positiveInfinity": {
        "prefix": "Vector3.positiveInfinity",
        "body": [
            "positiveInfinity"
        ],
        "description": "return:static Vector3 des: Shorthand for writing Vector3(float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity)."
    },
    "Vector3.right": {
        "prefix": "Vector3.right",
        "body": [
            "right"
        ],
        "description": "return:static Vector3 des: Shorthand for writing Vector3(1, 0, 0)."
    },
    "Vector3.up": {
        "prefix": "Vector3.up",
        "body": [
            "up"
        ],
        "description": "return:static Vector3 des: Shorthand for writing Vector3(0, 1, 0)."
    },
    "Vector3.zero": {
        "prefix": "Vector3.zero",
        "body": [
            "zero"
        ],
        "description": "return:static Vector3 des: Shorthand for writing Vector3(0, 0, 0)."
    },
    "Vector3Int.down": {
        "prefix": "Vector3Int.down",
        "body": [
            "down"
        ],
        "description": "return:static Vector3Int des: Shorthand for writing Vector3Int (0, -1, 0)."
    },
    "Vector3Int.left": {
        "prefix": "Vector3Int.left",
        "body": [
            "left"
        ],
        "description": "return:static Vector3Int des: Shorthand for writing Vector3Int (-1, 0, 0)."
    },
    "Vector3Int.one": {
        "prefix": "Vector3Int.one",
        "body": [
            "one"
        ],
        "description": "return:static Vector3Int des: Shorthand for writing Vector3Int (1, 1, 1)."
    },
    "Vector3Int.right": {
        "prefix": "Vector3Int.right",
        "body": [
            "right"
        ],
        "description": "return:static Vector3Int des: Shorthand for writing Vector3Int (1, 0, 0)."
    },
    "Vector3Int.up": {
        "prefix": "Vector3Int.up",
        "body": [
            "up"
        ],
        "description": "return:static Vector3Int des: Shorthand for writing Vector3Int (0, 1, 0)."
    },
    "Vector3Int.zero": {
        "prefix": "Vector3Int.zero",
        "body": [
            "zero"
        ],
        "description": "return:static Vector3Int des: Shorthand for writing Vector3Int (0, 0, 0)."
    },
    "Vector4.negativeInfinity": {
        "prefix": "Vector4.negativeInfinity",
        "body": [
            "negativeInfinity"
        ],
        "description": "return:static Vector4 des: Shorthand for writing Vector4(float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity)."
    },
    "Vector4.one": {
        "prefix": "Vector4.one",
        "body": [
            "one"
        ],
        "description": "return:static Vector4 des: Shorthand for writing Vector4(1,1,1,1)."
    },
    "Vector4.positiveInfinity": {
        "prefix": "Vector4.positiveInfinity",
        "body": [
            "positiveInfinity"
        ],
        "description": "return:static Vector4 des: Shorthand for writing Vector4(float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity)."
    },
    "Vector4.zero": {
        "prefix": "Vector4.zero",
        "body": [
            "zero"
        ],
        "description": "return:static Vector4 des: Shorthand for writing Vector4(0,0,0,0)."
    },
    "WebCamTexture.devices": {
        "prefix": "WebCamTexture.devices",
        "body": [
            "devices"
        ],
        "description": "return:static WebCamDevice[] des: Return a list of available devices."
    },
    "WebCamTexture.currentTextureMemory": {
        "prefix": "WebCamTexture.currentTextureMemory",
        "body": [
            "currentTextureMemory"
        ],
        "description": "return:static ulong des: The amount of memory currently being used by textures."
    },
    "WebCamTexture.desiredTextureMemory": {
        "prefix": "WebCamTexture.desiredTextureMemory",
        "body": [
            "desiredTextureMemory"
        ],
        "description": "return:static ulong des: This amount of texture memory would be used before the texture streaming budget is applied."
    },
    "WebCamTexture.nonStreamingTextureCount": {
        "prefix": "WebCamTexture.nonStreamingTextureCount",
        "body": [
            "nonStreamingTextureCount"
        ],
        "description": "return:static ulong des: Number of non-streaming textures."
    },
    "WebCamTexture.nonStreamingTextureMemory": {
        "prefix": "WebCamTexture.nonStreamingTextureMemory",
        "body": [
            "nonStreamingTextureMemory"
        ],
        "description": "return:static ulong des: Total amount of memory being used by non-streaming textures."
    },
    "WebCamTexture.streamingMipmapUploadCount": {
        "prefix": "WebCamTexture.streamingMipmapUploadCount",
        "body": [
            "streamingMipmapUploadCount"
        ],
        "description": "return:static ulong des: How many times has a texture been uploaded due to texture mipmap streaming."
    },
    "WebCamTexture.streamingRendererCount": {
        "prefix": "WebCamTexture.streamingRendererCount",
        "body": [
            "streamingRendererCount"
        ],
        "description": "return:static ulong des: Number of renderers registered with the texture streaming system."
    },
    "WebCamTexture.streamingTextureCount": {
        "prefix": "WebCamTexture.streamingTextureCount",
        "body": [
            "streamingTextureCount"
        ],
        "description": "return:static ulong des: Number of streaming textures."
    },
    "WebCamTexture.streamingTextureDiscardUnusedMips": {
        "prefix": "WebCamTexture.streamingTextureDiscardUnusedMips",
        "body": [
            "streamingTextureDiscardUnusedMips"
        ],
        "description": "return:static bool des: Force the streaming texture system to discard all unused mipmaps immediately, rather than caching them until the texture memory budget is exceeded."
    },
    "WebCamTexture.streamingTextureForceLoadAll": {
        "prefix": "WebCamTexture.streamingTextureForceLoadAll",
        "body": [
            "streamingTextureForceLoadAll"
        ],
        "description": "return:static bool des: Force streaming textures to load all mipmap levels."
    },
    "WebCamTexture.streamingTextureLoadingCount": {
        "prefix": "WebCamTexture.streamingTextureLoadingCount",
        "body": [
            "streamingTextureLoadingCount"
        ],
        "description": "return:static ulong des: Number of streaming textures with mipmaps currently loading."
    },
    "WebCamTexture.streamingTexturePendingLoadCount": {
        "prefix": "WebCamTexture.streamingTexturePendingLoadCount",
        "body": [
            "streamingTexturePendingLoadCount"
        ],
        "description": "return:static ulong des: Number of streaming textures with outstanding mipmaps to be loaded."
    },
    "WebCamTexture.targetTextureMemory": {
        "prefix": "WebCamTexture.targetTextureMemory",
        "body": [
            "targetTextureMemory"
        ],
        "description": "return:static ulong des: The amount of memory used by textures after the mipmap streaming and budget are applied and loading is complete."
    },
    "WebCamTexture.totalTextureMemory": {
        "prefix": "WebCamTexture.totalTextureMemory",
        "body": [
            "totalTextureMemory"
        ],
        "description": "return:static ulong des: The total amount of memory that would be used by all textures at mipmap level 0."
    },
    "WebGLInput.captureAllKeyboardInput": {
        "prefix": "WebGLInput.captureAllKeyboardInput",
        "body": [
            "captureAllKeyboardInput"
        ],
        "description": "return:static bool des: Capture all keyboard inputs."
    }
}