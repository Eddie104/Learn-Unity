{
	"Load scene": {
		"prefix": "LoadScene",
		"body": [
			"SceneManager.LoadScene('$1')"
		],
		"description": "Load scene"
	},
	"Log info": {
		"prefix": "logInfo",
		"body": [
			"logInfo('$1')"
		],
		"description": "logInfo"
	},
	"Log debug": {
		"prefix": "logDebug",
		"body": [
			"logDebug('$1')"
		],
		"description": "logDebug"
	},
	"Log warn": {
		"prefix": "logWarn",
		"body": [
			"logWarn('$1')"
		],
		"description": "logWarn"
	},
	"Log error": {
		"prefix": "logError",
		"body": [
			"logError('$1')"
		],
		"description": "logError"
	},
	"AccelerationEvent.acceleration": {
		"prefix": "AccelerationEvent.acceleration",
		"body": [
			"acceleration"
		],
		"description": "return:Vector3 des: Value of acceleration."
	}
,
	"AccelerationEvent.deltaTime": {
		"prefix": "AccelerationEvent.deltaTime",
		"body": [
			"deltaTime"
		],
		"description": "return:float des: Amount of time passed since last accelerometer measurement."
	}
,
	"AnchoredJoint2D.anchor": {
		"prefix": "AnchoredJoint2D.anchor",
		"body": [
			"anchor"
		],
		"description": "return:Vector2 des: The joint's anchor point on the object that has the joint component."
	}
,
	"AnchoredJoint2D.autoConfigureConnectedAnchor": {
		"prefix": "AnchoredJoint2D.autoConfigureConnectedAnchor",
		"body": [
			"autoConfigureConnectedAnchor"
		],
		"description": "return:bool des: Should the connectedAnchor be calculated automatically?"
	}
,
	"AnchoredJoint2D.connectedAnchor": {
		"prefix": "AnchoredJoint2D.connectedAnchor",
		"body": [
			"connectedAnchor"
		],
		"description": "return:Vector2 des: The joint's anchor point on the second object (ie, the one which doesn't have the joint component)."
	}
,
	"AnchoredJoint2D.enabled": {
		"prefix": "AnchoredJoint2D.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"AnchoredJoint2D.isActiveAndEnabled": {
		"prefix": "AnchoredJoint2D.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"AnchoredJoint2D.gameObject": {
		"prefix": "AnchoredJoint2D.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"AnchoredJoint2D.tag": {
		"prefix": "AnchoredJoint2D.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"AnchoredJoint2D.transform": {
		"prefix": "AnchoredJoint2D.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"AnchoredJoint2D.attachedRigidbody": {
		"prefix": "AnchoredJoint2D.attachedRigidbody",
		"body": [
			"attachedRigidbody"
		],
		"description": "return:Rigidbody2D des: The Rigidbody2D attached to the Joint2D."
	}
,
	"AnchoredJoint2D.breakForce": {
		"prefix": "AnchoredJoint2D.breakForce",
		"body": [
			"breakForce"
		],
		"description": "return:float des: The force that needs to be applied for this joint to break."
	}
,
	"AnchoredJoint2D.breakTorque": {
		"prefix": "AnchoredJoint2D.breakTorque",
		"body": [
			"breakTorque"
		],
		"description": "return:float des: The torque that needs to be applied for this joint to break."
	}
,
	"AnchoredJoint2D.connectedBody": {
		"prefix": "AnchoredJoint2D.connectedBody",
		"body": [
			"connectedBody"
		],
		"description": "return:Rigidbody2D des: The Rigidbody2D object to which the other end of the joint is attached (ie, the object without the joint component)."
	}
,
	"AnchoredJoint2D.enableCollision": {
		"prefix": "AnchoredJoint2D.enableCollision",
		"body": [
			"enableCollision"
		],
		"description": "return:bool des: Should the two rigid bodies connected with this joint collide with each other?"
	}
,
	"AnchoredJoint2D.reactionForce": {
		"prefix": "AnchoredJoint2D.reactionForce",
		"body": [
			"reactionForce"
		],
		"description": "return:Vector2 des: Gets the reaction force of the joint."
	}
,
	"AnchoredJoint2D.reactionTorque": {
		"prefix": "AnchoredJoint2D.reactionTorque",
		"body": [
			"reactionTorque"
		],
		"description": "return:float des: Gets the reaction torque of the joint."
	}
,
	"AnchoredJoint2D.hideFlags": {
		"prefix": "AnchoredJoint2D.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"AnchoredJoint2D.name": {
		"prefix": "AnchoredJoint2D.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"AnchoredJoint2D.BroadcastMessage": {
		"prefix": "AnchoredJoint2D.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"AnchoredJoint2D.CompareTag": {
		"prefix": "AnchoredJoint2D.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"AnchoredJoint2D.GetComponent": {
		"prefix": "AnchoredJoint2D.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"AnchoredJoint2D.GetComponentInChildren": {
		"prefix": "AnchoredJoint2D.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"AnchoredJoint2D.GetComponentInParent": {
		"prefix": "AnchoredJoint2D.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"AnchoredJoint2D.GetComponents": {
		"prefix": "AnchoredJoint2D.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"AnchoredJoint2D.GetComponentsInChildren": {
		"prefix": "AnchoredJoint2D.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"AnchoredJoint2D.GetComponentsInParent": {
		"prefix": "AnchoredJoint2D.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"AnchoredJoint2D.SendMessage": {
		"prefix": "AnchoredJoint2D.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"AnchoredJoint2D.SendMessageUpwards": {
		"prefix": "AnchoredJoint2D.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"AnchoredJoint2D.GetReactionForce": {
		"prefix": "AnchoredJoint2D.GetReactionForce",
		"body": [
			"GetReactionForce($1)"
		],
		"description": "public Vector2 GetReactionForce(float timeStep); des: Gets the reaction force of the joint given the specified timeStep."
	}
,
	"AnchoredJoint2D.GetReactionTorque": {
		"prefix": "AnchoredJoint2D.GetReactionTorque",
		"body": [
			"GetReactionTorque($1)"
		],
		"description": "public float GetReactionTorque(float timeStep); des: Gets the reaction torque of the joint given the specified timeStep."
	}
,
	"AnchoredJoint2D.GetInstanceID": {
		"prefix": "AnchoredJoint2D.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"AnchoredJoint2D.ToString": {
		"prefix": "AnchoredJoint2D.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"AnchoredJoint2D.Destroy": {
		"prefix": "AnchoredJoint2D.Destroy",
		"body": [
			"AnchoredJoint2D.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"AnchoredJoint2D.DestroyImmediate": {
		"prefix": "AnchoredJoint2D.DestroyImmediate",
		"body": [
			"AnchoredJoint2D.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"AnchoredJoint2D.DontDestroyOnLoad": {
		"prefix": "AnchoredJoint2D.DontDestroyOnLoad",
		"body": [
			"AnchoredJoint2D.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"AnchoredJoint2D.FindObjectOfType": {
		"prefix": "AnchoredJoint2D.FindObjectOfType",
		"body": [
			"AnchoredJoint2D.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"AnchoredJoint2D.FindObjectsOfType": {
		"prefix": "AnchoredJoint2D.FindObjectsOfType",
		"body": [
			"AnchoredJoint2D.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"AnchoredJoint2D.Instantiate": {
		"prefix": "AnchoredJoint2D.Instantiate",
		"body": [
			"AnchoredJoint2D.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"AnchoredJoint2D.OnJointBreak2D": {
		"prefix": "AnchoredJoint2D.OnJointBreak2D",
		"body": [
			"OnJointBreak2D"
		],
		"description": "Called when a Joint2D attached to the same game object breaks."
	}
,
	"AndroidInput.GetSecondaryTouch": {
		"prefix": "AndroidInput.GetSecondaryTouch",
		"body": [
			"AndroidInput.GetSecondaryTouch"
		],
		"description": "public static Touch GetSecondaryTouch(int index); des: Returns object representing status of a specific touch on a secondary touchpad (Does not allocate temporary variables)."
	}
,
	"AndroidJavaClass.Call": {
		"prefix": "AndroidJavaClass.Call",
		"body": [
			"Call($1)"
		],
		"description": "public void Call(string methodName, params object[] args); public ReturnType Call(string methodName, params object[] args); des: Calls a Java method on an object (non-static)."
	}
,
	"AndroidJavaClass.CallStatic": {
		"prefix": "AndroidJavaClass.CallStatic",
		"body": [
			"CallStatic($1)"
		],
		"description": "public void CallStatic(string methodName, params object[] args); public ReturnType CallStatic(string methodName, params object[] args); des: Call a static Java method on a class."
	}
,
	"AndroidJavaClass.Dispose": {
		"prefix": "AndroidJavaClass.Dispose",
		"body": [
			"Dispose($1)"
		],
		"description": "public void Dispose(); des: IDisposable callback."
	}
,
	"AndroidJavaClass.Get": {
		"prefix": "AndroidJavaClass.Get",
		"body": [
			"Get($1)"
		],
		"description": "public FieldType Get(string fieldName); des: Get the value of a field in an object (non-static)."
	}
,
	"AndroidJavaClass.GetRawClass": {
		"prefix": "AndroidJavaClass.GetRawClass",
		"body": [
			"GetRawClass($1)"
		],
		"description": "public IntPtr GetRawClass(); des: Retrieves the raw jclass pointer to the Java class."
	}
,
	"AndroidJavaClass.GetRawObject": {
		"prefix": "AndroidJavaClass.GetRawObject",
		"body": [
			"GetRawObject($1)"
		],
		"description": "public IntPtr GetRawObject(); des: Retrieves the raw jobject pointer to the Java object."
	}
,
	"AndroidJavaClass.GetStatic": {
		"prefix": "AndroidJavaClass.GetStatic",
		"body": [
			"GetStatic($1)"
		],
		"description": "public FieldType GetStatic(string fieldName); des: Get the value of a static field in an object type."
	}
,
	"AndroidJavaClass.Set": {
		"prefix": "AndroidJavaClass.Set",
		"body": [
			"Set($1)"
		],
		"description": "public void Set(string fieldName, FieldType val); des: Set the value of a field in an object (non-static)."
	}
,
	"AndroidJavaClass.SetStatic": {
		"prefix": "AndroidJavaClass.SetStatic",
		"body": [
			"SetStatic($1)"
		],
		"description": "public void SetStatic(string fieldName, FieldType val); des: Set the value of a static field in an object type."
	}
,
	"AndroidJavaObject.Call": {
		"prefix": "AndroidJavaObject.Call",
		"body": [
			"Call($1)"
		],
		"description": "public void Call(string methodName, params object[] args); public ReturnType Call(string methodName, params object[] args); des: Calls a Java method on an object (non-static)."
	}
,
	"AndroidJavaObject.CallStatic": {
		"prefix": "AndroidJavaObject.CallStatic",
		"body": [
			"CallStatic($1)"
		],
		"description": "public void CallStatic(string methodName, params object[] args); public ReturnType CallStatic(string methodName, params object[] args); des: Call a static Java method on a class."
	}
,
	"AndroidJavaObject.Dispose": {
		"prefix": "AndroidJavaObject.Dispose",
		"body": [
			"Dispose($1)"
		],
		"description": "public void Dispose(); des: IDisposable callback."
	}
,
	"AndroidJavaObject.Get": {
		"prefix": "AndroidJavaObject.Get",
		"body": [
			"Get($1)"
		],
		"description": "public FieldType Get(string fieldName); des: Get the value of a field in an object (non-static)."
	}
,
	"AndroidJavaObject.GetRawClass": {
		"prefix": "AndroidJavaObject.GetRawClass",
		"body": [
			"GetRawClass($1)"
		],
		"description": "public IntPtr GetRawClass(); des: Retrieves the raw jclass pointer to the Java class."
	}
,
	"AndroidJavaObject.GetRawObject": {
		"prefix": "AndroidJavaObject.GetRawObject",
		"body": [
			"GetRawObject($1)"
		],
		"description": "public IntPtr GetRawObject(); des: Retrieves the raw jobject pointer to the Java object."
	}
,
	"AndroidJavaObject.GetStatic": {
		"prefix": "AndroidJavaObject.GetStatic",
		"body": [
			"GetStatic($1)"
		],
		"description": "public FieldType GetStatic(string fieldName); des: Get the value of a static field in an object type."
	}
,
	"AndroidJavaObject.Set": {
		"prefix": "AndroidJavaObject.Set",
		"body": [
			"Set($1)"
		],
		"description": "public void Set(string fieldName, FieldType val); des: Set the value of a field in an object (non-static)."
	}
,
	"AndroidJavaObject.SetStatic": {
		"prefix": "AndroidJavaObject.SetStatic",
		"body": [
			"SetStatic($1)"
		],
		"description": "public void SetStatic(string fieldName, FieldType val); des: Set the value of a static field in an object type."
	}
,
	"AndroidJavaProxy.javaInterface": {
		"prefix": "AndroidJavaProxy.javaInterface",
		"body": [
			"javaInterface"
		],
		"description": "return:AndroidJavaClass des: Java interface implemented by the proxy."
	}
,
	"AndroidJavaProxy.equals": {
		"prefix": "AndroidJavaProxy.equals",
		"body": [
			"equals($1)"
		],
		"description": "public bool equals(AndroidJavaObject obj); des: The equivalent of the java.lang.Object equals() method."
	}
,
	"AndroidJavaProxy.hashCode": {
		"prefix": "AndroidJavaProxy.hashCode",
		"body": [
			"hashCode($1)"
		],
		"description": "public int hashCode(); des: The equivalent of the java.lang.Object hashCode() method."
	}
,
	"AndroidJavaProxy.Invoke": {
		"prefix": "AndroidJavaProxy.Invoke",
		"body": [
			"Invoke($1)"
		],
		"description": "public AndroidJavaObject Invoke(string methodName, object[] args); public AndroidJavaObject Invoke(string methodName, AndroidJavaObject[] javaArgs); des: Called by the java vm whenever a method is invoked on the java proxy interface. You can override this to run special code on method invokation, or you can leave the implementation as is, and leave the default behavior which is to look for c# methods matching the signature of the java method."
	}
,
	"AndroidJavaProxy.toString": {
		"prefix": "AndroidJavaProxy.toString",
		"body": [
			"toString($1)"
		],
		"description": "public string toString(); des: The equivalent of the java.lang.Object toString() method."
	}
,
	"AndroidJNI.AllocObject": {
		"prefix": "AndroidJNI.AllocObject",
		"body": [
			"AndroidJNI.AllocObject"
		],
		"description": "public static IntPtr AllocObject(IntPtr clazz); des: Allocates a new Java object without invoking any of the constructors for the object."
	}
,
	"AndroidJNI.AttachCurrentThread": {
		"prefix": "AndroidJNI.AttachCurrentThread",
		"body": [
			"AndroidJNI.AttachCurrentThread"
		],
		"description": "public static int AttachCurrentThread(); des: Attaches the current thread to a Java (Dalvik) VM."
	}
,
	"AndroidJNI.CallBooleanMethod": {
		"prefix": "AndroidJNI.CallBooleanMethod",
		"body": [
			"AndroidJNI.CallBooleanMethod"
		],
		"description": "public static bool CallBooleanMethod(IntPtr obj, IntPtr methodID, jvalue[] args); des: Calls an instance (nonstatic) Java method defined by methodID, optionally passing an array of arguments (args) to the method."
	}
,
	"AndroidJNI.CallByteMethod": {
		"prefix": "AndroidJNI.CallByteMethod",
		"body": [
			"AndroidJNI.CallByteMethod"
		],
		"description": "public static byte CallByteMethod(IntPtr obj, IntPtr methodID, jvalue[] args); des: Calls an instance (nonstatic) Java method defined by methodID, optionally passing an array of arguments (args) to the method."
	}
,
	"AndroidJNI.CallCharMethod": {
		"prefix": "AndroidJNI.CallCharMethod",
		"body": [
			"AndroidJNI.CallCharMethod"
		],
		"description": "public static char CallCharMethod(IntPtr obj, IntPtr methodID, jvalue[] args); des: Calls an instance (nonstatic) Java method defined by methodID, optionally passing an array of arguments (args) to the method."
	}
,
	"AndroidJNI.CallDoubleMethod": {
		"prefix": "AndroidJNI.CallDoubleMethod",
		"body": [
			"AndroidJNI.CallDoubleMethod"
		],
		"description": "public static double CallDoubleMethod(IntPtr obj, IntPtr methodID, jvalue[] args); des: Calls an instance (nonstatic) Java method defined by methodID, optionally passing an array of arguments (args) to the method."
	}
,
	"AndroidJNI.CallFloatMethod": {
		"prefix": "AndroidJNI.CallFloatMethod",
		"body": [
			"AndroidJNI.CallFloatMethod"
		],
		"description": "public static float CallFloatMethod(IntPtr obj, IntPtr methodID, jvalue[] args); des: Calls an instance (nonstatic) Java method defined by methodID, optionally passing an array of arguments (args) to the method."
	}
,
	"AndroidJNI.CallIntMethod": {
		"prefix": "AndroidJNI.CallIntMethod",
		"body": [
			"AndroidJNI.CallIntMethod"
		],
		"description": "public static int CallIntMethod(IntPtr obj, IntPtr methodID, jvalue[] args); des: Calls an instance (nonstatic) Java method defined by methodID, optionally passing an array of arguments (args) to the method."
	}
,
	"AndroidJNI.CallLongMethod": {
		"prefix": "AndroidJNI.CallLongMethod",
		"body": [
			"AndroidJNI.CallLongMethod"
		],
		"description": "public static long CallLongMethod(IntPtr obj, IntPtr methodID, jvalue[] args); des: Calls an instance (nonstatic) Java method defined by methodID, optionally passing an array of arguments (args) to the method."
	}
,
	"AndroidJNI.CallObjectMethod": {
		"prefix": "AndroidJNI.CallObjectMethod",
		"body": [
			"AndroidJNI.CallObjectMethod"
		],
		"description": "public static IntPtr CallObjectMethod(IntPtr obj, IntPtr methodID, jvalue[] args); des: Calls an instance (nonstatic) Java method defined by methodID, optionally passing an array of arguments (args) to the method."
	}
,
	"AndroidJNI.CallShortMethod": {
		"prefix": "AndroidJNI.CallShortMethod",
		"body": [
			"AndroidJNI.CallShortMethod"
		],
		"description": "public static short CallShortMethod(IntPtr obj, IntPtr methodID, jvalue[] args); des: Calls an instance (nonstatic) Java method defined by methodID, optionally passing an array of arguments (args) to the method."
	}
,
	"AndroidJNI.CallStaticBooleanMethod": {
		"prefix": "AndroidJNI.CallStaticBooleanMethod",
		"body": [
			"AndroidJNI.CallStaticBooleanMethod"
		],
		"description": "public static bool CallStaticBooleanMethod(IntPtr clazz, IntPtr methodID, jvalue[] args); des: Invokes a static method on a Java object, according to the specified methodID, optionally passing an array of arguments (args) to the method."
	}
,
	"AndroidJNI.CallStaticByteMethod": {
		"prefix": "AndroidJNI.CallStaticByteMethod",
		"body": [
			"AndroidJNI.CallStaticByteMethod"
		],
		"description": "public static byte CallStaticByteMethod(IntPtr clazz, IntPtr methodID, jvalue[] args); des: Invokes a static method on a Java object, according to the specified methodID, optionally passing an array of arguments (args) to the method."
	}
,
	"AndroidJNI.CallStaticCharMethod": {
		"prefix": "AndroidJNI.CallStaticCharMethod",
		"body": [
			"AndroidJNI.CallStaticCharMethod"
		],
		"description": "public static char CallStaticCharMethod(IntPtr clazz, IntPtr methodID, jvalue[] args); des: Invokes a static method on a Java object, according to the specified methodID, optionally passing an array of arguments (args) to the method."
	}
,
	"AndroidJNI.CallStaticDoubleMethod": {
		"prefix": "AndroidJNI.CallStaticDoubleMethod",
		"body": [
			"AndroidJNI.CallStaticDoubleMethod"
		],
		"description": "public static double CallStaticDoubleMethod(IntPtr clazz, IntPtr methodID, jvalue[] args); des: Invokes a static method on a Java object, according to the specified methodID, optionally passing an array of arguments (args) to the method."
	}
,
	"AndroidJNI.CallStaticFloatMethod": {
		"prefix": "AndroidJNI.CallStaticFloatMethod",
		"body": [
			"AndroidJNI.CallStaticFloatMethod"
		],
		"description": "public static float CallStaticFloatMethod(IntPtr clazz, IntPtr methodID, jvalue[] args); des: Invokes a static method on a Java object, according to the specified methodID, optionally passing an array of arguments (args) to the method."
	}
,
	"AndroidJNI.CallStaticIntMethod": {
		"prefix": "AndroidJNI.CallStaticIntMethod",
		"body": [
			"AndroidJNI.CallStaticIntMethod"
		],
		"description": "public static int CallStaticIntMethod(IntPtr clazz, IntPtr methodID, jvalue[] args); des: Invokes a static method on a Java object, according to the specified methodID, optionally passing an array of arguments (args) to the method."
	}
,
	"AndroidJNI.CallStaticLongMethod": {
		"prefix": "AndroidJNI.CallStaticLongMethod",
		"body": [
			"AndroidJNI.CallStaticLongMethod"
		],
		"description": "public static long CallStaticLongMethod(IntPtr clazz, IntPtr methodID, jvalue[] args); des: Invokes a static method on a Java object, according to the specified methodID, optionally passing an array of arguments (args) to the method."
	}
,
	"AndroidJNI.CallStaticObjectMethod": {
		"prefix": "AndroidJNI.CallStaticObjectMethod",
		"body": [
			"AndroidJNI.CallStaticObjectMethod"
		],
		"description": "public static IntPtr CallStaticObjectMethod(IntPtr clazz, IntPtr methodID, jvalue[] args); des: Invokes a static method on a Java object, according to the specified methodID, optionally passing an array of arguments (args) to the method."
	}
,
	"AndroidJNI.CallStaticShortMethod": {
		"prefix": "AndroidJNI.CallStaticShortMethod",
		"body": [
			"AndroidJNI.CallStaticShortMethod"
		],
		"description": "public static short CallStaticShortMethod(IntPtr clazz, IntPtr methodID, jvalue[] args); des: Invokes a static method on a Java object, according to the specified methodID, optionally passing an array of arguments (args) to the method."
	}
,
	"AndroidJNI.CallStaticStringMethod": {
		"prefix": "AndroidJNI.CallStaticStringMethod",
		"body": [
			"AndroidJNI.CallStaticStringMethod"
		],
		"description": "public static string CallStaticStringMethod(IntPtr clazz, IntPtr methodID, jvalue[] args); des: Invokes a static method on a Java object, according to the specified methodID, optionally passing an array of arguments (args) to the method."
	}
,
	"AndroidJNI.CallStaticVoidMethod": {
		"prefix": "AndroidJNI.CallStaticVoidMethod",
		"body": [
			"AndroidJNI.CallStaticVoidMethod"
		],
		"description": "public static void CallStaticVoidMethod(IntPtr clazz, IntPtr methodID, jvalue[] args); des: Invokes a static method on a Java object, according to the specified methodID, optionally passing an array of arguments (args) to the method."
	}
,
	"AndroidJNI.CallStringMethod": {
		"prefix": "AndroidJNI.CallStringMethod",
		"body": [
			"AndroidJNI.CallStringMethod"
		],
		"description": "public static string CallStringMethod(IntPtr obj, IntPtr methodID, jvalue[] args); des: Calls an instance (nonstatic) Java method defined by methodID, optionally passing an array of arguments (args) to the method."
	}
,
	"AndroidJNI.CallVoidMethod": {
		"prefix": "AndroidJNI.CallVoidMethod",
		"body": [
			"AndroidJNI.CallVoidMethod"
		],
		"description": "public static void CallVoidMethod(IntPtr obj, IntPtr methodID, jvalue[] args); des: Calls an instance (nonstatic) Java method defined by methodID, optionally passing an array of arguments (args) to the method."
	}
,
	"AndroidJNI.DeleteGlobalRef": {
		"prefix": "AndroidJNI.DeleteGlobalRef",
		"body": [
			"AndroidJNI.DeleteGlobalRef"
		],
		"description": "public static void DeleteGlobalRef(IntPtr obj); des: Deletes the global reference pointed to by obj."
	}
,
	"AndroidJNI.DeleteLocalRef": {
		"prefix": "AndroidJNI.DeleteLocalRef",
		"body": [
			"AndroidJNI.DeleteLocalRef"
		],
		"description": "public static void DeleteLocalRef(IntPtr obj); des: Deletes the local reference pointed to by obj."
	}
,
	"AndroidJNI.DetachCurrentThread": {
		"prefix": "AndroidJNI.DetachCurrentThread",
		"body": [
			"AndroidJNI.DetachCurrentThread"
		],
		"description": "public static int DetachCurrentThread(); des: Detaches the current thread from a Java (Dalvik) VM."
	}
,
	"AndroidJNI.EnsureLocalCapacity": {
		"prefix": "AndroidJNI.EnsureLocalCapacity",
		"body": [
			"AndroidJNI.EnsureLocalCapacity"
		],
		"description": "public static int EnsureLocalCapacity(int capacity); des: Ensures that at least a given number of local references can be created in the current thread."
	}
,
	"AndroidJNI.ExceptionClear": {
		"prefix": "AndroidJNI.ExceptionClear",
		"body": [
			"AndroidJNI.ExceptionClear"
		],
		"description": "public static void ExceptionClear(); des: Clears any exception that is currently being thrown."
	}
,
	"AndroidJNI.ExceptionDescribe": {
		"prefix": "AndroidJNI.ExceptionDescribe",
		"body": [
			"AndroidJNI.ExceptionDescribe"
		],
		"description": "public static void ExceptionDescribe(); des: Prints an exception and a backtrace of the stack to the logcat"
	}
,
	"AndroidJNI.ExceptionOccurred": {
		"prefix": "AndroidJNI.ExceptionOccurred",
		"body": [
			"AndroidJNI.ExceptionOccurred"
		],
		"description": "public static IntPtr ExceptionOccurred(); des: Determines if an exception is being thrown."
	}
,
	"AndroidJNI.FatalError": {
		"prefix": "AndroidJNI.FatalError",
		"body": [
			"AndroidJNI.FatalError"
		],
		"description": "public static void FatalError(string message); des: Raises a fatal error and does not expect the VM to recover. This function does not return."
	}
,
	"AndroidJNI.FindClass": {
		"prefix": "AndroidJNI.FindClass",
		"body": [
			"AndroidJNI.FindClass"
		],
		"description": "public static IntPtr FindClass(string name); des: This function loads a locally-defined class."
	}
,
	"AndroidJNI.FromBooleanArray": {
		"prefix": "AndroidJNI.FromBooleanArray",
		"body": [
			"AndroidJNI.FromBooleanArray"
		],
		"description": "public static bool[] FromBooleanArray(IntPtr array); des: Convert a Java array of boolean to a managed array of System.Boolean."
	}
,
	"AndroidJNI.FromByteArray": {
		"prefix": "AndroidJNI.FromByteArray",
		"body": [
			"AndroidJNI.FromByteArray"
		],
		"description": "public static byte[] FromByteArray(IntPtr array); des: Convert a Java array of byte to a managed array of System.Byte."
	}
,
	"AndroidJNI.FromCharArray": {
		"prefix": "AndroidJNI.FromCharArray",
		"body": [
			"AndroidJNI.FromCharArray"
		],
		"description": "public static char[] FromCharArray(IntPtr array); des: Convert a Java array of char to a managed array of System.Char."
	}
,
	"AndroidJNI.FromDoubleArray": {
		"prefix": "AndroidJNI.FromDoubleArray",
		"body": [
			"AndroidJNI.FromDoubleArray"
		],
		"description": "public static double[] FromDoubleArray(IntPtr array); des: Convert a Java array of double to a managed array of System.Double."
	}
,
	"AndroidJNI.FromFloatArray": {
		"prefix": "AndroidJNI.FromFloatArray",
		"body": [
			"AndroidJNI.FromFloatArray"
		],
		"description": "public static float[] FromFloatArray(IntPtr array); des: Convert a Java array of float to a managed array of System.Single."
	}
,
	"AndroidJNI.FromIntArray": {
		"prefix": "AndroidJNI.FromIntArray",
		"body": [
			"AndroidJNI.FromIntArray"
		],
		"description": "public static int[] FromIntArray(IntPtr array); des: Convert a Java array of int to a managed array of System.Int32."
	}
,
	"AndroidJNI.FromLongArray": {
		"prefix": "AndroidJNI.FromLongArray",
		"body": [
			"AndroidJNI.FromLongArray"
		],
		"description": "public static long[] FromLongArray(IntPtr array); des: Convert a Java array of long to a managed array of System.Int64."
	}
,
	"AndroidJNI.FromObjectArray": {
		"prefix": "AndroidJNI.FromObjectArray",
		"body": [
			"AndroidJNI.FromObjectArray"
		],
		"description": "public static IntPtr[] FromObjectArray(IntPtr array); des: Convert a Java array of java.lang.Object to a managed array of System.IntPtr, representing Java objects."
	}
,
	"AndroidJNI.FromReflectedField": {
		"prefix": "AndroidJNI.FromReflectedField",
		"body": [
			"AndroidJNI.FromReflectedField"
		],
		"description": "public static IntPtr FromReflectedField(IntPtr refField); des: Converts a java.lang.reflect.Field to a field ID."
	}
,
	"AndroidJNI.FromReflectedMethod": {
		"prefix": "AndroidJNI.FromReflectedMethod",
		"body": [
			"AndroidJNI.FromReflectedMethod"
		],
		"description": "public static IntPtr FromReflectedMethod(IntPtr refMethod); des: Converts a java.lang.reflect.Method or java.lang.reflect.Constructor object to a method ID."
	}
,
	"AndroidJNI.FromShortArray": {
		"prefix": "AndroidJNI.FromShortArray",
		"body": [
			"AndroidJNI.FromShortArray"
		],
		"description": "public static short[] FromShortArray(IntPtr array); des: Convert a Java array of short to a managed array of System.Int16."
	}
,
	"AndroidJNI.GetArrayLength": {
		"prefix": "AndroidJNI.GetArrayLength",
		"body": [
			"AndroidJNI.GetArrayLength"
		],
		"description": "public static int GetArrayLength(IntPtr array); des: Returns the number of elements in the array."
	}
,
	"AndroidJNI.GetBooleanArrayElement": {
		"prefix": "AndroidJNI.GetBooleanArrayElement",
		"body": [
			"AndroidJNI.GetBooleanArrayElement"
		],
		"description": "public static bool GetBooleanArrayElement(IntPtr array, int index); des: Returns the value of one element of a primitive array."
	}
,
	"AndroidJNI.GetBooleanField": {
		"prefix": "AndroidJNI.GetBooleanField",
		"body": [
			"AndroidJNI.GetBooleanField"
		],
		"description": "public static bool GetBooleanField(IntPtr obj, IntPtr fieldID); des: This function returns the value of an instance (nonstatic) field of an object."
	}
,
	"AndroidJNI.GetByteArrayElement": {
		"prefix": "AndroidJNI.GetByteArrayElement",
		"body": [
			"AndroidJNI.GetByteArrayElement"
		],
		"description": "public static byte GetByteArrayElement(IntPtr array, int index); des: Returns the value of one element of a primitive array."
	}
,
	"AndroidJNI.GetByteField": {
		"prefix": "AndroidJNI.GetByteField",
		"body": [
			"AndroidJNI.GetByteField"
		],
		"description": "public static byte GetByteField(IntPtr obj, IntPtr fieldID); des: This function returns the value of an instance (nonstatic) field of an object."
	}
,
	"AndroidJNI.GetCharArrayElement": {
		"prefix": "AndroidJNI.GetCharArrayElement",
		"body": [
			"AndroidJNI.GetCharArrayElement"
		],
		"description": "public static char GetCharArrayElement(IntPtr array, int index); des: Returns the value of one element of a primitive array."
	}
,
	"AndroidJNI.GetCharField": {
		"prefix": "AndroidJNI.GetCharField",
		"body": [
			"AndroidJNI.GetCharField"
		],
		"description": "public static char GetCharField(IntPtr obj, IntPtr fieldID); des: This function returns the value of an instance (nonstatic) field of an object."
	}
,
	"AndroidJNI.GetDoubleArrayElement": {
		"prefix": "AndroidJNI.GetDoubleArrayElement",
		"body": [
			"AndroidJNI.GetDoubleArrayElement"
		],
		"description": "public static double GetDoubleArrayElement(IntPtr array, int index); des: Returns the value of one element of a primitive array."
	}
,
	"AndroidJNI.GetDoubleField": {
		"prefix": "AndroidJNI.GetDoubleField",
		"body": [
			"AndroidJNI.GetDoubleField"
		],
		"description": "public static double GetDoubleField(IntPtr obj, IntPtr fieldID); des: This function returns the value of an instance (nonstatic) field of an object."
	}
,
	"AndroidJNI.GetFieldID": {
		"prefix": "AndroidJNI.GetFieldID",
		"body": [
			"AndroidJNI.GetFieldID"
		],
		"description": "public static IntPtr GetFieldID(IntPtr clazz, string name, string sig); des: Returns the field ID for an instance (nonstatic) field of a class."
	}
,
	"AndroidJNI.GetFloatArrayElement": {
		"prefix": "AndroidJNI.GetFloatArrayElement",
		"body": [
			"AndroidJNI.GetFloatArrayElement"
		],
		"description": "public static float GetFloatArrayElement(IntPtr array, int index); des: Returns the value of one element of a primitive array."
	}
,
	"AndroidJNI.GetFloatField": {
		"prefix": "AndroidJNI.GetFloatField",
		"body": [
			"AndroidJNI.GetFloatField"
		],
		"description": "public static float GetFloatField(IntPtr obj, IntPtr fieldID); des: This function returns the value of an instance (nonstatic) field of an object."
	}
,
	"AndroidJNI.GetIntArrayElement": {
		"prefix": "AndroidJNI.GetIntArrayElement",
		"body": [
			"AndroidJNI.GetIntArrayElement"
		],
		"description": "public static int GetIntArrayElement(IntPtr array, int index); des: Returns the value of one element of a primitive array."
	}
,
	"AndroidJNI.GetIntField": {
		"prefix": "AndroidJNI.GetIntField",
		"body": [
			"AndroidJNI.GetIntField"
		],
		"description": "public static int GetIntField(IntPtr obj, IntPtr fieldID); des: This function returns the value of an instance (nonstatic) field of an object."
	}
,
	"AndroidJNI.GetLongArrayElement": {
		"prefix": "AndroidJNI.GetLongArrayElement",
		"body": [
			"AndroidJNI.GetLongArrayElement"
		],
		"description": "public static long GetLongArrayElement(IntPtr array, int index); des: Returns the value of one element of a primitive array."
	}
,
	"AndroidJNI.GetLongField": {
		"prefix": "AndroidJNI.GetLongField",
		"body": [
			"AndroidJNI.GetLongField"
		],
		"description": "public static long GetLongField(IntPtr obj, IntPtr fieldID); des: This function returns the value of an instance (nonstatic) field of an object."
	}
,
	"AndroidJNI.GetMethodID": {
		"prefix": "AndroidJNI.GetMethodID",
		"body": [
			"AndroidJNI.GetMethodID"
		],
		"description": "public static IntPtr GetMethodID(IntPtr clazz, string name, string sig); des: Returns the method ID for an instance (nonstatic) method of a class or interface."
	}
,
	"AndroidJNI.GetObjectArrayElement": {
		"prefix": "AndroidJNI.GetObjectArrayElement",
		"body": [
			"AndroidJNI.GetObjectArrayElement"
		],
		"description": "public static IntPtr GetObjectArrayElement(IntPtr array, int index); des: Returns an element of an Object array."
	}
,
	"AndroidJNI.GetObjectClass": {
		"prefix": "AndroidJNI.GetObjectClass",
		"body": [
			"AndroidJNI.GetObjectClass"
		],
		"description": "public static IntPtr GetObjectClass(IntPtr obj); des: Returns the class of an object."
	}
,
	"AndroidJNI.GetObjectField": {
		"prefix": "AndroidJNI.GetObjectField",
		"body": [
			"AndroidJNI.GetObjectField"
		],
		"description": "public static IntPtr GetObjectField(IntPtr obj, IntPtr fieldID); des: This function returns the value of an instance (nonstatic) field of an object."
	}
,
	"AndroidJNI.GetShortArrayElement": {
		"prefix": "AndroidJNI.GetShortArrayElement",
		"body": [
			"AndroidJNI.GetShortArrayElement"
		],
		"description": "public static short GetShortArrayElement(IntPtr array, int index); des: Returns the value of one element of a primitive array."
	}
,
	"AndroidJNI.GetShortField": {
		"prefix": "AndroidJNI.GetShortField",
		"body": [
			"AndroidJNI.GetShortField"
		],
		"description": "public static short GetShortField(IntPtr obj, IntPtr fieldID); des: This function returns the value of an instance (nonstatic) field of an object."
	}
,
	"AndroidJNI.GetStaticBooleanField": {
		"prefix": "AndroidJNI.GetStaticBooleanField",
		"body": [
			"AndroidJNI.GetStaticBooleanField"
		],
		"description": "public static bool GetStaticBooleanField(IntPtr clazz, IntPtr fieldID); des: This function returns the value of a static field of an object."
	}
,
	"AndroidJNI.GetStaticByteField": {
		"prefix": "AndroidJNI.GetStaticByteField",
		"body": [
			"AndroidJNI.GetStaticByteField"
		],
		"description": "public static byte GetStaticByteField(IntPtr clazz, IntPtr fieldID); des: This function returns the value of a static field of an object."
	}
,
	"AndroidJNI.GetStaticCharField": {
		"prefix": "AndroidJNI.GetStaticCharField",
		"body": [
			"AndroidJNI.GetStaticCharField"
		],
		"description": "public static char GetStaticCharField(IntPtr clazz, IntPtr fieldID); des: This function returns the value of a static field of an object."
	}
,
	"AndroidJNI.GetStaticDoubleField": {
		"prefix": "AndroidJNI.GetStaticDoubleField",
		"body": [
			"AndroidJNI.GetStaticDoubleField"
		],
		"description": "public static double GetStaticDoubleField(IntPtr clazz, IntPtr fieldID); des: This function returns the value of a static field of an object."
	}
,
	"AndroidJNI.GetStaticFieldID": {
		"prefix": "AndroidJNI.GetStaticFieldID",
		"body": [
			"AndroidJNI.GetStaticFieldID"
		],
		"description": "public static IntPtr GetStaticFieldID(IntPtr clazz, string name, string sig); des: Returns the field ID for a static field of a class."
	}
,
	"AndroidJNI.GetStaticFloatField": {
		"prefix": "AndroidJNI.GetStaticFloatField",
		"body": [
			"AndroidJNI.GetStaticFloatField"
		],
		"description": "public static float GetStaticFloatField(IntPtr clazz, IntPtr fieldID); des: This function returns the value of a static field of an object."
	}
,
	"AndroidJNI.GetStaticIntField": {
		"prefix": "AndroidJNI.GetStaticIntField",
		"body": [
			"AndroidJNI.GetStaticIntField"
		],
		"description": "public static int GetStaticIntField(IntPtr clazz, IntPtr fieldID); des: This function returns the value of a static field of an object."
	}
,
	"AndroidJNI.GetStaticLongField": {
		"prefix": "AndroidJNI.GetStaticLongField",
		"body": [
			"AndroidJNI.GetStaticLongField"
		],
		"description": "public static long GetStaticLongField(IntPtr clazz, IntPtr fieldID); des: This function returns the value of a static field of an object."
	}
,
	"AndroidJNI.GetStaticMethodID": {
		"prefix": "AndroidJNI.GetStaticMethodID",
		"body": [
			"AndroidJNI.GetStaticMethodID"
		],
		"description": "public static IntPtr GetStaticMethodID(IntPtr clazz, string name, string sig); des: Returns the method ID for a static method of a class."
	}
,
	"AndroidJNI.GetStaticObjectField": {
		"prefix": "AndroidJNI.GetStaticObjectField",
		"body": [
			"AndroidJNI.GetStaticObjectField"
		],
		"description": "public static IntPtr GetStaticObjectField(IntPtr clazz, IntPtr fieldID); des: This function returns the value of a static field of an object."
	}
,
	"AndroidJNI.GetStaticShortField": {
		"prefix": "AndroidJNI.GetStaticShortField",
		"body": [
			"AndroidJNI.GetStaticShortField"
		],
		"description": "public static short GetStaticShortField(IntPtr clazz, IntPtr fieldID); des: This function returns the value of a static field of an object."
	}
,
	"AndroidJNI.GetStaticStringField": {
		"prefix": "AndroidJNI.GetStaticStringField",
		"body": [
			"AndroidJNI.GetStaticStringField"
		],
		"description": "public static string GetStaticStringField(IntPtr clazz, IntPtr fieldID); des: This function returns the value of a static field of an object."
	}
,
	"AndroidJNI.GetStringField": {
		"prefix": "AndroidJNI.GetStringField",
		"body": [
			"AndroidJNI.GetStringField"
		],
		"description": "public static string GetStringField(IntPtr obj, IntPtr fieldID); des: This function returns the value of an instance (nonstatic) field of an object."
	}
,
	"AndroidJNI.GetStringUTFChars": {
		"prefix": "AndroidJNI.GetStringUTFChars",
		"body": [
			"AndroidJNI.GetStringUTFChars"
		],
		"description": "public static string GetStringUTFChars(IntPtr str); des: Returns a managed string object representing the string in modified UTF-8 encoding."
	}
,
	"AndroidJNI.GetStringUTFLength": {
		"prefix": "AndroidJNI.GetStringUTFLength",
		"body": [
			"AndroidJNI.GetStringUTFLength"
		],
		"description": "public static int GetStringUTFLength(IntPtr str); des: Returns the length in bytes of the modified UTF-8 representation of a string."
	}
,
	"AndroidJNI.GetSuperclass": {
		"prefix": "AndroidJNI.GetSuperclass",
		"body": [
			"AndroidJNI.GetSuperclass"
		],
		"description": "public static IntPtr GetSuperclass(IntPtr clazz); des: If clazz represents any class other than the class Object, then this function returns the object that represents the superclass of the class specified by clazz."
	}
,
	"AndroidJNI.GetVersion": {
		"prefix": "AndroidJNI.GetVersion",
		"body": [
			"AndroidJNI.GetVersion"
		],
		"description": "public static int GetVersion(); des: Returns the version of the native method interface."
	}
,
	"AndroidJNI.IsAssignableFrom": {
		"prefix": "AndroidJNI.IsAssignableFrom",
		"body": [
			"AndroidJNI.IsAssignableFrom"
		],
		"description": "public static bool IsAssignableFrom(IntPtr clazz1, IntPtr clazz2); des: Determines whether an object of clazz1 can be safely cast to clazz2."
	}
,
	"AndroidJNI.IsInstanceOf": {
		"prefix": "AndroidJNI.IsInstanceOf",
		"body": [
			"AndroidJNI.IsInstanceOf"
		],
		"description": "public static bool IsInstanceOf(IntPtr obj, IntPtr clazz); des: Tests whether an object is an instance of a class."
	}
,
	"AndroidJNI.IsSameObject": {
		"prefix": "AndroidJNI.IsSameObject",
		"body": [
			"AndroidJNI.IsSameObject"
		],
		"description": "public static bool IsSameObject(IntPtr obj1, IntPtr obj2); des: Tests whether two references refer to the same Java object."
	}
,
	"AndroidJNI.NewBooleanArray": {
		"prefix": "AndroidJNI.NewBooleanArray",
		"body": [
			"AndroidJNI.NewBooleanArray"
		],
		"description": "public static IntPtr NewBooleanArray(int size); des: Construct a new primitive array object."
	}
,
	"AndroidJNI.NewByteArray": {
		"prefix": "AndroidJNI.NewByteArray",
		"body": [
			"AndroidJNI.NewByteArray"
		],
		"description": "public static IntPtr NewByteArray(int size); des: Construct a new primitive array object."
	}
,
	"AndroidJNI.NewCharArray": {
		"prefix": "AndroidJNI.NewCharArray",
		"body": [
			"AndroidJNI.NewCharArray"
		],
		"description": "public static IntPtr NewCharArray(int size); des: Construct a new primitive array object."
	}
,
	"AndroidJNI.NewDoubleArray": {
		"prefix": "AndroidJNI.NewDoubleArray",
		"body": [
			"AndroidJNI.NewDoubleArray"
		],
		"description": "public static IntPtr NewDoubleArray(int size); des: Construct a new primitive array object."
	}
,
	"AndroidJNI.NewFloatArray": {
		"prefix": "AndroidJNI.NewFloatArray",
		"body": [
			"AndroidJNI.NewFloatArray"
		],
		"description": "public static IntPtr NewFloatArray(int size); des: Construct a new primitive array object."
	}
,
	"AndroidJNI.NewGlobalRef": {
		"prefix": "AndroidJNI.NewGlobalRef",
		"body": [
			"AndroidJNI.NewGlobalRef"
		],
		"description": "public static IntPtr NewGlobalRef(IntPtr obj); des: Creates a new global reference to the object referred to by the obj argument."
	}
,
	"AndroidJNI.NewIntArray": {
		"prefix": "AndroidJNI.NewIntArray",
		"body": [
			"AndroidJNI.NewIntArray"
		],
		"description": "public static IntPtr NewIntArray(int size); des: Construct a new primitive array object."
	}
,
	"AndroidJNI.NewLocalRef": {
		"prefix": "AndroidJNI.NewLocalRef",
		"body": [
			"AndroidJNI.NewLocalRef"
		],
		"description": "public static IntPtr NewLocalRef(IntPtr obj); des: Creates a new local reference that refers to the same object as obj."
	}
,
	"AndroidJNI.NewLongArray": {
		"prefix": "AndroidJNI.NewLongArray",
		"body": [
			"AndroidJNI.NewLongArray"
		],
		"description": "public static IntPtr NewLongArray(int size); des: Construct a new primitive array object."
	}
,
	"AndroidJNI.NewObject": {
		"prefix": "AndroidJNI.NewObject",
		"body": [
			"AndroidJNI.NewObject"
		],
		"description": "public static IntPtr NewObject(IntPtr clazz, IntPtr methodID, jvalue[] args); des: Constructs a new Java object. The method ID indicates which constructor method to invoke. This ID must be obtained by calling GetMethodID() with <init> as the method name and void (V) as the return type."
	}
,
	"AndroidJNI.NewObjectArray": {
		"prefix": "AndroidJNI.NewObjectArray",
		"body": [
			"AndroidJNI.NewObjectArray"
		],
		"description": "public static IntPtr NewObjectArray(int size, IntPtr clazz, IntPtr obj); des: Constructs a new array holding objects in class clazz. All elements are initially set to obj."
	}
,
	"AndroidJNI.NewShortArray": {
		"prefix": "AndroidJNI.NewShortArray",
		"body": [
			"AndroidJNI.NewShortArray"
		],
		"description": "public static IntPtr NewShortArray(int size); des: Construct a new primitive array object."
	}
,
	"AndroidJNI.NewStringUTF": {
		"prefix": "AndroidJNI.NewStringUTF",
		"body": [
			"AndroidJNI.NewStringUTF"
		],
		"description": "public static IntPtr NewStringUTF(string bytes); des: Constructs a new java.lang.String object from an array of characters in modified UTF-8 encoding."
	}
,
	"AndroidJNI.PopLocalFrame": {
		"prefix": "AndroidJNI.PopLocalFrame",
		"body": [
			"AndroidJNI.PopLocalFrame"
		],
		"description": "public static IntPtr PopLocalFrame(IntPtr ptr); des: Pops off the current local reference frame, frees all the local references, and returns a local reference in the previous local reference frame for the given result object."
	}
,
	"AndroidJNI.PushLocalFrame": {
		"prefix": "AndroidJNI.PushLocalFrame",
		"body": [
			"AndroidJNI.PushLocalFrame"
		],
		"description": "public static int PushLocalFrame(int capacity); des: Creates a new local reference frame, in which at least a given number of local references can be created."
	}
,
	"AndroidJNI.SetBooleanArrayElement": {
		"prefix": "AndroidJNI.SetBooleanArrayElement",
		"body": [
			"AndroidJNI.SetBooleanArrayElement"
		],
		"description": "public static void SetBooleanArrayElement(IntPtr array, int index, byte val); des: Sets the value of one element in a primitive array."
	}
,
	"AndroidJNI.SetBooleanField": {
		"prefix": "AndroidJNI.SetBooleanField",
		"body": [
			"AndroidJNI.SetBooleanField"
		],
		"description": "public static void SetBooleanField(IntPtr obj, IntPtr fieldID, bool val); des: This function sets the value of an instance (nonstatic) field of an object."
	}
,
	"AndroidJNI.SetByteArrayElement": {
		"prefix": "AndroidJNI.SetByteArrayElement",
		"body": [
			"AndroidJNI.SetByteArrayElement"
		],
		"description": "public static void SetByteArrayElement(IntPtr array, int index, sbyte val); des: Sets the value of one element in a primitive array."
	}
,
	"AndroidJNI.SetByteField": {
		"prefix": "AndroidJNI.SetByteField",
		"body": [
			"AndroidJNI.SetByteField"
		],
		"description": "public static void SetByteField(IntPtr obj, IntPtr fieldID, byte val); des: This function sets the value of an instance (nonstatic) field of an object."
	}
,
	"AndroidJNI.SetCharArrayElement": {
		"prefix": "AndroidJNI.SetCharArrayElement",
		"body": [
			"AndroidJNI.SetCharArrayElement"
		],
		"description": "public static void SetCharArrayElement(IntPtr array, int index, char val); des: Sets the value of one element in a primitive array."
	}
,
	"AndroidJNI.SetCharField": {
		"prefix": "AndroidJNI.SetCharField",
		"body": [
			"AndroidJNI.SetCharField"
		],
		"description": "public static void SetCharField(IntPtr obj, IntPtr fieldID, char val); des: This function sets the value of an instance (nonstatic) field of an object."
	}
,
	"AndroidJNI.SetDoubleArrayElement": {
		"prefix": "AndroidJNI.SetDoubleArrayElement",
		"body": [
			"AndroidJNI.SetDoubleArrayElement"
		],
		"description": "public static void SetDoubleArrayElement(IntPtr array, int index, double val); des: Sets the value of one element in a primitive array."
	}
,
	"AndroidJNI.SetDoubleField": {
		"prefix": "AndroidJNI.SetDoubleField",
		"body": [
			"AndroidJNI.SetDoubleField"
		],
		"description": "public static void SetDoubleField(IntPtr obj, IntPtr fieldID, double val); des: This function sets the value of an instance (nonstatic) field of an object."
	}
,
	"AndroidJNI.SetFloatArrayElement": {
		"prefix": "AndroidJNI.SetFloatArrayElement",
		"body": [
			"AndroidJNI.SetFloatArrayElement"
		],
		"description": "public static void SetFloatArrayElement(IntPtr array, int index, float val); des: Sets the value of one element in a primitive array."
	}
,
	"AndroidJNI.SetFloatField": {
		"prefix": "AndroidJNI.SetFloatField",
		"body": [
			"AndroidJNI.SetFloatField"
		],
		"description": "public static void SetFloatField(IntPtr obj, IntPtr fieldID, float val); des: This function sets the value of an instance (nonstatic) field of an object."
	}
,
	"AndroidJNI.SetIntArrayElement": {
		"prefix": "AndroidJNI.SetIntArrayElement",
		"body": [
			"AndroidJNI.SetIntArrayElement"
		],
		"description": "public static void SetIntArrayElement(IntPtr array, int index, int val); des: Sets the value of one element in a primitive array."
	}
,
	"AndroidJNI.SetIntField": {
		"prefix": "AndroidJNI.SetIntField",
		"body": [
			"AndroidJNI.SetIntField"
		],
		"description": "public static void SetIntField(IntPtr obj, IntPtr fieldID, int val); des: This function sets the value of an instance (nonstatic) field of an object."
	}
,
	"AndroidJNI.SetLongArrayElement": {
		"prefix": "AndroidJNI.SetLongArrayElement",
		"body": [
			"AndroidJNI.SetLongArrayElement"
		],
		"description": "public static void SetLongArrayElement(IntPtr array, int index, long val); des: Sets the value of one element in a primitive array."
	}
,
	"AndroidJNI.SetLongField": {
		"prefix": "AndroidJNI.SetLongField",
		"body": [
			"AndroidJNI.SetLongField"
		],
		"description": "public static void SetLongField(IntPtr obj, IntPtr fieldID, long val); des: This function sets the value of an instance (nonstatic) field of an object."
	}
,
	"AndroidJNI.SetObjectArrayElement": {
		"prefix": "AndroidJNI.SetObjectArrayElement",
		"body": [
			"AndroidJNI.SetObjectArrayElement"
		],
		"description": "public static void SetObjectArrayElement(IntPtr array, int index, IntPtr obj); des: Sets an element of an Object array."
	}
,
	"AndroidJNI.SetObjectField": {
		"prefix": "AndroidJNI.SetObjectField",
		"body": [
			"AndroidJNI.SetObjectField"
		],
		"description": "public static void SetObjectField(IntPtr obj, IntPtr fieldID, IntPtr val); des: This function sets the value of an instance (nonstatic) field of an object."
	}
,
	"AndroidJNI.SetShortArrayElement": {
		"prefix": "AndroidJNI.SetShortArrayElement",
		"body": [
			"AndroidJNI.SetShortArrayElement"
		],
		"description": "public static void SetShortArrayElement(IntPtr array, int index, short val); des: Sets the value of one element in a primitive array."
	}
,
	"AndroidJNI.SetShortField": {
		"prefix": "AndroidJNI.SetShortField",
		"body": [
			"AndroidJNI.SetShortField"
		],
		"description": "public static void SetShortField(IntPtr obj, IntPtr fieldID, short val); des: This function sets the value of an instance (nonstatic) field of an object."
	}
,
	"AndroidJNI.SetStaticBooleanField": {
		"prefix": "AndroidJNI.SetStaticBooleanField",
		"body": [
			"AndroidJNI.SetStaticBooleanField"
		],
		"description": "public static void SetStaticBooleanField(IntPtr clazz, IntPtr fieldID, bool val); des: This function ets the value of a static field of an object."
	}
,
	"AndroidJNI.SetStaticByteField": {
		"prefix": "AndroidJNI.SetStaticByteField",
		"body": [
			"AndroidJNI.SetStaticByteField"
		],
		"description": "public static void SetStaticByteField(IntPtr clazz, IntPtr fieldID, byte val); des: This function ets the value of a static field of an object."
	}
,
	"AndroidJNI.SetStaticCharField": {
		"prefix": "AndroidJNI.SetStaticCharField",
		"body": [
			"AndroidJNI.SetStaticCharField"
		],
		"description": "public static void SetStaticCharField(IntPtr clazz, IntPtr fieldID, char val); des: This function ets the value of a static field of an object."
	}
,
	"AndroidJNI.SetStaticDoubleField": {
		"prefix": "AndroidJNI.SetStaticDoubleField",
		"body": [
			"AndroidJNI.SetStaticDoubleField"
		],
		"description": "public static void SetStaticDoubleField(IntPtr clazz, IntPtr fieldID, double val); des: This function ets the value of a static field of an object."
	}
,
	"AndroidJNI.SetStaticFloatField": {
		"prefix": "AndroidJNI.SetStaticFloatField",
		"body": [
			"AndroidJNI.SetStaticFloatField"
		],
		"description": "public static void SetStaticFloatField(IntPtr clazz, IntPtr fieldID, float val); des: This function ets the value of a static field of an object."
	}
,
	"AndroidJNI.SetStaticIntField": {
		"prefix": "AndroidJNI.SetStaticIntField",
		"body": [
			"AndroidJNI.SetStaticIntField"
		],
		"description": "public static void SetStaticIntField(IntPtr clazz, IntPtr fieldID, int val); des: This function ets the value of a static field of an object."
	}
,
	"AndroidJNI.SetStaticLongField": {
		"prefix": "AndroidJNI.SetStaticLongField",
		"body": [
			"AndroidJNI.SetStaticLongField"
		],
		"description": "public static void SetStaticLongField(IntPtr clazz, IntPtr fieldID, long val); des: This function ets the value of a static field of an object."
	}
,
	"AndroidJNI.SetStaticObjectField": {
		"prefix": "AndroidJNI.SetStaticObjectField",
		"body": [
			"AndroidJNI.SetStaticObjectField"
		],
		"description": "public static void SetStaticObjectField(IntPtr clazz, IntPtr fieldID, IntPtr val); des: This function ets the value of a static field of an object."
	}
,
	"AndroidJNI.SetStaticShortField": {
		"prefix": "AndroidJNI.SetStaticShortField",
		"body": [
			"AndroidJNI.SetStaticShortField"
		],
		"description": "public static void SetStaticShortField(IntPtr clazz, IntPtr fieldID, short val); des: This function ets the value of a static field of an object."
	}
,
	"AndroidJNI.SetStaticStringField": {
		"prefix": "AndroidJNI.SetStaticStringField",
		"body": [
			"AndroidJNI.SetStaticStringField"
		],
		"description": "public static void SetStaticStringField(IntPtr clazz, IntPtr fieldID, string val); des: This function ets the value of a static field of an object."
	}
,
	"AndroidJNI.SetStringField": {
		"prefix": "AndroidJNI.SetStringField",
		"body": [
			"AndroidJNI.SetStringField"
		],
		"description": "public static void SetStringField(IntPtr obj, IntPtr fieldID, string val); des: This function sets the value of an instance (nonstatic) field of an object."
	}
,
	"AndroidJNI.Throw": {
		"prefix": "AndroidJNI.Throw",
		"body": [
			"AndroidJNI.Throw"
		],
		"description": "public static int Throw(IntPtr obj); des: Causes a java.lang.Throwable object to be thrown."
	}
,
	"AndroidJNI.ThrowNew": {
		"prefix": "AndroidJNI.ThrowNew",
		"body": [
			"AndroidJNI.ThrowNew"
		],
		"description": "public static int ThrowNew(IntPtr clazz, string message); des: Constructs an exception object from the specified class with the message specified by message and causes that exception to be thrown."
	}
,
	"AndroidJNI.ToBooleanArray": {
		"prefix": "AndroidJNI.ToBooleanArray",
		"body": [
			"AndroidJNI.ToBooleanArray"
		],
		"description": "public static IntPtr ToBooleanArray(bool[] array); des: Convert a managed array of System.Boolean to a Java array of boolean."
	}
,
	"AndroidJNI.ToByteArray": {
		"prefix": "AndroidJNI.ToByteArray",
		"body": [
			"AndroidJNI.ToByteArray"
		],
		"description": "public static IntPtr ToByteArray(byte[] array); des: Convert a managed array of System.Byte to a Java array of byte."
	}
,
	"AndroidJNI.ToCharArray": {
		"prefix": "AndroidJNI.ToCharArray",
		"body": [
			"AndroidJNI.ToCharArray"
		],
		"description": "public static IntPtr ToCharArray(char[] array); des: Convert a managed array of System.Char to a Java array of char."
	}
,
	"AndroidJNI.ToDoubleArray": {
		"prefix": "AndroidJNI.ToDoubleArray",
		"body": [
			"AndroidJNI.ToDoubleArray"
		],
		"description": "public static IntPtr ToDoubleArray(double[] array); des: Convert a managed array of System.Double to a Java array of double."
	}
,
	"AndroidJNI.ToFloatArray": {
		"prefix": "AndroidJNI.ToFloatArray",
		"body": [
			"AndroidJNI.ToFloatArray"
		],
		"description": "public static IntPtr ToFloatArray(float[] array); des: Convert a managed array of System.Single to a Java array of float."
	}
,
	"AndroidJNI.ToIntArray": {
		"prefix": "AndroidJNI.ToIntArray",
		"body": [
			"AndroidJNI.ToIntArray"
		],
		"description": "public static IntPtr ToIntArray(int[] array); des: Convert a managed array of System.Int32 to a Java array of int."
	}
,
	"AndroidJNI.ToLongArray": {
		"prefix": "AndroidJNI.ToLongArray",
		"body": [
			"AndroidJNI.ToLongArray"
		],
		"description": "public static IntPtr ToLongArray(long[] array); des: Convert a managed array of System.Int64 to a Java array of long."
	}
,
	"AndroidJNI.ToObjectArray": {
		"prefix": "AndroidJNI.ToObjectArray",
		"body": [
			"AndroidJNI.ToObjectArray"
		],
		"description": "public static IntPtr ToObjectArray(IntPtr[] array); des: Convert a managed array of System.IntPtr, representing Java objects, to a Java array of java.lang.Object."
	}
,
	"AndroidJNI.ToReflectedField": {
		"prefix": "AndroidJNI.ToReflectedField",
		"body": [
			"AndroidJNI.ToReflectedField"
		],
		"description": "public static IntPtr ToReflectedField(IntPtr clazz, IntPtr fieldID, bool isStatic); des: Converts a field ID derived from cls to a java.lang.reflect.Field object."
	}
,
	"AndroidJNI.ToReflectedMethod": {
		"prefix": "AndroidJNI.ToReflectedMethod",
		"body": [
			"AndroidJNI.ToReflectedMethod"
		],
		"description": "public static IntPtr ToReflectedMethod(IntPtr clazz, IntPtr methodID, bool isStatic); des: Converts a method ID derived from clazz to a java.lang.reflect.Method or java.lang.reflect.Constructor object."
	}
,
	"AndroidJNI.ToShortArray": {
		"prefix": "AndroidJNI.ToShortArray",
		"body": [
			"AndroidJNI.ToShortArray"
		],
		"description": "public static IntPtr ToShortArray(short[] array); des: Convert a managed array of System.Int16 to a Java array of short."
	}
,
	"AndroidJNIHelper.ConvertFromJNIArray": {
		"prefix": "AndroidJNIHelper.ConvertFromJNIArray",
		"body": [
			"AndroidJNIHelper.ConvertFromJNIArray"
		],
		"description": "public static ArrayType ConvertFromJNIArray(IntPtr array); des: Creates a managed array from a Java array."
	}
,
	"AndroidJNIHelper.ConvertToJNIArray": {
		"prefix": "AndroidJNIHelper.ConvertToJNIArray",
		"body": [
			"AndroidJNIHelper.ConvertToJNIArray"
		],
		"description": "public static IntPtr ConvertToJNIArray(Array array); des: Creates a Java array from a managed array."
	}
,
	"AndroidJNIHelper.CreateJavaProxy": {
		"prefix": "AndroidJNIHelper.CreateJavaProxy",
		"body": [
			"AndroidJNIHelper.CreateJavaProxy"
		],
		"description": "public static IntPtr CreateJavaProxy(AndroidJavaProxy proxy); des: Creates a java proxy object which connects to the supplied proxy implementation."
	}
,
	"AndroidJNIHelper.CreateJavaRunnable": {
		"prefix": "AndroidJNIHelper.CreateJavaRunnable",
		"body": [
			"AndroidJNIHelper.CreateJavaRunnable"
		],
		"description": "public static IntPtr CreateJavaRunnable(AndroidJavaRunnable jrunnable); des: Creates a UnityJavaRunnable object (implements java.lang.Runnable)."
	}
,
	"AndroidJNIHelper.CreateJNIArgArray": {
		"prefix": "AndroidJNIHelper.CreateJNIArgArray",
		"body": [
			"AndroidJNIHelper.CreateJNIArgArray"
		],
		"description": "public static jvalue[] CreateJNIArgArray(object[] args); des: Creates the parameter array to be used as argument list when invoking Java code through CallMethod() in AndroidJNI."
	}
,
	"AndroidJNIHelper.DeleteJNIArgArray": {
		"prefix": "AndroidJNIHelper.DeleteJNIArgArray",
		"body": [
			"AndroidJNIHelper.DeleteJNIArgArray"
		],
		"description": "public static void DeleteJNIArgArray(object[] args, jvalue[] jniArgs); des: Deletes any local jni references previously allocated by CreateJNIArgArray()."
	}
,
	"AndroidJNIHelper.GetConstructorID": {
		"prefix": "AndroidJNIHelper.GetConstructorID",
		"body": [
			"AndroidJNIHelper.GetConstructorID"
		],
		"description": "public static IntPtr GetConstructorID(IntPtr javaClass); public static IntPtr GetConstructorID(IntPtr javaClass, string signature); public static IntPtr GetConstructorID(IntPtr jclass, object[] args); des: Scans a particular Java class for a constructor method matching a signature."
	}
,
	"AndroidJNIHelper.GetFieldID": {
		"prefix": "AndroidJNIHelper.GetFieldID",
		"body": [
			"AndroidJNIHelper.GetFieldID"
		],
		"description": "public static IntPtr GetFieldID(IntPtr javaClass, string fieldName); public static IntPtr GetFieldID(IntPtr javaClass, string fieldName, string signature); public static IntPtr GetFieldID(IntPtr javaClass, string fieldName, string signature, bool isStatic = false); public static IntPtr GetFieldID(IntPtr jclass, string fieldName, bool isStatic); des: Scans a particular Java class for a field matching a name and a signature."
	}
,
	"AndroidJNIHelper.GetMethodID": {
		"prefix": "AndroidJNIHelper.GetMethodID",
		"body": [
			"AndroidJNIHelper.GetMethodID"
		],
		"description": "public static IntPtr GetMethodID(IntPtr javaClass, string methodName); public static IntPtr GetMethodID(IntPtr javaClass, string methodName, string signature); public static IntPtr GetMethodID(IntPtr javaClass, string methodName, string signature, bool isStatic = false); public static IntPtr GetMethodID(IntPtr jclass, string methodName, object[] args, bool isStatic); public static IntPtr GetMethodID(IntPtr jclass, string methodName, object[] args, bool isStatic); des: Scans a particular Java class for a method matching a name and a signature."
	}
,
	"AndroidJNIHelper.GetSignature": {
		"prefix": "AndroidJNIHelper.GetSignature",
		"body": [
			"AndroidJNIHelper.GetSignature"
		],
		"description": "public static string GetSignature(object obj); public static string GetSignature(object[] args); public static string GetSignature(object[] args); des: Creates the JNI signature string for particular object type."
	}
,
	"Animation.animatePhysics": {
		"prefix": "Animation.animatePhysics",
		"body": [
			"animatePhysics"
		],
		"description": "return:bool des: When turned on, animations will be executed in the physics loop. This is only useful in conjunction with kinematic rigidbodies."
	}
,
	"Animation.clip": {
		"prefix": "Animation.clip",
		"body": [
			"clip"
		],
		"description": "return:AnimationClip des: The default animation."
	}
,
	"Animation.cullingType": {
		"prefix": "Animation.cullingType",
		"body": [
			"cullingType"
		],
		"description": "return:AnimationCullingType des: Controls culling of this Animation component."
	}
,
	"Animation.isPlaying": {
		"prefix": "Animation.isPlaying",
		"body": [
			"isPlaying"
		],
		"description": "return:bool des: Is an animation currently being played?"
	}
,
	"Animation.localBounds": {
		"prefix": "Animation.localBounds",
		"body": [
			"localBounds"
		],
		"description": "return:Bounds des: AABB of this Animation animation component in local space."
	}
,
	"Animation.playAutomatically": {
		"prefix": "Animation.playAutomatically",
		"body": [
			"playAutomatically"
		],
		"description": "return:bool des: Should the default animation clip (the Animation.clip property) automatically start playing on startup?"
	}
,
	"Animation.this[string]": {
		"prefix": "Animation.this[string]",
		"body": [
			"this[string]"
		],
		"description": "return:AnimationState des: Returns the animation state named name."
	}
,
	"Animation.wrapMode": {
		"prefix": "Animation.wrapMode",
		"body": [
			"wrapMode"
		],
		"description": "return:WrapMode des: How should time beyond the playback range of the clip be treated?"
	}
,
	"Animation.AddClip": {
		"prefix": "Animation.AddClip",
		"body": [
			"AddClip($1)"
		],
		"description": "public void AddClip(AnimationClip clip, string newName); public void AddClip(AnimationClip clip, string newName, int firstFrame, int lastFrame, bool addLoopFrame = false); des: Adds a clip to the animation with name newName."
	}
,
	"Animation.Blend": {
		"prefix": "Animation.Blend",
		"body": [
			"Blend($1)"
		],
		"description": "public void Blend(string animation, float targetWeight = 1.0F, float fadeLength = 0.3F); des: Blends the animation named animation towards targetWeight over the next time seconds."
	}
,
	"Animation.CrossFade": {
		"prefix": "Animation.CrossFade",
		"body": [
			"CrossFade($1)"
		],
		"description": "public void CrossFade(string animation, float fadeLength = 0.3F, PlayMode mode = PlayMode.StopSameLayer); des: Fades the animation with name animation in over a period of time seconds and fades other animations out."
	}
,
	"Animation.CrossFadeQueued": {
		"prefix": "Animation.CrossFadeQueued",
		"body": [
			"CrossFadeQueued($1)"
		],
		"description": "public AnimationState CrossFadeQueued(string animation, float fadeLength = 0.3F, QueueMode queue = QueueMode.CompleteOthers, PlayMode mode = PlayMode.StopSameLayer); des: Cross fades an animation after previous animations has finished playing."
	}
,
	"Animation.GetClipCount": {
		"prefix": "Animation.GetClipCount",
		"body": [
			"GetClipCount($1)"
		],
		"description": "public int GetClipCount(); des: Get the number of clips currently assigned to this animation."
	}
,
	"Animation.IsPlaying": {
		"prefix": "Animation.IsPlaying",
		"body": [
			"IsPlaying($1)"
		],
		"description": "public bool IsPlaying(string name); des: Is the animation named name playing?"
	}
,
	"Animation.Play": {
		"prefix": "Animation.Play",
		"body": [
			"Play($1)"
		],
		"description": "public bool Play(PlayMode mode = PlayMode.StopSameLayer); public bool Play(string animation, PlayMode mode = PlayMode.StopSameLayer); des: Plays an animation without blending."
	}
,
	"Animation.PlayQueued": {
		"prefix": "Animation.PlayQueued",
		"body": [
			"PlayQueued($1)"
		],
		"description": "public AnimationState PlayQueued(string animation, QueueMode queue = QueueMode.CompleteOthers, PlayMode mode = PlayMode.StopSameLayer); des: Plays an animation after previous animations has finished playing."
	}
,
	"Animation.RemoveClip": {
		"prefix": "Animation.RemoveClip",
		"body": [
			"RemoveClip($1)"
		],
		"description": "public void RemoveClip(AnimationClip clip); public void RemoveClip(string clipName); des: Remove clip from the animation list."
	}
,
	"Animation.Rewind": {
		"prefix": "Animation.Rewind",
		"body": [
			"Rewind($1)"
		],
		"description": "public void Rewind(string name); public void Rewind(); des: Rewinds the animation named name."
	}
,
	"Animation.Sample": {
		"prefix": "Animation.Sample",
		"body": [
			"Sample($1)"
		],
		"description": "public void Sample(); des: Samples animations at the current state."
	}
,
	"Animation.Stop": {
		"prefix": "Animation.Stop",
		"body": [
			"Stop($1)"
		],
		"description": "public void Stop(); public void Stop(string name); des: Stops all playing animations that were started with this Animation."
	}
,
	"Animation.enabled": {
		"prefix": "Animation.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"Animation.isActiveAndEnabled": {
		"prefix": "Animation.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"Animation.gameObject": {
		"prefix": "Animation.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"Animation.tag": {
		"prefix": "Animation.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"Animation.transform": {
		"prefix": "Animation.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"Animation.hideFlags": {
		"prefix": "Animation.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Animation.name": {
		"prefix": "Animation.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Animation.BroadcastMessage": {
		"prefix": "Animation.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"Animation.CompareTag": {
		"prefix": "Animation.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"Animation.GetComponent": {
		"prefix": "Animation.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"Animation.GetComponentInChildren": {
		"prefix": "Animation.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"Animation.GetComponentInParent": {
		"prefix": "Animation.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"Animation.GetComponents": {
		"prefix": "Animation.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"Animation.GetComponentsInChildren": {
		"prefix": "Animation.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"Animation.GetComponentsInParent": {
		"prefix": "Animation.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"Animation.SendMessage": {
		"prefix": "Animation.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"Animation.SendMessageUpwards": {
		"prefix": "Animation.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"Animation.GetInstanceID": {
		"prefix": "Animation.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Animation.ToString": {
		"prefix": "Animation.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Animation.Destroy": {
		"prefix": "Animation.Destroy",
		"body": [
			"Animation.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Animation.DestroyImmediate": {
		"prefix": "Animation.DestroyImmediate",
		"body": [
			"Animation.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Animation.DontDestroyOnLoad": {
		"prefix": "Animation.DontDestroyOnLoad",
		"body": [
			"Animation.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Animation.FindObjectOfType": {
		"prefix": "Animation.FindObjectOfType",
		"body": [
			"Animation.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Animation.FindObjectsOfType": {
		"prefix": "Animation.FindObjectsOfType",
		"body": [
			"Animation.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Animation.Instantiate": {
		"prefix": "Animation.Instantiate",
		"body": [
			"Animation.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"AnimationClip.empty": {
		"prefix": "AnimationClip.empty",
		"body": [
			"empty"
		],
		"description": "return:bool des: Returns true if the animation clip has no curves and no events."
	}
,
	"AnimationClip.events": {
		"prefix": "AnimationClip.events",
		"body": [
			"events"
		],
		"description": "return:AnimationEvent[] des: Animation Events for this animation clip."
	}
,
	"AnimationClip.frameRate": {
		"prefix": "AnimationClip.frameRate",
		"body": [
			"frameRate"
		],
		"description": "return:float des: Frame rate at which keyframes are sampled. (Read Only)"
	}
,
	"AnimationClip.humanMotion": {
		"prefix": "AnimationClip.humanMotion",
		"body": [
			"humanMotion"
		],
		"description": "return:bool des: Returns true if the animation contains curve that drives a humanoid rig."
	}
,
	"AnimationClip.legacy": {
		"prefix": "AnimationClip.legacy",
		"body": [
			"legacy"
		],
		"description": "return:bool des: Set to true if the AnimationClip will be used with the Legacy Animation component ( instead of the Animator )."
	}
,
	"AnimationClip.length": {
		"prefix": "AnimationClip.length",
		"body": [
			"length"
		],
		"description": "return:float des: Animation length in seconds. (Read Only)"
	}
,
	"AnimationClip.localBounds": {
		"prefix": "AnimationClip.localBounds",
		"body": [
			"localBounds"
		],
		"description": "return:Bounds des: AABB of this Animation Clip in local space of Animation component that it is attached too."
	}
,
	"AnimationClip.wrapMode": {
		"prefix": "AnimationClip.wrapMode",
		"body": [
			"wrapMode"
		],
		"description": "return:WrapMode des: Sets the default wrap mode used in the animation state."
	}
,
	"AnimationClip.AddEvent": {
		"prefix": "AnimationClip.AddEvent",
		"body": [
			"AddEvent($1)"
		],
		"description": "public void AddEvent(AnimationEvent evt); des: Adds an animation event to the clip."
	}
,
	"AnimationClip.ClearCurves": {
		"prefix": "AnimationClip.ClearCurves",
		"body": [
			"ClearCurves($1)"
		],
		"description": "public void ClearCurves(); des: Clears all curves from the clip."
	}
,
	"AnimationClip.EnsureQuaternionContinuity": {
		"prefix": "AnimationClip.EnsureQuaternionContinuity",
		"body": [
			"EnsureQuaternionContinuity($1)"
		],
		"description": "public void EnsureQuaternionContinuity(); des: Realigns quaternion keys to ensure shortest interpolation paths."
	}
,
	"AnimationClip.SampleAnimation": {
		"prefix": "AnimationClip.SampleAnimation",
		"body": [
			"SampleAnimation($1)"
		],
		"description": "public void SampleAnimation(GameObject go, float time); des: Samples an animation at a given time for any animated properties."
	}
,
	"AnimationClip.SetCurve": {
		"prefix": "AnimationClip.SetCurve",
		"body": [
			"SetCurve($1)"
		],
		"description": "public void SetCurve(string relativePath, Type type, string propertyName, AnimationCurve curve); des: Assigns the curve to animate a specific property."
	}
,
	"AnimationClip.hideFlags": {
		"prefix": "AnimationClip.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"AnimationClip.name": {
		"prefix": "AnimationClip.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"AnimationClip.GetInstanceID": {
		"prefix": "AnimationClip.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"AnimationClip.ToString": {
		"prefix": "AnimationClip.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"AnimationClip.Destroy": {
		"prefix": "AnimationClip.Destroy",
		"body": [
			"AnimationClip.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"AnimationClip.DestroyImmediate": {
		"prefix": "AnimationClip.DestroyImmediate",
		"body": [
			"AnimationClip.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"AnimationClip.DontDestroyOnLoad": {
		"prefix": "AnimationClip.DontDestroyOnLoad",
		"body": [
			"AnimationClip.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"AnimationClip.FindObjectOfType": {
		"prefix": "AnimationClip.FindObjectOfType",
		"body": [
			"AnimationClip.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"AnimationClip.FindObjectsOfType": {
		"prefix": "AnimationClip.FindObjectsOfType",
		"body": [
			"AnimationClip.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"AnimationClip.Instantiate": {
		"prefix": "AnimationClip.Instantiate",
		"body": [
			"AnimationClip.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"AnimationCurve.keys": {
		"prefix": "AnimationCurve.keys",
		"body": [
			"keys"
		],
		"description": "return:Keyframe[] des: All keys defined in the animation curve."
	}
,
	"AnimationCurve.length": {
		"prefix": "AnimationCurve.length",
		"body": [
			"length"
		],
		"description": "return:int des: The number of keys in the curve. (Read Only)"
	}
,
	"AnimationCurve.postWrapMode": {
		"prefix": "AnimationCurve.postWrapMode",
		"body": [
			"postWrapMode"
		],
		"description": "return:WrapMode des: The behaviour of the animation after the last keyframe."
	}
,
	"AnimationCurve.preWrapMode": {
		"prefix": "AnimationCurve.preWrapMode",
		"body": [
			"preWrapMode"
		],
		"description": "return:WrapMode des: The behaviour of the animation before the first keyframe."
	}
,
	"AnimationCurve.this[int]": {
		"prefix": "AnimationCurve.this[int]",
		"body": [
			"this[int]"
		],
		"description": "return:Keyframe des: Retrieves the key at index. (Read Only)"
	}
,
	"AnimationCurve.AddKey": {
		"prefix": "AnimationCurve.AddKey",
		"body": [
			"AddKey($1)"
		],
		"description": "public int AddKey(float time, float value); public int AddKey(Keyframe key); des: Add a new key to the curve."
	}
,
	"AnimationCurve.Evaluate": {
		"prefix": "AnimationCurve.Evaluate",
		"body": [
			"Evaluate($1)"
		],
		"description": "public float Evaluate(float time); des: Evaluate the curve at time."
	}
,
	"AnimationCurve.MoveKey": {
		"prefix": "AnimationCurve.MoveKey",
		"body": [
			"MoveKey($1)"
		],
		"description": "public int MoveKey(int index, Keyframe key); des: Removes the keyframe at index and inserts key."
	}
,
	"AnimationCurve.RemoveKey": {
		"prefix": "AnimationCurve.RemoveKey",
		"body": [
			"RemoveKey($1)"
		],
		"description": "public void RemoveKey(int index); des: Removes a key."
	}
,
	"AnimationCurve.SmoothTangents": {
		"prefix": "AnimationCurve.SmoothTangents",
		"body": [
			"SmoothTangents($1)"
		],
		"description": "public void SmoothTangents(int index, float weight); des: Smooth the in and out tangents of the keyframe at index."
	}
,
	"AnimationCurve.Constant": {
		"prefix": "AnimationCurve.Constant",
		"body": [
			"AnimationCurve.Constant"
		],
		"description": "public static AnimationCurve Constant(float timeStart, float timeEnd, float value); des: Creates a constant \"curve\" starting at timeStart, ending at timeEnd and with the value value."
	}
,
	"AnimationCurve.EaseInOut": {
		"prefix": "AnimationCurve.EaseInOut",
		"body": [
			"AnimationCurve.EaseInOut"
		],
		"description": "public static AnimationCurve EaseInOut(float timeStart, float valueStart, float timeEnd, float valueEnd); des: Creates an ease-in and out curve starting at timeStart, valueStart and ending at timeEnd, valueEnd."
	}
,
	"AnimationCurve.Linear": {
		"prefix": "AnimationCurve.Linear",
		"body": [
			"AnimationCurve.Linear"
		],
		"description": "public static AnimationCurve Linear(float timeStart, float valueStart, float timeEnd, float valueEnd); des: A straight Line starting at timeStart, valueStart and ending at timeEnd, valueEnd."
	}
,
	"AnimationEvent.animationState": {
		"prefix": "AnimationEvent.animationState",
		"body": [
			"animationState"
		],
		"description": "return:AnimationState des: The animation state that fired this event (Read Only)."
	}
,
	"AnimationEvent.animatorClipInfo": {
		"prefix": "AnimationEvent.animatorClipInfo",
		"body": [
			"animatorClipInfo"
		],
		"description": "return:AnimatorClipInfo des: The animator clip info related to this event (Read Only)."
	}
,
	"AnimationEvent.animatorStateInfo": {
		"prefix": "AnimationEvent.animatorStateInfo",
		"body": [
			"animatorStateInfo"
		],
		"description": "return:AnimatorStateInfo des: The animator state info related to this event (Read Only)."
	}
,
	"AnimationEvent.floatParameter": {
		"prefix": "AnimationEvent.floatParameter",
		"body": [
			"floatParameter"
		],
		"description": "return:float des: Float parameter that is stored in the event and will be sent to the function."
	}
,
	"AnimationEvent.functionName": {
		"prefix": "AnimationEvent.functionName",
		"body": [
			"functionName"
		],
		"description": "return:string des: The name of the function that will be called."
	}
,
	"AnimationEvent.intParameter": {
		"prefix": "AnimationEvent.intParameter",
		"body": [
			"intParameter"
		],
		"description": "return:int des: Int parameter that is stored in the event and will be sent to the function."
	}
,
	"AnimationEvent.isFiredByAnimator": {
		"prefix": "AnimationEvent.isFiredByAnimator",
		"body": [
			"isFiredByAnimator"
		],
		"description": "return:bool des: Returns true if this Animation event has been fired by an Animator component."
	}
,
	"AnimationEvent.isFiredByLegacy": {
		"prefix": "AnimationEvent.isFiredByLegacy",
		"body": [
			"isFiredByLegacy"
		],
		"description": "return:bool des: Returns true if this Animation event has been fired by an Animation component."
	}
,
	"AnimationEvent.messageOptions": {
		"prefix": "AnimationEvent.messageOptions",
		"body": [
			"messageOptions"
		],
		"description": "return:SendMessageOptions des: Function call options."
	}
,
	"AnimationEvent.objectReferenceParameter": {
		"prefix": "AnimationEvent.objectReferenceParameter",
		"body": [
			"objectReferenceParameter"
		],
		"description": "return:Object des: Object reference parameter that is stored in the event and will be sent to the function."
	}
,
	"AnimationEvent.stringParameter": {
		"prefix": "AnimationEvent.stringParameter",
		"body": [
			"stringParameter"
		],
		"description": "return:string des: String parameter that is stored in the event and will be sent to the function."
	}
,
	"AnimationEvent.time": {
		"prefix": "AnimationEvent.time",
		"body": [
			"time"
		],
		"description": "return:float des: The time at which the event will be fired off."
	}
,
	"AnimationState.blendMode": {
		"prefix": "AnimationState.blendMode",
		"body": [
			"blendMode"
		],
		"description": "return:AnimationBlendMode des: Which blend mode should be used?"
	}
,
	"AnimationState.clip": {
		"prefix": "AnimationState.clip",
		"body": [
			"clip"
		],
		"description": "return:AnimationClip des: The clip that is being played by this animation state."
	}
,
	"AnimationState.enabled": {
		"prefix": "AnimationState.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enables / disables the animation."
	}
,
	"AnimationState.length": {
		"prefix": "AnimationState.length",
		"body": [
			"length"
		],
		"description": "return:float des: The length of the animation clip in seconds."
	}
,
	"AnimationState.name": {
		"prefix": "AnimationState.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the animation."
	}
,
	"AnimationState.normalizedSpeed": {
		"prefix": "AnimationState.normalizedSpeed",
		"body": [
			"normalizedSpeed"
		],
		"description": "return:float des: The normalized playback speed."
	}
,
	"AnimationState.normalizedTime": {
		"prefix": "AnimationState.normalizedTime",
		"body": [
			"normalizedTime"
		],
		"description": "return:float des: The normalized time of the animation."
	}
,
	"AnimationState.speed": {
		"prefix": "AnimationState.speed",
		"body": [
			"speed"
		],
		"description": "return:float des: The playback speed of the animation. 1 is normal playback speed."
	}
,
	"AnimationState.time": {
		"prefix": "AnimationState.time",
		"body": [
			"time"
		],
		"description": "return:float des: The current time of the animation."
	}
,
	"AnimationState.weight": {
		"prefix": "AnimationState.weight",
		"body": [
			"weight"
		],
		"description": "return:float des: The weight of animation."
	}
,
	"AnimationState.wrapMode": {
		"prefix": "AnimationState.wrapMode",
		"body": [
			"wrapMode"
		],
		"description": "return:WrapMode des: Wrapping mode of the animation."
	}
,
	"AnimationState.AddMixingTransform": {
		"prefix": "AnimationState.AddMixingTransform",
		"body": [
			"AddMixingTransform($1)"
		],
		"description": "public void AddMixingTransform(Transform mix, bool recursive = true); des: Adds a transform which should be animated. This allows you to reduce the number of animations you have to create."
	}
,
	"AnimationState.RemoveMixingTransform": {
		"prefix": "AnimationState.RemoveMixingTransform",
		"body": [
			"RemoveMixingTransform($1)"
		],
		"description": "public void RemoveMixingTransform(Transform mix); des: Removes a transform which should be animated."
	}
,
	"Animator.angularVelocity": {
		"prefix": "Animator.angularVelocity",
		"body": [
			"angularVelocity"
		],
		"description": "return:Vector3 des: Gets the avatar angular velocity for the last evaluated frame."
	}
,
	"Animator.applyRootMotion": {
		"prefix": "Animator.applyRootMotion",
		"body": [
			"applyRootMotion"
		],
		"description": "return:bool des: Should root motion be applied?"
	}
,
	"Animator.avatar": {
		"prefix": "Animator.avatar",
		"body": [
			"avatar"
		],
		"description": "return:Avatar des: Gets/Sets the current Avatar."
	}
,
	"Animator.bodyPosition": {
		"prefix": "Animator.bodyPosition",
		"body": [
			"bodyPosition"
		],
		"description": "return:Vector3 des: The position of the body center of mass."
	}
,
	"Animator.bodyRotation": {
		"prefix": "Animator.bodyRotation",
		"body": [
			"bodyRotation"
		],
		"description": "return:Quaternion des: The rotation of the body center of mass."
	}
,
	"Animator.cullingMode": {
		"prefix": "Animator.cullingMode",
		"body": [
			"cullingMode"
		],
		"description": "return:AnimatorCullingMode des: Controls culling of this Animator component."
	}
,
	"Animator.deltaPosition": {
		"prefix": "Animator.deltaPosition",
		"body": [
			"deltaPosition"
		],
		"description": "return:Vector3 des: Gets the avatar delta position for the last evaluated frame."
	}
,
	"Animator.deltaRotation": {
		"prefix": "Animator.deltaRotation",
		"body": [
			"deltaRotation"
		],
		"description": "return:Quaternion des: Gets the avatar delta rotation for the last evaluated frame."
	}
,
	"Animator.feetPivotActive": {
		"prefix": "Animator.feetPivotActive",
		"body": [
			"feetPivotActive"
		],
		"description": "return:float des: Blends pivot point between body center of mass and feet pivot."
	}
,
	"Animator.fireEvents": {
		"prefix": "Animator.fireEvents",
		"body": [
			"fireEvents"
		],
		"description": "return:bool des: Sets whether the Animator sends events of type AnimationEvent."
	}
,
	"Animator.gravityWeight": {
		"prefix": "Animator.gravityWeight",
		"body": [
			"gravityWeight"
		],
		"description": "return:float des: The current gravity weight based on current animations that are played."
	}
,
	"Animator.hasBoundPlayables": {
		"prefix": "Animator.hasBoundPlayables",
		"body": [
			"hasBoundPlayables"
		],
		"description": "return:bool des: Returns true if Animator has any playables assigned to it."
	}
,
	"Animator.hasRootMotion": {
		"prefix": "Animator.hasRootMotion",
		"body": [
			"hasRootMotion"
		],
		"description": "return:bool des: Returns true if the current rig has root motion."
	}
,
	"Animator.hasTransformHierarchy": {
		"prefix": "Animator.hasTransformHierarchy",
		"body": [
			"hasTransformHierarchy"
		],
		"description": "return:bool des: Returns true if the object has a transform hierarchy."
	}
,
	"Animator.humanScale": {
		"prefix": "Animator.humanScale",
		"body": [
			"humanScale"
		],
		"description": "return:float des: Returns the scale of the current Avatar for a humanoid rig, (1 by default if the rig is generic)."
	}
,
	"Animator.isHuman": {
		"prefix": "Animator.isHuman",
		"body": [
			"isHuman"
		],
		"description": "return:bool des: Returns true if the current rig is humanoid, false if it is generic."
	}
,
	"Animator.isInitialized": {
		"prefix": "Animator.isInitialized",
		"body": [
			"isInitialized"
		],
		"description": "return:bool des: Returns whether the animator is initialized successfully."
	}
,
	"Animator.isMatchingTarget": {
		"prefix": "Animator.isMatchingTarget",
		"body": [
			"isMatchingTarget"
		],
		"description": "return:bool des: If automatic matching is active."
	}
,
	"Animator.isOptimizable": {
		"prefix": "Animator.isOptimizable",
		"body": [
			"isOptimizable"
		],
		"description": "return:bool des: Returns true if the current rig is optimizable with AnimatorUtility.OptimizeTransformHierarchy."
	}
,
	"Animator.keepAnimatorControllerStateOnDisable": {
		"prefix": "Animator.keepAnimatorControllerStateOnDisable",
		"body": [
			"keepAnimatorControllerStateOnDisable"
		],
		"description": "return:bool des: Controls the behaviour of the Animator component when a GameObject is disabled."
	}
,
	"Animator.layerCount": {
		"prefix": "Animator.layerCount",
		"body": [
			"layerCount"
		],
		"description": "return:int des: Returns the number of layers in the controller."
	}
,
	"Animator.layersAffectMassCenter": {
		"prefix": "Animator.layersAffectMassCenter",
		"body": [
			"layersAffectMassCenter"
		],
		"description": "return:bool des: Additional layers affects the center of mass."
	}
,
	"Animator.leftFeetBottomHeight": {
		"prefix": "Animator.leftFeetBottomHeight",
		"body": [
			"leftFeetBottomHeight"
		],
		"description": "return:float des: Get left foot bottom height."
	}
,
	"Animator.linearVelocityBlending": {
		"prefix": "Animator.linearVelocityBlending",
		"body": [
			"linearVelocityBlending"
		],
		"description": "return:bool des: When linearVelocityBlending is set to true, the root motion velocity and angular velocity will be blended linearly."
	}
,
	"Animator.parameterCount": {
		"prefix": "Animator.parameterCount",
		"body": [
			"parameterCount"
		],
		"description": "return:int des: Returns the number of parameters in the controller."
	}
,
	"Animator.parameters": {
		"prefix": "Animator.parameters",
		"body": [
			"parameters"
		],
		"description": "return:AnimatorControllerParameter[] des: The AnimatorControllerParameter list used by the animator. (Read Only)"
	}
,
	"Animator.pivotPosition": {
		"prefix": "Animator.pivotPosition",
		"body": [
			"pivotPosition"
		],
		"description": "return:Vector3 des: Get the current position of the pivot."
	}
,
	"Animator.pivotWeight": {
		"prefix": "Animator.pivotWeight",
		"body": [
			"pivotWeight"
		],
		"description": "return:float des: Gets the pivot weight."
	}
,
	"Animator.playableGraph": {
		"prefix": "Animator.playableGraph",
		"body": [
			"playableGraph"
		],
		"description": "return:Playables.PlayableGraph des: The PlayableGraph created by the Animator."
	}
,
	"Animator.playbackTime": {
		"prefix": "Animator.playbackTime",
		"body": [
			"playbackTime"
		],
		"description": "return:float des: Sets the playback position in the recording buffer."
	}
,
	"Animator.recorderMode": {
		"prefix": "Animator.recorderMode",
		"body": [
			"recorderMode"
		],
		"description": "return:AnimatorRecorderMode des: Gets the mode of the Animator recorder."
	}
,
	"Animator.recorderStartTime": {
		"prefix": "Animator.recorderStartTime",
		"body": [
			"recorderStartTime"
		],
		"description": "return:float des: Start time of the first frame of the buffer relative to the frame at which StartRecording was called."
	}
,
	"Animator.recorderStopTime": {
		"prefix": "Animator.recorderStopTime",
		"body": [
			"recorderStopTime"
		],
		"description": "return:float des: End time of the recorded clip relative to when StartRecording was called."
	}
,
	"Animator.rightFeetBottomHeight": {
		"prefix": "Animator.rightFeetBottomHeight",
		"body": [
			"rightFeetBottomHeight"
		],
		"description": "return:float des: Get right foot bottom height."
	}
,
	"Animator.rootPosition": {
		"prefix": "Animator.rootPosition",
		"body": [
			"rootPosition"
		],
		"description": "return:Vector3 des: The root position, the position of the game object."
	}
,
	"Animator.rootRotation": {
		"prefix": "Animator.rootRotation",
		"body": [
			"rootRotation"
		],
		"description": "return:Quaternion des: The root rotation, the rotation of the game object."
	}
,
	"Animator.runtimeAnimatorController": {
		"prefix": "Animator.runtimeAnimatorController",
		"body": [
			"runtimeAnimatorController"
		],
		"description": "return:RuntimeAnimatorController des: The runtime representation of AnimatorController that controls the Animator."
	}
,
	"Animator.speed": {
		"prefix": "Animator.speed",
		"body": [
			"speed"
		],
		"description": "return:float des: The playback speed of the Animator. 1 is normal playback speed."
	}
,
	"Animator.stabilizeFeet": {
		"prefix": "Animator.stabilizeFeet",
		"body": [
			"stabilizeFeet"
		],
		"description": "return:bool des: Automatic stabilization of feet during transition and blending."
	}
,
	"Animator.targetPosition": {
		"prefix": "Animator.targetPosition",
		"body": [
			"targetPosition"
		],
		"description": "return:Vector3 des: Returns the position of the target specified by SetTarget."
	}
,
	"Animator.targetRotation": {
		"prefix": "Animator.targetRotation",
		"body": [
			"targetRotation"
		],
		"description": "return:Quaternion des: Returns the rotation of the target specified by SetTarget."
	}
,
	"Animator.updateMode": {
		"prefix": "Animator.updateMode",
		"body": [
			"updateMode"
		],
		"description": "return:AnimatorUpdateMode des: Specifies the update mode of the Animator."
	}
,
	"Animator.velocity": {
		"prefix": "Animator.velocity",
		"body": [
			"velocity"
		],
		"description": "return:Vector3 des: Gets the avatar velocity for the last evaluated frame."
	}
,
	"Animator.ApplyBuiltinRootMotion": {
		"prefix": "Animator.ApplyBuiltinRootMotion",
		"body": [
			"ApplyBuiltinRootMotion($1)"
		],
		"description": "public void ApplyBuiltinRootMotion(); des: Apply the default Root Motion."
	}
,
	"Animator.CrossFade": {
		"prefix": "Animator.CrossFade",
		"body": [
			"CrossFade($1)"
		],
		"description": "public void CrossFade(string stateName, float normalizedTransitionDuration, int layer = -1, float normalizedTimeOffset = float.NegativeInfinity, float normalizedTransitionTime = 0.0f); public void CrossFade(int stateHashName, float normalizedTransitionDuration, int layer = -1, float normalizedTimeOffset = 0.0f, float normalizedTransitionTime = 0.0f); des: Creates a crossfade from the current state to any other state using normalized times."
	}
,
	"Animator.CrossFadeInFixedTime": {
		"prefix": "Animator.CrossFadeInFixedTime",
		"body": [
			"CrossFadeInFixedTime($1)"
		],
		"description": "public void CrossFadeInFixedTime(int stateHashName, float fixedTransitionDuration, int layer = -1, float fixedTimeOffset = 0.0f, float normalizedTransitionTime = 0.0f); public void CrossFadeInFixedTime(string stateName, float fixedTransitionDuration, int layer = -1, float fixedTimeOffset = 0.0f, float normalizedTransitionTime = 0.0f); des: Creates a crossfade from the current state to any other state using times in seconds."
	}
,
	"Animator.GetAnimatorTransitionInfo": {
		"prefix": "Animator.GetAnimatorTransitionInfo",
		"body": [
			"GetAnimatorTransitionInfo($1)"
		],
		"description": "public AnimatorTransitionInfo GetAnimatorTransitionInfo(int layerIndex); des: Returns an AnimatorTransitionInfo with the informations on the current transition."
	}
,
	"Animator.GetBehaviour": {
		"prefix": "Animator.GetBehaviour",
		"body": [
			"GetBehaviour($1)"
		],
		"description": "public T GetBehaviour(); des: Returns the first StateMachineBehaviour that matches type T or is derived from T. Returns null if none are found."
	}
,
	"Animator.GetBehaviours": {
		"prefix": "Animator.GetBehaviours",
		"body": [
			"GetBehaviours($1)"
		],
		"description": "public T[] GetBehaviours(); des: Returns all StateMachineBehaviour that match type T or are derived from T. Returns null if none are found."
	}
,
	"Animator.GetBoneTransform": {
		"prefix": "Animator.GetBoneTransform",
		"body": [
			"GetBoneTransform($1)"
		],
		"description": "public Transform GetBoneTransform(HumanBodyBones humanBoneId); des: Returns Transform mapped to this human bone id."
	}
,
	"Animator.GetBool": {
		"prefix": "Animator.GetBool",
		"body": [
			"GetBool($1)"
		],
		"description": "public bool GetBool(string name); public bool GetBool(int id); des: Returns the value of the given boolean parameter."
	}
,
	"Animator.GetCurrentAnimatorClipInfo": {
		"prefix": "Animator.GetCurrentAnimatorClipInfo",
		"body": [
			"GetCurrentAnimatorClipInfo($1)"
		],
		"description": "public AnimatorClipInfo[] GetCurrentAnimatorClipInfo(int layerIndex); public void GetCurrentAnimatorClipInfo(int layerIndex, List<AnimatorClipInfo> clips); des: Returns an array of all the AnimatorClipInfo in the current state of the given layer."
	}
,
	"Animator.GetCurrentAnimatorClipInfoCount": {
		"prefix": "Animator.GetCurrentAnimatorClipInfoCount",
		"body": [
			"GetCurrentAnimatorClipInfoCount($1)"
		],
		"description": "public int GetCurrentAnimatorClipInfoCount(int layerIndex); des: Returns the number of AnimatorClipInfo in the current state."
	}
,
	"Animator.GetCurrentAnimatorStateInfo": {
		"prefix": "Animator.GetCurrentAnimatorStateInfo",
		"body": [
			"GetCurrentAnimatorStateInfo($1)"
		],
		"description": "public AnimatorStateInfo GetCurrentAnimatorStateInfo(int layerIndex); des: Returns an AnimatorStateInfo with the information on the current state."
	}
,
	"Animator.GetFloat": {
		"prefix": "Animator.GetFloat",
		"body": [
			"GetFloat($1)"
		],
		"description": "public float GetFloat(string name); public float GetFloat(int id); des: Returns the value of the given float parameter."
	}
,
	"Animator.GetIKHintPosition": {
		"prefix": "Animator.GetIKHintPosition",
		"body": [
			"GetIKHintPosition($1)"
		],
		"description": "public Vector3 GetIKHintPosition(AvatarIKHint hint); des: Gets the position of an IK hint."
	}
,
	"Animator.GetIKHintPositionWeight": {
		"prefix": "Animator.GetIKHintPositionWeight",
		"body": [
			"GetIKHintPositionWeight($1)"
		],
		"description": "public float GetIKHintPositionWeight(AvatarIKHint hint); des: Gets the translative weight of an IK Hint (0 = at the original animation before IK, 1 = at the hint)."
	}
,
	"Animator.GetIKPosition": {
		"prefix": "Animator.GetIKPosition",
		"body": [
			"GetIKPosition($1)"
		],
		"description": "public Vector3 GetIKPosition(AvatarIKGoal goal); des: Gets the position of an IK goal."
	}
,
	"Animator.GetIKPositionWeight": {
		"prefix": "Animator.GetIKPositionWeight",
		"body": [
			"GetIKPositionWeight($1)"
		],
		"description": "public float GetIKPositionWeight(AvatarIKGoal goal); des: Gets the translative weight of an IK goal (0 = at the original animation before IK, 1 = at the goal)."
	}
,
	"Animator.GetIKRotation": {
		"prefix": "Animator.GetIKRotation",
		"body": [
			"GetIKRotation($1)"
		],
		"description": "public Quaternion GetIKRotation(AvatarIKGoal goal); des: Gets the rotation of an IK goal."
	}
,
	"Animator.GetIKRotationWeight": {
		"prefix": "Animator.GetIKRotationWeight",
		"body": [
			"GetIKRotationWeight($1)"
		],
		"description": "public float GetIKRotationWeight(AvatarIKGoal goal); des: Gets the rotational weight of an IK goal (0 = rotation before IK, 1 = rotation at the IK goal)."
	}
,
	"Animator.GetInteger": {
		"prefix": "Animator.GetInteger",
		"body": [
			"GetInteger($1)"
		],
		"description": "public int GetInteger(string name); public int GetInteger(int id); des: Returns the value of the given integer parameter."
	}
,
	"Animator.GetLayerIndex": {
		"prefix": "Animator.GetLayerIndex",
		"body": [
			"GetLayerIndex($1)"
		],
		"description": "public int GetLayerIndex(string layerName); des: Returns the index of the layer with the given name."
	}
,
	"Animator.GetLayerName": {
		"prefix": "Animator.GetLayerName",
		"body": [
			"GetLayerName($1)"
		],
		"description": "public string GetLayerName(int layerIndex); des: Returns the layer name."
	}
,
	"Animator.GetLayerWeight": {
		"prefix": "Animator.GetLayerWeight",
		"body": [
			"GetLayerWeight($1)"
		],
		"description": "public float GetLayerWeight(int layerIndex); des: Returns the weight of the layer at the specified index."
	}
,
	"Animator.GetNextAnimatorClipInfo": {
		"prefix": "Animator.GetNextAnimatorClipInfo",
		"body": [
			"GetNextAnimatorClipInfo($1)"
		],
		"description": "public AnimatorClipInfo[] GetNextAnimatorClipInfo(int layerIndex); public void GetNextAnimatorClipInfo(int layerIndex, List<AnimatorClipInfo> clips); des: Returns an array of all the AnimatorClipInfo in the next state of the given layer."
	}
,
	"Animator.GetNextAnimatorClipInfoCount": {
		"prefix": "Animator.GetNextAnimatorClipInfoCount",
		"body": [
			"GetNextAnimatorClipInfoCount($1)"
		],
		"description": "public int GetNextAnimatorClipInfoCount(int layerIndex); des: Returns the number of AnimatorClipInfo in the next state."
	}
,
	"Animator.GetNextAnimatorStateInfo": {
		"prefix": "Animator.GetNextAnimatorStateInfo",
		"body": [
			"GetNextAnimatorStateInfo($1)"
		],
		"description": "public AnimatorStateInfo GetNextAnimatorStateInfo(int layerIndex); des: Returns an AnimatorStateInfo with the information on the next state."
	}
,
	"Animator.GetParameter": {
		"prefix": "Animator.GetParameter",
		"body": [
			"GetParameter($1)"
		],
		"description": "public AnimatorControllerParameter GetParameter(int index); des: See AnimatorController.parameters."
	}
,
	"Animator.HasState": {
		"prefix": "Animator.HasState",
		"body": [
			"HasState($1)"
		],
		"description": "public bool HasState(int layerIndex, int stateID); des: Returns true if the state exists in this layer, false otherwise."
	}
,
	"Animator.InterruptMatchTarget": {
		"prefix": "Animator.InterruptMatchTarget",
		"body": [
			"InterruptMatchTarget($1)"
		],
		"description": "public void InterruptMatchTarget(); public void InterruptMatchTarget(bool completeMatch = true); des: Interrupts the automatic target matching."
	}
,
	"Animator.IsInTransition": {
		"prefix": "Animator.IsInTransition",
		"body": [
			"IsInTransition($1)"
		],
		"description": "public bool IsInTransition(int layerIndex); des: Returns true if there is a transition on the given layer, false otherwise."
	}
,
	"Animator.IsParameterControlledByCurve": {
		"prefix": "Animator.IsParameterControlledByCurve",
		"body": [
			"IsParameterControlledByCurve($1)"
		],
		"description": "public bool IsParameterControlledByCurve(string name); public bool IsParameterControlledByCurve(int id); des: Returns true if the parameter is controlled by a curve, false otherwise."
	}
,
	"Animator.MatchTarget": {
		"prefix": "Animator.MatchTarget",
		"body": [
			"MatchTarget($1)"
		],
		"description": "public void MatchTarget(Vector3 matchPosition, Quaternion matchRotation, AvatarTarget targetBodyPart, MatchTargetWeightMask weightMask, float startNormalizedTime, float targetNormalizedTime = 1); des: Automatically adjust the GameObject position and rotation."
	}
,
	"Animator.Play": {
		"prefix": "Animator.Play",
		"body": [
			"Play($1)"
		],
		"description": "public void Play(string stateName, int layer = -1, float normalizedTime = float.NegativeInfinity); public void Play(int stateNameHash, int layer = -1, float normalizedTime = float.NegativeInfinity); des: Plays a state."
	}
,
	"Animator.PlayInFixedTime": {
		"prefix": "Animator.PlayInFixedTime",
		"body": [
			"PlayInFixedTime($1)"
		],
		"description": "public void PlayInFixedTime(string stateName, int layer = -1, float fixedTime = float.NegativeInfinity); public void PlayInFixedTime(int stateNameHash, int layer = -1, float fixedTime = float.NegativeInfinity); des: Plays a state."
	}
,
	"Animator.Rebind": {
		"prefix": "Animator.Rebind",
		"body": [
			"Rebind($1)"
		],
		"description": "public void Rebind(); des: Rebind all the animated properties and mesh data with the Animator."
	}
,
	"Animator.ResetTrigger": {
		"prefix": "Animator.ResetTrigger",
		"body": [
			"ResetTrigger($1)"
		],
		"description": "public void ResetTrigger(string name); public void ResetTrigger(int id); des: Resets the value of the given trigger parameter."
	}
,
	"Animator.SetBoneLocalRotation": {
		"prefix": "Animator.SetBoneLocalRotation",
		"body": [
			"SetBoneLocalRotation($1)"
		],
		"description": "public void SetBoneLocalRotation(HumanBodyBones humanBoneId, Quaternion rotation); des: Sets local rotation of a human bone during a IK pass."
	}
,
	"Animator.SetBool": {
		"prefix": "Animator.SetBool",
		"body": [
			"SetBool($1)"
		],
		"description": "public void SetBool(string name, bool value); public void SetBool(int id, bool value); des: Sets the value of the given boolean parameter."
	}
,
	"Animator.SetFloat": {
		"prefix": "Animator.SetFloat",
		"body": [
			"SetFloat($1)"
		],
		"description": "public void SetFloat(string name, float value); public void SetFloat(string name, float value, float dampTime, float deltaTime); public void SetFloat(int id, float value); public void SetFloat(int id, float value, float dampTime, float deltaTime); des: Send float values to the Animator to affect transitions."
	}
,
	"Animator.SetIKHintPosition": {
		"prefix": "Animator.SetIKHintPosition",
		"body": [
			"SetIKHintPosition($1)"
		],
		"description": "public void SetIKHintPosition(AvatarIKHint hint, Vector3 hintPosition); des: Sets the position of an IK hint."
	}
,
	"Animator.SetIKHintPositionWeight": {
		"prefix": "Animator.SetIKHintPositionWeight",
		"body": [
			"SetIKHintPositionWeight($1)"
		],
		"description": "public void SetIKHintPositionWeight(AvatarIKHint hint, float value); des: Sets the translative weight of an IK hint (0 = at the original animation before IK, 1 = at the hint)."
	}
,
	"Animator.SetIKPosition": {
		"prefix": "Animator.SetIKPosition",
		"body": [
			"SetIKPosition($1)"
		],
		"description": "public void SetIKPosition(AvatarIKGoal goal, Vector3 goalPosition); des: Sets the position of an IK goal."
	}
,
	"Animator.SetIKPositionWeight": {
		"prefix": "Animator.SetIKPositionWeight",
		"body": [
			"SetIKPositionWeight($1)"
		],
		"description": "public void SetIKPositionWeight(AvatarIKGoal goal, float value); des: Sets the translative weight of an IK goal (0 = at the original animation before IK, 1 = at the goal)."
	}
,
	"Animator.SetIKRotation": {
		"prefix": "Animator.SetIKRotation",
		"body": [
			"SetIKRotation($1)"
		],
		"description": "public void SetIKRotation(AvatarIKGoal goal, Quaternion goalRotation); des: Sets the rotation of an IK goal."
	}
,
	"Animator.SetIKRotationWeight": {
		"prefix": "Animator.SetIKRotationWeight",
		"body": [
			"SetIKRotationWeight($1)"
		],
		"description": "public void SetIKRotationWeight(AvatarIKGoal goal, float value); des: Sets the rotational weight of an IK goal (0 = rotation before IK, 1 = rotation at the IK goal)."
	}
,
	"Animator.SetInteger": {
		"prefix": "Animator.SetInteger",
		"body": [
			"SetInteger($1)"
		],
		"description": "public void SetInteger(string name, int value); public void SetInteger(int id, int value); des: Sets the value of the given integer parameter."
	}
,
	"Animator.SetLayerWeight": {
		"prefix": "Animator.SetLayerWeight",
		"body": [
			"SetLayerWeight($1)"
		],
		"description": "public void SetLayerWeight(int layerIndex, float weight); des: Sets the weight of the layer at the given index."
	}
,
	"Animator.SetLookAtPosition": {
		"prefix": "Animator.SetLookAtPosition",
		"body": [
			"SetLookAtPosition($1)"
		],
		"description": "public void SetLookAtPosition(Vector3 lookAtPosition); des: Sets the look at position."
	}
,
	"Animator.SetLookAtWeight": {
		"prefix": "Animator.SetLookAtWeight",
		"body": [
			"SetLookAtWeight($1)"
		],
		"description": "public void SetLookAtWeight(float weight); public void SetLookAtWeight(float weight, float bodyWeight); public void SetLookAtWeight(float weight, float bodyWeight, float headWeight); public void SetLookAtWeight(float weight, float bodyWeight, float headWeight, float eyesWeight); public void SetLookAtWeight(float weight, float bodyWeight = 0.0f, float headWeight = 1.0f, float eyesWeight = 0.0f, float clampWeight = 0.5f); des: Set look at weights."
	}
,
	"Animator.SetTarget": {
		"prefix": "Animator.SetTarget",
		"body": [
			"SetTarget($1)"
		],
		"description": "public void SetTarget(AvatarTarget targetIndex, float targetNormalizedTime); des: Sets an AvatarTarget and a targetNormalizedTime for the current state."
	}
,
	"Animator.SetTrigger": {
		"prefix": "Animator.SetTrigger",
		"body": [
			"SetTrigger($1)"
		],
		"description": "public void SetTrigger(string name); public void SetTrigger(int id); des: Sets the value of the given trigger parameter."
	}
,
	"Animator.StartPlayback": {
		"prefix": "Animator.StartPlayback",
		"body": [
			"StartPlayback($1)"
		],
		"description": "public void StartPlayback(); des: Sets the animator in playback mode."
	}
,
	"Animator.StartRecording": {
		"prefix": "Animator.StartRecording",
		"body": [
			"StartRecording($1)"
		],
		"description": "public void StartRecording(int frameCount); des: Sets the animator in recording mode, and allocates a circular buffer of size frameCount."
	}
,
	"Animator.StopPlayback": {
		"prefix": "Animator.StopPlayback",
		"body": [
			"StopPlayback($1)"
		],
		"description": "public void StopPlayback(); des: Stops the animator playback mode. When playback stops, the avatar resumes getting control from game logic."
	}
,
	"Animator.StopRecording": {
		"prefix": "Animator.StopRecording",
		"body": [
			"StopRecording($1)"
		],
		"description": "public void StopRecording(); des: Stops animator record mode."
	}
,
	"Animator.Update": {
		"prefix": "Animator.Update",
		"body": [
			"Update($1)"
		],
		"description": "public void Update(float deltaTime); des: Evaluates the animator based on deltaTime."
	}
,
	"Animator.StringToHash": {
		"prefix": "Animator.StringToHash",
		"body": [
			"Animator.StringToHash"
		],
		"description": "public static int StringToHash(string name); des: Generates an parameter id from a string."
	}
,
	"Animator.enabled": {
		"prefix": "Animator.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"Animator.isActiveAndEnabled": {
		"prefix": "Animator.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"Animator.gameObject": {
		"prefix": "Animator.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"Animator.tag": {
		"prefix": "Animator.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"Animator.transform": {
		"prefix": "Animator.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"Animator.hideFlags": {
		"prefix": "Animator.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Animator.name": {
		"prefix": "Animator.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Animator.BroadcastMessage": {
		"prefix": "Animator.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"Animator.CompareTag": {
		"prefix": "Animator.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"Animator.GetComponent": {
		"prefix": "Animator.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"Animator.GetComponentInChildren": {
		"prefix": "Animator.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"Animator.GetComponentInParent": {
		"prefix": "Animator.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"Animator.GetComponents": {
		"prefix": "Animator.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"Animator.GetComponentsInChildren": {
		"prefix": "Animator.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"Animator.GetComponentsInParent": {
		"prefix": "Animator.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"Animator.SendMessage": {
		"prefix": "Animator.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"Animator.SendMessageUpwards": {
		"prefix": "Animator.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"Animator.GetInstanceID": {
		"prefix": "Animator.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Animator.ToString": {
		"prefix": "Animator.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Animator.Destroy": {
		"prefix": "Animator.Destroy",
		"body": [
			"Animator.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Animator.DestroyImmediate": {
		"prefix": "Animator.DestroyImmediate",
		"body": [
			"Animator.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Animator.DontDestroyOnLoad": {
		"prefix": "Animator.DontDestroyOnLoad",
		"body": [
			"Animator.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Animator.FindObjectOfType": {
		"prefix": "Animator.FindObjectOfType",
		"body": [
			"Animator.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Animator.FindObjectsOfType": {
		"prefix": "Animator.FindObjectsOfType",
		"body": [
			"Animator.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Animator.Instantiate": {
		"prefix": "Animator.Instantiate",
		"body": [
			"Animator.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"AnimatorClipInfo.clip": {
		"prefix": "AnimatorClipInfo.clip",
		"body": [
			"clip"
		],
		"description": "return:AnimationClip des: Returns the animation clip played by the Animator."
	}
,
	"AnimatorClipInfo.weight": {
		"prefix": "AnimatorClipInfo.weight",
		"body": [
			"weight"
		],
		"description": "return:float des: Returns the blending weight used by the Animator to blend this clip."
	}
,
	"AnimatorControllerParameter.defaultBool": {
		"prefix": "AnimatorControllerParameter.defaultBool",
		"body": [
			"defaultBool"
		],
		"description": "return:bool des: The default bool value for the parameter."
	}
,
	"AnimatorControllerParameter.defaultFloat": {
		"prefix": "AnimatorControllerParameter.defaultFloat",
		"body": [
			"defaultFloat"
		],
		"description": "return:float des: The default float value for the parameter."
	}
,
	"AnimatorControllerParameter.defaultInt": {
		"prefix": "AnimatorControllerParameter.defaultInt",
		"body": [
			"defaultInt"
		],
		"description": "return:int des: The default int value for the parameter."
	}
,
	"AnimatorControllerParameter.name": {
		"prefix": "AnimatorControllerParameter.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the parameter."
	}
,
	"AnimatorControllerParameter.nameHash": {
		"prefix": "AnimatorControllerParameter.nameHash",
		"body": [
			"nameHash"
		],
		"description": "return:int des: Returns the hash of the parameter based on its name."
	}
,
	"AnimatorControllerParameter.type": {
		"prefix": "AnimatorControllerParameter.type",
		"body": [
			"type"
		],
		"description": "return:AnimatorControllerParameterType des: The type of the parameter."
	}
,
	"AnimatorOverrideController.overridesCount": {
		"prefix": "AnimatorOverrideController.overridesCount",
		"body": [
			"overridesCount"
		],
		"description": "return:int des: Returns the count of overrides."
	}
,
	"AnimatorOverrideController.runtimeAnimatorController": {
		"prefix": "AnimatorOverrideController.runtimeAnimatorController",
		"body": [
			"runtimeAnimatorController"
		],
		"description": "return:RuntimeAnimatorController des: The Runtime Animator Controller that the Animator Override Controller overrides."
	}
,
	"AnimatorOverrideController.this[string]": {
		"prefix": "AnimatorOverrideController.this[string]",
		"body": [
			"this[string]"
		],
		"description": "return:AnimationClip   AnimationClip this[AnimationClip] des: Returns either the overriding Animation Clip if set or the original Animation Clip named name."
	}
,
	"AnimatorOverrideController.ApplyOverrides": {
		"prefix": "AnimatorOverrideController.ApplyOverrides",
		"body": [
			"ApplyOverrides($1)"
		],
		"description": "public void ApplyOverrides(IList<KeyValuePair<AnimationClip,AnimationClip>> overrides); des: Applies the list of overrides on this Animator Override Controller."
	}
,
	"AnimatorOverrideController.GetOverrides": {
		"prefix": "AnimatorOverrideController.GetOverrides",
		"body": [
			"GetOverrides($1)"
		],
		"description": "public void GetOverrides(List<KeyValuePair<AnimationClip,AnimationClip>> overrides); des: Gets the list of Animation Clip overrides currently defined in this Animator Override Controller."
	}
,
	"AnimatorOverrideController.hideFlags": {
		"prefix": "AnimatorOverrideController.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"AnimatorOverrideController.name": {
		"prefix": "AnimatorOverrideController.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"AnimatorOverrideController.animationClips": {
		"prefix": "AnimatorOverrideController.animationClips",
		"body": [
			"animationClips"
		],
		"description": "return:AnimationClip[] des: Retrieves all AnimationClip used by the controller."
	}
,
	"AnimatorOverrideController.GetInstanceID": {
		"prefix": "AnimatorOverrideController.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"AnimatorOverrideController.ToString": {
		"prefix": "AnimatorOverrideController.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"AnimatorOverrideController.Destroy": {
		"prefix": "AnimatorOverrideController.Destroy",
		"body": [
			"AnimatorOverrideController.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"AnimatorOverrideController.DestroyImmediate": {
		"prefix": "AnimatorOverrideController.DestroyImmediate",
		"body": [
			"AnimatorOverrideController.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"AnimatorOverrideController.DontDestroyOnLoad": {
		"prefix": "AnimatorOverrideController.DontDestroyOnLoad",
		"body": [
			"AnimatorOverrideController.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"AnimatorOverrideController.FindObjectOfType": {
		"prefix": "AnimatorOverrideController.FindObjectOfType",
		"body": [
			"AnimatorOverrideController.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"AnimatorOverrideController.FindObjectsOfType": {
		"prefix": "AnimatorOverrideController.FindObjectsOfType",
		"body": [
			"AnimatorOverrideController.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"AnimatorOverrideController.Instantiate": {
		"prefix": "AnimatorOverrideController.Instantiate",
		"body": [
			"AnimatorOverrideController.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"AnimatorStateInfo.fullPathHash": {
		"prefix": "AnimatorStateInfo.fullPathHash",
		"body": [
			"fullPathHash"
		],
		"description": "return:int des: The full path hash for this state."
	}
,
	"AnimatorStateInfo.length": {
		"prefix": "AnimatorStateInfo.length",
		"body": [
			"length"
		],
		"description": "return:float des: Current duration of the state."
	}
,
	"AnimatorStateInfo.loop": {
		"prefix": "AnimatorStateInfo.loop",
		"body": [
			"loop"
		],
		"description": "return:bool des: Is the state looping."
	}
,
	"AnimatorStateInfo.normalizedTime": {
		"prefix": "AnimatorStateInfo.normalizedTime",
		"body": [
			"normalizedTime"
		],
		"description": "return:float des: Normalized time of the State."
	}
,
	"AnimatorStateInfo.shortNameHash": {
		"prefix": "AnimatorStateInfo.shortNameHash",
		"body": [
			"shortNameHash"
		],
		"description": "return:int des: The hash is generated using Animator.StringToHash. The hash does not include the name of the parent layer."
	}
,
	"AnimatorStateInfo.speed": {
		"prefix": "AnimatorStateInfo.speed",
		"body": [
			"speed"
		],
		"description": "return:float des: The playback speed of the animation. 1 is the normal playback speed."
	}
,
	"AnimatorStateInfo.speedMultiplier": {
		"prefix": "AnimatorStateInfo.speedMultiplier",
		"body": [
			"speedMultiplier"
		],
		"description": "return:float des: The speed multiplier for this state."
	}
,
	"AnimatorStateInfo.tagHash": {
		"prefix": "AnimatorStateInfo.tagHash",
		"body": [
			"tagHash"
		],
		"description": "return:int des: The Tag of the State."
	}
,
	"AnimatorStateInfo.IsName": {
		"prefix": "AnimatorStateInfo.IsName",
		"body": [
			"IsName($1)"
		],
		"description": "public bool IsName(string name); des: Does name match the name of the active state in the statemachine?"
	}
,
	"AnimatorStateInfo.IsTag": {
		"prefix": "AnimatorStateInfo.IsTag",
		"body": [
			"IsTag($1)"
		],
		"description": "public bool IsTag(string tag); des: Does tag match the tag of the active state in the statemachine."
	}
,
	"AnimatorTransitionInfo.anyState": {
		"prefix": "AnimatorTransitionInfo.anyState",
		"body": [
			"anyState"
		],
		"description": "return:bool des: Returns true if the transition is from an AnyState node, or from Animator.CrossFade."
	}
,
	"AnimatorTransitionInfo.duration": {
		"prefix": "AnimatorTransitionInfo.duration",
		"body": [
			"duration"
		],
		"description": "return:float des: Duration of the transition."
	}
,
	"AnimatorTransitionInfo.durationUnit": {
		"prefix": "AnimatorTransitionInfo.durationUnit",
		"body": [
			"durationUnit"
		],
		"description": "return:DurationUnit des: The unit of the transition duration."
	}
,
	"AnimatorTransitionInfo.fullPathHash": {
		"prefix": "AnimatorTransitionInfo.fullPathHash",
		"body": [
			"fullPathHash"
		],
		"description": "return:int des: The hash name of the Transition."
	}
,
	"AnimatorTransitionInfo.nameHash": {
		"prefix": "AnimatorTransitionInfo.nameHash",
		"body": [
			"nameHash"
		],
		"description": "return:int des: The simplified name of the Transition."
	}
,
	"AnimatorTransitionInfo.normalizedTime": {
		"prefix": "AnimatorTransitionInfo.normalizedTime",
		"body": [
			"normalizedTime"
		],
		"description": "return:float des: Normalized time of the Transition."
	}
,
	"AnimatorTransitionInfo.userNameHash": {
		"prefix": "AnimatorTransitionInfo.userNameHash",
		"body": [
			"userNameHash"
		],
		"description": "return:int des: The user-specified name of the Transition."
	}
,
	"AnimatorTransitionInfo.IsName": {
		"prefix": "AnimatorTransitionInfo.IsName",
		"body": [
			"IsName($1)"
		],
		"description": "public bool IsName(string name); des: Does name match the name of the active Transition."
	}
,
	"AnimatorTransitionInfo.IsUserName": {
		"prefix": "AnimatorTransitionInfo.IsUserName",
		"body": [
			"IsUserName($1)"
		],
		"description": "public bool IsUserName(string name); des: Does userName match the name of the active Transition."
	}
,
	"AnimatorUtility.DeoptimizeTransformHierarchy": {
		"prefix": "AnimatorUtility.DeoptimizeTransformHierarchy",
		"body": [
			"AnimatorUtility.DeoptimizeTransformHierarchy"
		],
		"description": "public static void DeoptimizeTransformHierarchy(GameObject go); des: This function will recreate all transform hierarchy under GameObject."
	}
,
	"AnimatorUtility.OptimizeTransformHierarchy": {
		"prefix": "AnimatorUtility.OptimizeTransformHierarchy",
		"body": [
			"AnimatorUtility.OptimizeTransformHierarchy"
		],
		"description": "public static void OptimizeTransformHierarchy(GameObject go, string[] exposedTransforms); des: This function will remove all transform hierarchy under GameObject, the animator will write directly transform matrices into the skin mesh matrices saving alot of CPU cycles."
	}
,
	"Application.CanStreamedLevelBeLoaded": {
		"prefix": "Application.CanStreamedLevelBeLoaded",
		"body": [
			"Application.CanStreamedLevelBeLoaded"
		],
		"description": "public static bool CanStreamedLevelBeLoaded(int levelIndex); public static bool CanStreamedLevelBeLoaded(string levelName); des: Can the streamed level be loaded?"
	}
,
	"Application.GetBuildTags": {
		"prefix": "Application.GetBuildTags",
		"body": [
			"Application.GetBuildTags"
		],
		"description": "public static string[] GetBuildTags(); des: Returns an array of feature tags in use for this build."
	}
,
	"Application.GetStackTraceLogType": {
		"prefix": "Application.GetStackTraceLogType",
		"body": [
			"Application.GetStackTraceLogType"
		],
		"description": "public static StackTraceLogType GetStackTraceLogType(LogType logType); des: Get stack trace logging options. The default value is StackTraceLogType.ScriptOnly."
	}
,
	"Application.HasProLicense": {
		"prefix": "Application.HasProLicense",
		"body": [
			"Application.HasProLicense"
		],
		"description": "public static bool HasProLicense(); des: Is Unity activated with the Pro license?"
	}
,
	"Application.HasUserAuthorization": {
		"prefix": "Application.HasUserAuthorization",
		"body": [
			"Application.HasUserAuthorization"
		],
		"description": "public static bool HasUserAuthorization(UserAuthorization mode); des: Check if the user has authorized use of the webcam or microphone in the Web Player."
	}
,
	"Application.OpenURL": {
		"prefix": "Application.OpenURL",
		"body": [
			"Application.OpenURL"
		],
		"description": "public static void OpenURL(string url); des: Opens the url in a browser."
	}
,
	"Application.Quit": {
		"prefix": "Application.Quit",
		"body": [
			"Application.Quit"
		],
		"description": "public static void Quit(); des: Quits the player application."
	}
,
	"Application.RequestAdvertisingIdentifierAsync": {
		"prefix": "Application.RequestAdvertisingIdentifierAsync",
		"body": [
			"Application.RequestAdvertisingIdentifierAsync"
		],
		"description": "public static bool RequestAdvertisingIdentifierAsync(Application.AdvertisingIdentifierCallback delegateMethod); des: Request advertising ID for iOS, Android and Windows Store."
	}
,
	"Application.RequestUserAuthorization": {
		"prefix": "Application.RequestUserAuthorization",
		"body": [
			"Application.RequestUserAuthorization"
		],
		"description": "public static AsyncOperation RequestUserAuthorization(UserAuthorization mode); des: Request authorization to use the webcam or microphone on iOS."
	}
,
	"Application.SetBuildTags": {
		"prefix": "Application.SetBuildTags",
		"body": [
			"Application.SetBuildTags"
		],
		"description": "public static void SetBuildTags(string[] buildTags); des: Set an array of feature tags for this build."
	}
,
	"Application.SetStackTraceLogType": {
		"prefix": "Application.SetStackTraceLogType",
		"body": [
			"Application.SetStackTraceLogType"
		],
		"description": "public static void SetStackTraceLogType(LogType logType, StackTraceLogType stackTraceType); des: Set stack trace logging options. The default value is StackTraceLogType.ScriptOnly."
	}
,
	"Application.Unload": {
		"prefix": "Application.Unload",
		"body": [
			"Application.Unload"
		],
		"description": "public static void Unload(); des: Unloads the Unity runtime."
	}
,
	"AreaEffector2D.angularDrag": {
		"prefix": "AreaEffector2D.angularDrag",
		"body": [
			"angularDrag"
		],
		"description": "return:float des: The angular drag to apply to rigid-bodies."
	}
,
	"AreaEffector2D.drag": {
		"prefix": "AreaEffector2D.drag",
		"body": [
			"drag"
		],
		"description": "return:float des: The linear drag to apply to rigid-bodies."
	}
,
	"AreaEffector2D.forceAngle": {
		"prefix": "AreaEffector2D.forceAngle",
		"body": [
			"forceAngle"
		],
		"description": "return:float des: The angle of the force to be applied."
	}
,
	"AreaEffector2D.forceMagnitude": {
		"prefix": "AreaEffector2D.forceMagnitude",
		"body": [
			"forceMagnitude"
		],
		"description": "return:float des: The magnitude of the force to be applied."
	}
,
	"AreaEffector2D.forceTarget": {
		"prefix": "AreaEffector2D.forceTarget",
		"body": [
			"forceTarget"
		],
		"description": "return:EffectorSelection2D des: The target for where the effector applies any force."
	}
,
	"AreaEffector2D.forceVariation": {
		"prefix": "AreaEffector2D.forceVariation",
		"body": [
			"forceVariation"
		],
		"description": "return:float des: The variation of the magnitude of the force to be applied."
	}
,
	"AreaEffector2D.useGlobalAngle": {
		"prefix": "AreaEffector2D.useGlobalAngle",
		"body": [
			"useGlobalAngle"
		],
		"description": "return:bool des: Should the forceAngle use global space?"
	}
,
	"AreaEffector2D.enabled": {
		"prefix": "AreaEffector2D.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"AreaEffector2D.isActiveAndEnabled": {
		"prefix": "AreaEffector2D.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"AreaEffector2D.gameObject": {
		"prefix": "AreaEffector2D.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"AreaEffector2D.tag": {
		"prefix": "AreaEffector2D.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"AreaEffector2D.transform": {
		"prefix": "AreaEffector2D.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"AreaEffector2D.colliderMask": {
		"prefix": "AreaEffector2D.colliderMask",
		"body": [
			"colliderMask"
		],
		"description": "return:int des: The mask used to select specific layers allowed to interact with the effector."
	}
,
	"AreaEffector2D.useColliderMask": {
		"prefix": "AreaEffector2D.useColliderMask",
		"body": [
			"useColliderMask"
		],
		"description": "return:bool des: Should the collider-mask be used or the global collision matrix?"
	}
,
	"AreaEffector2D.hideFlags": {
		"prefix": "AreaEffector2D.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"AreaEffector2D.name": {
		"prefix": "AreaEffector2D.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"AreaEffector2D.BroadcastMessage": {
		"prefix": "AreaEffector2D.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"AreaEffector2D.CompareTag": {
		"prefix": "AreaEffector2D.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"AreaEffector2D.GetComponent": {
		"prefix": "AreaEffector2D.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"AreaEffector2D.GetComponentInChildren": {
		"prefix": "AreaEffector2D.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"AreaEffector2D.GetComponentInParent": {
		"prefix": "AreaEffector2D.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"AreaEffector2D.GetComponents": {
		"prefix": "AreaEffector2D.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"AreaEffector2D.GetComponentsInChildren": {
		"prefix": "AreaEffector2D.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"AreaEffector2D.GetComponentsInParent": {
		"prefix": "AreaEffector2D.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"AreaEffector2D.SendMessage": {
		"prefix": "AreaEffector2D.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"AreaEffector2D.SendMessageUpwards": {
		"prefix": "AreaEffector2D.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"AreaEffector2D.GetInstanceID": {
		"prefix": "AreaEffector2D.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"AreaEffector2D.ToString": {
		"prefix": "AreaEffector2D.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"AreaEffector2D.Destroy": {
		"prefix": "AreaEffector2D.Destroy",
		"body": [
			"AreaEffector2D.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"AreaEffector2D.DestroyImmediate": {
		"prefix": "AreaEffector2D.DestroyImmediate",
		"body": [
			"AreaEffector2D.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"AreaEffector2D.DontDestroyOnLoad": {
		"prefix": "AreaEffector2D.DontDestroyOnLoad",
		"body": [
			"AreaEffector2D.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"AreaEffector2D.FindObjectOfType": {
		"prefix": "AreaEffector2D.FindObjectOfType",
		"body": [
			"AreaEffector2D.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"AreaEffector2D.FindObjectsOfType": {
		"prefix": "AreaEffector2D.FindObjectsOfType",
		"body": [
			"AreaEffector2D.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"AreaEffector2D.Instantiate": {
		"prefix": "AreaEffector2D.Instantiate",
		"body": [
			"AreaEffector2D.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"AssetBundle.isStreamedSceneAssetBundle": {
		"prefix": "AssetBundle.isStreamedSceneAssetBundle",
		"body": [
			"isStreamedSceneAssetBundle"
		],
		"description": "return:bool des: Return true if the AssetBundle is a streamed scene AssetBundle."
	}
,
	"AssetBundle.mainAsset": {
		"prefix": "AssetBundle.mainAsset",
		"body": [
			"mainAsset"
		],
		"description": "return:Object des: Main asset that was supplied when building the asset bundle (Read Only)."
	}
,
	"AssetBundle.Contains": {
		"prefix": "AssetBundle.Contains",
		"body": [
			"Contains($1)"
		],
		"description": "public bool Contains(string name); des: Check if an AssetBundle contains a specific object."
	}
,
	"AssetBundle.GetAllAssetNames": {
		"prefix": "AssetBundle.GetAllAssetNames",
		"body": [
			"GetAllAssetNames($1)"
		],
		"description": "public string[] GetAllAssetNames(); des: Return all asset names in the AssetBundle."
	}
,
	"AssetBundle.GetAllScenePaths": {
		"prefix": "AssetBundle.GetAllScenePaths",
		"body": [
			"GetAllScenePaths($1)"
		],
		"description": "public string[] GetAllScenePaths(); des: Return all the scene asset paths (paths to *.unity assets) in the AssetBundle."
	}
,
	"AssetBundle.LoadAllAssets": {
		"prefix": "AssetBundle.LoadAllAssets",
		"body": [
			"LoadAllAssets($1)"
		],
		"description": "public Object[] LoadAllAssets(Type type); public Object[] LoadAllAssets(); public T[] LoadAllAssets(); des: Loads all assets contained in the asset bundle that inherit from type."
	}
,
	"AssetBundle.LoadAllAssetsAsync": {
		"prefix": "AssetBundle.LoadAllAssetsAsync",
		"body": [
			"LoadAllAssetsAsync($1)"
		],
		"description": "public AssetBundleRequest LoadAllAssetsAsync(); public AssetBundleRequest LoadAllAssetsAsync(); public AssetBundleRequest LoadAllAssetsAsync(Type type); des: Loads all assets contained in the asset bundle asynchronously."
	}
,
	"AssetBundle.LoadAsset": {
		"prefix": "AssetBundle.LoadAsset",
		"body": [
			"LoadAsset($1)"
		],
		"description": "public Object LoadAsset(string name); public Object LoadAsset(string name, Type type); public T LoadAsset(string name); des: Loads asset with name from the bundle."
	}
,
	"AssetBundle.LoadAssetAsync": {
		"prefix": "AssetBundle.LoadAssetAsync",
		"body": [
			"LoadAssetAsync($1)"
		],
		"description": "public AssetBundleRequest LoadAssetAsync(string name); public AssetBundleRequest LoadAssetAsync(string name); public AssetBundleRequest LoadAssetAsync(string name, Type type); des: Asynchronously loads asset with name from the bundle."
	}
,
	"AssetBundle.LoadAssetWithSubAssets": {
		"prefix": "AssetBundle.LoadAssetWithSubAssets",
		"body": [
			"LoadAssetWithSubAssets($1)"
		],
		"description": "public Object[] LoadAssetWithSubAssets(string name); public Object[] LoadAssetWithSubAssets(string name, Type type); public T[] LoadAssetWithSubAssets(string name); des: Loads asset and sub assets with name from the bundle."
	}
,
	"AssetBundle.LoadAssetWithSubAssetsAsync": {
		"prefix": "AssetBundle.LoadAssetWithSubAssetsAsync",
		"body": [
			"LoadAssetWithSubAssetsAsync($1)"
		],
		"description": "public AssetBundleRequest LoadAssetWithSubAssetsAsync(string name); public AssetBundleRequest LoadAssetWithSubAssetsAsync(string name); public AssetBundleRequest LoadAssetWithSubAssetsAsync(string name, Type type); des: Loads asset with sub assets with name from the bundle asynchronously."
	}
,
	"AssetBundle.Unload": {
		"prefix": "AssetBundle.Unload",
		"body": [
			"Unload($1)"
		],
		"description": "public void Unload(bool unloadAllLoadedObjects); des: Unloads all assets in the bundle."
	}
,
	"AssetBundle.GetAllLoadedAssetBundles": {
		"prefix": "AssetBundle.GetAllLoadedAssetBundles",
		"body": [
			"AssetBundle.GetAllLoadedAssetBundles"
		],
		"description": "public static IEnumerable<AssetBundle> GetAllLoadedAssetBundles(); des: To use when you need to get a list of all the currently loaded Asset Bundles."
	}
,
	"AssetBundle.LoadFromFile": {
		"prefix": "AssetBundle.LoadFromFile",
		"body": [
			"AssetBundle.LoadFromFile"
		],
		"description": "public static AssetBundle LoadFromFile(string path, uint crc, ulong offset);  des: Synchronously loads an AssetBundle from a file on disk."
	}
,
	"AssetBundle.LoadFromFileAsync": {
		"prefix": "AssetBundle.LoadFromFileAsync",
		"body": [
			"AssetBundle.LoadFromFileAsync"
		],
		"description": "public static AssetBundleCreateRequest LoadFromFileAsync(string path, uint crc, ulong offset); des: Asynchronously loads an AssetBundle from a file on disk."
	}
,
	"AssetBundle.LoadFromMemory": {
		"prefix": "AssetBundle.LoadFromMemory",
		"body": [
			"AssetBundle.LoadFromMemory"
		],
		"description": "public static AssetBundle LoadFromMemory(byte[] binary, uint crc); des: Synchronously create an AssetBundle from a memory region."
	}
,
	"AssetBundle.LoadFromMemoryAsync": {
		"prefix": "AssetBundle.LoadFromMemoryAsync",
		"body": [
			"AssetBundle.LoadFromMemoryAsync"
		],
		"description": "public static AssetBundleCreateRequest LoadFromMemoryAsync(byte[] binary, uint crc); des: Asynchronously create an AssetBundle from a memory region."
	}
,
	"AssetBundle.LoadFromStream": {
		"prefix": "AssetBundle.LoadFromStream",
		"body": [
			"AssetBundle.LoadFromStream"
		],
		"description": "public static AssetBundle LoadFromStream(Stream stream, uint crc, uint managedReadBufferSize); des: Synchronously loads an AssetBundle from a managed Stream."
	}
,
	"AssetBundle.LoadFromStreamAsync": {
		"prefix": "AssetBundle.LoadFromStreamAsync",
		"body": [
			"AssetBundle.LoadFromStreamAsync"
		],
		"description": "public static AssetBundleCreateRequest LoadFromStreamAsync(Stream stream, uint crc, uint managedReadBufferSize); des: Asynchronously loads an AssetBundle from a managed Stream."
	}
,
	"AssetBundle.UnloadAllAssetBundles": {
		"prefix": "AssetBundle.UnloadAllAssetBundles",
		"body": [
			"AssetBundle.UnloadAllAssetBundles"
		],
		"description": "public static void UnloadAllAssetBundles(bool unloadAllObjects); des: Unloads all currently loaded Asset Bundles."
	}
,
	"AssetBundle.hideFlags": {
		"prefix": "AssetBundle.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"AssetBundle.name": {
		"prefix": "AssetBundle.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"AssetBundle.GetInstanceID": {
		"prefix": "AssetBundle.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"AssetBundle.ToString": {
		"prefix": "AssetBundle.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"AssetBundle.Destroy": {
		"prefix": "AssetBundle.Destroy",
		"body": [
			"AssetBundle.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"AssetBundle.DestroyImmediate": {
		"prefix": "AssetBundle.DestroyImmediate",
		"body": [
			"AssetBundle.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"AssetBundle.DontDestroyOnLoad": {
		"prefix": "AssetBundle.DontDestroyOnLoad",
		"body": [
			"AssetBundle.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"AssetBundle.FindObjectOfType": {
		"prefix": "AssetBundle.FindObjectOfType",
		"body": [
			"AssetBundle.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"AssetBundle.FindObjectsOfType": {
		"prefix": "AssetBundle.FindObjectsOfType",
		"body": [
			"AssetBundle.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"AssetBundle.Instantiate": {
		"prefix": "AssetBundle.Instantiate",
		"body": [
			"AssetBundle.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"AssetBundleCreateRequest.assetBundle": {
		"prefix": "AssetBundleCreateRequest.assetBundle",
		"body": [
			"assetBundle"
		],
		"description": "return:AssetBundle des: Asset object being loaded (Read Only)."
	}
,
	"AssetBundleCreateRequest.allowSceneActivation": {
		"prefix": "AssetBundleCreateRequest.allowSceneActivation",
		"body": [
			"allowSceneActivation"
		],
		"description": "return:bool des: Allow scenes to be activated as soon as it is ready."
	}
,
	"AssetBundleCreateRequest.isDone": {
		"prefix": "AssetBundleCreateRequest.isDone",
		"body": [
			"isDone"
		],
		"description": "return:bool des: Has the operation finished? (Read Only)"
	}
,
	"AssetBundleCreateRequest.priority": {
		"prefix": "AssetBundleCreateRequest.priority",
		"body": [
			"priority"
		],
		"description": "return:int des: Priority lets you tweak in which order async operation calls will be performed."
	}
,
	"AssetBundleCreateRequest.progress": {
		"prefix": "AssetBundleCreateRequest.progress",
		"body": [
			"progress"
		],
		"description": "return:float des: What's the operation's progress. (Read Only)"
	}
,
	"AssetBundleManifest.GetAllAssetBundles": {
		"prefix": "AssetBundleManifest.GetAllAssetBundles",
		"body": [
			"GetAllAssetBundles($1)"
		],
		"description": "public string[] GetAllAssetBundles(); des: Get all the AssetBundles in the manifest."
	}
,
	"AssetBundleManifest.GetAllAssetBundlesWithVariant": {
		"prefix": "AssetBundleManifest.GetAllAssetBundlesWithVariant",
		"body": [
			"GetAllAssetBundlesWithVariant($1)"
		],
		"description": "public string[] GetAllAssetBundlesWithVariant(); des: Get all the AssetBundles with variant in the manifest."
	}
,
	"AssetBundleManifest.GetAllDependencies": {
		"prefix": "AssetBundleManifest.GetAllDependencies",
		"body": [
			"GetAllDependencies($1)"
		],
		"description": "public string[] GetAllDependencies(string assetBundleName); des: Get all the dependent AssetBundles for the given AssetBundle."
	}
,
	"AssetBundleManifest.GetAssetBundleHash": {
		"prefix": "AssetBundleManifest.GetAssetBundleHash",
		"body": [
			"GetAssetBundleHash($1)"
		],
		"description": "public Hash128 GetAssetBundleHash(string assetBundleName); des: Get the hash for the given AssetBundle."
	}
,
	"AssetBundleManifest.GetDirectDependencies": {
		"prefix": "AssetBundleManifest.GetDirectDependencies",
		"body": [
			"GetDirectDependencies($1)"
		],
		"description": "public string[] GetDirectDependencies(string assetBundleName); des: Get the direct dependent AssetBundles for the given AssetBundle."
	}
,
	"AssetBundleManifest.hideFlags": {
		"prefix": "AssetBundleManifest.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"AssetBundleManifest.name": {
		"prefix": "AssetBundleManifest.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"AssetBundleManifest.GetInstanceID": {
		"prefix": "AssetBundleManifest.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"AssetBundleManifest.ToString": {
		"prefix": "AssetBundleManifest.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"AssetBundleManifest.Destroy": {
		"prefix": "AssetBundleManifest.Destroy",
		"body": [
			"AssetBundleManifest.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"AssetBundleManifest.DestroyImmediate": {
		"prefix": "AssetBundleManifest.DestroyImmediate",
		"body": [
			"AssetBundleManifest.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"AssetBundleManifest.DontDestroyOnLoad": {
		"prefix": "AssetBundleManifest.DontDestroyOnLoad",
		"body": [
			"AssetBundleManifest.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"AssetBundleManifest.FindObjectOfType": {
		"prefix": "AssetBundleManifest.FindObjectOfType",
		"body": [
			"AssetBundleManifest.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"AssetBundleManifest.FindObjectsOfType": {
		"prefix": "AssetBundleManifest.FindObjectsOfType",
		"body": [
			"AssetBundleManifest.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"AssetBundleManifest.Instantiate": {
		"prefix": "AssetBundleManifest.Instantiate",
		"body": [
			"AssetBundleManifest.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"AssetBundleRequest.allAssets": {
		"prefix": "AssetBundleRequest.allAssets",
		"body": [
			"allAssets"
		],
		"description": "return:Object[] des: Asset objects with sub assets being loaded. (Read Only)"
	}
,
	"AssetBundleRequest.asset": {
		"prefix": "AssetBundleRequest.asset",
		"body": [
			"asset"
		],
		"description": "return:Object des: Asset object being loaded (Read Only)."
	}
,
	"AssetBundleRequest.allowSceneActivation": {
		"prefix": "AssetBundleRequest.allowSceneActivation",
		"body": [
			"allowSceneActivation"
		],
		"description": "return:bool des: Allow scenes to be activated as soon as it is ready."
	}
,
	"AssetBundleRequest.isDone": {
		"prefix": "AssetBundleRequest.isDone",
		"body": [
			"isDone"
		],
		"description": "return:bool des: Has the operation finished? (Read Only)"
	}
,
	"AssetBundleRequest.priority": {
		"prefix": "AssetBundleRequest.priority",
		"body": [
			"priority"
		],
		"description": "return:int des: Priority lets you tweak in which order async operation calls will be performed."
	}
,
	"AssetBundleRequest.progress": {
		"prefix": "AssetBundleRequest.progress",
		"body": [
			"progress"
		],
		"description": "return:float des: What's the operation's progress. (Read Only)"
	}
,
	"AsyncOperation.allowSceneActivation": {
		"prefix": "AsyncOperation.allowSceneActivation",
		"body": [
			"allowSceneActivation"
		],
		"description": "return:bool des: Allow scenes to be activated as soon as it is ready."
	}
,
	"AsyncOperation.isDone": {
		"prefix": "AsyncOperation.isDone",
		"body": [
			"isDone"
		],
		"description": "return:bool des: Has the operation finished? (Read Only)"
	}
,
	"AsyncOperation.priority": {
		"prefix": "AsyncOperation.priority",
		"body": [
			"priority"
		],
		"description": "return:int des: Priority lets you tweak in which order async operation calls will be performed."
	}
,
	"AsyncOperation.progress": {
		"prefix": "AsyncOperation.progress",
		"body": [
			"progress"
		],
		"description": "return:float des: What's the operation's progress. (Read Only)"
	}
,
	"AudioChorusFilter.delay": {
		"prefix": "AudioChorusFilter.delay",
		"body": [
			"delay"
		],
		"description": "return:float des: Chorus delay in ms. 0.1 to 100.0. Default = 40.0 ms."
	}
,
	"AudioChorusFilter.depth": {
		"prefix": "AudioChorusFilter.depth",
		"body": [
			"depth"
		],
		"description": "return:float des: Chorus modulation depth. 0.0 to 1.0. Default = 0.03."
	}
,
	"AudioChorusFilter.dryMix": {
		"prefix": "AudioChorusFilter.dryMix",
		"body": [
			"dryMix"
		],
		"description": "return:float des: Volume of original signal to pass to output. 0.0 to 1.0. Default = 0.5."
	}
,
	"AudioChorusFilter.rate": {
		"prefix": "AudioChorusFilter.rate",
		"body": [
			"rate"
		],
		"description": "return:float des: Chorus modulation rate in hz. 0.0 to 20.0. Default = 0.8 hz."
	}
,
	"AudioChorusFilter.wetMix1": {
		"prefix": "AudioChorusFilter.wetMix1",
		"body": [
			"wetMix1"
		],
		"description": "return:float des: Volume of 1st chorus tap. 0.0 to 1.0. Default = 0.5."
	}
,
	"AudioChorusFilter.wetMix2": {
		"prefix": "AudioChorusFilter.wetMix2",
		"body": [
			"wetMix2"
		],
		"description": "return:float des: Volume of 2nd chorus tap. This tap is 90 degrees out of phase of the first tap. 0.0 to 1.0. Default = 0.5."
	}
,
	"AudioChorusFilter.wetMix3": {
		"prefix": "AudioChorusFilter.wetMix3",
		"body": [
			"wetMix3"
		],
		"description": "return:float des: Volume of 3rd chorus tap. This tap is 90 degrees out of phase of the second tap. 0.0 to 1.0. Default = 0.5."
	}
,
	"AudioChorusFilter.enabled": {
		"prefix": "AudioChorusFilter.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"AudioChorusFilter.isActiveAndEnabled": {
		"prefix": "AudioChorusFilter.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"AudioChorusFilter.gameObject": {
		"prefix": "AudioChorusFilter.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"AudioChorusFilter.tag": {
		"prefix": "AudioChorusFilter.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"AudioChorusFilter.transform": {
		"prefix": "AudioChorusFilter.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"AudioChorusFilter.hideFlags": {
		"prefix": "AudioChorusFilter.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"AudioChorusFilter.name": {
		"prefix": "AudioChorusFilter.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"AudioChorusFilter.BroadcastMessage": {
		"prefix": "AudioChorusFilter.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"AudioChorusFilter.CompareTag": {
		"prefix": "AudioChorusFilter.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"AudioChorusFilter.GetComponent": {
		"prefix": "AudioChorusFilter.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"AudioChorusFilter.GetComponentInChildren": {
		"prefix": "AudioChorusFilter.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"AudioChorusFilter.GetComponentInParent": {
		"prefix": "AudioChorusFilter.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"AudioChorusFilter.GetComponents": {
		"prefix": "AudioChorusFilter.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"AudioChorusFilter.GetComponentsInChildren": {
		"prefix": "AudioChorusFilter.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"AudioChorusFilter.GetComponentsInParent": {
		"prefix": "AudioChorusFilter.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"AudioChorusFilter.SendMessage": {
		"prefix": "AudioChorusFilter.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"AudioChorusFilter.SendMessageUpwards": {
		"prefix": "AudioChorusFilter.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"AudioChorusFilter.GetInstanceID": {
		"prefix": "AudioChorusFilter.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"AudioChorusFilter.ToString": {
		"prefix": "AudioChorusFilter.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"AudioChorusFilter.Destroy": {
		"prefix": "AudioChorusFilter.Destroy",
		"body": [
			"AudioChorusFilter.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"AudioChorusFilter.DestroyImmediate": {
		"prefix": "AudioChorusFilter.DestroyImmediate",
		"body": [
			"AudioChorusFilter.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"AudioChorusFilter.DontDestroyOnLoad": {
		"prefix": "AudioChorusFilter.DontDestroyOnLoad",
		"body": [
			"AudioChorusFilter.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"AudioChorusFilter.FindObjectOfType": {
		"prefix": "AudioChorusFilter.FindObjectOfType",
		"body": [
			"AudioChorusFilter.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"AudioChorusFilter.FindObjectsOfType": {
		"prefix": "AudioChorusFilter.FindObjectsOfType",
		"body": [
			"AudioChorusFilter.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"AudioChorusFilter.Instantiate": {
		"prefix": "AudioChorusFilter.Instantiate",
		"body": [
			"AudioChorusFilter.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"AudioClip.ambisonic": {
		"prefix": "AudioClip.ambisonic",
		"body": [
			"ambisonic"
		],
		"description": "return:bool des: Returns true if this audio clip is ambisonic (read-only)."
	}
,
	"AudioClip.channels": {
		"prefix": "AudioClip.channels",
		"body": [
			"channels"
		],
		"description": "return:int des: The number of channels in the audio clip. (Read Only)"
	}
,
	"AudioClip.frequency": {
		"prefix": "AudioClip.frequency",
		"body": [
			"frequency"
		],
		"description": "return:int des: The sample frequency of the clip in Hertz. (Read Only)"
	}
,
	"AudioClip.length": {
		"prefix": "AudioClip.length",
		"body": [
			"length"
		],
		"description": "return:float des: The length of the audio clip in seconds. (Read Only)"
	}
,
	"AudioClip.loadInBackground": {
		"prefix": "AudioClip.loadInBackground",
		"body": [
			"loadInBackground"
		],
		"description": "return:bool des: Corresponding to the \"Load In Background\" flag in the inspector, when this flag is set, the loading will happen delayed without blocking the main thread."
	}
,
	"AudioClip.loadState": {
		"prefix": "AudioClip.loadState",
		"body": [
			"loadState"
		],
		"description": "return:AudioDataLoadState des: Returns the current load state of the audio data associated with an AudioClip."
	}
,
	"AudioClip.loadType": {
		"prefix": "AudioClip.loadType",
		"body": [
			"loadType"
		],
		"description": "return:AudioClipLoadType des: The load type of the clip (read-only)."
	}
,
	"AudioClip.preloadAudioData": {
		"prefix": "AudioClip.preloadAudioData",
		"body": [
			"preloadAudioData"
		],
		"description": "return:bool des: Preloads audio data of the clip when the clip asset is loaded. When this flag is off, scripts have to call AudioClip.LoadAudioData() to load the data before the clip can be played. Properties like length, channels and format are available before the audio data has been loaded."
	}
,
	"AudioClip.samples": {
		"prefix": "AudioClip.samples",
		"body": [
			"samples"
		],
		"description": "return:int des: The length of the audio clip in samples. (Read Only)"
	}
,
	"AudioClip.GetData": {
		"prefix": "AudioClip.GetData",
		"body": [
			"GetData($1)"
		],
		"description": "public bool GetData(float[] data, int offsetSamples); des: Fills an array with sample data from the clip."
	}
,
	"AudioClip.LoadAudioData": {
		"prefix": "AudioClip.LoadAudioData",
		"body": [
			"LoadAudioData($1)"
		],
		"description": "public bool LoadAudioData(); des: Loads the audio data of a clip. Clips that have \"Preload Audio Data\" set will load the audio data automatically."
	}
,
	"AudioClip.SetData": {
		"prefix": "AudioClip.SetData",
		"body": [
			"SetData($1)"
		],
		"description": "public bool SetData(float[] data, int offsetSamples); des: Set sample data in a clip."
	}
,
	"AudioClip.UnloadAudioData": {
		"prefix": "AudioClip.UnloadAudioData",
		"body": [
			"UnloadAudioData($1)"
		],
		"description": "public bool UnloadAudioData(); des: Unloads the audio data associated with the clip. This works only for AudioClips that are based on actual sound file assets."
	}
,
	"AudioClip.Create": {
		"prefix": "AudioClip.Create",
		"body": [
			"AudioClip.Create"
		],
		"description": "public static AudioClip Create(string name, int lengthSamples, int channels, int frequency, bool stream); public static AudioClip Create(string name, int lengthSamples, int channels, int frequency, bool stream, AudioClip.PCMReaderCallback pcmreadercallback); public static AudioClip Create(string name, int lengthSamples, int channels, int frequency, bool stream, AudioClip.PCMReaderCallback pcmreadercallback, AudioClip.PCMSetPositionCallback pcmsetpositioncallback); Obsolete public static AudioClip Create(string name, int lengthSamples, int channels, int frequency, bool _3D, bool stream); Obsolete public static AudioClip Create(string name, int lengthSamples, int channels, int frequency, bool _3D, bool stream, AudioClip.PCMReaderCallback pcmreadercallback); Obsolete public static AudioClip Create(string name, int lengthSamples, int channels, int frequency, bool _3D, bool stream, AudioClip.PCMReaderCallback pcmreadercallback, AudioClip.PCMSetPositionCallback pcmsetpositioncallback); des: Creates a user AudioClip with a name and with the given length in samples, channels and frequency."
	}
,
	"AudioClip.hideFlags": {
		"prefix": "AudioClip.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"AudioClip.name": {
		"prefix": "AudioClip.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"AudioClip.GetInstanceID": {
		"prefix": "AudioClip.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"AudioClip.ToString": {
		"prefix": "AudioClip.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"AudioClip.Destroy": {
		"prefix": "AudioClip.Destroy",
		"body": [
			"AudioClip.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"AudioClip.DestroyImmediate": {
		"prefix": "AudioClip.DestroyImmediate",
		"body": [
			"AudioClip.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"AudioClip.DontDestroyOnLoad": {
		"prefix": "AudioClip.DontDestroyOnLoad",
		"body": [
			"AudioClip.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"AudioClip.FindObjectOfType": {
		"prefix": "AudioClip.FindObjectOfType",
		"body": [
			"AudioClip.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"AudioClip.FindObjectsOfType": {
		"prefix": "AudioClip.FindObjectsOfType",
		"body": [
			"AudioClip.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"AudioClip.Instantiate": {
		"prefix": "AudioClip.Instantiate",
		"body": [
			"AudioClip.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"AudioConfiguration.dspBufferSize": {
		"prefix": "AudioConfiguration.dspBufferSize",
		"body": [
			"dspBufferSize"
		],
		"description": "return:int des: The length of the DSP buffer in samples determining the latency of sounds by the audio output device."
	}
,
	"AudioConfiguration.numRealVoices": {
		"prefix": "AudioConfiguration.numRealVoices",
		"body": [
			"numRealVoices"
		],
		"description": "return:int des: The current maximum number of simultaneously audible sounds in the game."
	}
,
	"AudioConfiguration.numVirtualVoices": {
		"prefix": "AudioConfiguration.numVirtualVoices",
		"body": [
			"numVirtualVoices"
		],
		"description": "return:int des: The maximum number of managed sounds in the game. Beyond this limit sounds will simply stop playing."
	}
,
	"AudioConfiguration.sampleRate": {
		"prefix": "AudioConfiguration.sampleRate",
		"body": [
			"sampleRate"
		],
		"description": "return:int des: The current sample rate of the audio output device used."
	}
,
	"AudioConfiguration.speakerMode": {
		"prefix": "AudioConfiguration.speakerMode",
		"body": [
			"speakerMode"
		],
		"description": "return:AudioSpeakerMode des: The current speaker mode used by the audio output device."
	}
,
	"AudioDistortionFilter.distortionLevel": {
		"prefix": "AudioDistortionFilter.distortionLevel",
		"body": [
			"distortionLevel"
		],
		"description": "return:float des: Distortion value. 0.0 to 1.0. Default = 0.5."
	}
,
	"AudioDistortionFilter.enabled": {
		"prefix": "AudioDistortionFilter.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"AudioDistortionFilter.isActiveAndEnabled": {
		"prefix": "AudioDistortionFilter.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"AudioDistortionFilter.gameObject": {
		"prefix": "AudioDistortionFilter.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"AudioDistortionFilter.tag": {
		"prefix": "AudioDistortionFilter.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"AudioDistortionFilter.transform": {
		"prefix": "AudioDistortionFilter.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"AudioDistortionFilter.hideFlags": {
		"prefix": "AudioDistortionFilter.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"AudioDistortionFilter.name": {
		"prefix": "AudioDistortionFilter.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"AudioDistortionFilter.BroadcastMessage": {
		"prefix": "AudioDistortionFilter.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"AudioDistortionFilter.CompareTag": {
		"prefix": "AudioDistortionFilter.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"AudioDistortionFilter.GetComponent": {
		"prefix": "AudioDistortionFilter.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"AudioDistortionFilter.GetComponentInChildren": {
		"prefix": "AudioDistortionFilter.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"AudioDistortionFilter.GetComponentInParent": {
		"prefix": "AudioDistortionFilter.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"AudioDistortionFilter.GetComponents": {
		"prefix": "AudioDistortionFilter.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"AudioDistortionFilter.GetComponentsInChildren": {
		"prefix": "AudioDistortionFilter.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"AudioDistortionFilter.GetComponentsInParent": {
		"prefix": "AudioDistortionFilter.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"AudioDistortionFilter.SendMessage": {
		"prefix": "AudioDistortionFilter.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"AudioDistortionFilter.SendMessageUpwards": {
		"prefix": "AudioDistortionFilter.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"AudioDistortionFilter.GetInstanceID": {
		"prefix": "AudioDistortionFilter.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"AudioDistortionFilter.ToString": {
		"prefix": "AudioDistortionFilter.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"AudioDistortionFilter.Destroy": {
		"prefix": "AudioDistortionFilter.Destroy",
		"body": [
			"AudioDistortionFilter.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"AudioDistortionFilter.DestroyImmediate": {
		"prefix": "AudioDistortionFilter.DestroyImmediate",
		"body": [
			"AudioDistortionFilter.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"AudioDistortionFilter.DontDestroyOnLoad": {
		"prefix": "AudioDistortionFilter.DontDestroyOnLoad",
		"body": [
			"AudioDistortionFilter.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"AudioDistortionFilter.FindObjectOfType": {
		"prefix": "AudioDistortionFilter.FindObjectOfType",
		"body": [
			"AudioDistortionFilter.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"AudioDistortionFilter.FindObjectsOfType": {
		"prefix": "AudioDistortionFilter.FindObjectsOfType",
		"body": [
			"AudioDistortionFilter.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"AudioDistortionFilter.Instantiate": {
		"prefix": "AudioDistortionFilter.Instantiate",
		"body": [
			"AudioDistortionFilter.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"AudioEchoFilter.decayRatio": {
		"prefix": "AudioEchoFilter.decayRatio",
		"body": [
			"decayRatio"
		],
		"description": "return:float des: Echo decay per delay. 0 to 1. 1.0 = No decay, 0.0 = total decay (i.e. simple 1 line delay). Default = 0.5."
	}
,
	"AudioEchoFilter.delay": {
		"prefix": "AudioEchoFilter.delay",
		"body": [
			"delay"
		],
		"description": "return:float des: Echo delay in ms. 10 to 5000. Default = 500."
	}
,
	"AudioEchoFilter.dryMix": {
		"prefix": "AudioEchoFilter.dryMix",
		"body": [
			"dryMix"
		],
		"description": "return:float des: Volume of original signal to pass to output. 0.0 to 1.0. Default = 1.0."
	}
,
	"AudioEchoFilter.wetMix": {
		"prefix": "AudioEchoFilter.wetMix",
		"body": [
			"wetMix"
		],
		"description": "return:float des: Volume of echo signal to pass to output. 0.0 to 1.0. Default = 1.0."
	}
,
	"AudioEchoFilter.enabled": {
		"prefix": "AudioEchoFilter.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"AudioEchoFilter.isActiveAndEnabled": {
		"prefix": "AudioEchoFilter.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"AudioEchoFilter.gameObject": {
		"prefix": "AudioEchoFilter.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"AudioEchoFilter.tag": {
		"prefix": "AudioEchoFilter.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"AudioEchoFilter.transform": {
		"prefix": "AudioEchoFilter.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"AudioEchoFilter.hideFlags": {
		"prefix": "AudioEchoFilter.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"AudioEchoFilter.name": {
		"prefix": "AudioEchoFilter.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"AudioEchoFilter.BroadcastMessage": {
		"prefix": "AudioEchoFilter.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"AudioEchoFilter.CompareTag": {
		"prefix": "AudioEchoFilter.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"AudioEchoFilter.GetComponent": {
		"prefix": "AudioEchoFilter.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"AudioEchoFilter.GetComponentInChildren": {
		"prefix": "AudioEchoFilter.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"AudioEchoFilter.GetComponentInParent": {
		"prefix": "AudioEchoFilter.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"AudioEchoFilter.GetComponents": {
		"prefix": "AudioEchoFilter.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"AudioEchoFilter.GetComponentsInChildren": {
		"prefix": "AudioEchoFilter.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"AudioEchoFilter.GetComponentsInParent": {
		"prefix": "AudioEchoFilter.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"AudioEchoFilter.SendMessage": {
		"prefix": "AudioEchoFilter.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"AudioEchoFilter.SendMessageUpwards": {
		"prefix": "AudioEchoFilter.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"AudioEchoFilter.GetInstanceID": {
		"prefix": "AudioEchoFilter.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"AudioEchoFilter.ToString": {
		"prefix": "AudioEchoFilter.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"AudioEchoFilter.Destroy": {
		"prefix": "AudioEchoFilter.Destroy",
		"body": [
			"AudioEchoFilter.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"AudioEchoFilter.DestroyImmediate": {
		"prefix": "AudioEchoFilter.DestroyImmediate",
		"body": [
			"AudioEchoFilter.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"AudioEchoFilter.DontDestroyOnLoad": {
		"prefix": "AudioEchoFilter.DontDestroyOnLoad",
		"body": [
			"AudioEchoFilter.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"AudioEchoFilter.FindObjectOfType": {
		"prefix": "AudioEchoFilter.FindObjectOfType",
		"body": [
			"AudioEchoFilter.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"AudioEchoFilter.FindObjectsOfType": {
		"prefix": "AudioEchoFilter.FindObjectsOfType",
		"body": [
			"AudioEchoFilter.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"AudioEchoFilter.Instantiate": {
		"prefix": "AudioEchoFilter.Instantiate",
		"body": [
			"AudioEchoFilter.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"AudioHighPassFilter.cutoffFrequency": {
		"prefix": "AudioHighPassFilter.cutoffFrequency",
		"body": [
			"cutoffFrequency"
		],
		"description": "return:float des: Highpass cutoff frequency in hz. 10.0 to 22000.0. Default = 5000.0."
	}
,
	"AudioHighPassFilter.highpassResonanceQ": {
		"prefix": "AudioHighPassFilter.highpassResonanceQ",
		"body": [
			"highpassResonanceQ"
		],
		"description": "return:float des: Determines how much the filter's self-resonance isdampened."
	}
,
	"AudioHighPassFilter.enabled": {
		"prefix": "AudioHighPassFilter.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"AudioHighPassFilter.isActiveAndEnabled": {
		"prefix": "AudioHighPassFilter.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"AudioHighPassFilter.gameObject": {
		"prefix": "AudioHighPassFilter.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"AudioHighPassFilter.tag": {
		"prefix": "AudioHighPassFilter.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"AudioHighPassFilter.transform": {
		"prefix": "AudioHighPassFilter.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"AudioHighPassFilter.hideFlags": {
		"prefix": "AudioHighPassFilter.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"AudioHighPassFilter.name": {
		"prefix": "AudioHighPassFilter.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"AudioHighPassFilter.BroadcastMessage": {
		"prefix": "AudioHighPassFilter.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"AudioHighPassFilter.CompareTag": {
		"prefix": "AudioHighPassFilter.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"AudioHighPassFilter.GetComponent": {
		"prefix": "AudioHighPassFilter.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"AudioHighPassFilter.GetComponentInChildren": {
		"prefix": "AudioHighPassFilter.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"AudioHighPassFilter.GetComponentInParent": {
		"prefix": "AudioHighPassFilter.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"AudioHighPassFilter.GetComponents": {
		"prefix": "AudioHighPassFilter.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"AudioHighPassFilter.GetComponentsInChildren": {
		"prefix": "AudioHighPassFilter.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"AudioHighPassFilter.GetComponentsInParent": {
		"prefix": "AudioHighPassFilter.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"AudioHighPassFilter.SendMessage": {
		"prefix": "AudioHighPassFilter.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"AudioHighPassFilter.SendMessageUpwards": {
		"prefix": "AudioHighPassFilter.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"AudioHighPassFilter.GetInstanceID": {
		"prefix": "AudioHighPassFilter.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"AudioHighPassFilter.ToString": {
		"prefix": "AudioHighPassFilter.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"AudioHighPassFilter.Destroy": {
		"prefix": "AudioHighPassFilter.Destroy",
		"body": [
			"AudioHighPassFilter.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"AudioHighPassFilter.DestroyImmediate": {
		"prefix": "AudioHighPassFilter.DestroyImmediate",
		"body": [
			"AudioHighPassFilter.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"AudioHighPassFilter.DontDestroyOnLoad": {
		"prefix": "AudioHighPassFilter.DontDestroyOnLoad",
		"body": [
			"AudioHighPassFilter.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"AudioHighPassFilter.FindObjectOfType": {
		"prefix": "AudioHighPassFilter.FindObjectOfType",
		"body": [
			"AudioHighPassFilter.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"AudioHighPassFilter.FindObjectsOfType": {
		"prefix": "AudioHighPassFilter.FindObjectsOfType",
		"body": [
			"AudioHighPassFilter.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"AudioHighPassFilter.Instantiate": {
		"prefix": "AudioHighPassFilter.Instantiate",
		"body": [
			"AudioHighPassFilter.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"AudioListener.velocityUpdateMode": {
		"prefix": "AudioListener.velocityUpdateMode",
		"body": [
			"velocityUpdateMode"
		],
		"description": "return:AudioVelocityUpdateMode des: This lets you set whether the Audio Listener should be updated in the fixed or dynamic update."
	}
,
	"AudioListener.GetOutputData": {
		"prefix": "AudioListener.GetOutputData",
		"body": [
			"AudioListener.GetOutputData"
		],
		"description": "public static void GetOutputData(float[] samples, int channel); Obsolete public static float[] GetOutputData(int numSamples, int channel); des: Provides a block of the listener (master)'s output data."
	}
,
	"AudioListener.GetSpectrumData": {
		"prefix": "AudioListener.GetSpectrumData",
		"body": [
			"AudioListener.GetSpectrumData"
		],
		"description": "public static void GetSpectrumData(float[] samples, int channel, FFTWindow window); Obsolete public static float[] GetSpectrumData(int numSamples, int channel, FFTWindow window); des: Provides a block of the listener (master)'s spectrum data."
	}
,
	"AudioListener.enabled": {
		"prefix": "AudioListener.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"AudioListener.isActiveAndEnabled": {
		"prefix": "AudioListener.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"AudioListener.gameObject": {
		"prefix": "AudioListener.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"AudioListener.tag": {
		"prefix": "AudioListener.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"AudioListener.transform": {
		"prefix": "AudioListener.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"AudioListener.hideFlags": {
		"prefix": "AudioListener.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"AudioListener.name": {
		"prefix": "AudioListener.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"AudioListener.BroadcastMessage": {
		"prefix": "AudioListener.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"AudioListener.CompareTag": {
		"prefix": "AudioListener.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"AudioListener.GetComponent": {
		"prefix": "AudioListener.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"AudioListener.GetComponentInChildren": {
		"prefix": "AudioListener.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"AudioListener.GetComponentInParent": {
		"prefix": "AudioListener.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"AudioListener.GetComponents": {
		"prefix": "AudioListener.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"AudioListener.GetComponentsInChildren": {
		"prefix": "AudioListener.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"AudioListener.GetComponentsInParent": {
		"prefix": "AudioListener.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"AudioListener.SendMessage": {
		"prefix": "AudioListener.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"AudioListener.SendMessageUpwards": {
		"prefix": "AudioListener.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"AudioListener.GetInstanceID": {
		"prefix": "AudioListener.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"AudioListener.ToString": {
		"prefix": "AudioListener.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"AudioListener.Destroy": {
		"prefix": "AudioListener.Destroy",
		"body": [
			"AudioListener.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"AudioListener.DestroyImmediate": {
		"prefix": "AudioListener.DestroyImmediate",
		"body": [
			"AudioListener.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"AudioListener.DontDestroyOnLoad": {
		"prefix": "AudioListener.DontDestroyOnLoad",
		"body": [
			"AudioListener.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"AudioListener.FindObjectOfType": {
		"prefix": "AudioListener.FindObjectOfType",
		"body": [
			"AudioListener.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"AudioListener.FindObjectsOfType": {
		"prefix": "AudioListener.FindObjectsOfType",
		"body": [
			"AudioListener.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"AudioListener.Instantiate": {
		"prefix": "AudioListener.Instantiate",
		"body": [
			"AudioListener.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"AudioLowPassFilter.customCutoffCurve": {
		"prefix": "AudioLowPassFilter.customCutoffCurve",
		"body": [
			"customCutoffCurve"
		],
		"description": "return:AnimationCurve des: Returns or sets the current custom frequency cutoff curve."
	}
,
	"AudioLowPassFilter.cutoffFrequency": {
		"prefix": "AudioLowPassFilter.cutoffFrequency",
		"body": [
			"cutoffFrequency"
		],
		"description": "return:float des: Lowpass cutoff frequency in hz. 10.0 to 22000.0. Default = 5000.0."
	}
,
	"AudioLowPassFilter.lowpassResonanceQ": {
		"prefix": "AudioLowPassFilter.lowpassResonanceQ",
		"body": [
			"lowpassResonanceQ"
		],
		"description": "return:float des: Determines how much the filter's self-resonance is dampened."
	}
,
	"AudioLowPassFilter.enabled": {
		"prefix": "AudioLowPassFilter.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"AudioLowPassFilter.isActiveAndEnabled": {
		"prefix": "AudioLowPassFilter.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"AudioLowPassFilter.gameObject": {
		"prefix": "AudioLowPassFilter.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"AudioLowPassFilter.tag": {
		"prefix": "AudioLowPassFilter.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"AudioLowPassFilter.transform": {
		"prefix": "AudioLowPassFilter.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"AudioLowPassFilter.hideFlags": {
		"prefix": "AudioLowPassFilter.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"AudioLowPassFilter.name": {
		"prefix": "AudioLowPassFilter.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"AudioLowPassFilter.BroadcastMessage": {
		"prefix": "AudioLowPassFilter.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"AudioLowPassFilter.CompareTag": {
		"prefix": "AudioLowPassFilter.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"AudioLowPassFilter.GetComponent": {
		"prefix": "AudioLowPassFilter.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"AudioLowPassFilter.GetComponentInChildren": {
		"prefix": "AudioLowPassFilter.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"AudioLowPassFilter.GetComponentInParent": {
		"prefix": "AudioLowPassFilter.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"AudioLowPassFilter.GetComponents": {
		"prefix": "AudioLowPassFilter.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"AudioLowPassFilter.GetComponentsInChildren": {
		"prefix": "AudioLowPassFilter.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"AudioLowPassFilter.GetComponentsInParent": {
		"prefix": "AudioLowPassFilter.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"AudioLowPassFilter.SendMessage": {
		"prefix": "AudioLowPassFilter.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"AudioLowPassFilter.SendMessageUpwards": {
		"prefix": "AudioLowPassFilter.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"AudioLowPassFilter.GetInstanceID": {
		"prefix": "AudioLowPassFilter.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"AudioLowPassFilter.ToString": {
		"prefix": "AudioLowPassFilter.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"AudioLowPassFilter.Destroy": {
		"prefix": "AudioLowPassFilter.Destroy",
		"body": [
			"AudioLowPassFilter.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"AudioLowPassFilter.DestroyImmediate": {
		"prefix": "AudioLowPassFilter.DestroyImmediate",
		"body": [
			"AudioLowPassFilter.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"AudioLowPassFilter.DontDestroyOnLoad": {
		"prefix": "AudioLowPassFilter.DontDestroyOnLoad",
		"body": [
			"AudioLowPassFilter.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"AudioLowPassFilter.FindObjectOfType": {
		"prefix": "AudioLowPassFilter.FindObjectOfType",
		"body": [
			"AudioLowPassFilter.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"AudioLowPassFilter.FindObjectsOfType": {
		"prefix": "AudioLowPassFilter.FindObjectsOfType",
		"body": [
			"AudioLowPassFilter.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"AudioLowPassFilter.Instantiate": {
		"prefix": "AudioLowPassFilter.Instantiate",
		"body": [
			"AudioLowPassFilter.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"AudioRenderer.GetSampleCountForCaptureFrame": {
		"prefix": "AudioRenderer.GetSampleCountForCaptureFrame",
		"body": [
			"AudioRenderer.GetSampleCountForCaptureFrame"
		],
		"description": "public static int GetSampleCountForCaptureFrame(); des: Returns the number of samples available since the last time AudioRenderer.Render was called. This is dependent on the frame capture rate."
	}
,
	"AudioRenderer.Render": {
		"prefix": "AudioRenderer.Render",
		"body": [
			"AudioRenderer.Render"
		],
		"description": "public static bool Render(NativeArray<float> buffer); des: Performs the recording of the main output as well as any optional mixer groups that have been registered via AudioRenderer.AddMixerGroupSink."
	}
,
	"AudioRenderer.Start": {
		"prefix": "AudioRenderer.Start",
		"body": [
			"AudioRenderer.Start"
		],
		"description": "public static bool Start(); des: Enters audio recording mode. After this Unity will output silence until AudioRenderer.Stop is called."
	}
,
	"AudioRenderer.Stop": {
		"prefix": "AudioRenderer.Stop",
		"body": [
			"AudioRenderer.Stop"
		],
		"description": "public static bool Stop(); des: Exits audio recording mode. After this audio output will be audible again."
	}
,
	"AudioReverbFilter.decayHFRatio": {
		"prefix": "AudioReverbFilter.decayHFRatio",
		"body": [
			"decayHFRatio"
		],
		"description": "return:float des: Decay HF Ratio : High-frequency to low-frequency decay time ratio. Ranges from 0.1 to 2.0. Default is 0.5."
	}
,
	"AudioReverbFilter.decayTime": {
		"prefix": "AudioReverbFilter.decayTime",
		"body": [
			"decayTime"
		],
		"description": "return:float des: Reverberation decay time at low-frequencies in seconds. Ranges from 0.1 to 20.0. Default is 1.0."
	}
,
	"AudioReverbFilter.density": {
		"prefix": "AudioReverbFilter.density",
		"body": [
			"density"
		],
		"description": "return:float des: Reverberation density (modal density) in percent. Ranges from 0.0 to 100.0. Default is 100.0."
	}
,
	"AudioReverbFilter.diffusion": {
		"prefix": "AudioReverbFilter.diffusion",
		"body": [
			"diffusion"
		],
		"description": "return:float des: Reverberation diffusion (echo density) in percent. Ranges from 0.0 to 100.0. Default is 100.0."
	}
,
	"AudioReverbFilter.dryLevel": {
		"prefix": "AudioReverbFilter.dryLevel",
		"body": [
			"dryLevel"
		],
		"description": "return:float des: Mix level of dry signal in output in mB. Ranges from -10000.0 to 0.0. Default is 0."
	}
,
	"AudioReverbFilter.hfReference": {
		"prefix": "AudioReverbFilter.hfReference",
		"body": [
			"hfReference"
		],
		"description": "return:float des: Reference high frequency in Hz. Ranges from 1000.0 to 20000.0. Default is 5000.0."
	}
,
	"AudioReverbFilter.lfReference": {
		"prefix": "AudioReverbFilter.lfReference",
		"body": [
			"lfReference"
		],
		"description": "return:float des: Reference low-frequency in Hz. Ranges from 20.0 to 1000.0. Default is 250.0."
	}
,
	"AudioReverbFilter.reflectionsDelay": {
		"prefix": "AudioReverbFilter.reflectionsDelay",
		"body": [
			"reflectionsDelay"
		],
		"description": "return:float des: Late reverberation level relative to room effect in mB. Ranges from -10000.0 to 2000.0. Default is 0.0."
	}
,
	"AudioReverbFilter.reflectionsLevel": {
		"prefix": "AudioReverbFilter.reflectionsLevel",
		"body": [
			"reflectionsLevel"
		],
		"description": "return:float des: Early reflections level relative to room effect in mB. Ranges from -10000.0 to 1000.0. Default is -10000.0."
	}
,
	"AudioReverbFilter.reverbDelay": {
		"prefix": "AudioReverbFilter.reverbDelay",
		"body": [
			"reverbDelay"
		],
		"description": "return:float des: Late reverberation delay time relative to first reflection in seconds. Ranges from 0.0 to 0.1. Default is 0.04."
	}
,
	"AudioReverbFilter.reverbLevel": {
		"prefix": "AudioReverbFilter.reverbLevel",
		"body": [
			"reverbLevel"
		],
		"description": "return:float des: Late reverberation level relative to room effect in mB. Ranges from -10000.0 to 2000.0. Default is 0.0."
	}
,
	"AudioReverbFilter.reverbPreset": {
		"prefix": "AudioReverbFilter.reverbPreset",
		"body": [
			"reverbPreset"
		],
		"description": "return:AudioReverbPreset des: Set/Get reverb preset properties."
	}
,
	"AudioReverbFilter.room": {
		"prefix": "AudioReverbFilter.room",
		"body": [
			"room"
		],
		"description": "return:float des: Room effect level at low frequencies in mB. Ranges from -10000.0 to 0.0. Default is 0.0."
	}
,
	"AudioReverbFilter.roomHF": {
		"prefix": "AudioReverbFilter.roomHF",
		"body": [
			"roomHF"
		],
		"description": "return:float des: Room effect high-frequency level re. low frequency level in mB. Ranges from -10000.0 to 0.0. Default is 0.0."
	}
,
	"AudioReverbFilter.roomLF": {
		"prefix": "AudioReverbFilter.roomLF",
		"body": [
			"roomLF"
		],
		"description": "return:float des: Room effect low-frequency level in mB. Ranges from -10000.0 to 0.0. Default is 0.0."
	}
,
	"AudioReverbFilter.enabled": {
		"prefix": "AudioReverbFilter.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"AudioReverbFilter.isActiveAndEnabled": {
		"prefix": "AudioReverbFilter.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"AudioReverbFilter.gameObject": {
		"prefix": "AudioReverbFilter.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"AudioReverbFilter.tag": {
		"prefix": "AudioReverbFilter.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"AudioReverbFilter.transform": {
		"prefix": "AudioReverbFilter.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"AudioReverbFilter.hideFlags": {
		"prefix": "AudioReverbFilter.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"AudioReverbFilter.name": {
		"prefix": "AudioReverbFilter.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"AudioReverbFilter.BroadcastMessage": {
		"prefix": "AudioReverbFilter.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"AudioReverbFilter.CompareTag": {
		"prefix": "AudioReverbFilter.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"AudioReverbFilter.GetComponent": {
		"prefix": "AudioReverbFilter.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"AudioReverbFilter.GetComponentInChildren": {
		"prefix": "AudioReverbFilter.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"AudioReverbFilter.GetComponentInParent": {
		"prefix": "AudioReverbFilter.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"AudioReverbFilter.GetComponents": {
		"prefix": "AudioReverbFilter.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"AudioReverbFilter.GetComponentsInChildren": {
		"prefix": "AudioReverbFilter.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"AudioReverbFilter.GetComponentsInParent": {
		"prefix": "AudioReverbFilter.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"AudioReverbFilter.SendMessage": {
		"prefix": "AudioReverbFilter.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"AudioReverbFilter.SendMessageUpwards": {
		"prefix": "AudioReverbFilter.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"AudioReverbFilter.GetInstanceID": {
		"prefix": "AudioReverbFilter.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"AudioReverbFilter.ToString": {
		"prefix": "AudioReverbFilter.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"AudioReverbFilter.Destroy": {
		"prefix": "AudioReverbFilter.Destroy",
		"body": [
			"AudioReverbFilter.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"AudioReverbFilter.DestroyImmediate": {
		"prefix": "AudioReverbFilter.DestroyImmediate",
		"body": [
			"AudioReverbFilter.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"AudioReverbFilter.DontDestroyOnLoad": {
		"prefix": "AudioReverbFilter.DontDestroyOnLoad",
		"body": [
			"AudioReverbFilter.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"AudioReverbFilter.FindObjectOfType": {
		"prefix": "AudioReverbFilter.FindObjectOfType",
		"body": [
			"AudioReverbFilter.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"AudioReverbFilter.FindObjectsOfType": {
		"prefix": "AudioReverbFilter.FindObjectsOfType",
		"body": [
			"AudioReverbFilter.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"AudioReverbFilter.Instantiate": {
		"prefix": "AudioReverbFilter.Instantiate",
		"body": [
			"AudioReverbFilter.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"AudioReverbZone.decayHFRatio": {
		"prefix": "AudioReverbZone.decayHFRatio",
		"body": [
			"decayHFRatio"
		],
		"description": "return:float des: High-frequency to mid-frequency decay time ratio."
	}
,
	"AudioReverbZone.decayTime": {
		"prefix": "AudioReverbZone.decayTime",
		"body": [
			"decayTime"
		],
		"description": "return:float des: Reverberation decay time at mid frequencies."
	}
,
	"AudioReverbZone.density": {
		"prefix": "AudioReverbZone.density",
		"body": [
			"density"
		],
		"description": "return:float des: Value that controls the modal density in the late reverberation decay."
	}
,
	"AudioReverbZone.diffusion": {
		"prefix": "AudioReverbZone.diffusion",
		"body": [
			"diffusion"
		],
		"description": "return:float des: Value that controls the echo density in the late reverberation decay."
	}
,
	"AudioReverbZone.HFReference": {
		"prefix": "AudioReverbZone.HFReference",
		"body": [
			"HFReference"
		],
		"description": "return:float des: Reference high frequency (hz)."
	}
,
	"AudioReverbZone.LFReference": {
		"prefix": "AudioReverbZone.LFReference",
		"body": [
			"LFReference"
		],
		"description": "return:float des: Reference low frequency (hz)."
	}
,
	"AudioReverbZone.maxDistance": {
		"prefix": "AudioReverbZone.maxDistance",
		"body": [
			"maxDistance"
		],
		"description": "return:float des: The distance from the centerpoint that the reverb will not have any effect. Default = 15.0."
	}
,
	"AudioReverbZone.minDistance": {
		"prefix": "AudioReverbZone.minDistance",
		"body": [
			"minDistance"
		],
		"description": "return:float des: The distance from the centerpoint that the reverb will have full effect at. Default = 10.0."
	}
,
	"AudioReverbZone.reflections": {
		"prefix": "AudioReverbZone.reflections",
		"body": [
			"reflections"
		],
		"description": "return:int des: Early reflections level relative to room effect."
	}
,
	"AudioReverbZone.reflectionsDelay": {
		"prefix": "AudioReverbZone.reflectionsDelay",
		"body": [
			"reflectionsDelay"
		],
		"description": "return:float des: Initial reflection delay time."
	}
,
	"AudioReverbZone.reverb": {
		"prefix": "AudioReverbZone.reverb",
		"body": [
			"reverb"
		],
		"description": "return:int des: Late reverberation level relative to room effect."
	}
,
	"AudioReverbZone.reverbDelay": {
		"prefix": "AudioReverbZone.reverbDelay",
		"body": [
			"reverbDelay"
		],
		"description": "return:float des: Late reverberation delay time relative to initial reflection."
	}
,
	"AudioReverbZone.reverbPreset": {
		"prefix": "AudioReverbZone.reverbPreset",
		"body": [
			"reverbPreset"
		],
		"description": "return:AudioReverbPreset des: Set/Get reverb preset properties."
	}
,
	"AudioReverbZone.room": {
		"prefix": "AudioReverbZone.room",
		"body": [
			"room"
		],
		"description": "return:int des: Room effect level (at mid frequencies)."
	}
,
	"AudioReverbZone.roomHF": {
		"prefix": "AudioReverbZone.roomHF",
		"body": [
			"roomHF"
		],
		"description": "return:int des: Relative room effect level at high frequencies."
	}
,
	"AudioReverbZone.roomLF": {
		"prefix": "AudioReverbZone.roomLF",
		"body": [
			"roomLF"
		],
		"description": "return:int des: Relative room effect level at low frequencies."
	}
,
	"AudioReverbZone.enabled": {
		"prefix": "AudioReverbZone.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"AudioReverbZone.isActiveAndEnabled": {
		"prefix": "AudioReverbZone.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"AudioReverbZone.gameObject": {
		"prefix": "AudioReverbZone.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"AudioReverbZone.tag": {
		"prefix": "AudioReverbZone.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"AudioReverbZone.transform": {
		"prefix": "AudioReverbZone.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"AudioReverbZone.hideFlags": {
		"prefix": "AudioReverbZone.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"AudioReverbZone.name": {
		"prefix": "AudioReverbZone.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"AudioReverbZone.BroadcastMessage": {
		"prefix": "AudioReverbZone.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"AudioReverbZone.CompareTag": {
		"prefix": "AudioReverbZone.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"AudioReverbZone.GetComponent": {
		"prefix": "AudioReverbZone.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"AudioReverbZone.GetComponentInChildren": {
		"prefix": "AudioReverbZone.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"AudioReverbZone.GetComponentInParent": {
		"prefix": "AudioReverbZone.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"AudioReverbZone.GetComponents": {
		"prefix": "AudioReverbZone.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"AudioReverbZone.GetComponentsInChildren": {
		"prefix": "AudioReverbZone.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"AudioReverbZone.GetComponentsInParent": {
		"prefix": "AudioReverbZone.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"AudioReverbZone.SendMessage": {
		"prefix": "AudioReverbZone.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"AudioReverbZone.SendMessageUpwards": {
		"prefix": "AudioReverbZone.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"AudioReverbZone.GetInstanceID": {
		"prefix": "AudioReverbZone.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"AudioReverbZone.ToString": {
		"prefix": "AudioReverbZone.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"AudioReverbZone.Destroy": {
		"prefix": "AudioReverbZone.Destroy",
		"body": [
			"AudioReverbZone.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"AudioReverbZone.DestroyImmediate": {
		"prefix": "AudioReverbZone.DestroyImmediate",
		"body": [
			"AudioReverbZone.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"AudioReverbZone.DontDestroyOnLoad": {
		"prefix": "AudioReverbZone.DontDestroyOnLoad",
		"body": [
			"AudioReverbZone.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"AudioReverbZone.FindObjectOfType": {
		"prefix": "AudioReverbZone.FindObjectOfType",
		"body": [
			"AudioReverbZone.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"AudioReverbZone.FindObjectsOfType": {
		"prefix": "AudioReverbZone.FindObjectsOfType",
		"body": [
			"AudioReverbZone.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"AudioReverbZone.Instantiate": {
		"prefix": "AudioReverbZone.Instantiate",
		"body": [
			"AudioReverbZone.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"AudioSettings.GetConfiguration": {
		"prefix": "AudioSettings.GetConfiguration",
		"body": [
			"AudioSettings.GetConfiguration"
		],
		"description": "public static AudioConfiguration GetConfiguration(); des: Returns the current configuration of the audio device and system. The values in the struct may then be modified and reapplied via AudioSettings.Reset."
	}
,
	"AudioSettings.GetDSPBufferSize": {
		"prefix": "AudioSettings.GetDSPBufferSize",
		"body": [
			"AudioSettings.GetDSPBufferSize"
		],
		"description": "public static void GetDSPBufferSize(out int bufferLength, out int numBuffers); des: Get the mixer's buffer size in samples."
	}
,
	"AudioSettings.GetSpatializerPluginName": {
		"prefix": "AudioSettings.GetSpatializerPluginName",
		"body": [
			"AudioSettings.GetSpatializerPluginName"
		],
		"description": "public static string GetSpatializerPluginName(); des: Returns the name of the spatializer selected on the currently-running platform."
	}
,
	"AudioSettings.GetSpatializerPluginNames": {
		"prefix": "AudioSettings.GetSpatializerPluginNames",
		"body": [
			"AudioSettings.GetSpatializerPluginNames"
		],
		"description": "public static string[] GetSpatializerPluginNames(); des: Returns an array with the names of all the available spatializer plugins."
	}
,
	"AudioSettings.Reset": {
		"prefix": "AudioSettings.Reset",
		"body": [
			"AudioSettings.Reset"
		],
		"description": "public static bool Reset(AudioConfiguration config); des: Performs a change of the device configuration. In response to this the AudioSettings.OnAudioConfigurationChanged delegate is invoked with the argument deviceWasChanged=false. It cannot be guaranteed that the exact settings specified can be used, but the an attempt is made to use the closest match supported by the system."
	}
,
	"AudioSettings.SetSpatializerPluginName": {
		"prefix": "AudioSettings.SetSpatializerPluginName",
		"body": [
			"AudioSettings.SetSpatializerPluginName"
		],
		"description": "public static void SetSpatializerPluginName(string pluginName); des: Sets the spatializer plugin for all platform groups. If a null or empty string is passed in, the existing spatializer plugin will be cleared."
	}
,
	"AudioSource.bypassEffects": {
		"prefix": "AudioSource.bypassEffects",
		"body": [
			"bypassEffects"
		],
		"description": "return:bool des: Bypass effects (Applied from filter components or global listener filters)."
	}
,
	"AudioSource.bypassListenerEffects": {
		"prefix": "AudioSource.bypassListenerEffects",
		"body": [
			"bypassListenerEffects"
		],
		"description": "return:bool des: When set global effects on the AudioListener will not be applied to the audio signal generated by the AudioSource. Does not apply if the AudioSource is playing into a mixer group."
	}
,
	"AudioSource.bypassReverbZones": {
		"prefix": "AudioSource.bypassReverbZones",
		"body": [
			"bypassReverbZones"
		],
		"description": "return:bool des: When set doesn't route the signal from an AudioSource into the global reverb associated with reverb zones."
	}
,
	"AudioSource.clip": {
		"prefix": "AudioSource.clip",
		"body": [
			"clip"
		],
		"description": "return:AudioClip des: The default AudioClip to play."
	}
,
	"AudioSource.dopplerLevel": {
		"prefix": "AudioSource.dopplerLevel",
		"body": [
			"dopplerLevel"
		],
		"description": "return:float des: Sets the Doppler scale for this AudioSource."
	}
,
	"AudioSource.ignoreListenerPause": {
		"prefix": "AudioSource.ignoreListenerPause",
		"body": [
			"ignoreListenerPause"
		],
		"description": "return:bool des: Allows AudioSource to play even though AudioListener.pause is set to true. This is useful for the menu element sounds or background music in pause menus."
	}
,
	"AudioSource.ignoreListenerVolume": {
		"prefix": "AudioSource.ignoreListenerVolume",
		"body": [
			"ignoreListenerVolume"
		],
		"description": "return:bool des: This makes the audio source not take into account the volume of the audio listener."
	}
,
	"AudioSource.isPlaying": {
		"prefix": "AudioSource.isPlaying",
		"body": [
			"isPlaying"
		],
		"description": "return:bool des: Is the clip playing right now (Read Only)?"
	}
,
	"AudioSource.isVirtual": {
		"prefix": "AudioSource.isVirtual",
		"body": [
			"isVirtual"
		],
		"description": "return:bool des: True if all sounds played by the AudioSource (main sound started by Play() or playOnAwake as well as one-shots) are culled by the audio system."
	}
,
	"AudioSource.loop": {
		"prefix": "AudioSource.loop",
		"body": [
			"loop"
		],
		"description": "return:bool des: Is the audio clip looping?"
	}
,
	"AudioSource.maxDistance": {
		"prefix": "AudioSource.maxDistance",
		"body": [
			"maxDistance"
		],
		"description": "return:float des: (Logarithmic rolloff) MaxDistance is the distance a sound stops attenuating at."
	}
,
	"AudioSource.minDistance": {
		"prefix": "AudioSource.minDistance",
		"body": [
			"minDistance"
		],
		"description": "return:float des: Within the Min distance the AudioSource will cease to grow louder in volume."
	}
,
	"AudioSource.mute": {
		"prefix": "AudioSource.mute",
		"body": [
			"mute"
		],
		"description": "return:bool des: Un- / Mutes the AudioSource. Mute sets the volume=0, Un-Mute restore the original volume."
	}
,
	"AudioSource.outputAudioMixerGroup": {
		"prefix": "AudioSource.outputAudioMixerGroup",
		"body": [
			"outputAudioMixerGroup"
		],
		"description": "return:Audio.AudioMixerGroup des: The target group to which the AudioSource should route its signal."
	}
,
	"AudioSource.panStereo": {
		"prefix": "AudioSource.panStereo",
		"body": [
			"panStereo"
		],
		"description": "return:float des: Pans a playing sound in a stereo way (left or right). This only applies to sounds that are Mono or Stereo."
	}
,
	"AudioSource.pitch": {
		"prefix": "AudioSource.pitch",
		"body": [
			"pitch"
		],
		"description": "return:float des: The pitch of the audio source."
	}
,
	"AudioSource.playOnAwake": {
		"prefix": "AudioSource.playOnAwake",
		"body": [
			"playOnAwake"
		],
		"description": "return:bool des: If set to true, the audio source will automatically start playing on awake."
	}
,
	"AudioSource.priority": {
		"prefix": "AudioSource.priority",
		"body": [
			"priority"
		],
		"description": "return:int des: Sets the priority of the AudioSource."
	}
,
	"AudioSource.reverbZoneMix": {
		"prefix": "AudioSource.reverbZoneMix",
		"body": [
			"reverbZoneMix"
		],
		"description": "return:float des: The amount by which the signal from the AudioSource will be mixed into the global reverb associated with the Reverb Zones."
	}
,
	"AudioSource.rolloffMode": {
		"prefix": "AudioSource.rolloffMode",
		"body": [
			"rolloffMode"
		],
		"description": "return:AudioRolloffMode des: Sets/Gets how the AudioSource attenuates over distance."
	}
,
	"AudioSource.spatialBlend": {
		"prefix": "AudioSource.spatialBlend",
		"body": [
			"spatialBlend"
		],
		"description": "return:float des: Sets how much this AudioSource is affected by 3D spatialisation calculations (attenuation, doppler etc). 0.0 makes the sound full 2D, 1.0 makes it full 3D."
	}
,
	"AudioSource.spatialize": {
		"prefix": "AudioSource.spatialize",
		"body": [
			"spatialize"
		],
		"description": "return:bool des: Enables or disables spatialization."
	}
,
	"AudioSource.spatializePostEffects": {
		"prefix": "AudioSource.spatializePostEffects",
		"body": [
			"spatializePostEffects"
		],
		"description": "return:bool des: Determines if the spatializer effect is inserted before or after the effect filters."
	}
,
	"AudioSource.spread": {
		"prefix": "AudioSource.spread",
		"body": [
			"spread"
		],
		"description": "return:float des: Sets the spread angle (in degrees) of a 3d stereo or multichannel sound in speaker space."
	}
,
	"AudioSource.time": {
		"prefix": "AudioSource.time",
		"body": [
			"time"
		],
		"description": "return:float des: Playback position in seconds."
	}
,
	"AudioSource.timeSamples": {
		"prefix": "AudioSource.timeSamples",
		"body": [
			"timeSamples"
		],
		"description": "return:int des: Playback position in PCM samples."
	}
,
	"AudioSource.velocityUpdateMode": {
		"prefix": "AudioSource.velocityUpdateMode",
		"body": [
			"velocityUpdateMode"
		],
		"description": "return:AudioVelocityUpdateMode des: Whether the Audio Source should be updated in the fixed or dynamic update."
	}
,
	"AudioSource.volume": {
		"prefix": "AudioSource.volume",
		"body": [
			"volume"
		],
		"description": "return:float des: The volume of the audio source (0.0 to 1.0)."
	}
,
	"AudioSource.GetAmbisonicDecoderFloat": {
		"prefix": "AudioSource.GetAmbisonicDecoderFloat",
		"body": [
			"GetAmbisonicDecoderFloat($1)"
		],
		"description": "public bool GetAmbisonicDecoderFloat(int index, out float value); des: Reads a user-defined parameter of a custom ambisonic decoder effect that is attached to an AudioSource."
	}
,
	"AudioSource.GetCustomCurve": {
		"prefix": "AudioSource.GetCustomCurve",
		"body": [
			"GetCustomCurve($1)"
		],
		"description": "public AnimationCurve GetCustomCurve(AudioSourceCurveType type); des: Get the current custom curve for the given AudioSourceCurveType."
	}
,
	"AudioSource.GetOutputData": {
		"prefix": "AudioSource.GetOutputData",
		"body": [
			"GetOutputData($1)"
		],
		"description": "public void GetOutputData(float[] samples, int channel); Obsolete public float[] GetOutputData(int numSamples, int channel); des: Provides a block of the currently playing source's output data."
	}
,
	"AudioSource.GetSpatializerFloat": {
		"prefix": "AudioSource.GetSpatializerFloat",
		"body": [
			"GetSpatializerFloat($1)"
		],
		"description": "public bool GetSpatializerFloat(int index, out float value); des: Reads a user-defined parameter of a custom spatializer effect that is attached to an AudioSource."
	}
,
	"AudioSource.GetSpectrumData": {
		"prefix": "AudioSource.GetSpectrumData",
		"body": [
			"GetSpectrumData($1)"
		],
		"description": "public void GetSpectrumData(float[] samples, int channel, FFTWindow window); Obsolete public float[] GetSpectrumData(int numSamples, int channel, FFTWindow window); des: Provides a block of the currently playing audio source's spectrum data."
	}
,
	"AudioSource.Pause": {
		"prefix": "AudioSource.Pause",
		"body": [
			"Pause($1)"
		],
		"description": "public void Pause(); des: Pauses playing the clip."
	}
,
	"AudioSource.Play": {
		"prefix": "AudioSource.Play",
		"body": [
			"Play($1)"
		],
		"description": "public void Play(ulong delay = 0); des: Plays the clip."
	}
,
	"AudioSource.PlayDelayed": {
		"prefix": "AudioSource.PlayDelayed",
		"body": [
			"PlayDelayed($1)"
		],
		"description": "public void PlayDelayed(float delay); des: Plays the clip with a delay specified in seconds. Users are advised to use this function instead of the old Play(delay) function that took a delay specified in samples relative to a reference rate of 44.1 kHz as an argument."
	}
,
	"AudioSource.PlayOneShot": {
		"prefix": "AudioSource.PlayOneShot",
		"body": [
			"PlayOneShot($1)"
		],
		"description": "public void PlayOneShot(AudioClip clip, float volumeScale = 1.0F); des: Plays an AudioClip, and scales the AudioSource volume by volumeScale."
	}
,
	"AudioSource.PlayScheduled": {
		"prefix": "AudioSource.PlayScheduled",
		"body": [
			"PlayScheduled($1)"
		],
		"description": "public void PlayScheduled(double time); des: Plays the clip at a specific time on the absolute time-line that AudioSettings.dspTime reads from."
	}
,
	"AudioSource.SetAmbisonicDecoderFloat": {
		"prefix": "AudioSource.SetAmbisonicDecoderFloat",
		"body": [
			"SetAmbisonicDecoderFloat($1)"
		],
		"description": "public bool SetAmbisonicDecoderFloat(int index, float value); des: Sets a user-defined parameter of a custom ambisonic decoder effect that is attached to an AudioSource."
	}
,
	"AudioSource.SetCustomCurve": {
		"prefix": "AudioSource.SetCustomCurve",
		"body": [
			"SetCustomCurve($1)"
		],
		"description": "public void SetCustomCurve(AudioSourceCurveType type, AnimationCurve curve); des: Set the custom curve for the given AudioSourceCurveType."
	}
,
	"AudioSource.SetScheduledEndTime": {
		"prefix": "AudioSource.SetScheduledEndTime",
		"body": [
			"SetScheduledEndTime($1)"
		],
		"description": "public void SetScheduledEndTime(double time); des: Changes the time at which a sound that has already been scheduled to play will end. Notice that depending on the timing not all rescheduling requests can be fulfilled."
	}
,
	"AudioSource.SetScheduledStartTime": {
		"prefix": "AudioSource.SetScheduledStartTime",
		"body": [
			"SetScheduledStartTime($1)"
		],
		"description": "public void SetScheduledStartTime(double time); des: Changes the time at which a sound that has already been scheduled to play will start."
	}
,
	"AudioSource.SetSpatializerFloat": {
		"prefix": "AudioSource.SetSpatializerFloat",
		"body": [
			"SetSpatializerFloat($1)"
		],
		"description": "public bool SetSpatializerFloat(int index, float value); des: Sets a user-defined parameter of a custom spatializer effect that is attached to an AudioSource."
	}
,
	"AudioSource.Stop": {
		"prefix": "AudioSource.Stop",
		"body": [
			"Stop($1)"
		],
		"description": "public void Stop(); des: Stops playing the clip."
	}
,
	"AudioSource.UnPause": {
		"prefix": "AudioSource.UnPause",
		"body": [
			"UnPause($1)"
		],
		"description": "public void UnPause(); des: Unpause the paused playback of this AudioSource."
	}
,
	"AudioSource.PlayClipAtPoint": {
		"prefix": "AudioSource.PlayClipAtPoint",
		"body": [
			"AudioSource.PlayClipAtPoint"
		],
		"description": "public static void PlayClipAtPoint(AudioClip clip, Vector3 position, float volume = 1.0F); des: Plays an AudioClip at a given position in world space."
	}
,
	"AudioSource.enabled": {
		"prefix": "AudioSource.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"AudioSource.isActiveAndEnabled": {
		"prefix": "AudioSource.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"AudioSource.gameObject": {
		"prefix": "AudioSource.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"AudioSource.tag": {
		"prefix": "AudioSource.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"AudioSource.transform": {
		"prefix": "AudioSource.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"AudioSource.hideFlags": {
		"prefix": "AudioSource.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"AudioSource.name": {
		"prefix": "AudioSource.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"AudioSource.BroadcastMessage": {
		"prefix": "AudioSource.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"AudioSource.CompareTag": {
		"prefix": "AudioSource.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"AudioSource.GetComponent": {
		"prefix": "AudioSource.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"AudioSource.GetComponentInChildren": {
		"prefix": "AudioSource.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"AudioSource.GetComponentInParent": {
		"prefix": "AudioSource.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"AudioSource.GetComponents": {
		"prefix": "AudioSource.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"AudioSource.GetComponentsInChildren": {
		"prefix": "AudioSource.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"AudioSource.GetComponentsInParent": {
		"prefix": "AudioSource.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"AudioSource.SendMessage": {
		"prefix": "AudioSource.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"AudioSource.SendMessageUpwards": {
		"prefix": "AudioSource.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"AudioSource.GetInstanceID": {
		"prefix": "AudioSource.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"AudioSource.ToString": {
		"prefix": "AudioSource.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"AudioSource.Destroy": {
		"prefix": "AudioSource.Destroy",
		"body": [
			"AudioSource.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"AudioSource.DestroyImmediate": {
		"prefix": "AudioSource.DestroyImmediate",
		"body": [
			"AudioSource.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"AudioSource.DontDestroyOnLoad": {
		"prefix": "AudioSource.DontDestroyOnLoad",
		"body": [
			"AudioSource.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"AudioSource.FindObjectOfType": {
		"prefix": "AudioSource.FindObjectOfType",
		"body": [
			"AudioSource.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"AudioSource.FindObjectsOfType": {
		"prefix": "AudioSource.FindObjectsOfType",
		"body": [
			"AudioSource.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"AudioSource.Instantiate": {
		"prefix": "AudioSource.Instantiate",
		"body": [
			"AudioSource.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"Avatar.isHuman": {
		"prefix": "Avatar.isHuman",
		"body": [
			"isHuman"
		],
		"description": "return:bool des: Return true if this avatar is a valid human avatar."
	}
,
	"Avatar.isValid": {
		"prefix": "Avatar.isValid",
		"body": [
			"isValid"
		],
		"description": "return:bool des: Return true if this avatar is a valid mecanim avatar. It can be a generic avatar or a human avatar."
	}
,
	"Avatar.hideFlags": {
		"prefix": "Avatar.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Avatar.name": {
		"prefix": "Avatar.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Avatar.GetInstanceID": {
		"prefix": "Avatar.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Avatar.ToString": {
		"prefix": "Avatar.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Avatar.Destroy": {
		"prefix": "Avatar.Destroy",
		"body": [
			"Avatar.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Avatar.DestroyImmediate": {
		"prefix": "Avatar.DestroyImmediate",
		"body": [
			"Avatar.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Avatar.DontDestroyOnLoad": {
		"prefix": "Avatar.DontDestroyOnLoad",
		"body": [
			"Avatar.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Avatar.FindObjectOfType": {
		"prefix": "Avatar.FindObjectOfType",
		"body": [
			"Avatar.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Avatar.FindObjectsOfType": {
		"prefix": "Avatar.FindObjectsOfType",
		"body": [
			"Avatar.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Avatar.Instantiate": {
		"prefix": "Avatar.Instantiate",
		"body": [
			"Avatar.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"AvatarBuilder.BuildGenericAvatar": {
		"prefix": "AvatarBuilder.BuildGenericAvatar",
		"body": [
			"AvatarBuilder.BuildGenericAvatar"
		],
		"description": "public static Avatar BuildGenericAvatar(GameObject go, string rootMotionTransformName); des: Create a new generic avatar."
	}
,
	"AvatarBuilder.BuildHumanAvatar": {
		"prefix": "AvatarBuilder.BuildHumanAvatar",
		"body": [
			"AvatarBuilder.BuildHumanAvatar"
		],
		"description": "public static Avatar BuildHumanAvatar(GameObject go, HumanDescription humanDescription); des: Create a humanoid avatar."
	}
,
	"AvatarMask.transformCount": {
		"prefix": "AvatarMask.transformCount",
		"body": [
			"transformCount"
		],
		"description": "return:int des: Number of transforms."
	}
,
	"AvatarMask.AddTransformPath": {
		"prefix": "AvatarMask.AddTransformPath",
		"body": [
			"AddTransformPath($1)"
		],
		"description": "public void AddTransformPath(Transform transform, bool recursive = true); des: Adds a transform path into the AvatarMask."
	}
,
	"AvatarMask.GetHumanoidBodyPartActive": {
		"prefix": "AvatarMask.GetHumanoidBodyPartActive",
		"body": [
			"GetHumanoidBodyPartActive($1)"
		],
		"description": "public bool GetHumanoidBodyPartActive(AvatarMaskBodyPart index); des: Returns true if the humanoid body part at the given index is active."
	}
,
	"AvatarMask.GetTransformActive": {
		"prefix": "AvatarMask.GetTransformActive",
		"body": [
			"GetTransformActive($1)"
		],
		"description": "public bool GetTransformActive(int index); des: Returns true if the transform at the given index is active."
	}
,
	"AvatarMask.GetTransformPath": {
		"prefix": "AvatarMask.GetTransformPath",
		"body": [
			"GetTransformPath($1)"
		],
		"description": "public string GetTransformPath(int index); des: Returns the path of the transform at the given index."
	}
,
	"AvatarMask.RemoveTransformPath": {
		"prefix": "AvatarMask.RemoveTransformPath",
		"body": [
			"RemoveTransformPath($1)"
		],
		"description": "public void RemoveTransformPath(Transform transform, bool recursive = true); des: Removes a transform path from the AvatarMask."
	}
,
	"AvatarMask.SetHumanoidBodyPartActive": {
		"prefix": "AvatarMask.SetHumanoidBodyPartActive",
		"body": [
			"SetHumanoidBodyPartActive($1)"
		],
		"description": "public void SetHumanoidBodyPartActive(AvatarMaskBodyPart index, bool value); des: Sets the humanoid body part at the given index to active or not."
	}
,
	"AvatarMask.SetTransformActive": {
		"prefix": "AvatarMask.SetTransformActive",
		"body": [
			"SetTransformActive($1)"
		],
		"description": "public void SetTransformActive(int index, bool value); des: Sets the tranform at the given index to active or not."
	}
,
	"AvatarMask.SetTransformPath": {
		"prefix": "AvatarMask.SetTransformPath",
		"body": [
			"SetTransformPath($1)"
		],
		"description": "public void SetTransformPath(int index, string path); des: Sets the path of the transform at the given index."
	}
,
	"AvatarMask.hideFlags": {
		"prefix": "AvatarMask.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"AvatarMask.name": {
		"prefix": "AvatarMask.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"AvatarMask.GetInstanceID": {
		"prefix": "AvatarMask.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"AvatarMask.ToString": {
		"prefix": "AvatarMask.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"AvatarMask.Destroy": {
		"prefix": "AvatarMask.Destroy",
		"body": [
			"AvatarMask.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"AvatarMask.DestroyImmediate": {
		"prefix": "AvatarMask.DestroyImmediate",
		"body": [
			"AvatarMask.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"AvatarMask.DontDestroyOnLoad": {
		"prefix": "AvatarMask.DontDestroyOnLoad",
		"body": [
			"AvatarMask.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"AvatarMask.FindObjectOfType": {
		"prefix": "AvatarMask.FindObjectOfType",
		"body": [
			"AvatarMask.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"AvatarMask.FindObjectsOfType": {
		"prefix": "AvatarMask.FindObjectsOfType",
		"body": [
			"AvatarMask.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"AvatarMask.Instantiate": {
		"prefix": "AvatarMask.Instantiate",
		"body": [
			"AvatarMask.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"Behaviour.enabled": {
		"prefix": "Behaviour.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"Behaviour.isActiveAndEnabled": {
		"prefix": "Behaviour.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"Behaviour.gameObject": {
		"prefix": "Behaviour.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"Behaviour.tag": {
		"prefix": "Behaviour.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"Behaviour.transform": {
		"prefix": "Behaviour.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"Behaviour.hideFlags": {
		"prefix": "Behaviour.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Behaviour.name": {
		"prefix": "Behaviour.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Behaviour.BroadcastMessage": {
		"prefix": "Behaviour.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"Behaviour.CompareTag": {
		"prefix": "Behaviour.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"Behaviour.GetComponent": {
		"prefix": "Behaviour.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"Behaviour.GetComponentInChildren": {
		"prefix": "Behaviour.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"Behaviour.GetComponentInParent": {
		"prefix": "Behaviour.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"Behaviour.GetComponents": {
		"prefix": "Behaviour.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"Behaviour.GetComponentsInChildren": {
		"prefix": "Behaviour.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"Behaviour.GetComponentsInParent": {
		"prefix": "Behaviour.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"Behaviour.SendMessage": {
		"prefix": "Behaviour.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"Behaviour.SendMessageUpwards": {
		"prefix": "Behaviour.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"Behaviour.GetInstanceID": {
		"prefix": "Behaviour.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Behaviour.ToString": {
		"prefix": "Behaviour.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Behaviour.Destroy": {
		"prefix": "Behaviour.Destroy",
		"body": [
			"Behaviour.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Behaviour.DestroyImmediate": {
		"prefix": "Behaviour.DestroyImmediate",
		"body": [
			"Behaviour.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Behaviour.DontDestroyOnLoad": {
		"prefix": "Behaviour.DontDestroyOnLoad",
		"body": [
			"Behaviour.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Behaviour.FindObjectOfType": {
		"prefix": "Behaviour.FindObjectOfType",
		"body": [
			"Behaviour.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Behaviour.FindObjectsOfType": {
		"prefix": "Behaviour.FindObjectsOfType",
		"body": [
			"Behaviour.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Behaviour.Instantiate": {
		"prefix": "Behaviour.Instantiate",
		"body": [
			"Behaviour.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"BillboardAsset.bottom": {
		"prefix": "BillboardAsset.bottom",
		"body": [
			"bottom"
		],
		"description": "return:float des: Height of the billboard that is below ground."
	}
,
	"BillboardAsset.height": {
		"prefix": "BillboardAsset.height",
		"body": [
			"height"
		],
		"description": "return:float des: Height of the billboard."
	}
,
	"BillboardAsset.imageCount": {
		"prefix": "BillboardAsset.imageCount",
		"body": [
			"imageCount"
		],
		"description": "return:int des: Number of pre-rendered images that can be switched when the billboard is viewed from different angles."
	}
,
	"BillboardAsset.indexCount": {
		"prefix": "BillboardAsset.indexCount",
		"body": [
			"indexCount"
		],
		"description": "return:int des: Number of indices in the billboard mesh."
	}
,
	"BillboardAsset.material": {
		"prefix": "BillboardAsset.material",
		"body": [
			"material"
		],
		"description": "return:Material des: The material used for rendering."
	}
,
	"BillboardAsset.vertexCount": {
		"prefix": "BillboardAsset.vertexCount",
		"body": [
			"vertexCount"
		],
		"description": "return:int des: Number of vertices in the billboard mesh."
	}
,
	"BillboardAsset.width": {
		"prefix": "BillboardAsset.width",
		"body": [
			"width"
		],
		"description": "return:float des: Width of the billboard."
	}
,
	"BillboardAsset.GetImageTexCoords": {
		"prefix": "BillboardAsset.GetImageTexCoords",
		"body": [
			"GetImageTexCoords($1)"
		],
		"description": "public Vector4[] GetImageTexCoords(); public void GetImageTexCoords(List<Vector4> imageTexCoords); des: Get the array of billboard image texture coordinate data."
	}
,
	"BillboardAsset.GetIndices": {
		"prefix": "BillboardAsset.GetIndices",
		"body": [
			"GetIndices($1)"
		],
		"description": "public ushort[] GetIndices(); public void GetIndices(List<ushort> indices); des: Get the indices of the billboard mesh."
	}
,
	"BillboardAsset.GetVertices": {
		"prefix": "BillboardAsset.GetVertices",
		"body": [
			"GetVertices($1)"
		],
		"description": "public Vector2[] GetVertices(); public void GetVertices(List<Vector2> vertices); des: Get the vertices of the billboard mesh."
	}
,
	"BillboardAsset.SetImageTexCoords": {
		"prefix": "BillboardAsset.SetImageTexCoords",
		"body": [
			"SetImageTexCoords($1)"
		],
		"description": "public void SetImageTexCoords(Vector4[] imageTexCoords); public void SetImageTexCoords(List<Vector4> imageTexCoords); des: Set the array of billboard image texture coordinate data."
	}
,
	"BillboardAsset.SetIndices": {
		"prefix": "BillboardAsset.SetIndices",
		"body": [
			"SetIndices($1)"
		],
		"description": "public void SetIndices(ushort[] indices); public void SetIndices(List<ushort> indices); des: Set the indices of the billboard mesh."
	}
,
	"BillboardAsset.SetVertices": {
		"prefix": "BillboardAsset.SetVertices",
		"body": [
			"SetVertices($1)"
		],
		"description": "public void SetVertices(Vector2[] vertices); public void SetVertices(List<Vector2> vertices); des: Set the vertices of the billboard mesh."
	}
,
	"BillboardAsset.hideFlags": {
		"prefix": "BillboardAsset.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"BillboardAsset.name": {
		"prefix": "BillboardAsset.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"BillboardAsset.GetInstanceID": {
		"prefix": "BillboardAsset.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"BillboardAsset.ToString": {
		"prefix": "BillboardAsset.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"BillboardAsset.Destroy": {
		"prefix": "BillboardAsset.Destroy",
		"body": [
			"BillboardAsset.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"BillboardAsset.DestroyImmediate": {
		"prefix": "BillboardAsset.DestroyImmediate",
		"body": [
			"BillboardAsset.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"BillboardAsset.DontDestroyOnLoad": {
		"prefix": "BillboardAsset.DontDestroyOnLoad",
		"body": [
			"BillboardAsset.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"BillboardAsset.FindObjectOfType": {
		"prefix": "BillboardAsset.FindObjectOfType",
		"body": [
			"BillboardAsset.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"BillboardAsset.FindObjectsOfType": {
		"prefix": "BillboardAsset.FindObjectsOfType",
		"body": [
			"BillboardAsset.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"BillboardAsset.Instantiate": {
		"prefix": "BillboardAsset.Instantiate",
		"body": [
			"BillboardAsset.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"BillboardRenderer.billboard": {
		"prefix": "BillboardRenderer.billboard",
		"body": [
			"billboard"
		],
		"description": "return:BillboardAsset des: The BillboardAsset to render."
	}
,
	"BillboardRenderer.gameObject": {
		"prefix": "BillboardRenderer.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"BillboardRenderer.tag": {
		"prefix": "BillboardRenderer.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"BillboardRenderer.transform": {
		"prefix": "BillboardRenderer.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"BillboardRenderer.hideFlags": {
		"prefix": "BillboardRenderer.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"BillboardRenderer.name": {
		"prefix": "BillboardRenderer.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"BillboardRenderer.allowOcclusionWhenDynamic": {
		"prefix": "BillboardRenderer.allowOcclusionWhenDynamic",
		"body": [
			"allowOcclusionWhenDynamic"
		],
		"description": "return:bool des: Controls if dynamic occlusion culling should be performed for this renderer."
	}
,
	"BillboardRenderer.bounds": {
		"prefix": "BillboardRenderer.bounds",
		"body": [
			"bounds"
		],
		"description": "return:Bounds des: The bounding volume of the renderer (Read Only)."
	}
,
	"BillboardRenderer.enabled": {
		"prefix": "BillboardRenderer.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Makes the rendered 3D object visible if enabled."
	}
,
	"BillboardRenderer.isPartOfStaticBatch": {
		"prefix": "BillboardRenderer.isPartOfStaticBatch",
		"body": [
			"isPartOfStaticBatch"
		],
		"description": "return:bool des: Has this renderer been statically batched with any other renderers?"
	}
,
	"BillboardRenderer.isVisible": {
		"prefix": "BillboardRenderer.isVisible",
		"body": [
			"isVisible"
		],
		"description": "return:bool des: Is this renderer visible in any camera? (Read Only)"
	}
,
	"BillboardRenderer.lightmapIndex": {
		"prefix": "BillboardRenderer.lightmapIndex",
		"body": [
			"lightmapIndex"
		],
		"description": "return:int des: The index of the baked lightmap applied to this renderer."
	}
,
	"BillboardRenderer.lightmapScaleOffset": {
		"prefix": "BillboardRenderer.lightmapScaleOffset",
		"body": [
			"lightmapScaleOffset"
		],
		"description": "return:Vector4 des: The UV scale & offset used for a lightmap."
	}
,
	"BillboardRenderer.lightProbeProxyVolumeOverride": {
		"prefix": "BillboardRenderer.lightProbeProxyVolumeOverride",
		"body": [
			"lightProbeProxyVolumeOverride"
		],
		"description": "return:GameObject des: If set, the Renderer will use the Light Probe Proxy Volume component attached to the source GameObject."
	}
,
	"BillboardRenderer.lightProbeUsage": {
		"prefix": "BillboardRenderer.lightProbeUsage",
		"body": [
			"lightProbeUsage"
		],
		"description": "return:Rendering.LightProbeUsage des: The light probe interpolation type."
	}
,
	"BillboardRenderer.localToWorldMatrix": {
		"prefix": "BillboardRenderer.localToWorldMatrix",
		"body": [
			"localToWorldMatrix"
		],
		"description": "return:Matrix4x4 des: Matrix that transforms a point from local space into world space (Read Only)."
	}
,
	"BillboardRenderer.material": {
		"prefix": "BillboardRenderer.material",
		"body": [
			"material"
		],
		"description": "return:Material des: Returns the first instantiated Material assigned to the renderer."
	}
,
	"BillboardRenderer.materials": {
		"prefix": "BillboardRenderer.materials",
		"body": [
			"materials"
		],
		"description": "return:Material[] des: Returns all the instantiated materials of this object."
	}
,
	"BillboardRenderer.motionVectorGenerationMode": {
		"prefix": "BillboardRenderer.motionVectorGenerationMode",
		"body": [
			"motionVectorGenerationMode"
		],
		"description": "return:MotionVectorGenerationMode des: Specifies the mode for motion vector rendering."
	}
,
	"BillboardRenderer.probeAnchor": {
		"prefix": "BillboardRenderer.probeAnchor",
		"body": [
			"probeAnchor"
		],
		"description": "return:Transform des: If set, Renderer will use this Transform's position to find the light or reflection probe."
	}
,
	"BillboardRenderer.realtimeLightmapIndex": {
		"prefix": "BillboardRenderer.realtimeLightmapIndex",
		"body": [
			"realtimeLightmapIndex"
		],
		"description": "return:int des: The index of the realtime lightmap applied to this renderer."
	}
,
	"BillboardRenderer.realtimeLightmapScaleOffset": {
		"prefix": "BillboardRenderer.realtimeLightmapScaleOffset",
		"body": [
			"realtimeLightmapScaleOffset"
		],
		"description": "return:Vector4 des: The UV scale & offset used for a realtime lightmap."
	}
,
	"BillboardRenderer.receiveShadows": {
		"prefix": "BillboardRenderer.receiveShadows",
		"body": [
			"receiveShadows"
		],
		"description": "return:bool des: Does this object receive shadows?"
	}
,
	"BillboardRenderer.reflectionProbeUsage": {
		"prefix": "BillboardRenderer.reflectionProbeUsage",
		"body": [
			"reflectionProbeUsage"
		],
		"description": "return:Rendering.ReflectionProbeUsage des: Should reflection probes be used for this Renderer?"
	}
,
	"BillboardRenderer.renderingLayerMask": {
		"prefix": "BillboardRenderer.renderingLayerMask",
		"body": [
			"renderingLayerMask"
		],
		"description": "return:uint des: Determines which rendering layer this renderer lives on."
	}
,
	"BillboardRenderer.shadowCastingMode": {
		"prefix": "BillboardRenderer.shadowCastingMode",
		"body": [
			"shadowCastingMode"
		],
		"description": "return:Rendering.ShadowCastingMode des: Does this object cast shadows?"
	}
,
	"BillboardRenderer.sharedMaterial": {
		"prefix": "BillboardRenderer.sharedMaterial",
		"body": [
			"sharedMaterial"
		],
		"description": "return:Material des: The shared material of this object."
	}
,
	"BillboardRenderer.sharedMaterials": {
		"prefix": "BillboardRenderer.sharedMaterials",
		"body": [
			"sharedMaterials"
		],
		"description": "return:Material[] des: All the shared materials of this object."
	}
,
	"BillboardRenderer.sortingLayerID": {
		"prefix": "BillboardRenderer.sortingLayerID",
		"body": [
			"sortingLayerID"
		],
		"description": "return:int des: Unique ID of the Renderer's sorting layer."
	}
,
	"BillboardRenderer.sortingLayerName": {
		"prefix": "BillboardRenderer.sortingLayerName",
		"body": [
			"sortingLayerName"
		],
		"description": "return:string des: Name of the Renderer's sorting layer."
	}
,
	"BillboardRenderer.sortingOrder": {
		"prefix": "BillboardRenderer.sortingOrder",
		"body": [
			"sortingOrder"
		],
		"description": "return:int des: Renderer's order within a sorting layer."
	}
,
	"BillboardRenderer.worldToLocalMatrix": {
		"prefix": "BillboardRenderer.worldToLocalMatrix",
		"body": [
			"worldToLocalMatrix"
		],
		"description": "return:Matrix4x4 des: Matrix that transforms a point from world space into local space (Read Only)."
	}
,
	"BillboardRenderer.BroadcastMessage": {
		"prefix": "BillboardRenderer.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"BillboardRenderer.CompareTag": {
		"prefix": "BillboardRenderer.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"BillboardRenderer.GetComponent": {
		"prefix": "BillboardRenderer.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"BillboardRenderer.GetComponentInChildren": {
		"prefix": "BillboardRenderer.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"BillboardRenderer.GetComponentInParent": {
		"prefix": "BillboardRenderer.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"BillboardRenderer.GetComponents": {
		"prefix": "BillboardRenderer.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"BillboardRenderer.GetComponentsInChildren": {
		"prefix": "BillboardRenderer.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"BillboardRenderer.GetComponentsInParent": {
		"prefix": "BillboardRenderer.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"BillboardRenderer.SendMessage": {
		"prefix": "BillboardRenderer.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"BillboardRenderer.SendMessageUpwards": {
		"prefix": "BillboardRenderer.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"BillboardRenderer.GetInstanceID": {
		"prefix": "BillboardRenderer.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"BillboardRenderer.ToString": {
		"prefix": "BillboardRenderer.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"BillboardRenderer.GetClosestReflectionProbes": {
		"prefix": "BillboardRenderer.GetClosestReflectionProbes",
		"body": [
			"GetClosestReflectionProbes($1)"
		],
		"description": "public void GetClosestReflectionProbes(List<ReflectionProbeBlendInfo> result); des: Returns an array of closest reflection probes with weights, weight shows how much influence the probe has on the renderer, this value is also used when blending between reflection probes occur."
	}
,
	"BillboardRenderer.GetMaterials": {
		"prefix": "BillboardRenderer.GetMaterials",
		"body": [
			"GetMaterials($1)"
		],
		"description": "public void GetMaterials(List<Material> m); des: Returns all the instantiated materials of this object."
	}
,
	"BillboardRenderer.GetPropertyBlock": {
		"prefix": "BillboardRenderer.GetPropertyBlock",
		"body": [
			"GetPropertyBlock($1)"
		],
		"description": "public void GetPropertyBlock(MaterialPropertyBlock properties); public void GetPropertyBlock(MaterialPropertyBlock properties, int materialIndex); des: Get per-Renderer or per-Material property block."
	}
,
	"BillboardRenderer.GetSharedMaterials": {
		"prefix": "BillboardRenderer.GetSharedMaterials",
		"body": [
			"GetSharedMaterials($1)"
		],
		"description": "public void GetSharedMaterials(List<Material> m); des: Returns all the shared materials of this object."
	}
,
	"BillboardRenderer.HasPropertyBlock": {
		"prefix": "BillboardRenderer.HasPropertyBlock",
		"body": [
			"HasPropertyBlock($1)"
		],
		"description": "public bool HasPropertyBlock(); des: Returns true if the Renderer has a material property block attached via SetPropertyBlock."
	}
,
	"BillboardRenderer.SetPropertyBlock": {
		"prefix": "BillboardRenderer.SetPropertyBlock",
		"body": [
			"SetPropertyBlock($1)"
		],
		"description": "public void SetPropertyBlock(MaterialPropertyBlock properties); public void SetPropertyBlock(MaterialPropertyBlock properties, int materialIndex); des: Lets you set or clear per-renderer or per-material parameter overrides."
	}
,
	"BillboardRenderer.Destroy": {
		"prefix": "BillboardRenderer.Destroy",
		"body": [
			"BillboardRenderer.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"BillboardRenderer.DestroyImmediate": {
		"prefix": "BillboardRenderer.DestroyImmediate",
		"body": [
			"BillboardRenderer.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"BillboardRenderer.DontDestroyOnLoad": {
		"prefix": "BillboardRenderer.DontDestroyOnLoad",
		"body": [
			"BillboardRenderer.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"BillboardRenderer.FindObjectOfType": {
		"prefix": "BillboardRenderer.FindObjectOfType",
		"body": [
			"BillboardRenderer.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"BillboardRenderer.FindObjectsOfType": {
		"prefix": "BillboardRenderer.FindObjectsOfType",
		"body": [
			"BillboardRenderer.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"BillboardRenderer.Instantiate": {
		"prefix": "BillboardRenderer.Instantiate",
		"body": [
			"BillboardRenderer.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"BillboardRenderer.OnBecameInvisible": {
		"prefix": "BillboardRenderer.OnBecameInvisible",
		"body": [
			"OnBecameInvisible"
		],
		"description": "OnBecameInvisible is called when the object is no longer visible by any camera."
	}
,
	"BillboardRenderer.OnBecameVisible": {
		"prefix": "BillboardRenderer.OnBecameVisible",
		"body": [
			"OnBecameVisible"
		],
		"description": "OnBecameVisible is called when the object became visible by any camera."
	}
,
	"BoneWeight.boneIndex0": {
		"prefix": "BoneWeight.boneIndex0",
		"body": [
			"boneIndex0"
		],
		"description": "return:int des: Index of first bone."
	}
,
	"BoneWeight.boneIndex1": {
		"prefix": "BoneWeight.boneIndex1",
		"body": [
			"boneIndex1"
		],
		"description": "return:int des: Index of second bone."
	}
,
	"BoneWeight.boneIndex2": {
		"prefix": "BoneWeight.boneIndex2",
		"body": [
			"boneIndex2"
		],
		"description": "return:int des: Index of third bone."
	}
,
	"BoneWeight.boneIndex3": {
		"prefix": "BoneWeight.boneIndex3",
		"body": [
			"boneIndex3"
		],
		"description": "return:int des: Index of fourth bone."
	}
,
	"BoneWeight.weight0": {
		"prefix": "BoneWeight.weight0",
		"body": [
			"weight0"
		],
		"description": "return:float des: Skinning weight for first bone."
	}
,
	"BoneWeight.weight1": {
		"prefix": "BoneWeight.weight1",
		"body": [
			"weight1"
		],
		"description": "return:float des: Skinning weight for second bone."
	}
,
	"BoneWeight.weight2": {
		"prefix": "BoneWeight.weight2",
		"body": [
			"weight2"
		],
		"description": "return:float des: Skinning weight for third bone."
	}
,
	"BoneWeight.weight3": {
		"prefix": "BoneWeight.weight3",
		"body": [
			"weight3"
		],
		"description": "return:float des: Skinning weight for fourth bone."
	}
,
	"BoundingSphere.position": {
		"prefix": "BoundingSphere.position",
		"body": [
			"position"
		],
		"description": "return:Vector3 des: The position of the center of the BoundingSphere."
	}
,
	"BoundingSphere.radius": {
		"prefix": "BoundingSphere.radius",
		"body": [
			"radius"
		],
		"description": "return:float des: The radius of the BoundingSphere."
	}
,
	"Bounds.center": {
		"prefix": "Bounds.center",
		"body": [
			"center"
		],
		"description": "return:Vector3 des: The center of the bounding box."
	}
,
	"Bounds.extents": {
		"prefix": "Bounds.extents",
		"body": [
			"extents"
		],
		"description": "return:Vector3 des: The extents of the Bounding Box. This is always half of the size of the Bounds."
	}
,
	"Bounds.max": {
		"prefix": "Bounds.max",
		"body": [
			"max"
		],
		"description": "return:Vector3 des: The maximal point of the box. This is always equal to center+extents."
	}
,
	"Bounds.min": {
		"prefix": "Bounds.min",
		"body": [
			"min"
		],
		"description": "return:Vector3 des: The minimal point of the box. This is always equal to center-extents."
	}
,
	"Bounds.size": {
		"prefix": "Bounds.size",
		"body": [
			"size"
		],
		"description": "return:Vector3 des: The total size of the box. This is always twice as large as the extents."
	}
,
	"Bounds.ClosestPoint": {
		"prefix": "Bounds.ClosestPoint",
		"body": [
			"ClosestPoint($1)"
		],
		"description": "public Vector3 ClosestPoint(Vector3 point); des: The closest point on the bounding box."
	}
,
	"Bounds.Contains": {
		"prefix": "Bounds.Contains",
		"body": [
			"Contains($1)"
		],
		"description": "public bool Contains(Vector3 point); des: Is point contained in the bounding box?"
	}
,
	"Bounds.Encapsulate": {
		"prefix": "Bounds.Encapsulate",
		"body": [
			"Encapsulate($1)"
		],
		"description": "public void Encapsulate(Vector3 point); public void Encapsulate(Bounds bounds); des: Grows the Bounds to include the point."
	}
,
	"Bounds.Expand": {
		"prefix": "Bounds.Expand",
		"body": [
			"Expand($1)"
		],
		"description": "public void Expand(float amount); public void Expand(Vector3 amount); des: Expand the bounds by increasing its size by amount along each side."
	}
,
	"Bounds.IntersectRay": {
		"prefix": "Bounds.IntersectRay",
		"body": [
			"IntersectRay($1)"
		],
		"description": "public bool IntersectRay(Ray ray); public bool IntersectRay(Ray ray, out float distance); des: Does ray intersect this bounding box?"
	}
,
	"Bounds.Intersects": {
		"prefix": "Bounds.Intersects",
		"body": [
			"Intersects($1)"
		],
		"description": "public bool Intersects(Bounds bounds); des: Does another bounding box intersect with this bounding box?"
	}
,
	"Bounds.SetMinMax": {
		"prefix": "Bounds.SetMinMax",
		"body": [
			"SetMinMax($1)"
		],
		"description": "public void SetMinMax(Vector3 min, Vector3 max); des: Sets the bounds to the min and max value of the box."
	}
,
	"Bounds.SqrDistance": {
		"prefix": "Bounds.SqrDistance",
		"body": [
			"SqrDistance($1)"
		],
		"description": "public float SqrDistance(Vector3 point); des: The smallest squared distance between the point and this bounding box."
	}
,
	"Bounds.ToString": {
		"prefix": "Bounds.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); public string ToString(string format); des: Returns a nicely formatted string for the bounds."
	}
,
	"BoundsInt.allPositionsWithin": {
		"prefix": "BoundsInt.allPositionsWithin",
		"body": [
			"allPositionsWithin"
		],
		"description": "return:BoundsInt.PositionEnumerator des: A BoundsInt.PositionCollection that contains all positions within the BoundsInt."
	}
,
	"BoundsInt.center": {
		"prefix": "BoundsInt.center",
		"body": [
			"center"
		],
		"description": "return:Vector3 des: The center of the bounding box."
	}
,
	"BoundsInt.max": {
		"prefix": "BoundsInt.max",
		"body": [
			"max"
		],
		"description": "return:Vector3Int des: The maximal point of the box."
	}
,
	"BoundsInt.min": {
		"prefix": "BoundsInt.min",
		"body": [
			"min"
		],
		"description": "return:Vector3Int des: The minimal point of the box."
	}
,
	"BoundsInt.position": {
		"prefix": "BoundsInt.position",
		"body": [
			"position"
		],
		"description": "return:Vector3Int des: The position of the bounding box."
	}
,
	"BoundsInt.size": {
		"prefix": "BoundsInt.size",
		"body": [
			"size"
		],
		"description": "return:Vector3Int des: The total size of the box."
	}
,
	"BoundsInt.x": {
		"prefix": "BoundsInt.x",
		"body": [
			"x"
		],
		"description": "return:int des: X value of the minimal point of the box."
	}
,
	"BoundsInt.xMax": {
		"prefix": "BoundsInt.xMax",
		"body": [
			"xMax"
		],
		"description": "return:int des: The maximal x point of the box."
	}
,
	"BoundsInt.xMin": {
		"prefix": "BoundsInt.xMin",
		"body": [
			"xMin"
		],
		"description": "return:int des: The minimal x point of the box."
	}
,
	"BoundsInt.y": {
		"prefix": "BoundsInt.y",
		"body": [
			"y"
		],
		"description": "return:int des: Y value of the minimal point of the box."
	}
,
	"BoundsInt.yMax": {
		"prefix": "BoundsInt.yMax",
		"body": [
			"yMax"
		],
		"description": "return:int des: The maximal y point of the box."
	}
,
	"BoundsInt.yMin": {
		"prefix": "BoundsInt.yMin",
		"body": [
			"yMin"
		],
		"description": "return:int des: The minimal y point of the box."
	}
,
	"BoundsInt.z": {
		"prefix": "BoundsInt.z",
		"body": [
			"z"
		],
		"description": "return:int des: Z value of the minimal point of the box."
	}
,
	"BoundsInt.zMax": {
		"prefix": "BoundsInt.zMax",
		"body": [
			"zMax"
		],
		"description": "return:int des: The maximal z point of the box."
	}
,
	"BoundsInt.zMin": {
		"prefix": "BoundsInt.zMin",
		"body": [
			"zMin"
		],
		"description": "return:int des: The minimal z point of the box."
	}
,
	"BoundsInt.ClampToBounds": {
		"prefix": "BoundsInt.ClampToBounds",
		"body": [
			"ClampToBounds($1)"
		],
		"description": "public void ClampToBounds(BoundsInt bounds); des: Clamps the position and size of this bounding box to the given bounds."
	}
,
	"BoundsInt.Contains": {
		"prefix": "BoundsInt.Contains",
		"body": [
			"Contains($1)"
		],
		"description": "public bool Contains(Vector3Int position);  des: Is point contained in the bounding box?"
	}
,
	"BoundsInt.SetMinMax": {
		"prefix": "BoundsInt.SetMinMax",
		"body": [
			"SetMinMax($1)"
		],
		"description": "public void SetMinMax(Vector3Int minPosition, Vector3Int maxPosition); des: Sets the bounds to the min and max value of the box."
	}
,
	"BoundsInt.ToString": {
		"prefix": "BoundsInt.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns a nicely formatted string for the bounds."
	}
,
	"BoundsInt.PositionEnumerator.Current": {
		"prefix": "BoundsInt.PositionEnumerator.Current",
		"body": [
			"Current"
		],
		"description": "return:Vector3Int des: Current position of the enumerator."
	}
,
	"BoundsInt.PositionEnumerator.GetEnumerator": {
		"prefix": "BoundsInt.PositionEnumerator.GetEnumerator",
		"body": [
			"GetEnumerator($1)"
		],
		"description": "public BoundsInt.PositionEnumerator GetEnumerator(); des: Returns this as an iterator that allows you to iterate over all positions within the BoundsInt."
	}
,
	"BoundsInt.PositionEnumerator.MoveNext": {
		"prefix": "BoundsInt.PositionEnumerator.MoveNext",
		"body": [
			"MoveNext($1)"
		],
		"description": "public bool MoveNext(); des: Moves the enumerator to the next position."
	}
,
	"BoundsInt.PositionEnumerator.Reset": {
		"prefix": "BoundsInt.PositionEnumerator.Reset",
		"body": [
			"Reset($1)"
		],
		"description": "public void Reset(); des: Resets this enumerator to its starting state."
	}
,
	"BoxCollider.center": {
		"prefix": "BoxCollider.center",
		"body": [
			"center"
		],
		"description": "return:Vector3 des: The center of the box, measured in the object's local space."
	}
,
	"BoxCollider.size": {
		"prefix": "BoxCollider.size",
		"body": [
			"size"
		],
		"description": "return:Vector3 des: The size of the box, measured in the object's local space."
	}
,
	"BoxCollider.attachedRigidbody": {
		"prefix": "BoxCollider.attachedRigidbody",
		"body": [
			"attachedRigidbody"
		],
		"description": "return:Rigidbody des: The rigidbody the collider is attached to."
	}
,
	"BoxCollider.bounds": {
		"prefix": "BoxCollider.bounds",
		"body": [
			"bounds"
		],
		"description": "return:Bounds des: The world space bounding volume of the collider (Read Only)."
	}
,
	"BoxCollider.contactOffset": {
		"prefix": "BoxCollider.contactOffset",
		"body": [
			"contactOffset"
		],
		"description": "return:float des: Contact offset value of this collider."
	}
,
	"BoxCollider.enabled": {
		"prefix": "BoxCollider.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Colliders will collide with other Colliders, disabled Colliders won't."
	}
,
	"BoxCollider.isTrigger": {
		"prefix": "BoxCollider.isTrigger",
		"body": [
			"isTrigger"
		],
		"description": "return:bool des: Is the collider a trigger?"
	}
,
	"BoxCollider.material": {
		"prefix": "BoxCollider.material",
		"body": [
			"material"
		],
		"description": "return:PhysicMaterial des: The material used by the collider."
	}
,
	"BoxCollider.sharedMaterial": {
		"prefix": "BoxCollider.sharedMaterial",
		"body": [
			"sharedMaterial"
		],
		"description": "return:PhysicMaterial des: The shared physic material of this collider."
	}
,
	"BoxCollider.gameObject": {
		"prefix": "BoxCollider.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"BoxCollider.tag": {
		"prefix": "BoxCollider.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"BoxCollider.transform": {
		"prefix": "BoxCollider.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"BoxCollider.hideFlags": {
		"prefix": "BoxCollider.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"BoxCollider.name": {
		"prefix": "BoxCollider.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"BoxCollider.ClosestPoint": {
		"prefix": "BoxCollider.ClosestPoint",
		"body": [
			"ClosestPoint($1)"
		],
		"description": "public Vector3 ClosestPoint(Vector3 position); des: Returns a point on the collider that is closest to a given location."
	}
,
	"BoxCollider.ClosestPointOnBounds": {
		"prefix": "BoxCollider.ClosestPointOnBounds",
		"body": [
			"ClosestPointOnBounds($1)"
		],
		"description": "public Vector3 ClosestPointOnBounds(Vector3 position); des: The closest point to the bounding box of the attached collider."
	}
,
	"BoxCollider.Raycast": {
		"prefix": "BoxCollider.Raycast",
		"body": [
			"Raycast($1)"
		],
		"description": "public bool Raycast(Ray ray, out RaycastHit hitInfo, float maxDistance); des: Casts a Ray that ignores all Colliders except this one."
	}
,
	"BoxCollider.BroadcastMessage": {
		"prefix": "BoxCollider.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"BoxCollider.CompareTag": {
		"prefix": "BoxCollider.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"BoxCollider.GetComponent": {
		"prefix": "BoxCollider.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"BoxCollider.GetComponentInChildren": {
		"prefix": "BoxCollider.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"BoxCollider.GetComponentInParent": {
		"prefix": "BoxCollider.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"BoxCollider.GetComponents": {
		"prefix": "BoxCollider.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"BoxCollider.GetComponentsInChildren": {
		"prefix": "BoxCollider.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"BoxCollider.GetComponentsInParent": {
		"prefix": "BoxCollider.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"BoxCollider.SendMessage": {
		"prefix": "BoxCollider.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"BoxCollider.SendMessageUpwards": {
		"prefix": "BoxCollider.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"BoxCollider.GetInstanceID": {
		"prefix": "BoxCollider.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"BoxCollider.ToString": {
		"prefix": "BoxCollider.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"BoxCollider.Destroy": {
		"prefix": "BoxCollider.Destroy",
		"body": [
			"BoxCollider.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"BoxCollider.DestroyImmediate": {
		"prefix": "BoxCollider.DestroyImmediate",
		"body": [
			"BoxCollider.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"BoxCollider.DontDestroyOnLoad": {
		"prefix": "BoxCollider.DontDestroyOnLoad",
		"body": [
			"BoxCollider.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"BoxCollider.FindObjectOfType": {
		"prefix": "BoxCollider.FindObjectOfType",
		"body": [
			"BoxCollider.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"BoxCollider.FindObjectsOfType": {
		"prefix": "BoxCollider.FindObjectsOfType",
		"body": [
			"BoxCollider.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"BoxCollider.Instantiate": {
		"prefix": "BoxCollider.Instantiate",
		"body": [
			"BoxCollider.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"BoxCollider.OnCollisionEnter": {
		"prefix": "BoxCollider.OnCollisionEnter",
		"body": [
			"OnCollisionEnter"
		],
		"description": "OnCollisionEnter is called when this collider/rigidbody has begun touching another rigidbody/collider."
	}
,
	"BoxCollider.OnCollisionExit": {
		"prefix": "BoxCollider.OnCollisionExit",
		"body": [
			"OnCollisionExit"
		],
		"description": "OnCollisionExit is called when this collider/rigidbody has stopped touching another rigidbody/collider."
	}
,
	"BoxCollider.OnCollisionStay": {
		"prefix": "BoxCollider.OnCollisionStay",
		"body": [
			"OnCollisionStay"
		],
		"description": "OnCollisionStay is called once per frame for every collider/rigidbody that is touching rigidbody/collider."
	}
,
	"BoxCollider.OnTriggerEnter": {
		"prefix": "BoxCollider.OnTriggerEnter",
		"body": [
			"OnTriggerEnter"
		],
		"description": "OnTriggerEnter is called when the Collider other enters the trigger."
	}
,
	"BoxCollider.OnTriggerExit": {
		"prefix": "BoxCollider.OnTriggerExit",
		"body": [
			"OnTriggerExit"
		],
		"description": "OnTriggerExit is called when the Collider other has stopped touching the trigger."
	}
,
	"BoxCollider.OnTriggerStay": {
		"prefix": "BoxCollider.OnTriggerStay",
		"body": [
			"OnTriggerStay"
		],
		"description": "OnTriggerStay is called almost all the frames for every Collider other that is touching the trigger. The function is on the physics timer so it won't necessarily run every frame."
	}
,
	"BoxCollider2D.autoTiling": {
		"prefix": "BoxCollider2D.autoTiling",
		"body": [
			"autoTiling"
		],
		"description": "return:bool des: Determines whether the BoxCollider2D's shape is automatically updated based on a SpriteRenderer's tiling properties."
	}
,
	"BoxCollider2D.edgeRadius": {
		"prefix": "BoxCollider2D.edgeRadius",
		"body": [
			"edgeRadius"
		],
		"description": "return:float des: Controls the radius of all edges created by the collider."
	}
,
	"BoxCollider2D.size": {
		"prefix": "BoxCollider2D.size",
		"body": [
			"size"
		],
		"description": "return:Vector2 des: The width and height of the rectangle."
	}
,
	"BoxCollider2D.enabled": {
		"prefix": "BoxCollider2D.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"BoxCollider2D.isActiveAndEnabled": {
		"prefix": "BoxCollider2D.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"BoxCollider2D.attachedRigidbody": {
		"prefix": "BoxCollider2D.attachedRigidbody",
		"body": [
			"attachedRigidbody"
		],
		"description": "return:Rigidbody2D des: The Rigidbody2D attached to the Collider2D."
	}
,
	"BoxCollider2D.bounciness": {
		"prefix": "BoxCollider2D.bounciness",
		"body": [
			"bounciness"
		],
		"description": "return:float des: Get the bounciness used by the collider."
	}
,
	"BoxCollider2D.bounds": {
		"prefix": "BoxCollider2D.bounds",
		"body": [
			"bounds"
		],
		"description": "return:Bounds des: The world space bounding area of the collider."
	}
,
	"BoxCollider2D.composite": {
		"prefix": "BoxCollider2D.composite",
		"body": [
			"composite"
		],
		"description": "return:CompositeCollider2D des: Get the CompositeCollider2D that is available to be attached to the collider."
	}
,
	"BoxCollider2D.density": {
		"prefix": "BoxCollider2D.density",
		"body": [
			"density"
		],
		"description": "return:float des: The density of the collider used to calculate its mass (when auto mass is enabled)."
	}
,
	"BoxCollider2D.friction": {
		"prefix": "BoxCollider2D.friction",
		"body": [
			"friction"
		],
		"description": "return:float des: Get the friction used by the collider."
	}
,
	"BoxCollider2D.isTrigger": {
		"prefix": "BoxCollider2D.isTrigger",
		"body": [
			"isTrigger"
		],
		"description": "return:bool des: Is this collider configured as a trigger?"
	}
,
	"BoxCollider2D.offset": {
		"prefix": "BoxCollider2D.offset",
		"body": [
			"offset"
		],
		"description": "return:Vector2 des: The local offset of the collider geometry."
	}
,
	"BoxCollider2D.shapeCount": {
		"prefix": "BoxCollider2D.shapeCount",
		"body": [
			"shapeCount"
		],
		"description": "return:int des: The number of separate shaped regions in the collider."
	}
,
	"BoxCollider2D.sharedMaterial": {
		"prefix": "BoxCollider2D.sharedMaterial",
		"body": [
			"sharedMaterial"
		],
		"description": "return:PhysicsMaterial2D des: The PhysicsMaterial2D that is applied to this collider."
	}
,
	"BoxCollider2D.usedByComposite": {
		"prefix": "BoxCollider2D.usedByComposite",
		"body": [
			"usedByComposite"
		],
		"description": "return:bool des: Sets whether the Collider will be used or not used by a CompositeCollider2D."
	}
,
	"BoxCollider2D.usedByEffector": {
		"prefix": "BoxCollider2D.usedByEffector",
		"body": [
			"usedByEffector"
		],
		"description": "return:bool des: Whether the collider is used by an attached effector or not."
	}
,
	"BoxCollider2D.gameObject": {
		"prefix": "BoxCollider2D.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"BoxCollider2D.tag": {
		"prefix": "BoxCollider2D.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"BoxCollider2D.transform": {
		"prefix": "BoxCollider2D.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"BoxCollider2D.hideFlags": {
		"prefix": "BoxCollider2D.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"BoxCollider2D.name": {
		"prefix": "BoxCollider2D.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"BoxCollider2D.Cast": {
		"prefix": "BoxCollider2D.Cast",
		"body": [
			"Cast($1)"
		],
		"description": "public int Cast(Vector2 direction, RaycastHit2D[] results, float distance = Mathf.Infinity, bool ignoreSiblingColliders = true); public int Cast(Vector2 direction, ContactFilter2D contactFilter, RaycastHit2D[] results, float distance = Mathf.Infinity, bool ignoreSiblingColliders = true); des: Casts the collider shape into the scene starting at the collider position ignoring the collider itself."
	}
,
	"BoxCollider2D.Distance": {
		"prefix": "BoxCollider2D.Distance",
		"body": [
			"Distance($1)"
		],
		"description": "public ColliderDistance2D Distance(Collider2D collider); des: Calculates the minimum separation of this collider against another collider."
	}
,
	"BoxCollider2D.GetContacts": {
		"prefix": "BoxCollider2D.GetContacts",
		"body": [
			"GetContacts($1)"
		],
		"description": "public int GetContacts(ContactPoint2D[] contacts); public int GetContacts(Collider2D[] colliders); public int GetContacts(ContactFilter2D contactFilter, ContactPoint2D[] contacts); public int GetContacts(ContactFilter2D contactFilter, Collider2D[] colliders); des: Retrieves all contact points for this collider."
	}
,
	"BoxCollider2D.IsTouching": {
		"prefix": "BoxCollider2D.IsTouching",
		"body": [
			"IsTouching($1)"
		],
		"description": "public bool IsTouching(Collider2D collider); public bool IsTouching(Collider2D collider, ContactFilter2D contactFilter); public bool IsTouching(ContactFilter2D contactFilter); des: Check whether this collider is touching the collider or not."
	}
,
	"BoxCollider2D.IsTouchingLayers": {
		"prefix": "BoxCollider2D.IsTouchingLayers",
		"body": [
			"IsTouchingLayers($1)"
		],
		"description": "public bool IsTouchingLayers(int layerMask = Physics2D.AllLayers); des: Checks whether this collider is touching any colliders on the specified layerMask or not."
	}
,
	"BoxCollider2D.OverlapCollider": {
		"prefix": "BoxCollider2D.OverlapCollider",
		"body": [
			"OverlapCollider($1)"
		],
		"description": "public int OverlapCollider(ContactFilter2D contactFilter, Collider2D[] results); des: Get a list of all colliders that overlap this collider."
	}
,
	"BoxCollider2D.OverlapPoint": {
		"prefix": "BoxCollider2D.OverlapPoint",
		"body": [
			"OverlapPoint($1)"
		],
		"description": "public bool OverlapPoint(Vector2 point); des: Check if a collider overlaps a point in space."
	}
,
	"BoxCollider2D.Raycast": {
		"prefix": "BoxCollider2D.Raycast",
		"body": [
			"Raycast($1)"
		],
		"description": "public int Raycast(Vector2 direction, RaycastHit2D[] results, float distance = Mathf.Infinity, int layerMask = Physics2D.AllLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); public int Raycast(Vector2 direction, ContactFilter2D contactFilter, RaycastHit2D[] results, float distance = Mathf.Infinity); des: Casts a ray into the scene starting at the collider position ignoring the collider itself."
	}
,
	"BoxCollider2D.BroadcastMessage": {
		"prefix": "BoxCollider2D.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"BoxCollider2D.CompareTag": {
		"prefix": "BoxCollider2D.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"BoxCollider2D.GetComponent": {
		"prefix": "BoxCollider2D.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"BoxCollider2D.GetComponentInChildren": {
		"prefix": "BoxCollider2D.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"BoxCollider2D.GetComponentInParent": {
		"prefix": "BoxCollider2D.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"BoxCollider2D.GetComponents": {
		"prefix": "BoxCollider2D.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"BoxCollider2D.GetComponentsInChildren": {
		"prefix": "BoxCollider2D.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"BoxCollider2D.GetComponentsInParent": {
		"prefix": "BoxCollider2D.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"BoxCollider2D.SendMessage": {
		"prefix": "BoxCollider2D.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"BoxCollider2D.SendMessageUpwards": {
		"prefix": "BoxCollider2D.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"BoxCollider2D.GetInstanceID": {
		"prefix": "BoxCollider2D.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"BoxCollider2D.ToString": {
		"prefix": "BoxCollider2D.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"BoxCollider2D.Destroy": {
		"prefix": "BoxCollider2D.Destroy",
		"body": [
			"BoxCollider2D.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"BoxCollider2D.DestroyImmediate": {
		"prefix": "BoxCollider2D.DestroyImmediate",
		"body": [
			"BoxCollider2D.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"BoxCollider2D.DontDestroyOnLoad": {
		"prefix": "BoxCollider2D.DontDestroyOnLoad",
		"body": [
			"BoxCollider2D.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"BoxCollider2D.FindObjectOfType": {
		"prefix": "BoxCollider2D.FindObjectOfType",
		"body": [
			"BoxCollider2D.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"BoxCollider2D.FindObjectsOfType": {
		"prefix": "BoxCollider2D.FindObjectsOfType",
		"body": [
			"BoxCollider2D.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"BoxCollider2D.Instantiate": {
		"prefix": "BoxCollider2D.Instantiate",
		"body": [
			"BoxCollider2D.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"BoxCollider2D.OnCollisionEnter2D": {
		"prefix": "BoxCollider2D.OnCollisionEnter2D",
		"body": [
			"OnCollisionEnter2D"
		],
		"description": "Sent when an incoming collider makes contact with this object's collider (2D physics only)."
	}
,
	"BoxCollider2D.OnCollisionExit2D": {
		"prefix": "BoxCollider2D.OnCollisionExit2D",
		"body": [
			"OnCollisionExit2D"
		],
		"description": "Sent when a collider on another object stops touching this object's collider (2D physics only)."
	}
,
	"BoxCollider2D.OnCollisionStay2D": {
		"prefix": "BoxCollider2D.OnCollisionStay2D",
		"body": [
			"OnCollisionStay2D"
		],
		"description": "Sent each frame where a collider on another object is touching this object's collider (2D physics only)."
	}
,
	"BoxCollider2D.OnTriggerEnter2D": {
		"prefix": "BoxCollider2D.OnTriggerEnter2D",
		"body": [
			"OnTriggerEnter2D"
		],
		"description": "Sent when another object enters a trigger collider attached to this object (2D physics only)."
	}
,
	"BoxCollider2D.OnTriggerExit2D": {
		"prefix": "BoxCollider2D.OnTriggerExit2D",
		"body": [
			"OnTriggerExit2D"
		],
		"description": "Sent when another object leaves a trigger collider attached to this object (2D physics only)."
	}
,
	"BoxCollider2D.OnTriggerStay2D": {
		"prefix": "BoxCollider2D.OnTriggerStay2D",
		"body": [
			"OnTriggerStay2D"
		],
		"description": "Sent each frame where another object is within a trigger collider attached to this object (2D physics only)."
	}
,
	"BuoyancyEffector2D.angularDrag": {
		"prefix": "BuoyancyEffector2D.angularDrag",
		"body": [
			"angularDrag"
		],
		"description": "return:float des: A force applied to slow angular movement of any Collider2D in contact with the effector."
	}
,
	"BuoyancyEffector2D.density": {
		"prefix": "BuoyancyEffector2D.density",
		"body": [
			"density"
		],
		"description": "return:float des: The density of the fluid used to calculate the buoyancy forces."
	}
,
	"BuoyancyEffector2D.flowAngle": {
		"prefix": "BuoyancyEffector2D.flowAngle",
		"body": [
			"flowAngle"
		],
		"description": "return:float des: The angle of the force used to similate fluid flow."
	}
,
	"BuoyancyEffector2D.flowMagnitude": {
		"prefix": "BuoyancyEffector2D.flowMagnitude",
		"body": [
			"flowMagnitude"
		],
		"description": "return:float des: The magnitude of the force used to similate fluid flow."
	}
,
	"BuoyancyEffector2D.flowVariation": {
		"prefix": "BuoyancyEffector2D.flowVariation",
		"body": [
			"flowVariation"
		],
		"description": "return:float des: The random variation of the force used to similate fluid flow."
	}
,
	"BuoyancyEffector2D.linearDrag": {
		"prefix": "BuoyancyEffector2D.linearDrag",
		"body": [
			"linearDrag"
		],
		"description": "return:float des: A force applied to slow linear movement of any Collider2D in contact with the effector."
	}
,
	"BuoyancyEffector2D.surfaceLevel": {
		"prefix": "BuoyancyEffector2D.surfaceLevel",
		"body": [
			"surfaceLevel"
		],
		"description": "return:float des: Defines an arbitrary horizontal line that represents the fluid surface level."
	}
,
	"BuoyancyEffector2D.enabled": {
		"prefix": "BuoyancyEffector2D.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"BuoyancyEffector2D.isActiveAndEnabled": {
		"prefix": "BuoyancyEffector2D.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"BuoyancyEffector2D.gameObject": {
		"prefix": "BuoyancyEffector2D.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"BuoyancyEffector2D.tag": {
		"prefix": "BuoyancyEffector2D.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"BuoyancyEffector2D.transform": {
		"prefix": "BuoyancyEffector2D.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"BuoyancyEffector2D.colliderMask": {
		"prefix": "BuoyancyEffector2D.colliderMask",
		"body": [
			"colliderMask"
		],
		"description": "return:int des: The mask used to select specific layers allowed to interact with the effector."
	}
,
	"BuoyancyEffector2D.useColliderMask": {
		"prefix": "BuoyancyEffector2D.useColliderMask",
		"body": [
			"useColliderMask"
		],
		"description": "return:bool des: Should the collider-mask be used or the global collision matrix?"
	}
,
	"BuoyancyEffector2D.hideFlags": {
		"prefix": "BuoyancyEffector2D.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"BuoyancyEffector2D.name": {
		"prefix": "BuoyancyEffector2D.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"BuoyancyEffector2D.BroadcastMessage": {
		"prefix": "BuoyancyEffector2D.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"BuoyancyEffector2D.CompareTag": {
		"prefix": "BuoyancyEffector2D.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"BuoyancyEffector2D.GetComponent": {
		"prefix": "BuoyancyEffector2D.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"BuoyancyEffector2D.GetComponentInChildren": {
		"prefix": "BuoyancyEffector2D.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"BuoyancyEffector2D.GetComponentInParent": {
		"prefix": "BuoyancyEffector2D.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"BuoyancyEffector2D.GetComponents": {
		"prefix": "BuoyancyEffector2D.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"BuoyancyEffector2D.GetComponentsInChildren": {
		"prefix": "BuoyancyEffector2D.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"BuoyancyEffector2D.GetComponentsInParent": {
		"prefix": "BuoyancyEffector2D.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"BuoyancyEffector2D.SendMessage": {
		"prefix": "BuoyancyEffector2D.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"BuoyancyEffector2D.SendMessageUpwards": {
		"prefix": "BuoyancyEffector2D.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"BuoyancyEffector2D.GetInstanceID": {
		"prefix": "BuoyancyEffector2D.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"BuoyancyEffector2D.ToString": {
		"prefix": "BuoyancyEffector2D.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"BuoyancyEffector2D.Destroy": {
		"prefix": "BuoyancyEffector2D.Destroy",
		"body": [
			"BuoyancyEffector2D.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"BuoyancyEffector2D.DestroyImmediate": {
		"prefix": "BuoyancyEffector2D.DestroyImmediate",
		"body": [
			"BuoyancyEffector2D.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"BuoyancyEffector2D.DontDestroyOnLoad": {
		"prefix": "BuoyancyEffector2D.DontDestroyOnLoad",
		"body": [
			"BuoyancyEffector2D.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"BuoyancyEffector2D.FindObjectOfType": {
		"prefix": "BuoyancyEffector2D.FindObjectOfType",
		"body": [
			"BuoyancyEffector2D.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"BuoyancyEffector2D.FindObjectsOfType": {
		"prefix": "BuoyancyEffector2D.FindObjectsOfType",
		"body": [
			"BuoyancyEffector2D.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"BuoyancyEffector2D.Instantiate": {
		"prefix": "BuoyancyEffector2D.Instantiate",
		"body": [
			"BuoyancyEffector2D.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"Cache.expirationDelay": {
		"prefix": "Cache.expirationDelay",
		"body": [
			"expirationDelay"
		],
		"description": "return:int des: The number of seconds that an AssetBundle may remain unused in the cache before it is automatically deleted."
	}
,
	"Cache.index": {
		"prefix": "Cache.index",
		"body": [
			"index"
		],
		"description": "return:int des: Returns the index of the cache in the cache list."
	}
,
	"Cache.maximumAvailableStorageSpace": {
		"prefix": "Cache.maximumAvailableStorageSpace",
		"body": [
			"maximumAvailableStorageSpace"
		],
		"description": "return:long des: Allows you to specify the total number of bytes that can be allocated for the cache."
	}
,
	"Cache.path": {
		"prefix": "Cache.path",
		"body": [
			"path"
		],
		"description": "return:string des: Returns the path of the cache."
	}
,
	"Cache.readOnly": {
		"prefix": "Cache.readOnly",
		"body": [
			"readOnly"
		],
		"description": "return:bool des: Returns true if the cache is readonly."
	}
,
	"Cache.ready": {
		"prefix": "Cache.ready",
		"body": [
			"ready"
		],
		"description": "return:bool des: Returns true if the cache is ready."
	}
,
	"Cache.spaceFree": {
		"prefix": "Cache.spaceFree",
		"body": [
			"spaceFree"
		],
		"description": "return:long des: Returns the number of currently unused bytes in the cache."
	}
,
	"Cache.spaceOccupied": {
		"prefix": "Cache.spaceOccupied",
		"body": [
			"spaceOccupied"
		],
		"description": "return:long des: Returns the used disk space in bytes."
	}
,
	"Cache.valid": {
		"prefix": "Cache.valid",
		"body": [
			"valid"
		],
		"description": "return:bool des: Returns true if the cache is valid."
	}
,
	"Cache.ClearCache": {
		"prefix": "Cache.ClearCache",
		"body": [
			"ClearCache($1)"
		],
		"description": "public bool ClearCache(); public bool ClearCache(int expiration); des: Removes all cached content in the cache that has been cached by the current application."
	}
,
	"CachedAssetBundle.hash": {
		"prefix": "CachedAssetBundle.hash",
		"body": [
			"hash"
		],
		"description": "return:Hash128 des: Hash128 which is used as the version of the AssetBundle."
	}
,
	"CachedAssetBundle.name": {
		"prefix": "CachedAssetBundle.name",
		"body": [
			"name"
		],
		"description": "return:string des: AssetBundle name which is used as the customized cache path."
	}
,
	"Caching.AddCache": {
		"prefix": "Caching.AddCache",
		"body": [
			"Caching.AddCache"
		],
		"description": "public static Cache AddCache(string cachePath); des: Add a cache with the given path."
	}
,
	"Caching.ClearAllCachedVersions": {
		"prefix": "Caching.ClearAllCachedVersions",
		"body": [
			"Caching.ClearAllCachedVersions"
		],
		"description": "public static bool ClearAllCachedVersions(string assetBundleName); des: Removes all the cached versions of the given AssetBundle from the cache."
	}
,
	"Caching.ClearCache": {
		"prefix": "Caching.ClearCache",
		"body": [
			"Caching.ClearCache"
		],
		"description": "public static bool ClearCache(); public static bool ClearCache(int expiration); des: Removes all AssetBundle content that has been cached by the current application."
	}
,
	"Caching.ClearCachedVersion": {
		"prefix": "Caching.ClearCachedVersion",
		"body": [
			"Caching.ClearCachedVersion"
		],
		"description": "public static bool ClearCachedVersion(string assetBundleName, Hash128 hash); des: Removes the given version of the AssetBundle."
	}
,
	"Caching.ClearOtherCachedVersions": {
		"prefix": "Caching.ClearOtherCachedVersions",
		"body": [
			"Caching.ClearOtherCachedVersions"
		],
		"description": "public static bool ClearOtherCachedVersions(string assetBundleName, Hash128 hash); des: Removes all the cached versions of the AssetBundle from the cache, except for the specified version."
	}
,
	"Caching.GetAllCachePaths": {
		"prefix": "Caching.GetAllCachePaths",
		"body": [
			"Caching.GetAllCachePaths"
		],
		"description": "public static void GetAllCachePaths(List<string> cachePaths); des: Returns all paths of the cache in the cache list."
	}
,
	"Caching.GetCacheAt": {
		"prefix": "Caching.GetCacheAt",
		"body": [
			"Caching.GetCacheAt"
		],
		"description": "public static Cache GetCacheAt(int cacheIndex); des: Returns the Cache at the given position in the cache list."
	}
,
	"Caching.GetCacheByPath": {
		"prefix": "Caching.GetCacheByPath",
		"body": [
			"Caching.GetCacheByPath"
		],
		"description": "public static Cache GetCacheByPath(string cachePath); des: Returns the Cache that has the given cache path."
	}
,
	"Caching.GetCachedVersions": {
		"prefix": "Caching.GetCachedVersions",
		"body": [
			"Caching.GetCachedVersions"
		],
		"description": "public static void GetCachedVersions(string assetBundleName, List<Hash128> outCachedVersions); des: Returns all cached versions of the given AssetBundle."
	}
,
	"Caching.IsVersionCached": {
		"prefix": "Caching.IsVersionCached",
		"body": [
			"Caching.IsVersionCached"
		],
		"description": "Obsolete public static bool IsVersionCached(string url, int version); des: Checks if an AssetBundle is cached."
	}
,
	"Caching.MarkAsUsed": {
		"prefix": "Caching.MarkAsUsed",
		"body": [
			"Caching.MarkAsUsed"
		],
		"description": "Obsolete public static bool MarkAsUsed(string url, int version); des: Bumps the timestamp of a cached file to be the current time."
	}
,
	"Caching.MoveCacheAfter": {
		"prefix": "Caching.MoveCacheAfter",
		"body": [
			"Caching.MoveCacheAfter"
		],
		"description": "public static void MoveCacheAfter(Cache src, Cache dst); des: Moves the source Cache after the destination Cache in the cache list."
	}
,
	"Caching.MoveCacheBefore": {
		"prefix": "Caching.MoveCacheBefore",
		"body": [
			"Caching.MoveCacheBefore"
		],
		"description": "public static void MoveCacheBefore(Cache src, Cache dst); des: Moves the source Cache before the destination Cache in the cache list."
	}
,
	"Caching.RemoveCache": {
		"prefix": "Caching.RemoveCache",
		"body": [
			"Caching.RemoveCache"
		],
		"description": "public static bool RemoveCache(Cache cache); des: Removes the Cache from cache list."
	}
,
	"Camera.activeTexture": {
		"prefix": "Camera.activeTexture",
		"body": [
			"activeTexture"
		],
		"description": "return:RenderTexture des: Gets the temporary RenderTexture target for this Camera."
	}
,
	"Camera.actualRenderingPath": {
		"prefix": "Camera.actualRenderingPath",
		"body": [
			"actualRenderingPath"
		],
		"description": "return:RenderingPath des: The rendering path that is currently being used (Read Only)."
	}
,
	"Camera.allowDynamicResolution": {
		"prefix": "Camera.allowDynamicResolution",
		"body": [
			"allowDynamicResolution"
		],
		"description": "return:bool des: Dynamic Resolution Scaling."
	}
,
	"Camera.allowHDR": {
		"prefix": "Camera.allowHDR",
		"body": [
			"allowHDR"
		],
		"description": "return:bool des: High dynamic range rendering."
	}
,
	"Camera.allowMSAA": {
		"prefix": "Camera.allowMSAA",
		"body": [
			"allowMSAA"
		],
		"description": "return:bool des: MSAA rendering."
	}
,
	"Camera.areVRStereoViewMatricesWithinSingleCullTolerance": {
		"prefix": "Camera.areVRStereoViewMatricesWithinSingleCullTolerance",
		"body": [
			"areVRStereoViewMatricesWithinSingleCullTolerance"
		],
		"description": "return:bool des: Determines whether the stereo view matrices are suitable to allow for a single pass cull."
	}
,
	"Camera.aspect": {
		"prefix": "Camera.aspect",
		"body": [
			"aspect"
		],
		"description": "return:float des: The aspect ratio (width divided by height)."
	}
,
	"Camera.backgroundColor": {
		"prefix": "Camera.backgroundColor",
		"body": [
			"backgroundColor"
		],
		"description": "return:Color des: The color with which the screen will be cleared."
	}
,
	"Camera.cameraToWorldMatrix": {
		"prefix": "Camera.cameraToWorldMatrix",
		"body": [
			"cameraToWorldMatrix"
		],
		"description": "return:Matrix4x4 des: Matrix that transforms from camera space to world space (Read Only)."
	}
,
	"Camera.cameraType": {
		"prefix": "Camera.cameraType",
		"body": [
			"cameraType"
		],
		"description": "return:CameraType des: Identifies what kind of camera this is."
	}
,
	"Camera.clearFlags": {
		"prefix": "Camera.clearFlags",
		"body": [
			"clearFlags"
		],
		"description": "return:CameraClearFlags des: How the camera clears the background."
	}
,
	"Camera.clearStencilAfterLightingPass": {
		"prefix": "Camera.clearStencilAfterLightingPass",
		"body": [
			"clearStencilAfterLightingPass"
		],
		"description": "return:bool des: Should the camera clear the stencil buffer after the deferred light pass?"
	}
,
	"Camera.commandBufferCount": {
		"prefix": "Camera.commandBufferCount",
		"body": [
			"commandBufferCount"
		],
		"description": "return:int des: Number of command buffers set up on this camera (Read Only)."
	}
,
	"Camera.cullingMask": {
		"prefix": "Camera.cullingMask",
		"body": [
			"cullingMask"
		],
		"description": "return:int des: This is used to render parts of the Scene selectively."
	}
,
	"Camera.cullingMatrix": {
		"prefix": "Camera.cullingMatrix",
		"body": [
			"cullingMatrix"
		],
		"description": "return:Matrix4x4 des: Sets a custom matrix for the camera to use for all culling queries."
	}
,
	"Camera.depth": {
		"prefix": "Camera.depth",
		"body": [
			"depth"
		],
		"description": "return:float des: Camera's depth in the camera rendering order."
	}
,
	"Camera.depthTextureMode": {
		"prefix": "Camera.depthTextureMode",
		"body": [
			"depthTextureMode"
		],
		"description": "return:DepthTextureMode des: How and if camera generates a depth texture."
	}
,
	"Camera.eventMask": {
		"prefix": "Camera.eventMask",
		"body": [
			"eventMask"
		],
		"description": "return:int des: Mask to select which layers can trigger events on the camera."
	}
,
	"Camera.farClipPlane": {
		"prefix": "Camera.farClipPlane",
		"body": [
			"farClipPlane"
		],
		"description": "return:float des: The far clipping plane distance."
	}
,
	"Camera.fieldOfView": {
		"prefix": "Camera.fieldOfView",
		"body": [
			"fieldOfView"
		],
		"description": "return:float des: The field of view of the camera in degrees."
	}
,
	"Camera.focalLength": {
		"prefix": "Camera.focalLength",
		"body": [
			"focalLength"
		],
		"description": "return:float des: The camera focal length, expressed in millimeters. To use this property, enable UsePhysicalProperties."
	}
,
	"Camera.forceIntoRenderTexture": {
		"prefix": "Camera.forceIntoRenderTexture",
		"body": [
			"forceIntoRenderTexture"
		],
		"description": "return:bool des: Should camera rendering be forced into a RenderTexture."
	}
,
	"Camera.layerCullDistances": {
		"prefix": "Camera.layerCullDistances",
		"body": [
			"layerCullDistances"
		],
		"description": "return:float[] des: Per-layer culling distances."
	}
,
	"Camera.layerCullSpherical": {
		"prefix": "Camera.layerCullSpherical",
		"body": [
			"layerCullSpherical"
		],
		"description": "return:bool des: How to perform per-layer culling for a Camera."
	}
,
	"Camera.lensShift": {
		"prefix": "Camera.lensShift",
		"body": [
			"lensShift"
		],
		"description": "return:Vector2 des: The lens offset of the camera. The lens shift is relative to the sensor size. For example, a lens shift of 0.5 offsets the sensor by half its horizontal size."
	}
,
	"Camera.nearClipPlane": {
		"prefix": "Camera.nearClipPlane",
		"body": [
			"nearClipPlane"
		],
		"description": "return:float des: The near clipping plane distance."
	}
,
	"Camera.nonJitteredProjectionMatrix": {
		"prefix": "Camera.nonJitteredProjectionMatrix",
		"body": [
			"nonJitteredProjectionMatrix"
		],
		"description": "return:Matrix4x4 des: Get or set the raw projection matrix with no camera offset (no jittering)."
	}
,
	"Camera.opaqueSortMode": {
		"prefix": "Camera.opaqueSortMode",
		"body": [
			"opaqueSortMode"
		],
		"description": "return:Rendering.OpaqueSortMode des: Opaque object sorting mode."
	}
,
	"Camera.orthographic": {
		"prefix": "Camera.orthographic",
		"body": [
			"orthographic"
		],
		"description": "return:bool des: Is the camera orthographic (true) or perspective (false)?"
	}
,
	"Camera.orthographicSize": {
		"prefix": "Camera.orthographicSize",
		"body": [
			"orthographicSize"
		],
		"description": "return:float des: Camera's half-size when in orthographic mode."
	}
,
	"Camera.pixelHeight": {
		"prefix": "Camera.pixelHeight",
		"body": [
			"pixelHeight"
		],
		"description": "return:int des: How tall is the camera in pixels (not accounting for dynamic resolution scaling) (Read Only)."
	}
,
	"Camera.pixelRect": {
		"prefix": "Camera.pixelRect",
		"body": [
			"pixelRect"
		],
		"description": "return:Rect des: Where on the screen is the camera rendered in pixel coordinates."
	}
,
	"Camera.pixelWidth": {
		"prefix": "Camera.pixelWidth",
		"body": [
			"pixelWidth"
		],
		"description": "return:int des: How wide is the camera in pixels (not accounting for dynamic resolution scaling) (Read Only)."
	}
,
	"Camera.previousViewProjectionMatrix": {
		"prefix": "Camera.previousViewProjectionMatrix",
		"body": [
			"previousViewProjectionMatrix"
		],
		"description": "return:Matrix4x4 des: Get the view projection matrix used on the last frame."
	}
,
	"Camera.projectionMatrix": {
		"prefix": "Camera.projectionMatrix",
		"body": [
			"projectionMatrix"
		],
		"description": "return:Matrix4x4 des: Set a custom projection matrix."
	}
,
	"Camera.rect": {
		"prefix": "Camera.rect",
		"body": [
			"rect"
		],
		"description": "return:Rect des: Where on the screen is the camera rendered in normalized coordinates."
	}
,
	"Camera.renderingPath": {
		"prefix": "Camera.renderingPath",
		"body": [
			"renderingPath"
		],
		"description": "return:RenderingPath des: The rendering path that should be used, if possible."
	}
,
	"Camera.scaledPixelHeight": {
		"prefix": "Camera.scaledPixelHeight",
		"body": [
			"scaledPixelHeight"
		],
		"description": "return:int des: How tall is the camera in pixels (accounting for dynamic resolution scaling) (Read Only)."
	}
,
	"Camera.scaledPixelWidth": {
		"prefix": "Camera.scaledPixelWidth",
		"body": [
			"scaledPixelWidth"
		],
		"description": "return:int des: How wide is the camera in pixels (accounting for dynamic resolution scaling) (Read Only)."
	}
,
	"Camera.scene": {
		"prefix": "Camera.scene",
		"body": [
			"scene"
		],
		"description": "return:SceneManagement.Scene des: If not null, the camera will only render the contents of the specified Scene."
	}
,
	"Camera.sensorSize": {
		"prefix": "Camera.sensorSize",
		"body": [
			"sensorSize"
		],
		"description": "return:Vector2 des: The size of the camera sensor, expressed in millimeters."
	}
,
	"Camera.stereoActiveEye": {
		"prefix": "Camera.stereoActiveEye",
		"body": [
			"stereoActiveEye"
		],
		"description": "return:Camera.MonoOrStereoscopicEye des: Returns the eye that is currently rendering. If called when stereo is not enabled it will return Camera.MonoOrStereoscopicEye.Mono.If called during a camera rendering callback such as OnRenderImage it will return the currently rendering eye.If called outside of a rendering callback and stereo is enabled, it will return the default eye which is Camera.MonoOrStereoscopicEye.Left."
	}
,
	"Camera.stereoConvergence": {
		"prefix": "Camera.stereoConvergence",
		"body": [
			"stereoConvergence"
		],
		"description": "return:float des: Distance to a point where virtual eyes converge."
	}
,
	"Camera.stereoEnabled": {
		"prefix": "Camera.stereoEnabled",
		"body": [
			"stereoEnabled"
		],
		"description": "return:bool des: Stereoscopic rendering."
	}
,
	"Camera.stereoSeparation": {
		"prefix": "Camera.stereoSeparation",
		"body": [
			"stereoSeparation"
		],
		"description": "return:float des: The distance between the virtual eyes. Use this to query or set the current eye separation. Note that most VR devices provide this value, in which case setting the value will have no effect."
	}
,
	"Camera.stereoTargetEye": {
		"prefix": "Camera.stereoTargetEye",
		"body": [
			"stereoTargetEye"
		],
		"description": "return:StereoTargetEyeMask des: Defines which eye of a VR display the Camera renders into."
	}
,
	"Camera.targetDisplay": {
		"prefix": "Camera.targetDisplay",
		"body": [
			"targetDisplay"
		],
		"description": "return:int des: Set the target display for this Camera."
	}
,
	"Camera.targetTexture": {
		"prefix": "Camera.targetTexture",
		"body": [
			"targetTexture"
		],
		"description": "return:RenderTexture des: Destination render texture."
	}
,
	"Camera.transparencySortAxis": {
		"prefix": "Camera.transparencySortAxis",
		"body": [
			"transparencySortAxis"
		],
		"description": "return:Vector3 des: An axis that describes the direction along which the distances of objects are measured for the purpose of sorting."
	}
,
	"Camera.transparencySortMode": {
		"prefix": "Camera.transparencySortMode",
		"body": [
			"transparencySortMode"
		],
		"description": "return:TransparencySortMode des: Transparent object sorting mode."
	}
,
	"Camera.useJitteredProjectionMatrixForTransparentRendering": {
		"prefix": "Camera.useJitteredProjectionMatrixForTransparentRendering",
		"body": [
			"useJitteredProjectionMatrixForTransparentRendering"
		],
		"description": "return:bool des: Should the jittered matrix be used for transparency rendering?"
	}
,
	"Camera.useOcclusionCulling": {
		"prefix": "Camera.useOcclusionCulling",
		"body": [
			"useOcclusionCulling"
		],
		"description": "return:bool des: Whether or not the Camera will use occlusion culling during rendering."
	}
,
	"Camera.usePhysicalProperties": {
		"prefix": "Camera.usePhysicalProperties",
		"body": [
			"usePhysicalProperties"
		],
		"description": "return:bool des: Enable [UsePhysicalProperties] to use physical camera properties to compute the field of view and the frustum."
	}
,
	"Camera.velocity": {
		"prefix": "Camera.velocity",
		"body": [
			"velocity"
		],
		"description": "return:Vector3 des: Get the world-space speed of the camera (Read Only)."
	}
,
	"Camera.worldToCameraMatrix": {
		"prefix": "Camera.worldToCameraMatrix",
		"body": [
			"worldToCameraMatrix"
		],
		"description": "return:Matrix4x4 des: Matrix that transforms from world to camera space."
	}
,
	"Camera.AddCommandBuffer": {
		"prefix": "Camera.AddCommandBuffer",
		"body": [
			"AddCommandBuffer($1)"
		],
		"description": "public void AddCommandBuffer(Rendering.CameraEvent evt, Rendering.CommandBuffer buffer); des: Add a command buffer to be executed at a specified place."
	}
,
	"Camera.AddCommandBufferAsync": {
		"prefix": "Camera.AddCommandBufferAsync",
		"body": [
			"AddCommandBufferAsync($1)"
		],
		"description": "public void AddCommandBufferAsync(Rendering.CameraEvent evt, Rendering.CommandBuffer buffer, Rendering.ComputeQueueType queueType); des: Adds a command buffer to the GPU's async compute queues and executes that command buffer when graphics processing reaches a given point."
	}
,
	"Camera.CalculateFrustumCorners": {
		"prefix": "Camera.CalculateFrustumCorners",
		"body": [
			"CalculateFrustumCorners($1)"
		],
		"description": "public void CalculateFrustumCorners(Rect viewport, float z, Camera.MonoOrStereoscopicEye eye, Vector3[] outCorners); des: Given viewport coordinates, calculates the view space vectors pointing to the four frustum corners at the specified camera depth."
	}
,
	"Camera.CalculateObliqueMatrix": {
		"prefix": "Camera.CalculateObliqueMatrix",
		"body": [
			"CalculateObliqueMatrix($1)"
		],
		"description": "public Matrix4x4 CalculateObliqueMatrix(Vector4 clipPlane); des: Calculates and returns oblique near-plane projection matrix."
	}
,
	"Camera.CopyFrom": {
		"prefix": "Camera.CopyFrom",
		"body": [
			"CopyFrom($1)"
		],
		"description": "public void CopyFrom(Camera other); des: Makes this camera's settings match other camera."
	}
,
	"Camera.CopyStereoDeviceProjectionMatrixToNonJittered": {
		"prefix": "Camera.CopyStereoDeviceProjectionMatrixToNonJittered",
		"body": [
			"CopyStereoDeviceProjectionMatrixToNonJittered($1)"
		],
		"description": "public void CopyStereoDeviceProjectionMatrixToNonJittered(Camera.StereoscopicEye eye); des: Sets the non-jittered projection matrix, sourced from the VR SDK."
	}
,
	"Camera.GetCommandBuffers": {
		"prefix": "Camera.GetCommandBuffers",
		"body": [
			"GetCommandBuffers($1)"
		],
		"description": "public CommandBuffer[] GetCommandBuffers(Rendering.CameraEvent evt); des: Get command buffers to be executed at a specified place."
	}
,
	"Camera.GetStereoNonJitteredProjectionMatrix": {
		"prefix": "Camera.GetStereoNonJitteredProjectionMatrix",
		"body": [
			"GetStereoNonJitteredProjectionMatrix($1)"
		],
		"description": "public Matrix4x4 GetStereoNonJitteredProjectionMatrix(Camera.StereoscopicEye eye); des: Gets the non-jittered projection matrix of a specific left or right stereoscopic eye."
	}
,
	"Camera.GetStereoProjectionMatrix": {
		"prefix": "Camera.GetStereoProjectionMatrix",
		"body": [
			"GetStereoProjectionMatrix($1)"
		],
		"description": "public Matrix4x4 GetStereoProjectionMatrix(Camera.StereoscopicEye eye); des: Gets the projection matrix of a specific left or right stereoscopic eye."
	}
,
	"Camera.GetStereoViewMatrix": {
		"prefix": "Camera.GetStereoViewMatrix",
		"body": [
			"GetStereoViewMatrix($1)"
		],
		"description": "public Matrix4x4 GetStereoViewMatrix(Camera.StereoscopicEye eye); des: Gets the left or right view matrix of a specific stereoscopic eye."
	}
,
	"Camera.RemoveAllCommandBuffers": {
		"prefix": "Camera.RemoveAllCommandBuffers",
		"body": [
			"RemoveAllCommandBuffers($1)"
		],
		"description": "public void RemoveAllCommandBuffers(); des: Remove all command buffers set on this camera."
	}
,
	"Camera.RemoveCommandBuffer": {
		"prefix": "Camera.RemoveCommandBuffer",
		"body": [
			"RemoveCommandBuffer($1)"
		],
		"description": "public void RemoveCommandBuffer(Rendering.CameraEvent evt, Rendering.CommandBuffer buffer); des: Remove command buffer from execution at a specified place."
	}
,
	"Camera.RemoveCommandBuffers": {
		"prefix": "Camera.RemoveCommandBuffers",
		"body": [
			"RemoveCommandBuffers($1)"
		],
		"description": "public void RemoveCommandBuffers(Rendering.CameraEvent evt); des: Remove command buffers from execution at a specified place."
	}
,
	"Camera.Render": {
		"prefix": "Camera.Render",
		"body": [
			"Render($1)"
		],
		"description": "public void Render(); des: Render the camera manually."
	}
,
	"Camera.RenderToCubemap": {
		"prefix": "Camera.RenderToCubemap",
		"body": [
			"RenderToCubemap($1)"
		],
		"description": "public bool RenderToCubemap(Cubemap cubemap, int faceMask); public bool RenderToCubemap(RenderTexture cubemap, int faceMask); public bool RenderToCubemap(RenderTexture cubemap, int faceMask, Camera.MonoOrStereoscopicEye stereoEye); des: Render into a static cubemap from this camera."
	}
,
	"Camera.RenderWithShader": {
		"prefix": "Camera.RenderWithShader",
		"body": [
			"RenderWithShader($1)"
		],
		"description": "public void RenderWithShader(Shader shader, string replacementTag); des: Render the camera with shader replacement."
	}
,
	"Camera.Reset": {
		"prefix": "Camera.Reset",
		"body": [
			"Reset($1)"
		],
		"description": "public void Reset(); des: Revert all camera parameters to default."
	}
,
	"Camera.ResetAspect": {
		"prefix": "Camera.ResetAspect",
		"body": [
			"ResetAspect($1)"
		],
		"description": "public void ResetAspect(); des: Revert the aspect ratio to the screen's aspect ratio."
	}
,
	"Camera.ResetCullingMatrix": {
		"prefix": "Camera.ResetCullingMatrix",
		"body": [
			"ResetCullingMatrix($1)"
		],
		"description": "public void ResetCullingMatrix(); des: Make culling queries reflect the camera's built in parameters."
	}
,
	"Camera.ResetProjectionMatrix": {
		"prefix": "Camera.ResetProjectionMatrix",
		"body": [
			"ResetProjectionMatrix($1)"
		],
		"description": "public void ResetProjectionMatrix(); des: Make the projection reflect normal camera's parameters."
	}
,
	"Camera.ResetReplacementShader": {
		"prefix": "Camera.ResetReplacementShader",
		"body": [
			"ResetReplacementShader($1)"
		],
		"description": "public void ResetReplacementShader(); des: Remove shader replacement from camera."
	}
,
	"Camera.ResetStereoProjectionMatrices": {
		"prefix": "Camera.ResetStereoProjectionMatrices",
		"body": [
			"ResetStereoProjectionMatrices($1)"
		],
		"description": "public void ResetStereoProjectionMatrices(); des: Reset the camera to using the Unity computed projection matrices for all stereoscopic eyes."
	}
,
	"Camera.ResetStereoViewMatrices": {
		"prefix": "Camera.ResetStereoViewMatrices",
		"body": [
			"ResetStereoViewMatrices($1)"
		],
		"description": "public void ResetStereoViewMatrices(); des: Reset the camera to using the Unity computed view matrices for all stereoscopic eyes."
	}
,
	"Camera.ResetTransparencySortSettings": {
		"prefix": "Camera.ResetTransparencySortSettings",
		"body": [
			"ResetTransparencySortSettings($1)"
		],
		"description": "public void ResetTransparencySortSettings(); des: Resets this Camera's transparency sort settings to the default. Default transparency settings are taken from GraphicsSettings instead of directly from this Camera."
	}
,
	"Camera.ResetWorldToCameraMatrix": {
		"prefix": "Camera.ResetWorldToCameraMatrix",
		"body": [
			"ResetWorldToCameraMatrix($1)"
		],
		"description": "public void ResetWorldToCameraMatrix(); des: Make the rendering position reflect the camera's position in the Scene."
	}
,
	"Camera.ScreenPointToRay": {
		"prefix": "Camera.ScreenPointToRay",
		"body": [
			"ScreenPointToRay($1)"
		],
		"description": "public Ray ScreenPointToRay(Vector3 pos); public Ray ScreenPointToRay(Vector3 pos, Camera.MonoOrStereoscopicEye eye); des: Returns a ray going from camera through a screen point."
	}
,
	"Camera.ScreenToViewportPoint": {
		"prefix": "Camera.ScreenToViewportPoint",
		"body": [
			"ScreenToViewportPoint($1)"
		],
		"description": "public Vector3 ScreenToViewportPoint(Vector3 position); des: Transforms position from screen space into viewport space."
	}
,
	"Camera.ScreenToWorldPoint": {
		"prefix": "Camera.ScreenToWorldPoint",
		"body": [
			"ScreenToWorldPoint($1)"
		],
		"description": "public Vector3 ScreenToWorldPoint(Vector3 position); des: Transforms position from screen space into world space."
	}
,
	"Camera.SetReplacementShader": {
		"prefix": "Camera.SetReplacementShader",
		"body": [
			"SetReplacementShader($1)"
		],
		"description": "public void SetReplacementShader(Shader shader, string replacementTag); des: Make the camera render with shader replacement."
	}
,
	"Camera.SetStereoProjectionMatrix": {
		"prefix": "Camera.SetStereoProjectionMatrix",
		"body": [
			"SetStereoProjectionMatrix($1)"
		],
		"description": "public void SetStereoProjectionMatrix(Camera.StereoscopicEye eye, Matrix4x4 matrix); des: Sets a custom projection matrix for a specific stereoscopic eye."
	}
,
	"Camera.SetStereoViewMatrix": {
		"prefix": "Camera.SetStereoViewMatrix",
		"body": [
			"SetStereoViewMatrix($1)"
		],
		"description": "public void SetStereoViewMatrix(Camera.StereoscopicEye eye, Matrix4x4 matrix); des: Sets a custom view matrix for a specific stereoscopic eye."
	}
,
	"Camera.SetTargetBuffers": {
		"prefix": "Camera.SetTargetBuffers",
		"body": [
			"SetTargetBuffers($1)"
		],
		"description": "public void SetTargetBuffers(RenderBuffer colorBuffer, RenderBuffer depthBuffer); public void SetTargetBuffers(RenderBuffer[] colorBuffer, RenderBuffer depthBuffer); des: Sets the Camera to render to the chosen buffers of one or more RenderTextures."
	}
,
	"Camera.ViewportPointToRay": {
		"prefix": "Camera.ViewportPointToRay",
		"body": [
			"ViewportPointToRay($1)"
		],
		"description": "public Ray ViewportPointToRay(Vector3 pos); public Ray ViewportPointToRay(Vector3 pos, Camera.MonoOrStereoscopicEye eye); des: Returns a ray going from camera through a viewport point."
	}
,
	"Camera.ViewportToScreenPoint": {
		"prefix": "Camera.ViewportToScreenPoint",
		"body": [
			"ViewportToScreenPoint($1)"
		],
		"description": "public Vector3 ViewportToScreenPoint(Vector3 position); des: Transforms position from viewport space into screen space."
	}
,
	"Camera.ViewportToWorldPoint": {
		"prefix": "Camera.ViewportToWorldPoint",
		"body": [
			"ViewportToWorldPoint($1)"
		],
		"description": "public Vector3 ViewportToWorldPoint(Vector3 position); des: Transforms position from viewport space into world space."
	}
,
	"Camera.WorldToScreenPoint": {
		"prefix": "Camera.WorldToScreenPoint",
		"body": [
			"WorldToScreenPoint($1)"
		],
		"description": "public Vector3 WorldToScreenPoint(Vector3 position); public Vector3 WorldToScreenPoint(Vector3 position, Camera.MonoOrStereoscopicEye eye); des: Transforms position from world space into screen space."
	}
,
	"Camera.WorldToViewportPoint": {
		"prefix": "Camera.WorldToViewportPoint",
		"body": [
			"WorldToViewportPoint($1)"
		],
		"description": "public Vector3 WorldToViewportPoint(Vector3 position); public Vector3 WorldToViewportPoint(Vector3 position, Camera.MonoOrStereoscopicEye eye); des: Transforms position from world space into viewport space."
	}
,
	"Camera.FocalLengthToFOV": {
		"prefix": "Camera.FocalLengthToFOV",
		"body": [
			"Camera.FocalLengthToFOV"
		],
		"description": "public static float FocalLengthToFOV(float focalLength, float sensorSize); des: Converts focal length to field of view."
	}
,
	"Camera.FOVToFocalLength": {
		"prefix": "Camera.FOVToFocalLength",
		"body": [
			"Camera.FOVToFocalLength"
		],
		"description": "public static float FOVToFocalLength(float fov, float sensorSize); des: Converts field of view to focal length. Use either sensor height and vertical field of view or sensor width and horizontal field of view."
	}
,
	"Camera.GetAllCameras": {
		"prefix": "Camera.GetAllCameras",
		"body": [
			"Camera.GetAllCameras"
		],
		"description": "public static int GetAllCameras(Camera[] cameras); des: Fills an array of Camera with the current cameras in the Scene, without allocating a new array."
	}
,
	"Camera.OnPostRender": {
		"prefix": "Camera.OnPostRender",
		"body": [
			"OnPostRender"
		],
		"description": "OnPostRender is called after a camera has finished rendering the Scene."
	}
,
	"Camera.OnPreCull": {
		"prefix": "Camera.OnPreCull",
		"body": [
			"OnPreCull"
		],
		"description": "OnPreCull is called before a camera culls the Scene."
	}
,
	"Camera.OnPreRender": {
		"prefix": "Camera.OnPreRender",
		"body": [
			"OnPreRender"
		],
		"description": "OnPreRender is called before a camera starts rendering the Scene."
	}
,
	"Camera.OnRenderImage": {
		"prefix": "Camera.OnRenderImage",
		"body": [
			"OnRenderImage"
		],
		"description": "OnRenderImage is called after all rendering is complete to render image."
	}
,
	"Camera.OnRenderObject": {
		"prefix": "Camera.OnRenderObject",
		"body": [
			"OnRenderObject"
		],
		"description": "OnRenderObject is called after camera has rendered the Scene."
	}
,
	"Camera.OnWillRenderObject": {
		"prefix": "Camera.OnWillRenderObject",
		"body": [
			"OnWillRenderObject"
		],
		"description": "OnWillRenderObject is called for each camera if the object is visible."
	}
,
	"Camera.enabled": {
		"prefix": "Camera.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"Camera.isActiveAndEnabled": {
		"prefix": "Camera.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"Camera.gameObject": {
		"prefix": "Camera.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"Camera.tag": {
		"prefix": "Camera.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"Camera.transform": {
		"prefix": "Camera.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"Camera.hideFlags": {
		"prefix": "Camera.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Camera.name": {
		"prefix": "Camera.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Camera.BroadcastMessage": {
		"prefix": "Camera.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"Camera.CompareTag": {
		"prefix": "Camera.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"Camera.GetComponent": {
		"prefix": "Camera.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"Camera.GetComponentInChildren": {
		"prefix": "Camera.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"Camera.GetComponentInParent": {
		"prefix": "Camera.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"Camera.GetComponents": {
		"prefix": "Camera.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"Camera.GetComponentsInChildren": {
		"prefix": "Camera.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"Camera.GetComponentsInParent": {
		"prefix": "Camera.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"Camera.SendMessage": {
		"prefix": "Camera.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"Camera.SendMessageUpwards": {
		"prefix": "Camera.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"Camera.GetInstanceID": {
		"prefix": "Camera.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Camera.ToString": {
		"prefix": "Camera.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Camera.Destroy": {
		"prefix": "Camera.Destroy",
		"body": [
			"Camera.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Camera.DestroyImmediate": {
		"prefix": "Camera.DestroyImmediate",
		"body": [
			"Camera.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Camera.DontDestroyOnLoad": {
		"prefix": "Camera.DontDestroyOnLoad",
		"body": [
			"Camera.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Camera.FindObjectOfType": {
		"prefix": "Camera.FindObjectOfType",
		"body": [
			"Camera.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Camera.FindObjectsOfType": {
		"prefix": "Camera.FindObjectsOfType",
		"body": [
			"Camera.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Camera.Instantiate": {
		"prefix": "Camera.Instantiate",
		"body": [
			"Camera.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"Camera.MonoOrStereoscopicEye.Left": {
		"prefix": "Camera.MonoOrStereoscopicEye.Left",
		"body": [
			"Left"
		],
		"description": "return: des: Camera eye corresponding to stereoscopic rendering of the left eye."
	}
,
	"Camera.MonoOrStereoscopicEye.Right": {
		"prefix": "Camera.MonoOrStereoscopicEye.Right",
		"body": [
			"Right"
		],
		"description": "return: des: Camera eye corresponding to stereoscopic rendering of the right eye."
	}
,
	"Camera.MonoOrStereoscopicEye.Mono": {
		"prefix": "Camera.MonoOrStereoscopicEye.Mono",
		"body": [
			"Mono"
		],
		"description": "return: des: Camera eye corresponding to non-stereoscopic rendering."
	}
,
	"Camera.StereoscopicEye.Left": {
		"prefix": "Camera.StereoscopicEye.Left",
		"body": [
			"Left"
		],
		"description": "return: des: Specifies the target to be the left eye."
	}
,
	"Camera.StereoscopicEye.Right": {
		"prefix": "Camera.StereoscopicEye.Right",
		"body": [
			"Right"
		],
		"description": "return: des: Specifies the target to be the right eye."
	}
,
	"Canvas.additionalShaderChannels": {
		"prefix": "Canvas.additionalShaderChannels",
		"body": [
			"additionalShaderChannels"
		],
		"description": "return:AdditionalCanvasShaderChannels des: Get or set the mask of additional shader channels to be used when creating the Canvas mesh."
	}
,
	"Canvas.cachedSortingLayerValue": {
		"prefix": "Canvas.cachedSortingLayerValue",
		"body": [
			"cachedSortingLayerValue"
		],
		"description": "return:int des: Cached calculated value based upon SortingLayerID."
	}
,
	"Canvas.isRootCanvas": {
		"prefix": "Canvas.isRootCanvas",
		"body": [
			"isRootCanvas"
		],
		"description": "return:bool des: Is this the root Canvas?"
	}
,
	"Canvas.normalizedSortingGridSize": {
		"prefix": "Canvas.normalizedSortingGridSize",
		"body": [
			"normalizedSortingGridSize"
		],
		"description": "return:float des: The normalized grid size that the canvas will split the renderable area into."
	}
,
	"Canvas.overridePixelPerfect": {
		"prefix": "Canvas.overridePixelPerfect",
		"body": [
			"overridePixelPerfect"
		],
		"description": "return:bool des: Allows for nested canvases to override pixelPerfect settings inherited from parent canvases."
	}
,
	"Canvas.overrideSorting": {
		"prefix": "Canvas.overrideSorting",
		"body": [
			"overrideSorting"
		],
		"description": "return:bool des: Override the sorting of canvas."
	}
,
	"Canvas.pixelPerfect": {
		"prefix": "Canvas.pixelPerfect",
		"body": [
			"pixelPerfect"
		],
		"description": "return:bool des: Force elements in the canvas to be aligned with pixels. Only applies with renderMode is Screen Space."
	}
,
	"Canvas.pixelRect": {
		"prefix": "Canvas.pixelRect",
		"body": [
			"pixelRect"
		],
		"description": "return:Rect des: Get the render rect for the Canvas."
	}
,
	"Canvas.planeDistance": {
		"prefix": "Canvas.planeDistance",
		"body": [
			"planeDistance"
		],
		"description": "return:float des: How far away from the camera is the Canvas generated."
	}
,
	"Canvas.referencePixelsPerUnit": {
		"prefix": "Canvas.referencePixelsPerUnit",
		"body": [
			"referencePixelsPerUnit"
		],
		"description": "return:float des: The number of pixels per unit that is considered the default."
	}
,
	"Canvas.renderMode": {
		"prefix": "Canvas.renderMode",
		"body": [
			"renderMode"
		],
		"description": "return:RenderMode des: Is the Canvas in World or Overlay mode?"
	}
,
	"Canvas.renderOrder": {
		"prefix": "Canvas.renderOrder",
		"body": [
			"renderOrder"
		],
		"description": "return:int des: The render order in which the canvas is being emitted to the scene. (Read Only)"
	}
,
	"Canvas.rootCanvas": {
		"prefix": "Canvas.rootCanvas",
		"body": [
			"rootCanvas"
		],
		"description": "return:Canvas des: Returns the Canvas closest to root, by checking through each parent and returning the last canvas found. If no other canvas is found then the canvas will return itself."
	}
,
	"Canvas.scaleFactor": {
		"prefix": "Canvas.scaleFactor",
		"body": [
			"scaleFactor"
		],
		"description": "return:float des: Used to scale the entire canvas, while still making it fit the screen. Only applies with renderMode is Screen Space."
	}
,
	"Canvas.sortingLayerID": {
		"prefix": "Canvas.sortingLayerID",
		"body": [
			"sortingLayerID"
		],
		"description": "return:int des: Unique ID of the Canvas' sorting layer."
	}
,
	"Canvas.sortingLayerName": {
		"prefix": "Canvas.sortingLayerName",
		"body": [
			"sortingLayerName"
		],
		"description": "return:string des: Name of the Canvas' sorting layer."
	}
,
	"Canvas.sortingOrder": {
		"prefix": "Canvas.sortingOrder",
		"body": [
			"sortingOrder"
		],
		"description": "return:int des: Canvas' order within a sorting layer."
	}
,
	"Canvas.targetDisplay": {
		"prefix": "Canvas.targetDisplay",
		"body": [
			"targetDisplay"
		],
		"description": "return:int des: For Overlay mode, display index on which the UI canvas will appear."
	}
,
	"Canvas.worldCamera": {
		"prefix": "Canvas.worldCamera",
		"body": [
			"worldCamera"
		],
		"description": "return:Camera des: Camera used for sizing the Canvas when in Screen Space - Camera. Also used as the Camera that events will be sent through for a World Space [[Canvas]."
	}
,
	"Canvas.ForceUpdateCanvases": {
		"prefix": "Canvas.ForceUpdateCanvases",
		"body": [
			"Canvas.ForceUpdateCanvases"
		],
		"description": "public static void ForceUpdateCanvases(); des: Force all canvases to update their content."
	}
,
	"Canvas.GetDefaultCanvasMaterial": {
		"prefix": "Canvas.GetDefaultCanvasMaterial",
		"body": [
			"Canvas.GetDefaultCanvasMaterial"
		],
		"description": "public static Material GetDefaultCanvasMaterial(); des: Returns the default material that can be used for rendering normal elements on the Canvas."
	}
,
	"Canvas.GetETC1SupportedCanvasMaterial": {
		"prefix": "Canvas.GetETC1SupportedCanvasMaterial",
		"body": [
			"Canvas.GetETC1SupportedCanvasMaterial"
		],
		"description": "public static Material GetETC1SupportedCanvasMaterial(); des: Gets or generates the ETC1 Material."
	}
,
	"Canvas.enabled": {
		"prefix": "Canvas.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"Canvas.isActiveAndEnabled": {
		"prefix": "Canvas.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"Canvas.gameObject": {
		"prefix": "Canvas.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"Canvas.tag": {
		"prefix": "Canvas.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"Canvas.transform": {
		"prefix": "Canvas.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"Canvas.hideFlags": {
		"prefix": "Canvas.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Canvas.name": {
		"prefix": "Canvas.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Canvas.BroadcastMessage": {
		"prefix": "Canvas.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"Canvas.CompareTag": {
		"prefix": "Canvas.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"Canvas.GetComponent": {
		"prefix": "Canvas.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"Canvas.GetComponentInChildren": {
		"prefix": "Canvas.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"Canvas.GetComponentInParent": {
		"prefix": "Canvas.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"Canvas.GetComponents": {
		"prefix": "Canvas.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"Canvas.GetComponentsInChildren": {
		"prefix": "Canvas.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"Canvas.GetComponentsInParent": {
		"prefix": "Canvas.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"Canvas.SendMessage": {
		"prefix": "Canvas.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"Canvas.SendMessageUpwards": {
		"prefix": "Canvas.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"Canvas.GetInstanceID": {
		"prefix": "Canvas.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Canvas.ToString": {
		"prefix": "Canvas.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Canvas.Destroy": {
		"prefix": "Canvas.Destroy",
		"body": [
			"Canvas.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Canvas.DestroyImmediate": {
		"prefix": "Canvas.DestroyImmediate",
		"body": [
			"Canvas.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Canvas.DontDestroyOnLoad": {
		"prefix": "Canvas.DontDestroyOnLoad",
		"body": [
			"Canvas.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Canvas.FindObjectOfType": {
		"prefix": "Canvas.FindObjectOfType",
		"body": [
			"Canvas.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Canvas.FindObjectsOfType": {
		"prefix": "Canvas.FindObjectsOfType",
		"body": [
			"Canvas.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Canvas.Instantiate": {
		"prefix": "Canvas.Instantiate",
		"body": [
			"Canvas.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"CanvasGroup.alpha": {
		"prefix": "CanvasGroup.alpha",
		"body": [
			"alpha"
		],
		"description": "return:float des: Set the alpha of the group."
	}
,
	"CanvasGroup.blocksRaycasts": {
		"prefix": "CanvasGroup.blocksRaycasts",
		"body": [
			"blocksRaycasts"
		],
		"description": "return:bool des: Does this group block raycasting (allow collision)."
	}
,
	"CanvasGroup.ignoreParentGroups": {
		"prefix": "CanvasGroup.ignoreParentGroups",
		"body": [
			"ignoreParentGroups"
		],
		"description": "return:bool des: Should the group ignore parent groups?"
	}
,
	"CanvasGroup.interactable": {
		"prefix": "CanvasGroup.interactable",
		"body": [
			"interactable"
		],
		"description": "return:bool des: Is the group interactable (are the elements beneath the group enabled)."
	}
,
	"CanvasGroup.IsRaycastLocationValid": {
		"prefix": "CanvasGroup.IsRaycastLocationValid",
		"body": [
			"IsRaycastLocationValid($1)"
		],
		"description": "public bool IsRaycastLocationValid(Vector2 sp, Camera eventCamera); des: Returns true if the Group allows raycasts."
	}
,
	"CanvasGroup.gameObject": {
		"prefix": "CanvasGroup.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"CanvasGroup.tag": {
		"prefix": "CanvasGroup.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"CanvasGroup.transform": {
		"prefix": "CanvasGroup.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"CanvasGroup.hideFlags": {
		"prefix": "CanvasGroup.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"CanvasGroup.name": {
		"prefix": "CanvasGroup.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"CanvasGroup.BroadcastMessage": {
		"prefix": "CanvasGroup.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"CanvasGroup.CompareTag": {
		"prefix": "CanvasGroup.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"CanvasGroup.GetComponent": {
		"prefix": "CanvasGroup.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"CanvasGroup.GetComponentInChildren": {
		"prefix": "CanvasGroup.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"CanvasGroup.GetComponentInParent": {
		"prefix": "CanvasGroup.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"CanvasGroup.GetComponents": {
		"prefix": "CanvasGroup.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"CanvasGroup.GetComponentsInChildren": {
		"prefix": "CanvasGroup.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"CanvasGroup.GetComponentsInParent": {
		"prefix": "CanvasGroup.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"CanvasGroup.SendMessage": {
		"prefix": "CanvasGroup.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"CanvasGroup.SendMessageUpwards": {
		"prefix": "CanvasGroup.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"CanvasGroup.GetInstanceID": {
		"prefix": "CanvasGroup.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"CanvasGroup.ToString": {
		"prefix": "CanvasGroup.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"CanvasGroup.Destroy": {
		"prefix": "CanvasGroup.Destroy",
		"body": [
			"CanvasGroup.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"CanvasGroup.DestroyImmediate": {
		"prefix": "CanvasGroup.DestroyImmediate",
		"body": [
			"CanvasGroup.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"CanvasGroup.DontDestroyOnLoad": {
		"prefix": "CanvasGroup.DontDestroyOnLoad",
		"body": [
			"CanvasGroup.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"CanvasGroup.FindObjectOfType": {
		"prefix": "CanvasGroup.FindObjectOfType",
		"body": [
			"CanvasGroup.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"CanvasGroup.FindObjectsOfType": {
		"prefix": "CanvasGroup.FindObjectsOfType",
		"body": [
			"CanvasGroup.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"CanvasGroup.Instantiate": {
		"prefix": "CanvasGroup.Instantiate",
		"body": [
			"CanvasGroup.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"CanvasRenderer.absoluteDepth": {
		"prefix": "CanvasRenderer.absoluteDepth",
		"body": [
			"absoluteDepth"
		],
		"description": "return:int des: Depth of the renderer relative to the root canvas."
	}
,
	"CanvasRenderer.cull": {
		"prefix": "CanvasRenderer.cull",
		"body": [
			"cull"
		],
		"description": "return:bool des: Indicates whether geometry emitted by this renderer is ignored."
	}
,
	"CanvasRenderer.cullTransparentMesh": {
		"prefix": "CanvasRenderer.cullTransparentMesh",
		"body": [
			"cullTransparentMesh"
		],
		"description": "return:bool des: Indicates whether geometry emitted by this renderer can be ignored when the vertex color alpha is close to zero for every vertex of the mesh."
	}
,
	"CanvasRenderer.hasMoved": {
		"prefix": "CanvasRenderer.hasMoved",
		"body": [
			"hasMoved"
		],
		"description": "return:bool des: True if any change has occured that would invalidate the positions of generated geometry."
	}
,
	"CanvasRenderer.hasPopInstruction": {
		"prefix": "CanvasRenderer.hasPopInstruction",
		"body": [
			"hasPopInstruction"
		],
		"description": "return:bool des: Enable 'render stack' pop draw call."
	}
,
	"CanvasRenderer.hasRectClipping": {
		"prefix": "CanvasRenderer.hasRectClipping",
		"body": [
			"hasRectClipping"
		],
		"description": "return:bool des: True if rect clipping has been enabled on this renderer. See Also: CanvasRenderer.EnableRectClipping, CanvasRenderer.DisableRectClipping."
	}
,
	"CanvasRenderer.materialCount": {
		"prefix": "CanvasRenderer.materialCount",
		"body": [
			"materialCount"
		],
		"description": "return:int des: The number of materials usable by this renderer."
	}
,
	"CanvasRenderer.popMaterialCount": {
		"prefix": "CanvasRenderer.popMaterialCount",
		"body": [
			"popMaterialCount"
		],
		"description": "return:int des: The number of materials usable by this renderer. Used internally for masking."
	}
,
	"CanvasRenderer.relativeDepth": {
		"prefix": "CanvasRenderer.relativeDepth",
		"body": [
			"relativeDepth"
		],
		"description": "return:int des: Depth of the renderer realative to the parent canvas."
	}
,
	"CanvasRenderer.Clear": {
		"prefix": "CanvasRenderer.Clear",
		"body": [
			"Clear($1)"
		],
		"description": "public void Clear(); des: Remove all cached vertices."
	}
,
	"CanvasRenderer.DisableRectClipping": {
		"prefix": "CanvasRenderer.DisableRectClipping",
		"body": [
			"DisableRectClipping($1)"
		],
		"description": "public void DisableRectClipping(); des: Disables rectangle clipping for this CanvasRenderer."
	}
,
	"CanvasRenderer.EnableRectClipping": {
		"prefix": "CanvasRenderer.EnableRectClipping",
		"body": [
			"EnableRectClipping($1)"
		],
		"description": "public void EnableRectClipping(Rect rect); des: Enables rect clipping on the CanvasRendered. Geometry outside of the specified rect will be clipped (not rendered)."
	}
,
	"CanvasRenderer.GetAlpha": {
		"prefix": "CanvasRenderer.GetAlpha",
		"body": [
			"GetAlpha($1)"
		],
		"description": "public float GetAlpha(); des: Get the current alpha of the renderer."
	}
,
	"CanvasRenderer.GetColor": {
		"prefix": "CanvasRenderer.GetColor",
		"body": [
			"GetColor($1)"
		],
		"description": "public Color GetColor(); des: Get the current color of the renderer."
	}
,
	"CanvasRenderer.GetMaterial": {
		"prefix": "CanvasRenderer.GetMaterial",
		"body": [
			"GetMaterial($1)"
		],
		"description": "public Material GetMaterial(int index); public Material GetMaterial(); des: Gets the current Material assigned to the CanvasRenderer."
	}
,
	"CanvasRenderer.GetPopMaterial": {
		"prefix": "CanvasRenderer.GetPopMaterial",
		"body": [
			"GetPopMaterial($1)"
		],
		"description": "public Material GetPopMaterial(int index); des: Gets the current Material assigned to the CanvasRenderer. Used internally for masking."
	}
,
	"CanvasRenderer.SetAlpha": {
		"prefix": "CanvasRenderer.SetAlpha",
		"body": [
			"SetAlpha($1)"
		],
		"description": "public void SetAlpha(float alpha); des: Set the alpha of the renderer. Will be multiplied with the UIVertex alpha and the Canvas alpha."
	}
,
	"CanvasRenderer.SetAlphaTexture": {
		"prefix": "CanvasRenderer.SetAlphaTexture",
		"body": [
			"SetAlphaTexture($1)"
		],
		"description": "public void SetAlphaTexture(Texture texture); des: The Alpha Texture that will be passed to the Shader under the _AlphaTex property."
	}
,
	"CanvasRenderer.SetColor": {
		"prefix": "CanvasRenderer.SetColor",
		"body": [
			"SetColor($1)"
		],
		"description": "public void SetColor(Color color); des: Set the color of the renderer. Will be multiplied with the UIVertex color and the Canvas color."
	}
,
	"CanvasRenderer.SetMaterial": {
		"prefix": "CanvasRenderer.SetMaterial",
		"body": [
			"SetMaterial($1)"
		],
		"description": "public void SetMaterial(Material material, int index); public void SetMaterial(Material material, Texture texture); des: Set the material for the canvas renderer. If a texture is specified then it will be used as the 'MainTex' instead of the material's 'MainTex'. See Also: CanvasRenderer.SetMaterialCount, CanvasRenderer.SetTexture."
	}
,
	"CanvasRenderer.SetMesh": {
		"prefix": "CanvasRenderer.SetMesh",
		"body": [
			"SetMesh($1)"
		],
		"description": "public void SetMesh(Mesh mesh); des: Sets the Mesh used by this renderer."
	}
,
	"CanvasRenderer.SetPopMaterial": {
		"prefix": "CanvasRenderer.SetPopMaterial",
		"body": [
			"SetPopMaterial($1)"
		],
		"description": "public void SetPopMaterial(Material material, int index); des: Set the material for the canvas renderer. Used internally for masking."
	}
,
	"CanvasRenderer.SetTexture": {
		"prefix": "CanvasRenderer.SetTexture",
		"body": [
			"SetTexture($1)"
		],
		"description": "public void SetTexture(Texture texture); des: Sets the texture used by this renderer's material."
	}
,
	"CanvasRenderer.AddUIVertexStream": {
		"prefix": "CanvasRenderer.AddUIVertexStream",
		"body": [
			"CanvasRenderer.AddUIVertexStream"
		],
		"description": "public static void AddUIVertexStream(List<UIVertex> verts, List<Vector3> positions, List<Color32> colors, List<Vector2> uv0S, List<Vector2> uv1S, List<Vector3> normals, List<Vector4> tangents); des: Take the Vertex steam and split it corrisponding arrays (positions, colors, uv0s, uv1s, normals and tangents)."
	}
,
	"CanvasRenderer.CreateUIVertexStream": {
		"prefix": "CanvasRenderer.CreateUIVertexStream",
		"body": [
			"CanvasRenderer.CreateUIVertexStream"
		],
		"description": "public static void CreateUIVertexStream(List<UIVertex> verts, List<Vector3> positions, List<Color32> colors, List<Vector2> uv0S, List<Vector2> uv1S, List<Vector3> normals, List<Vector4> tangents, List<int> indices); des: Convert a set of vertex components into a stream of UIVertex."
	}
,
	"CanvasRenderer.SplitUIVertexStreams": {
		"prefix": "CanvasRenderer.SplitUIVertexStreams",
		"body": [
			"CanvasRenderer.SplitUIVertexStreams"
		],
		"description": "public static void SplitUIVertexStreams(List<UIVertex> verts, List<Vector3> positions, List<Color32> colors, List<Vector2> uv0S, List<Vector2> uv1S, List<Vector3> normals, List<Vector4> tangents, List<int> indices); des: Given a list of UIVertex, split the stream into it's component types."
	}
,
	"CanvasRenderer.gameObject": {
		"prefix": "CanvasRenderer.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"CanvasRenderer.tag": {
		"prefix": "CanvasRenderer.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"CanvasRenderer.transform": {
		"prefix": "CanvasRenderer.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"CanvasRenderer.hideFlags": {
		"prefix": "CanvasRenderer.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"CanvasRenderer.name": {
		"prefix": "CanvasRenderer.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"CanvasRenderer.BroadcastMessage": {
		"prefix": "CanvasRenderer.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"CanvasRenderer.CompareTag": {
		"prefix": "CanvasRenderer.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"CanvasRenderer.GetComponent": {
		"prefix": "CanvasRenderer.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"CanvasRenderer.GetComponentInChildren": {
		"prefix": "CanvasRenderer.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"CanvasRenderer.GetComponentInParent": {
		"prefix": "CanvasRenderer.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"CanvasRenderer.GetComponents": {
		"prefix": "CanvasRenderer.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"CanvasRenderer.GetComponentsInChildren": {
		"prefix": "CanvasRenderer.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"CanvasRenderer.GetComponentsInParent": {
		"prefix": "CanvasRenderer.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"CanvasRenderer.SendMessage": {
		"prefix": "CanvasRenderer.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"CanvasRenderer.SendMessageUpwards": {
		"prefix": "CanvasRenderer.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"CanvasRenderer.GetInstanceID": {
		"prefix": "CanvasRenderer.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"CanvasRenderer.ToString": {
		"prefix": "CanvasRenderer.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"CanvasRenderer.Destroy": {
		"prefix": "CanvasRenderer.Destroy",
		"body": [
			"CanvasRenderer.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"CanvasRenderer.DestroyImmediate": {
		"prefix": "CanvasRenderer.DestroyImmediate",
		"body": [
			"CanvasRenderer.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"CanvasRenderer.DontDestroyOnLoad": {
		"prefix": "CanvasRenderer.DontDestroyOnLoad",
		"body": [
			"CanvasRenderer.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"CanvasRenderer.FindObjectOfType": {
		"prefix": "CanvasRenderer.FindObjectOfType",
		"body": [
			"CanvasRenderer.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"CanvasRenderer.FindObjectsOfType": {
		"prefix": "CanvasRenderer.FindObjectsOfType",
		"body": [
			"CanvasRenderer.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"CanvasRenderer.Instantiate": {
		"prefix": "CanvasRenderer.Instantiate",
		"body": [
			"CanvasRenderer.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"CapsuleCollider.center": {
		"prefix": "CapsuleCollider.center",
		"body": [
			"center"
		],
		"description": "return:Vector3 des: The center of the capsule, measured in the object's local space."
	}
,
	"CapsuleCollider.direction": {
		"prefix": "CapsuleCollider.direction",
		"body": [
			"direction"
		],
		"description": "return:int des: The direction of the capsule."
	}
,
	"CapsuleCollider.height": {
		"prefix": "CapsuleCollider.height",
		"body": [
			"height"
		],
		"description": "return:float des: The height of the capsule measured in the object's local space."
	}
,
	"CapsuleCollider.radius": {
		"prefix": "CapsuleCollider.radius",
		"body": [
			"radius"
		],
		"description": "return:float des: The radius of the sphere, measured in the object's local space."
	}
,
	"CapsuleCollider.attachedRigidbody": {
		"prefix": "CapsuleCollider.attachedRigidbody",
		"body": [
			"attachedRigidbody"
		],
		"description": "return:Rigidbody des: The rigidbody the collider is attached to."
	}
,
	"CapsuleCollider.bounds": {
		"prefix": "CapsuleCollider.bounds",
		"body": [
			"bounds"
		],
		"description": "return:Bounds des: The world space bounding volume of the collider (Read Only)."
	}
,
	"CapsuleCollider.contactOffset": {
		"prefix": "CapsuleCollider.contactOffset",
		"body": [
			"contactOffset"
		],
		"description": "return:float des: Contact offset value of this collider."
	}
,
	"CapsuleCollider.enabled": {
		"prefix": "CapsuleCollider.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Colliders will collide with other Colliders, disabled Colliders won't."
	}
,
	"CapsuleCollider.isTrigger": {
		"prefix": "CapsuleCollider.isTrigger",
		"body": [
			"isTrigger"
		],
		"description": "return:bool des: Is the collider a trigger?"
	}
,
	"CapsuleCollider.material": {
		"prefix": "CapsuleCollider.material",
		"body": [
			"material"
		],
		"description": "return:PhysicMaterial des: The material used by the collider."
	}
,
	"CapsuleCollider.sharedMaterial": {
		"prefix": "CapsuleCollider.sharedMaterial",
		"body": [
			"sharedMaterial"
		],
		"description": "return:PhysicMaterial des: The shared physic material of this collider."
	}
,
	"CapsuleCollider.gameObject": {
		"prefix": "CapsuleCollider.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"CapsuleCollider.tag": {
		"prefix": "CapsuleCollider.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"CapsuleCollider.transform": {
		"prefix": "CapsuleCollider.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"CapsuleCollider.hideFlags": {
		"prefix": "CapsuleCollider.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"CapsuleCollider.name": {
		"prefix": "CapsuleCollider.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"CapsuleCollider.ClosestPoint": {
		"prefix": "CapsuleCollider.ClosestPoint",
		"body": [
			"ClosestPoint($1)"
		],
		"description": "public Vector3 ClosestPoint(Vector3 position); des: Returns a point on the collider that is closest to a given location."
	}
,
	"CapsuleCollider.ClosestPointOnBounds": {
		"prefix": "CapsuleCollider.ClosestPointOnBounds",
		"body": [
			"ClosestPointOnBounds($1)"
		],
		"description": "public Vector3 ClosestPointOnBounds(Vector3 position); des: The closest point to the bounding box of the attached collider."
	}
,
	"CapsuleCollider.Raycast": {
		"prefix": "CapsuleCollider.Raycast",
		"body": [
			"Raycast($1)"
		],
		"description": "public bool Raycast(Ray ray, out RaycastHit hitInfo, float maxDistance); des: Casts a Ray that ignores all Colliders except this one."
	}
,
	"CapsuleCollider.BroadcastMessage": {
		"prefix": "CapsuleCollider.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"CapsuleCollider.CompareTag": {
		"prefix": "CapsuleCollider.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"CapsuleCollider.GetComponent": {
		"prefix": "CapsuleCollider.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"CapsuleCollider.GetComponentInChildren": {
		"prefix": "CapsuleCollider.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"CapsuleCollider.GetComponentInParent": {
		"prefix": "CapsuleCollider.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"CapsuleCollider.GetComponents": {
		"prefix": "CapsuleCollider.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"CapsuleCollider.GetComponentsInChildren": {
		"prefix": "CapsuleCollider.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"CapsuleCollider.GetComponentsInParent": {
		"prefix": "CapsuleCollider.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"CapsuleCollider.SendMessage": {
		"prefix": "CapsuleCollider.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"CapsuleCollider.SendMessageUpwards": {
		"prefix": "CapsuleCollider.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"CapsuleCollider.GetInstanceID": {
		"prefix": "CapsuleCollider.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"CapsuleCollider.ToString": {
		"prefix": "CapsuleCollider.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"CapsuleCollider.Destroy": {
		"prefix": "CapsuleCollider.Destroy",
		"body": [
			"CapsuleCollider.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"CapsuleCollider.DestroyImmediate": {
		"prefix": "CapsuleCollider.DestroyImmediate",
		"body": [
			"CapsuleCollider.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"CapsuleCollider.DontDestroyOnLoad": {
		"prefix": "CapsuleCollider.DontDestroyOnLoad",
		"body": [
			"CapsuleCollider.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"CapsuleCollider.FindObjectOfType": {
		"prefix": "CapsuleCollider.FindObjectOfType",
		"body": [
			"CapsuleCollider.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"CapsuleCollider.FindObjectsOfType": {
		"prefix": "CapsuleCollider.FindObjectsOfType",
		"body": [
			"CapsuleCollider.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"CapsuleCollider.Instantiate": {
		"prefix": "CapsuleCollider.Instantiate",
		"body": [
			"CapsuleCollider.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"CapsuleCollider.OnCollisionEnter": {
		"prefix": "CapsuleCollider.OnCollisionEnter",
		"body": [
			"OnCollisionEnter"
		],
		"description": "OnCollisionEnter is called when this collider/rigidbody has begun touching another rigidbody/collider."
	}
,
	"CapsuleCollider.OnCollisionExit": {
		"prefix": "CapsuleCollider.OnCollisionExit",
		"body": [
			"OnCollisionExit"
		],
		"description": "OnCollisionExit is called when this collider/rigidbody has stopped touching another rigidbody/collider."
	}
,
	"CapsuleCollider.OnCollisionStay": {
		"prefix": "CapsuleCollider.OnCollisionStay",
		"body": [
			"OnCollisionStay"
		],
		"description": "OnCollisionStay is called once per frame for every collider/rigidbody that is touching rigidbody/collider."
	}
,
	"CapsuleCollider.OnTriggerEnter": {
		"prefix": "CapsuleCollider.OnTriggerEnter",
		"body": [
			"OnTriggerEnter"
		],
		"description": "OnTriggerEnter is called when the Collider other enters the trigger."
	}
,
	"CapsuleCollider.OnTriggerExit": {
		"prefix": "CapsuleCollider.OnTriggerExit",
		"body": [
			"OnTriggerExit"
		],
		"description": "OnTriggerExit is called when the Collider other has stopped touching the trigger."
	}
,
	"CapsuleCollider.OnTriggerStay": {
		"prefix": "CapsuleCollider.OnTriggerStay",
		"body": [
			"OnTriggerStay"
		],
		"description": "OnTriggerStay is called almost all the frames for every Collider other that is touching the trigger. The function is on the physics timer so it won't necessarily run every frame."
	}
,
	"CapsuleCollider2D.direction": {
		"prefix": "CapsuleCollider2D.direction",
		"body": [
			"direction"
		],
		"description": "return:CapsuleDirection2D des: The direction that the capsule sides can extend."
	}
,
	"CapsuleCollider2D.size": {
		"prefix": "CapsuleCollider2D.size",
		"body": [
			"size"
		],
		"description": "return:Vector2 des: The width and height of the capsule area."
	}
,
	"CapsuleCollider2D.enabled": {
		"prefix": "CapsuleCollider2D.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"CapsuleCollider2D.isActiveAndEnabled": {
		"prefix": "CapsuleCollider2D.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"CapsuleCollider2D.attachedRigidbody": {
		"prefix": "CapsuleCollider2D.attachedRigidbody",
		"body": [
			"attachedRigidbody"
		],
		"description": "return:Rigidbody2D des: The Rigidbody2D attached to the Collider2D."
	}
,
	"CapsuleCollider2D.bounciness": {
		"prefix": "CapsuleCollider2D.bounciness",
		"body": [
			"bounciness"
		],
		"description": "return:float des: Get the bounciness used by the collider."
	}
,
	"CapsuleCollider2D.bounds": {
		"prefix": "CapsuleCollider2D.bounds",
		"body": [
			"bounds"
		],
		"description": "return:Bounds des: The world space bounding area of the collider."
	}
,
	"CapsuleCollider2D.composite": {
		"prefix": "CapsuleCollider2D.composite",
		"body": [
			"composite"
		],
		"description": "return:CompositeCollider2D des: Get the CompositeCollider2D that is available to be attached to the collider."
	}
,
	"CapsuleCollider2D.density": {
		"prefix": "CapsuleCollider2D.density",
		"body": [
			"density"
		],
		"description": "return:float des: The density of the collider used to calculate its mass (when auto mass is enabled)."
	}
,
	"CapsuleCollider2D.friction": {
		"prefix": "CapsuleCollider2D.friction",
		"body": [
			"friction"
		],
		"description": "return:float des: Get the friction used by the collider."
	}
,
	"CapsuleCollider2D.isTrigger": {
		"prefix": "CapsuleCollider2D.isTrigger",
		"body": [
			"isTrigger"
		],
		"description": "return:bool des: Is this collider configured as a trigger?"
	}
,
	"CapsuleCollider2D.offset": {
		"prefix": "CapsuleCollider2D.offset",
		"body": [
			"offset"
		],
		"description": "return:Vector2 des: The local offset of the collider geometry."
	}
,
	"CapsuleCollider2D.shapeCount": {
		"prefix": "CapsuleCollider2D.shapeCount",
		"body": [
			"shapeCount"
		],
		"description": "return:int des: The number of separate shaped regions in the collider."
	}
,
	"CapsuleCollider2D.sharedMaterial": {
		"prefix": "CapsuleCollider2D.sharedMaterial",
		"body": [
			"sharedMaterial"
		],
		"description": "return:PhysicsMaterial2D des: The PhysicsMaterial2D that is applied to this collider."
	}
,
	"CapsuleCollider2D.usedByComposite": {
		"prefix": "CapsuleCollider2D.usedByComposite",
		"body": [
			"usedByComposite"
		],
		"description": "return:bool des: Sets whether the Collider will be used or not used by a CompositeCollider2D."
	}
,
	"CapsuleCollider2D.usedByEffector": {
		"prefix": "CapsuleCollider2D.usedByEffector",
		"body": [
			"usedByEffector"
		],
		"description": "return:bool des: Whether the collider is used by an attached effector or not."
	}
,
	"CapsuleCollider2D.gameObject": {
		"prefix": "CapsuleCollider2D.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"CapsuleCollider2D.tag": {
		"prefix": "CapsuleCollider2D.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"CapsuleCollider2D.transform": {
		"prefix": "CapsuleCollider2D.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"CapsuleCollider2D.hideFlags": {
		"prefix": "CapsuleCollider2D.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"CapsuleCollider2D.name": {
		"prefix": "CapsuleCollider2D.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"CapsuleCollider2D.Cast": {
		"prefix": "CapsuleCollider2D.Cast",
		"body": [
			"Cast($1)"
		],
		"description": "public int Cast(Vector2 direction, RaycastHit2D[] results, float distance = Mathf.Infinity, bool ignoreSiblingColliders = true); public int Cast(Vector2 direction, ContactFilter2D contactFilter, RaycastHit2D[] results, float distance = Mathf.Infinity, bool ignoreSiblingColliders = true); des: Casts the collider shape into the scene starting at the collider position ignoring the collider itself."
	}
,
	"CapsuleCollider2D.Distance": {
		"prefix": "CapsuleCollider2D.Distance",
		"body": [
			"Distance($1)"
		],
		"description": "public ColliderDistance2D Distance(Collider2D collider); des: Calculates the minimum separation of this collider against another collider."
	}
,
	"CapsuleCollider2D.GetContacts": {
		"prefix": "CapsuleCollider2D.GetContacts",
		"body": [
			"GetContacts($1)"
		],
		"description": "public int GetContacts(ContactPoint2D[] contacts); public int GetContacts(Collider2D[] colliders); public int GetContacts(ContactFilter2D contactFilter, ContactPoint2D[] contacts); public int GetContacts(ContactFilter2D contactFilter, Collider2D[] colliders); des: Retrieves all contact points for this collider."
	}
,
	"CapsuleCollider2D.IsTouching": {
		"prefix": "CapsuleCollider2D.IsTouching",
		"body": [
			"IsTouching($1)"
		],
		"description": "public bool IsTouching(Collider2D collider); public bool IsTouching(Collider2D collider, ContactFilter2D contactFilter); public bool IsTouching(ContactFilter2D contactFilter); des: Check whether this collider is touching the collider or not."
	}
,
	"CapsuleCollider2D.IsTouchingLayers": {
		"prefix": "CapsuleCollider2D.IsTouchingLayers",
		"body": [
			"IsTouchingLayers($1)"
		],
		"description": "public bool IsTouchingLayers(int layerMask = Physics2D.AllLayers); des: Checks whether this collider is touching any colliders on the specified layerMask or not."
	}
,
	"CapsuleCollider2D.OverlapCollider": {
		"prefix": "CapsuleCollider2D.OverlapCollider",
		"body": [
			"OverlapCollider($1)"
		],
		"description": "public int OverlapCollider(ContactFilter2D contactFilter, Collider2D[] results); des: Get a list of all colliders that overlap this collider."
	}
,
	"CapsuleCollider2D.OverlapPoint": {
		"prefix": "CapsuleCollider2D.OverlapPoint",
		"body": [
			"OverlapPoint($1)"
		],
		"description": "public bool OverlapPoint(Vector2 point); des: Check if a collider overlaps a point in space."
	}
,
	"CapsuleCollider2D.Raycast": {
		"prefix": "CapsuleCollider2D.Raycast",
		"body": [
			"Raycast($1)"
		],
		"description": "public int Raycast(Vector2 direction, RaycastHit2D[] results, float distance = Mathf.Infinity, int layerMask = Physics2D.AllLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); public int Raycast(Vector2 direction, ContactFilter2D contactFilter, RaycastHit2D[] results, float distance = Mathf.Infinity); des: Casts a ray into the scene starting at the collider position ignoring the collider itself."
	}
,
	"CapsuleCollider2D.BroadcastMessage": {
		"prefix": "CapsuleCollider2D.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"CapsuleCollider2D.CompareTag": {
		"prefix": "CapsuleCollider2D.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"CapsuleCollider2D.GetComponent": {
		"prefix": "CapsuleCollider2D.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"CapsuleCollider2D.GetComponentInChildren": {
		"prefix": "CapsuleCollider2D.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"CapsuleCollider2D.GetComponentInParent": {
		"prefix": "CapsuleCollider2D.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"CapsuleCollider2D.GetComponents": {
		"prefix": "CapsuleCollider2D.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"CapsuleCollider2D.GetComponentsInChildren": {
		"prefix": "CapsuleCollider2D.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"CapsuleCollider2D.GetComponentsInParent": {
		"prefix": "CapsuleCollider2D.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"CapsuleCollider2D.SendMessage": {
		"prefix": "CapsuleCollider2D.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"CapsuleCollider2D.SendMessageUpwards": {
		"prefix": "CapsuleCollider2D.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"CapsuleCollider2D.GetInstanceID": {
		"prefix": "CapsuleCollider2D.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"CapsuleCollider2D.ToString": {
		"prefix": "CapsuleCollider2D.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"CapsuleCollider2D.Destroy": {
		"prefix": "CapsuleCollider2D.Destroy",
		"body": [
			"CapsuleCollider2D.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"CapsuleCollider2D.DestroyImmediate": {
		"prefix": "CapsuleCollider2D.DestroyImmediate",
		"body": [
			"CapsuleCollider2D.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"CapsuleCollider2D.DontDestroyOnLoad": {
		"prefix": "CapsuleCollider2D.DontDestroyOnLoad",
		"body": [
			"CapsuleCollider2D.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"CapsuleCollider2D.FindObjectOfType": {
		"prefix": "CapsuleCollider2D.FindObjectOfType",
		"body": [
			"CapsuleCollider2D.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"CapsuleCollider2D.FindObjectsOfType": {
		"prefix": "CapsuleCollider2D.FindObjectsOfType",
		"body": [
			"CapsuleCollider2D.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"CapsuleCollider2D.Instantiate": {
		"prefix": "CapsuleCollider2D.Instantiate",
		"body": [
			"CapsuleCollider2D.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"CapsuleCollider2D.OnCollisionEnter2D": {
		"prefix": "CapsuleCollider2D.OnCollisionEnter2D",
		"body": [
			"OnCollisionEnter2D"
		],
		"description": "Sent when an incoming collider makes contact with this object's collider (2D physics only)."
	}
,
	"CapsuleCollider2D.OnCollisionExit2D": {
		"prefix": "CapsuleCollider2D.OnCollisionExit2D",
		"body": [
			"OnCollisionExit2D"
		],
		"description": "Sent when a collider on another object stops touching this object's collider (2D physics only)."
	}
,
	"CapsuleCollider2D.OnCollisionStay2D": {
		"prefix": "CapsuleCollider2D.OnCollisionStay2D",
		"body": [
			"OnCollisionStay2D"
		],
		"description": "Sent each frame where a collider on another object is touching this object's collider (2D physics only)."
	}
,
	"CapsuleCollider2D.OnTriggerEnter2D": {
		"prefix": "CapsuleCollider2D.OnTriggerEnter2D",
		"body": [
			"OnTriggerEnter2D"
		],
		"description": "Sent when another object enters a trigger collider attached to this object (2D physics only)."
	}
,
	"CapsuleCollider2D.OnTriggerExit2D": {
		"prefix": "CapsuleCollider2D.OnTriggerExit2D",
		"body": [
			"OnTriggerExit2D"
		],
		"description": "Sent when another object leaves a trigger collider attached to this object (2D physics only)."
	}
,
	"CapsuleCollider2D.OnTriggerStay2D": {
		"prefix": "CapsuleCollider2D.OnTriggerStay2D",
		"body": [
			"OnTriggerStay2D"
		],
		"description": "Sent each frame where another object is within a trigger collider attached to this object (2D physics only)."
	}
,
	"CharacterController.center": {
		"prefix": "CharacterController.center",
		"body": [
			"center"
		],
		"description": "return:Vector3 des: The center of the character's capsule relative to the transform's position."
	}
,
	"CharacterController.collisionFlags": {
		"prefix": "CharacterController.collisionFlags",
		"body": [
			"collisionFlags"
		],
		"description": "return:CollisionFlags des: What part of the capsule collided with the environment during the last CharacterController.Move call."
	}
,
	"CharacterController.detectCollisions": {
		"prefix": "CharacterController.detectCollisions",
		"body": [
			"detectCollisions"
		],
		"description": "return:bool des: Determines whether other rigidbodies or character controllers collide with this character controller (by default this is always enabled)."
	}
,
	"CharacterController.enableOverlapRecovery": {
		"prefix": "CharacterController.enableOverlapRecovery",
		"body": [
			"enableOverlapRecovery"
		],
		"description": "return:bool des: Enables or disables overlap recovery. Enables or disables overlap recovery. Used to depenetrate character controllers from static objects when an overlap is detected."
	}
,
	"CharacterController.height": {
		"prefix": "CharacterController.height",
		"body": [
			"height"
		],
		"description": "return:float des: The height of the character's capsule."
	}
,
	"CharacterController.isGrounded": {
		"prefix": "CharacterController.isGrounded",
		"body": [
			"isGrounded"
		],
		"description": "return:bool des: Was the CharacterController touching the ground during the last move?"
	}
,
	"CharacterController.minMoveDistance": {
		"prefix": "CharacterController.minMoveDistance",
		"body": [
			"minMoveDistance"
		],
		"description": "return:float des: Gets or sets the minimum move distance of the character controller."
	}
,
	"CharacterController.radius": {
		"prefix": "CharacterController.radius",
		"body": [
			"radius"
		],
		"description": "return:float des: The radius of the character's capsule."
	}
,
	"CharacterController.skinWidth": {
		"prefix": "CharacterController.skinWidth",
		"body": [
			"skinWidth"
		],
		"description": "return:float des: The character's collision skin width."
	}
,
	"CharacterController.slopeLimit": {
		"prefix": "CharacterController.slopeLimit",
		"body": [
			"slopeLimit"
		],
		"description": "return:float des: The character controllers slope limit in degrees."
	}
,
	"CharacterController.stepOffset": {
		"prefix": "CharacterController.stepOffset",
		"body": [
			"stepOffset"
		],
		"description": "return:float des: The character controllers step offset in meters."
	}
,
	"CharacterController.velocity": {
		"prefix": "CharacterController.velocity",
		"body": [
			"velocity"
		],
		"description": "return:Vector3 des: The current relative velocity of the Character (see notes)."
	}
,
	"CharacterController.Move": {
		"prefix": "CharacterController.Move",
		"body": [
			"Move($1)"
		],
		"description": "public CollisionFlags Move(Vector3 motion); des: A more complex move function taking absolute movement deltas."
	}
,
	"CharacterController.SimpleMove": {
		"prefix": "CharacterController.SimpleMove",
		"body": [
			"SimpleMove($1)"
		],
		"description": "public bool SimpleMove(Vector3 speed); des: Moves the character with speed."
	}
,
	"CharacterController.OnControllerColliderHit": {
		"prefix": "CharacterController.OnControllerColliderHit",
		"body": [
			"OnControllerColliderHit"
		],
		"description": "OnControllerColliderHit is called when the controller hits a collider while performing a Move."
	}
,
	"CharacterController.attachedRigidbody": {
		"prefix": "CharacterController.attachedRigidbody",
		"body": [
			"attachedRigidbody"
		],
		"description": "return:Rigidbody des: The rigidbody the collider is attached to."
	}
,
	"CharacterController.bounds": {
		"prefix": "CharacterController.bounds",
		"body": [
			"bounds"
		],
		"description": "return:Bounds des: The world space bounding volume of the collider (Read Only)."
	}
,
	"CharacterController.contactOffset": {
		"prefix": "CharacterController.contactOffset",
		"body": [
			"contactOffset"
		],
		"description": "return:float des: Contact offset value of this collider."
	}
,
	"CharacterController.enabled": {
		"prefix": "CharacterController.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Colliders will collide with other Colliders, disabled Colliders won't."
	}
,
	"CharacterController.isTrigger": {
		"prefix": "CharacterController.isTrigger",
		"body": [
			"isTrigger"
		],
		"description": "return:bool des: Is the collider a trigger?"
	}
,
	"CharacterController.material": {
		"prefix": "CharacterController.material",
		"body": [
			"material"
		],
		"description": "return:PhysicMaterial des: The material used by the collider."
	}
,
	"CharacterController.sharedMaterial": {
		"prefix": "CharacterController.sharedMaterial",
		"body": [
			"sharedMaterial"
		],
		"description": "return:PhysicMaterial des: The shared physic material of this collider."
	}
,
	"CharacterController.gameObject": {
		"prefix": "CharacterController.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"CharacterController.tag": {
		"prefix": "CharacterController.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"CharacterController.transform": {
		"prefix": "CharacterController.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"CharacterController.hideFlags": {
		"prefix": "CharacterController.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"CharacterController.name": {
		"prefix": "CharacterController.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"CharacterController.ClosestPoint": {
		"prefix": "CharacterController.ClosestPoint",
		"body": [
			"ClosestPoint($1)"
		],
		"description": "public Vector3 ClosestPoint(Vector3 position); des: Returns a point on the collider that is closest to a given location."
	}
,
	"CharacterController.ClosestPointOnBounds": {
		"prefix": "CharacterController.ClosestPointOnBounds",
		"body": [
			"ClosestPointOnBounds($1)"
		],
		"description": "public Vector3 ClosestPointOnBounds(Vector3 position); des: The closest point to the bounding box of the attached collider."
	}
,
	"CharacterController.Raycast": {
		"prefix": "CharacterController.Raycast",
		"body": [
			"Raycast($1)"
		],
		"description": "public bool Raycast(Ray ray, out RaycastHit hitInfo, float maxDistance); des: Casts a Ray that ignores all Colliders except this one."
	}
,
	"CharacterController.BroadcastMessage": {
		"prefix": "CharacterController.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"CharacterController.CompareTag": {
		"prefix": "CharacterController.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"CharacterController.GetComponent": {
		"prefix": "CharacterController.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"CharacterController.GetComponentInChildren": {
		"prefix": "CharacterController.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"CharacterController.GetComponentInParent": {
		"prefix": "CharacterController.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"CharacterController.GetComponents": {
		"prefix": "CharacterController.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"CharacterController.GetComponentsInChildren": {
		"prefix": "CharacterController.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"CharacterController.GetComponentsInParent": {
		"prefix": "CharacterController.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"CharacterController.SendMessage": {
		"prefix": "CharacterController.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"CharacterController.SendMessageUpwards": {
		"prefix": "CharacterController.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"CharacterController.GetInstanceID": {
		"prefix": "CharacterController.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"CharacterController.ToString": {
		"prefix": "CharacterController.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"CharacterController.Destroy": {
		"prefix": "CharacterController.Destroy",
		"body": [
			"CharacterController.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"CharacterController.DestroyImmediate": {
		"prefix": "CharacterController.DestroyImmediate",
		"body": [
			"CharacterController.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"CharacterController.DontDestroyOnLoad": {
		"prefix": "CharacterController.DontDestroyOnLoad",
		"body": [
			"CharacterController.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"CharacterController.FindObjectOfType": {
		"prefix": "CharacterController.FindObjectOfType",
		"body": [
			"CharacterController.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"CharacterController.FindObjectsOfType": {
		"prefix": "CharacterController.FindObjectsOfType",
		"body": [
			"CharacterController.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"CharacterController.Instantiate": {
		"prefix": "CharacterController.Instantiate",
		"body": [
			"CharacterController.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"CharacterController.OnCollisionEnter": {
		"prefix": "CharacterController.OnCollisionEnter",
		"body": [
			"OnCollisionEnter"
		],
		"description": "OnCollisionEnter is called when this collider/rigidbody has begun touching another rigidbody/collider."
	}
,
	"CharacterController.OnCollisionExit": {
		"prefix": "CharacterController.OnCollisionExit",
		"body": [
			"OnCollisionExit"
		],
		"description": "OnCollisionExit is called when this collider/rigidbody has stopped touching another rigidbody/collider."
	}
,
	"CharacterController.OnCollisionStay": {
		"prefix": "CharacterController.OnCollisionStay",
		"body": [
			"OnCollisionStay"
		],
		"description": "OnCollisionStay is called once per frame for every collider/rigidbody that is touching rigidbody/collider."
	}
,
	"CharacterController.OnTriggerEnter": {
		"prefix": "CharacterController.OnTriggerEnter",
		"body": [
			"OnTriggerEnter"
		],
		"description": "OnTriggerEnter is called when the Collider other enters the trigger."
	}
,
	"CharacterController.OnTriggerExit": {
		"prefix": "CharacterController.OnTriggerExit",
		"body": [
			"OnTriggerExit"
		],
		"description": "OnTriggerExit is called when the Collider other has stopped touching the trigger."
	}
,
	"CharacterController.OnTriggerStay": {
		"prefix": "CharacterController.OnTriggerStay",
		"body": [
			"OnTriggerStay"
		],
		"description": "OnTriggerStay is called almost all the frames for every Collider other that is touching the trigger. The function is on the physics timer so it won't necessarily run every frame."
	}
,
	"CharacterInfo.advance": {
		"prefix": "CharacterInfo.advance",
		"body": [
			"advance"
		],
		"description": "return:int des: The horizontal distance, rounded to the nearest integer, from the origin of this character to the origin of the next character."
	}
,
	"CharacterInfo.bearing": {
		"prefix": "CharacterInfo.bearing",
		"body": [
			"bearing"
		],
		"description": "return:int des: The horizontal distance from the origin of this glyph to the begining of the glyph image."
	}
,
	"CharacterInfo.glyphHeight": {
		"prefix": "CharacterInfo.glyphHeight",
		"body": [
			"glyphHeight"
		],
		"description": "return:int des: The height of the glyph image."
	}
,
	"CharacterInfo.glyphWidth": {
		"prefix": "CharacterInfo.glyphWidth",
		"body": [
			"glyphWidth"
		],
		"description": "return:int des: The width of the glyph image."
	}
,
	"CharacterInfo.index": {
		"prefix": "CharacterInfo.index",
		"body": [
			"index"
		],
		"description": "return:int des: Unicode value of the character."
	}
,
	"CharacterInfo.maxX": {
		"prefix": "CharacterInfo.maxX",
		"body": [
			"maxX"
		],
		"description": "return:int des: The maximum extend of the glyph image in the x-axis."
	}
,
	"CharacterInfo.maxY": {
		"prefix": "CharacterInfo.maxY",
		"body": [
			"maxY"
		],
		"description": "return:int des: The maximum extend of the glyph image in the y-axis."
	}
,
	"CharacterInfo.minX": {
		"prefix": "CharacterInfo.minX",
		"body": [
			"minX"
		],
		"description": "return:int des: The minium extend of the glyph image in the x-axis."
	}
,
	"CharacterInfo.minY": {
		"prefix": "CharacterInfo.minY",
		"body": [
			"minY"
		],
		"description": "return:int des: The minimum extend of the glyph image in the y-axis."
	}
,
	"CharacterInfo.size": {
		"prefix": "CharacterInfo.size",
		"body": [
			"size"
		],
		"description": "return:int des: The size of the character or 0 if it is the default font size."
	}
,
	"CharacterInfo.style": {
		"prefix": "CharacterInfo.style",
		"body": [
			"style"
		],
		"description": "return:FontStyle des: The style of the character."
	}
,
	"CharacterInfo.uvBottomLeft": {
		"prefix": "CharacterInfo.uvBottomLeft",
		"body": [
			"uvBottomLeft"
		],
		"description": "return:Vector2 des: The uv coordinate matching the bottom left of the glyph image in the font texture."
	}
,
	"CharacterInfo.uvBottomRight": {
		"prefix": "CharacterInfo.uvBottomRight",
		"body": [
			"uvBottomRight"
		],
		"description": "return:Vector2 des: The uv coordinate matching the bottom right of the glyph image in the font texture."
	}
,
	"CharacterInfo.uvTopLeft": {
		"prefix": "CharacterInfo.uvTopLeft",
		"body": [
			"uvTopLeft"
		],
		"description": "return:Vector2 des: The uv coordinate matching the top left of the glyph image in the font texture."
	}
,
	"CharacterInfo.uvTopRight": {
		"prefix": "CharacterInfo.uvTopRight",
		"body": [
			"uvTopRight"
		],
		"description": "return:Vector2 des: The uv coordinate matching the top right of the glyph image in the font texture."
	}
,
	"CharacterJoint.enableProjection": {
		"prefix": "CharacterJoint.enableProjection",
		"body": [
			"enableProjection"
		],
		"description": "return:bool des: Brings violated constraints back into alignment even when the solver fails."
	}
,
	"CharacterJoint.highTwistLimit": {
		"prefix": "CharacterJoint.highTwistLimit",
		"body": [
			"highTwistLimit"
		],
		"description": "return:SoftJointLimit des: The upper limit around the primary axis of the character joint."
	}
,
	"CharacterJoint.lowTwistLimit": {
		"prefix": "CharacterJoint.lowTwistLimit",
		"body": [
			"lowTwistLimit"
		],
		"description": "return:SoftJointLimit des: The lower limit around the primary axis of the character joint."
	}
,
	"CharacterJoint.projectionAngle": {
		"prefix": "CharacterJoint.projectionAngle",
		"body": [
			"projectionAngle"
		],
		"description": "return:float des: Set the angular tolerance threshold (in degrees) for projection."
	}
,
	"CharacterJoint.projectionDistance": {
		"prefix": "CharacterJoint.projectionDistance",
		"body": [
			"projectionDistance"
		],
		"description": "return:float des: Set the linear tolerance threshold for projection."
	}
,
	"CharacterJoint.swing1Limit": {
		"prefix": "CharacterJoint.swing1Limit",
		"body": [
			"swing1Limit"
		],
		"description": "return:SoftJointLimit des: The angular limit of rotation (in degrees) around the primary axis of the character joint."
	}
,
	"CharacterJoint.swing2Limit": {
		"prefix": "CharacterJoint.swing2Limit",
		"body": [
			"swing2Limit"
		],
		"description": "return:SoftJointLimit des: The angular limit of rotation (in degrees) around the primary axis of the character joint."
	}
,
	"CharacterJoint.swingAxis": {
		"prefix": "CharacterJoint.swingAxis",
		"body": [
			"swingAxis"
		],
		"description": "return:Vector3 des: The secondary axis around which the joint can rotate."
	}
,
	"CharacterJoint.swingLimitSpring": {
		"prefix": "CharacterJoint.swingLimitSpring",
		"body": [
			"swingLimitSpring"
		],
		"description": "return:SoftJointLimitSpring des: The configuration of the spring attached to the swing limits of the joint."
	}
,
	"CharacterJoint.twistLimitSpring": {
		"prefix": "CharacterJoint.twistLimitSpring",
		"body": [
			"twistLimitSpring"
		],
		"description": "return:SoftJointLimitSpring des: The configuration of the spring attached to the twist limits of the joint."
	}
,
	"CharacterJoint.gameObject": {
		"prefix": "CharacterJoint.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"CharacterJoint.tag": {
		"prefix": "CharacterJoint.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"CharacterJoint.transform": {
		"prefix": "CharacterJoint.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"CharacterJoint.anchor": {
		"prefix": "CharacterJoint.anchor",
		"body": [
			"anchor"
		],
		"description": "return:Vector3 des: The Position of the anchor around which the joints motion is constrained."
	}
,
	"CharacterJoint.autoConfigureConnectedAnchor": {
		"prefix": "CharacterJoint.autoConfigureConnectedAnchor",
		"body": [
			"autoConfigureConnectedAnchor"
		],
		"description": "return:bool des: Should the connectedAnchor be calculated automatically?"
	}
,
	"CharacterJoint.axis": {
		"prefix": "CharacterJoint.axis",
		"body": [
			"axis"
		],
		"description": "return:Vector3 des: The Direction of the axis around which the body is constrained."
	}
,
	"CharacterJoint.breakForce": {
		"prefix": "CharacterJoint.breakForce",
		"body": [
			"breakForce"
		],
		"description": "return:float des: The force that needs to be applied for this joint to break."
	}
,
	"CharacterJoint.breakTorque": {
		"prefix": "CharacterJoint.breakTorque",
		"body": [
			"breakTorque"
		],
		"description": "return:float des: The torque that needs to be applied for this joint to break."
	}
,
	"CharacterJoint.connectedAnchor": {
		"prefix": "CharacterJoint.connectedAnchor",
		"body": [
			"connectedAnchor"
		],
		"description": "return:Vector3 des: Position of the anchor relative to the connected Rigidbody."
	}
,
	"CharacterJoint.connectedBody": {
		"prefix": "CharacterJoint.connectedBody",
		"body": [
			"connectedBody"
		],
		"description": "return:Rigidbody des: A reference to another rigidbody this joint connects to."
	}
,
	"CharacterJoint.connectedMassScale": {
		"prefix": "CharacterJoint.connectedMassScale",
		"body": [
			"connectedMassScale"
		],
		"description": "return:float des: The scale to apply to the inverse mass and inertia tensor of the connected body prior to solving the constraints."
	}
,
	"CharacterJoint.currentForce": {
		"prefix": "CharacterJoint.currentForce",
		"body": [
			"currentForce"
		],
		"description": "return:Vector3 des: The force applied by the solver to satisfy all constraints."
	}
,
	"CharacterJoint.currentTorque": {
		"prefix": "CharacterJoint.currentTorque",
		"body": [
			"currentTorque"
		],
		"description": "return:Vector3 des: The torque applied by the solver to satisfy all constraints."
	}
,
	"CharacterJoint.enableCollision": {
		"prefix": "CharacterJoint.enableCollision",
		"body": [
			"enableCollision"
		],
		"description": "return:bool des: Enable collision between bodies connected with the joint."
	}
,
	"CharacterJoint.enablePreprocessing": {
		"prefix": "CharacterJoint.enablePreprocessing",
		"body": [
			"enablePreprocessing"
		],
		"description": "return:bool des: Toggle preprocessing for this joint."
	}
,
	"CharacterJoint.massScale": {
		"prefix": "CharacterJoint.massScale",
		"body": [
			"massScale"
		],
		"description": "return:float des: The scale to apply to the inverse mass and inertia tensor of the body prior to solving the constraints."
	}
,
	"CharacterJoint.hideFlags": {
		"prefix": "CharacterJoint.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"CharacterJoint.name": {
		"prefix": "CharacterJoint.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"CharacterJoint.BroadcastMessage": {
		"prefix": "CharacterJoint.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"CharacterJoint.CompareTag": {
		"prefix": "CharacterJoint.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"CharacterJoint.GetComponent": {
		"prefix": "CharacterJoint.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"CharacterJoint.GetComponentInChildren": {
		"prefix": "CharacterJoint.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"CharacterJoint.GetComponentInParent": {
		"prefix": "CharacterJoint.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"CharacterJoint.GetComponents": {
		"prefix": "CharacterJoint.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"CharacterJoint.GetComponentsInChildren": {
		"prefix": "CharacterJoint.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"CharacterJoint.GetComponentsInParent": {
		"prefix": "CharacterJoint.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"CharacterJoint.SendMessage": {
		"prefix": "CharacterJoint.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"CharacterJoint.SendMessageUpwards": {
		"prefix": "CharacterJoint.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"CharacterJoint.GetInstanceID": {
		"prefix": "CharacterJoint.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"CharacterJoint.ToString": {
		"prefix": "CharacterJoint.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"CharacterJoint.Destroy": {
		"prefix": "CharacterJoint.Destroy",
		"body": [
			"CharacterJoint.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"CharacterJoint.DestroyImmediate": {
		"prefix": "CharacterJoint.DestroyImmediate",
		"body": [
			"CharacterJoint.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"CharacterJoint.DontDestroyOnLoad": {
		"prefix": "CharacterJoint.DontDestroyOnLoad",
		"body": [
			"CharacterJoint.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"CharacterJoint.FindObjectOfType": {
		"prefix": "CharacterJoint.FindObjectOfType",
		"body": [
			"CharacterJoint.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"CharacterJoint.FindObjectsOfType": {
		"prefix": "CharacterJoint.FindObjectsOfType",
		"body": [
			"CharacterJoint.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"CharacterJoint.Instantiate": {
		"prefix": "CharacterJoint.Instantiate",
		"body": [
			"CharacterJoint.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"CharacterJoint.OnJointBreak": {
		"prefix": "CharacterJoint.OnJointBreak",
		"body": [
			"OnJointBreak"
		],
		"description": "Called when a joint attached to the same game object broke."
	}
,
	"CircleCollider2D.radius": {
		"prefix": "CircleCollider2D.radius",
		"body": [
			"radius"
		],
		"description": "return:float des: Radius of the circle."
	}
,
	"CircleCollider2D.enabled": {
		"prefix": "CircleCollider2D.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"CircleCollider2D.isActiveAndEnabled": {
		"prefix": "CircleCollider2D.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"CircleCollider2D.attachedRigidbody": {
		"prefix": "CircleCollider2D.attachedRigidbody",
		"body": [
			"attachedRigidbody"
		],
		"description": "return:Rigidbody2D des: The Rigidbody2D attached to the Collider2D."
	}
,
	"CircleCollider2D.bounciness": {
		"prefix": "CircleCollider2D.bounciness",
		"body": [
			"bounciness"
		],
		"description": "return:float des: Get the bounciness used by the collider."
	}
,
	"CircleCollider2D.bounds": {
		"prefix": "CircleCollider2D.bounds",
		"body": [
			"bounds"
		],
		"description": "return:Bounds des: The world space bounding area of the collider."
	}
,
	"CircleCollider2D.composite": {
		"prefix": "CircleCollider2D.composite",
		"body": [
			"composite"
		],
		"description": "return:CompositeCollider2D des: Get the CompositeCollider2D that is available to be attached to the collider."
	}
,
	"CircleCollider2D.density": {
		"prefix": "CircleCollider2D.density",
		"body": [
			"density"
		],
		"description": "return:float des: The density of the collider used to calculate its mass (when auto mass is enabled)."
	}
,
	"CircleCollider2D.friction": {
		"prefix": "CircleCollider2D.friction",
		"body": [
			"friction"
		],
		"description": "return:float des: Get the friction used by the collider."
	}
,
	"CircleCollider2D.isTrigger": {
		"prefix": "CircleCollider2D.isTrigger",
		"body": [
			"isTrigger"
		],
		"description": "return:bool des: Is this collider configured as a trigger?"
	}
,
	"CircleCollider2D.offset": {
		"prefix": "CircleCollider2D.offset",
		"body": [
			"offset"
		],
		"description": "return:Vector2 des: The local offset of the collider geometry."
	}
,
	"CircleCollider2D.shapeCount": {
		"prefix": "CircleCollider2D.shapeCount",
		"body": [
			"shapeCount"
		],
		"description": "return:int des: The number of separate shaped regions in the collider."
	}
,
	"CircleCollider2D.sharedMaterial": {
		"prefix": "CircleCollider2D.sharedMaterial",
		"body": [
			"sharedMaterial"
		],
		"description": "return:PhysicsMaterial2D des: The PhysicsMaterial2D that is applied to this collider."
	}
,
	"CircleCollider2D.usedByComposite": {
		"prefix": "CircleCollider2D.usedByComposite",
		"body": [
			"usedByComposite"
		],
		"description": "return:bool des: Sets whether the Collider will be used or not used by a CompositeCollider2D."
	}
,
	"CircleCollider2D.usedByEffector": {
		"prefix": "CircleCollider2D.usedByEffector",
		"body": [
			"usedByEffector"
		],
		"description": "return:bool des: Whether the collider is used by an attached effector or not."
	}
,
	"CircleCollider2D.gameObject": {
		"prefix": "CircleCollider2D.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"CircleCollider2D.tag": {
		"prefix": "CircleCollider2D.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"CircleCollider2D.transform": {
		"prefix": "CircleCollider2D.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"CircleCollider2D.hideFlags": {
		"prefix": "CircleCollider2D.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"CircleCollider2D.name": {
		"prefix": "CircleCollider2D.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"CircleCollider2D.Cast": {
		"prefix": "CircleCollider2D.Cast",
		"body": [
			"Cast($1)"
		],
		"description": "public int Cast(Vector2 direction, RaycastHit2D[] results, float distance = Mathf.Infinity, bool ignoreSiblingColliders = true); public int Cast(Vector2 direction, ContactFilter2D contactFilter, RaycastHit2D[] results, float distance = Mathf.Infinity, bool ignoreSiblingColliders = true); des: Casts the collider shape into the scene starting at the collider position ignoring the collider itself."
	}
,
	"CircleCollider2D.Distance": {
		"prefix": "CircleCollider2D.Distance",
		"body": [
			"Distance($1)"
		],
		"description": "public ColliderDistance2D Distance(Collider2D collider); des: Calculates the minimum separation of this collider against another collider."
	}
,
	"CircleCollider2D.GetContacts": {
		"prefix": "CircleCollider2D.GetContacts",
		"body": [
			"GetContacts($1)"
		],
		"description": "public int GetContacts(ContactPoint2D[] contacts); public int GetContacts(Collider2D[] colliders); public int GetContacts(ContactFilter2D contactFilter, ContactPoint2D[] contacts); public int GetContacts(ContactFilter2D contactFilter, Collider2D[] colliders); des: Retrieves all contact points for this collider."
	}
,
	"CircleCollider2D.IsTouching": {
		"prefix": "CircleCollider2D.IsTouching",
		"body": [
			"IsTouching($1)"
		],
		"description": "public bool IsTouching(Collider2D collider); public bool IsTouching(Collider2D collider, ContactFilter2D contactFilter); public bool IsTouching(ContactFilter2D contactFilter); des: Check whether this collider is touching the collider or not."
	}
,
	"CircleCollider2D.IsTouchingLayers": {
		"prefix": "CircleCollider2D.IsTouchingLayers",
		"body": [
			"IsTouchingLayers($1)"
		],
		"description": "public bool IsTouchingLayers(int layerMask = Physics2D.AllLayers); des: Checks whether this collider is touching any colliders on the specified layerMask or not."
	}
,
	"CircleCollider2D.OverlapCollider": {
		"prefix": "CircleCollider2D.OverlapCollider",
		"body": [
			"OverlapCollider($1)"
		],
		"description": "public int OverlapCollider(ContactFilter2D contactFilter, Collider2D[] results); des: Get a list of all colliders that overlap this collider."
	}
,
	"CircleCollider2D.OverlapPoint": {
		"prefix": "CircleCollider2D.OverlapPoint",
		"body": [
			"OverlapPoint($1)"
		],
		"description": "public bool OverlapPoint(Vector2 point); des: Check if a collider overlaps a point in space."
	}
,
	"CircleCollider2D.Raycast": {
		"prefix": "CircleCollider2D.Raycast",
		"body": [
			"Raycast($1)"
		],
		"description": "public int Raycast(Vector2 direction, RaycastHit2D[] results, float distance = Mathf.Infinity, int layerMask = Physics2D.AllLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); public int Raycast(Vector2 direction, ContactFilter2D contactFilter, RaycastHit2D[] results, float distance = Mathf.Infinity); des: Casts a ray into the scene starting at the collider position ignoring the collider itself."
	}
,
	"CircleCollider2D.BroadcastMessage": {
		"prefix": "CircleCollider2D.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"CircleCollider2D.CompareTag": {
		"prefix": "CircleCollider2D.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"CircleCollider2D.GetComponent": {
		"prefix": "CircleCollider2D.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"CircleCollider2D.GetComponentInChildren": {
		"prefix": "CircleCollider2D.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"CircleCollider2D.GetComponentInParent": {
		"prefix": "CircleCollider2D.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"CircleCollider2D.GetComponents": {
		"prefix": "CircleCollider2D.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"CircleCollider2D.GetComponentsInChildren": {
		"prefix": "CircleCollider2D.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"CircleCollider2D.GetComponentsInParent": {
		"prefix": "CircleCollider2D.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"CircleCollider2D.SendMessage": {
		"prefix": "CircleCollider2D.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"CircleCollider2D.SendMessageUpwards": {
		"prefix": "CircleCollider2D.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"CircleCollider2D.GetInstanceID": {
		"prefix": "CircleCollider2D.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"CircleCollider2D.ToString": {
		"prefix": "CircleCollider2D.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"CircleCollider2D.Destroy": {
		"prefix": "CircleCollider2D.Destroy",
		"body": [
			"CircleCollider2D.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"CircleCollider2D.DestroyImmediate": {
		"prefix": "CircleCollider2D.DestroyImmediate",
		"body": [
			"CircleCollider2D.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"CircleCollider2D.DontDestroyOnLoad": {
		"prefix": "CircleCollider2D.DontDestroyOnLoad",
		"body": [
			"CircleCollider2D.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"CircleCollider2D.FindObjectOfType": {
		"prefix": "CircleCollider2D.FindObjectOfType",
		"body": [
			"CircleCollider2D.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"CircleCollider2D.FindObjectsOfType": {
		"prefix": "CircleCollider2D.FindObjectsOfType",
		"body": [
			"CircleCollider2D.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"CircleCollider2D.Instantiate": {
		"prefix": "CircleCollider2D.Instantiate",
		"body": [
			"CircleCollider2D.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"CircleCollider2D.OnCollisionEnter2D": {
		"prefix": "CircleCollider2D.OnCollisionEnter2D",
		"body": [
			"OnCollisionEnter2D"
		],
		"description": "Sent when an incoming collider makes contact with this object's collider (2D physics only)."
	}
,
	"CircleCollider2D.OnCollisionExit2D": {
		"prefix": "CircleCollider2D.OnCollisionExit2D",
		"body": [
			"OnCollisionExit2D"
		],
		"description": "Sent when a collider on another object stops touching this object's collider (2D physics only)."
	}
,
	"CircleCollider2D.OnCollisionStay2D": {
		"prefix": "CircleCollider2D.OnCollisionStay2D",
		"body": [
			"OnCollisionStay2D"
		],
		"description": "Sent each frame where a collider on another object is touching this object's collider (2D physics only)."
	}
,
	"CircleCollider2D.OnTriggerEnter2D": {
		"prefix": "CircleCollider2D.OnTriggerEnter2D",
		"body": [
			"OnTriggerEnter2D"
		],
		"description": "Sent when another object enters a trigger collider attached to this object (2D physics only)."
	}
,
	"CircleCollider2D.OnTriggerExit2D": {
		"prefix": "CircleCollider2D.OnTriggerExit2D",
		"body": [
			"OnTriggerExit2D"
		],
		"description": "Sent when another object leaves a trigger collider attached to this object (2D physics only)."
	}
,
	"CircleCollider2D.OnTriggerStay2D": {
		"prefix": "CircleCollider2D.OnTriggerStay2D",
		"body": [
			"OnTriggerStay2D"
		],
		"description": "Sent each frame where another object is within a trigger collider attached to this object (2D physics only)."
	}
,
	"Cloth.bendingStiffness": {
		"prefix": "Cloth.bendingStiffness",
		"body": [
			"bendingStiffness"
		],
		"description": "return:float des: Bending stiffness of the cloth."
	}
,
	"Cloth.capsuleColliders": {
		"prefix": "Cloth.capsuleColliders",
		"body": [
			"capsuleColliders"
		],
		"description": "return:CapsuleCollider[] des: An array of CapsuleColliders which this Cloth instance should collide with."
	}
,
	"Cloth.clothSolverFrequency": {
		"prefix": "Cloth.clothSolverFrequency",
		"body": [
			"clothSolverFrequency"
		],
		"description": "return:float des: Number of cloth solver iterations per second."
	}
,
	"Cloth.coefficients": {
		"prefix": "Cloth.coefficients",
		"body": [
			"coefficients"
		],
		"description": "return:ClothSkinningCoefficient[] des: The cloth skinning coefficients used to set up how the cloth interacts with the skinned mesh."
	}
,
	"Cloth.collisionMassScale": {
		"prefix": "Cloth.collisionMassScale",
		"body": [
			"collisionMassScale"
		],
		"description": "return:float des: How much to increase mass of colliding particles."
	}
,
	"Cloth.damping": {
		"prefix": "Cloth.damping",
		"body": [
			"damping"
		],
		"description": "return:float des: Damp cloth motion."
	}
,
	"Cloth.enableContinuousCollision": {
		"prefix": "Cloth.enableContinuousCollision",
		"body": [
			"enableContinuousCollision"
		],
		"description": "return:bool des: Enable continuous collision to improve collision stability."
	}
,
	"Cloth.enabled": {
		"prefix": "Cloth.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Is this cloth enabled?"
	}
,
	"Cloth.externalAcceleration": {
		"prefix": "Cloth.externalAcceleration",
		"body": [
			"externalAcceleration"
		],
		"description": "return:Vector3 des: A constant, external acceleration applied to the cloth."
	}
,
	"Cloth.friction": {
		"prefix": "Cloth.friction",
		"body": [
			"friction"
		],
		"description": "return:float des: The friction of the cloth when colliding with the character."
	}
,
	"Cloth.normals": {
		"prefix": "Cloth.normals",
		"body": [
			"normals"
		],
		"description": "return:Vector3[] des: The current normals of the cloth object."
	}
,
	"Cloth.randomAcceleration": {
		"prefix": "Cloth.randomAcceleration",
		"body": [
			"randomAcceleration"
		],
		"description": "return:Vector3 des: A random, external acceleration applied to the cloth."
	}
,
	"Cloth.selfCollisionDistance": {
		"prefix": "Cloth.selfCollisionDistance",
		"body": [
			"selfCollisionDistance"
		],
		"description": "return:float des: Minimum distance at which two cloth particles repel each other (default: 0.0)."
	}
,
	"Cloth.selfCollisionStiffness": {
		"prefix": "Cloth.selfCollisionStiffness",
		"body": [
			"selfCollisionStiffness"
		],
		"description": "return:float des: Self-collision stiffness defines how strong the separating impulse should be for colliding particles."
	}
,
	"Cloth.sleepThreshold": {
		"prefix": "Cloth.sleepThreshold",
		"body": [
			"sleepThreshold"
		],
		"description": "return:float des: Cloth's sleep threshold."
	}
,
	"Cloth.sphereColliders": {
		"prefix": "Cloth.sphereColliders",
		"body": [
			"sphereColliders"
		],
		"description": "return:ClothSphereColliderPair[] des: An array of ClothSphereColliderPairs which this Cloth instance should collide with."
	}
,
	"Cloth.stiffnessFrequency": {
		"prefix": "Cloth.stiffnessFrequency",
		"body": [
			"stiffnessFrequency"
		],
		"description": "return:float des: Sets the stiffness frequency parameter."
	}
,
	"Cloth.stretchingStiffness": {
		"prefix": "Cloth.stretchingStiffness",
		"body": [
			"stretchingStiffness"
		],
		"description": "return:float des: Stretching stiffness of the cloth."
	}
,
	"Cloth.useGravity": {
		"prefix": "Cloth.useGravity",
		"body": [
			"useGravity"
		],
		"description": "return:bool des: Should gravity affect the cloth simulation?"
	}
,
	"Cloth.useTethers": {
		"prefix": "Cloth.useTethers",
		"body": [
			"useTethers"
		],
		"description": "return:bool des: Use Tether Anchors."
	}
,
	"Cloth.useVirtualParticles": {
		"prefix": "Cloth.useVirtualParticles",
		"body": [
			"useVirtualParticles"
		],
		"description": "return:float des: Add one virtual particle per triangle to improve collision stability."
	}
,
	"Cloth.vertices": {
		"prefix": "Cloth.vertices",
		"body": [
			"vertices"
		],
		"description": "return:Vector3[] des: The current vertex positions of the cloth object."
	}
,
	"Cloth.worldAccelerationScale": {
		"prefix": "Cloth.worldAccelerationScale",
		"body": [
			"worldAccelerationScale"
		],
		"description": "return:float des: How much world-space acceleration of the character will affect cloth vertices."
	}
,
	"Cloth.worldVelocityScale": {
		"prefix": "Cloth.worldVelocityScale",
		"body": [
			"worldVelocityScale"
		],
		"description": "return:float des: How much world-space movement of the character will affect cloth vertices."
	}
,
	"Cloth.ClearTransformMotion": {
		"prefix": "Cloth.ClearTransformMotion",
		"body": [
			"ClearTransformMotion($1)"
		],
		"description": "public void ClearTransformMotion(); des: Clear the pending transform changes from affecting the cloth simulation."
	}
,
	"Cloth.GetSelfAndInterCollisionIndices": {
		"prefix": "Cloth.GetSelfAndInterCollisionIndices",
		"body": [
			"GetSelfAndInterCollisionIndices($1)"
		],
		"description": "public void GetSelfAndInterCollisionIndices(List<uint> indices); des: Get list of particles to be used for self and inter collision."
	}
,
	"Cloth.GetVirtualParticleIndices": {
		"prefix": "Cloth.GetVirtualParticleIndices",
		"body": [
			"GetVirtualParticleIndices($1)"
		],
		"description": "public void GetVirtualParticleIndices(List<uint> indices); des: Get list of indices to be used when generating virtual particles."
	}
,
	"Cloth.GetVirtualParticleWeights": {
		"prefix": "Cloth.GetVirtualParticleWeights",
		"body": [
			"GetVirtualParticleWeights($1)"
		],
		"description": "public void GetVirtualParticleWeights(List<Vector3> weights); des: Get weights to be used when generating virtual particles for cloth."
	}
,
	"Cloth.SetEnabledFading": {
		"prefix": "Cloth.SetEnabledFading",
		"body": [
			"SetEnabledFading($1)"
		],
		"description": "public void SetEnabledFading(bool enabled, float interpolationTime = 0.5f); des: Fade the cloth simulation in or out."
	}
,
	"Cloth.SetSelfAndInterCollisionIndices": {
		"prefix": "Cloth.SetSelfAndInterCollisionIndices",
		"body": [
			"SetSelfAndInterCollisionIndices($1)"
		],
		"description": "public void SetSelfAndInterCollisionIndices(List<uint> indices); des: This allows you to set the cloth indices used for self and inter collision."
	}
,
	"Cloth.SetVirtualParticleIndices": {
		"prefix": "Cloth.SetVirtualParticleIndices",
		"body": [
			"SetVirtualParticleIndices($1)"
		],
		"description": "public void SetVirtualParticleIndices(List<uint> indices); des: Set indices to use when generating virtual particles."
	}
,
	"Cloth.SetVirtualParticleWeights": {
		"prefix": "Cloth.SetVirtualParticleWeights",
		"body": [
			"SetVirtualParticleWeights($1)"
		],
		"description": "public void SetVirtualParticleWeights(List<Vector3> weights); des: Sets weights to be used when generating virtual particles for cloth."
	}
,
	"Cloth.gameObject": {
		"prefix": "Cloth.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"Cloth.tag": {
		"prefix": "Cloth.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"Cloth.transform": {
		"prefix": "Cloth.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"Cloth.hideFlags": {
		"prefix": "Cloth.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Cloth.name": {
		"prefix": "Cloth.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Cloth.BroadcastMessage": {
		"prefix": "Cloth.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"Cloth.CompareTag": {
		"prefix": "Cloth.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"Cloth.GetComponent": {
		"prefix": "Cloth.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"Cloth.GetComponentInChildren": {
		"prefix": "Cloth.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"Cloth.GetComponentInParent": {
		"prefix": "Cloth.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"Cloth.GetComponents": {
		"prefix": "Cloth.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"Cloth.GetComponentsInChildren": {
		"prefix": "Cloth.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"Cloth.GetComponentsInParent": {
		"prefix": "Cloth.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"Cloth.SendMessage": {
		"prefix": "Cloth.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"Cloth.SendMessageUpwards": {
		"prefix": "Cloth.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"Cloth.GetInstanceID": {
		"prefix": "Cloth.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Cloth.ToString": {
		"prefix": "Cloth.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Cloth.Destroy": {
		"prefix": "Cloth.Destroy",
		"body": [
			"Cloth.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Cloth.DestroyImmediate": {
		"prefix": "Cloth.DestroyImmediate",
		"body": [
			"Cloth.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Cloth.DontDestroyOnLoad": {
		"prefix": "Cloth.DontDestroyOnLoad",
		"body": [
			"Cloth.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Cloth.FindObjectOfType": {
		"prefix": "Cloth.FindObjectOfType",
		"body": [
			"Cloth.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Cloth.FindObjectsOfType": {
		"prefix": "Cloth.FindObjectsOfType",
		"body": [
			"Cloth.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Cloth.Instantiate": {
		"prefix": "Cloth.Instantiate",
		"body": [
			"Cloth.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"ClothSkinningCoefficient.collisionSphereDistance": {
		"prefix": "ClothSkinningCoefficient.collisionSphereDistance",
		"body": [
			"collisionSphereDistance"
		],
		"description": "return:float des: Definition of a sphere a vertex is not allowed to enter. This allows collision against the animated cloth."
	}
,
	"ClothSkinningCoefficient.maxDistance": {
		"prefix": "ClothSkinningCoefficient.maxDistance",
		"body": [
			"maxDistance"
		],
		"description": "return:float des: Distance a vertex is allowed to travel from the skinned mesh vertex position."
	}
,
	"ClothSphereColliderPair.first": {
		"prefix": "ClothSphereColliderPair.first",
		"body": [
			"first"
		],
		"description": "return:SphereCollider des: The first SphereCollider of a ClothSphereColliderPair."
	}
,
	"ClothSphereColliderPair.second": {
		"prefix": "ClothSphereColliderPair.second",
		"body": [
			"second"
		],
		"description": "return:SphereCollider des: The second SphereCollider of a ClothSphereColliderPair."
	}
,
	"ClusterInput.AddInput": {
		"prefix": "ClusterInput.AddInput",
		"body": [
			"ClusterInput.AddInput"
		],
		"description": "public static bool AddInput(string name, string deviceName, string serverUrl, int index, ClusterInputType type); des: Add a new VRPN input entry."
	}
,
	"ClusterInput.CheckConnectionToServer": {
		"prefix": "ClusterInput.CheckConnectionToServer",
		"body": [
			"ClusterInput.CheckConnectionToServer"
		],
		"description": "public static bool CheckConnectionToServer(string name); des: Check the connection status of the device to the VRPN server it connected to."
	}
,
	"ClusterInput.EditInput": {
		"prefix": "ClusterInput.EditInput",
		"body": [
			"ClusterInput.EditInput"
		],
		"description": "public static bool EditInput(string name, string deviceName, string serverUrl, int index, ClusterInputType type); des: Edit an input entry which added via ClusterInput.AddInput."
	}
,
	"ClusterInput.GetAxis": {
		"prefix": "ClusterInput.GetAxis",
		"body": [
			"ClusterInput.GetAxis"
		],
		"description": "public static float GetAxis(string name); des: Returns the axis value as a continous float."
	}
,
	"ClusterInput.GetButton": {
		"prefix": "ClusterInput.GetButton",
		"body": [
			"ClusterInput.GetButton"
		],
		"description": "public static bool GetButton(string name); des: Returns the binary value of a button."
	}
,
	"ClusterInput.GetTrackerPosition": {
		"prefix": "ClusterInput.GetTrackerPosition",
		"body": [
			"ClusterInput.GetTrackerPosition"
		],
		"description": "public static Vector3 GetTrackerPosition(string name); des: Return the position of a tracker as a Vector3."
	}
,
	"ClusterInput.GetTrackerRotation": {
		"prefix": "ClusterInput.GetTrackerRotation",
		"body": [
			"ClusterInput.GetTrackerRotation"
		],
		"description": "public static Quaternion GetTrackerRotation(string name); des: Returns the rotation of a tracker as a Quaternion."
	}
,
	"ClusterInput.SetAxis": {
		"prefix": "ClusterInput.SetAxis",
		"body": [
			"ClusterInput.SetAxis"
		],
		"description": "public static void SetAxis(string name, float value); des: Sets the axis value for this input. Only works for input typed Custom."
	}
,
	"ClusterInput.SetButton": {
		"prefix": "ClusterInput.SetButton",
		"body": [
			"ClusterInput.SetButton"
		],
		"description": "public static void SetButton(string name, bool value); des: Sets the button value for this input. Only works for input typed Custom."
	}
,
	"ClusterInput.SetTrackerPosition": {
		"prefix": "ClusterInput.SetTrackerPosition",
		"body": [
			"ClusterInput.SetTrackerPosition"
		],
		"description": "public static void SetTrackerPosition(string name, Vector3 value); des: Sets the tracker position for this input. Only works for input typed Custom."
	}
,
	"ClusterInput.SetTrackerRotation": {
		"prefix": "ClusterInput.SetTrackerRotation",
		"body": [
			"ClusterInput.SetTrackerRotation"
		],
		"description": "public static void SetTrackerRotation(string name, Quaternion value); des: Sets the tracker rotation for this input. Only works for input typed Custom."
	}
,
	"Collider.attachedRigidbody": {
		"prefix": "Collider.attachedRigidbody",
		"body": [
			"attachedRigidbody"
		],
		"description": "return:Rigidbody des: The rigidbody the collider is attached to."
	}
,
	"Collider.bounds": {
		"prefix": "Collider.bounds",
		"body": [
			"bounds"
		],
		"description": "return:Bounds des: The world space bounding volume of the collider (Read Only)."
	}
,
	"Collider.contactOffset": {
		"prefix": "Collider.contactOffset",
		"body": [
			"contactOffset"
		],
		"description": "return:float des: Contact offset value of this collider."
	}
,
	"Collider.enabled": {
		"prefix": "Collider.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Colliders will collide with other Colliders, disabled Colliders won't."
	}
,
	"Collider.isTrigger": {
		"prefix": "Collider.isTrigger",
		"body": [
			"isTrigger"
		],
		"description": "return:bool des: Is the collider a trigger?"
	}
,
	"Collider.material": {
		"prefix": "Collider.material",
		"body": [
			"material"
		],
		"description": "return:PhysicMaterial des: The material used by the collider."
	}
,
	"Collider.sharedMaterial": {
		"prefix": "Collider.sharedMaterial",
		"body": [
			"sharedMaterial"
		],
		"description": "return:PhysicMaterial des: The shared physic material of this collider."
	}
,
	"Collider.ClosestPoint": {
		"prefix": "Collider.ClosestPoint",
		"body": [
			"ClosestPoint($1)"
		],
		"description": "public Vector3 ClosestPoint(Vector3 position); des: Returns a point on the collider that is closest to a given location."
	}
,
	"Collider.ClosestPointOnBounds": {
		"prefix": "Collider.ClosestPointOnBounds",
		"body": [
			"ClosestPointOnBounds($1)"
		],
		"description": "public Vector3 ClosestPointOnBounds(Vector3 position); des: The closest point to the bounding box of the attached collider."
	}
,
	"Collider.Raycast": {
		"prefix": "Collider.Raycast",
		"body": [
			"Raycast($1)"
		],
		"description": "public bool Raycast(Ray ray, out RaycastHit hitInfo, float maxDistance); des: Casts a Ray that ignores all Colliders except this one."
	}
,
	"Collider.OnCollisionEnter": {
		"prefix": "Collider.OnCollisionEnter",
		"body": [
			"OnCollisionEnter"
		],
		"description": "OnCollisionEnter is called when this collider/rigidbody has begun touching another rigidbody/collider."
	}
,
	"Collider.OnCollisionExit": {
		"prefix": "Collider.OnCollisionExit",
		"body": [
			"OnCollisionExit"
		],
		"description": "OnCollisionExit is called when this collider/rigidbody has stopped touching another rigidbody/collider."
	}
,
	"Collider.OnCollisionStay": {
		"prefix": "Collider.OnCollisionStay",
		"body": [
			"OnCollisionStay"
		],
		"description": "OnCollisionStay is called once per frame for every collider/rigidbody that is touching rigidbody/collider."
	}
,
	"Collider.OnTriggerEnter": {
		"prefix": "Collider.OnTriggerEnter",
		"body": [
			"OnTriggerEnter"
		],
		"description": "OnTriggerEnter is called when the Collider other enters the trigger."
	}
,
	"Collider.OnTriggerExit": {
		"prefix": "Collider.OnTriggerExit",
		"body": [
			"OnTriggerExit"
		],
		"description": "OnTriggerExit is called when the Collider other has stopped touching the trigger."
	}
,
	"Collider.OnTriggerStay": {
		"prefix": "Collider.OnTriggerStay",
		"body": [
			"OnTriggerStay"
		],
		"description": "OnTriggerStay is called almost all the frames for every Collider other that is touching the trigger. The function is on the physics timer so it won't necessarily run every frame."
	}
,
	"Collider.gameObject": {
		"prefix": "Collider.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"Collider.tag": {
		"prefix": "Collider.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"Collider.transform": {
		"prefix": "Collider.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"Collider.hideFlags": {
		"prefix": "Collider.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Collider.name": {
		"prefix": "Collider.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Collider.BroadcastMessage": {
		"prefix": "Collider.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"Collider.CompareTag": {
		"prefix": "Collider.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"Collider.GetComponent": {
		"prefix": "Collider.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"Collider.GetComponentInChildren": {
		"prefix": "Collider.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"Collider.GetComponentInParent": {
		"prefix": "Collider.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"Collider.GetComponents": {
		"prefix": "Collider.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"Collider.GetComponentsInChildren": {
		"prefix": "Collider.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"Collider.GetComponentsInParent": {
		"prefix": "Collider.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"Collider.SendMessage": {
		"prefix": "Collider.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"Collider.SendMessageUpwards": {
		"prefix": "Collider.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"Collider.GetInstanceID": {
		"prefix": "Collider.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Collider.ToString": {
		"prefix": "Collider.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Collider.Destroy": {
		"prefix": "Collider.Destroy",
		"body": [
			"Collider.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Collider.DestroyImmediate": {
		"prefix": "Collider.DestroyImmediate",
		"body": [
			"Collider.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Collider.DontDestroyOnLoad": {
		"prefix": "Collider.DontDestroyOnLoad",
		"body": [
			"Collider.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Collider.FindObjectOfType": {
		"prefix": "Collider.FindObjectOfType",
		"body": [
			"Collider.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Collider.FindObjectsOfType": {
		"prefix": "Collider.FindObjectsOfType",
		"body": [
			"Collider.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Collider.Instantiate": {
		"prefix": "Collider.Instantiate",
		"body": [
			"Collider.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"Collider2D.attachedRigidbody": {
		"prefix": "Collider2D.attachedRigidbody",
		"body": [
			"attachedRigidbody"
		],
		"description": "return:Rigidbody2D des: The Rigidbody2D attached to the Collider2D."
	}
,
	"Collider2D.bounciness": {
		"prefix": "Collider2D.bounciness",
		"body": [
			"bounciness"
		],
		"description": "return:float des: Get the bounciness used by the collider."
	}
,
	"Collider2D.bounds": {
		"prefix": "Collider2D.bounds",
		"body": [
			"bounds"
		],
		"description": "return:Bounds des: The world space bounding area of the collider."
	}
,
	"Collider2D.composite": {
		"prefix": "Collider2D.composite",
		"body": [
			"composite"
		],
		"description": "return:CompositeCollider2D des: Get the CompositeCollider2D that is available to be attached to the collider."
	}
,
	"Collider2D.density": {
		"prefix": "Collider2D.density",
		"body": [
			"density"
		],
		"description": "return:float des: The density of the collider used to calculate its mass (when auto mass is enabled)."
	}
,
	"Collider2D.friction": {
		"prefix": "Collider2D.friction",
		"body": [
			"friction"
		],
		"description": "return:float des: Get the friction used by the collider."
	}
,
	"Collider2D.isTrigger": {
		"prefix": "Collider2D.isTrigger",
		"body": [
			"isTrigger"
		],
		"description": "return:bool des: Is this collider configured as a trigger?"
	}
,
	"Collider2D.offset": {
		"prefix": "Collider2D.offset",
		"body": [
			"offset"
		],
		"description": "return:Vector2 des: The local offset of the collider geometry."
	}
,
	"Collider2D.shapeCount": {
		"prefix": "Collider2D.shapeCount",
		"body": [
			"shapeCount"
		],
		"description": "return:int des: The number of separate shaped regions in the collider."
	}
,
	"Collider2D.sharedMaterial": {
		"prefix": "Collider2D.sharedMaterial",
		"body": [
			"sharedMaterial"
		],
		"description": "return:PhysicsMaterial2D des: The PhysicsMaterial2D that is applied to this collider."
	}
,
	"Collider2D.usedByComposite": {
		"prefix": "Collider2D.usedByComposite",
		"body": [
			"usedByComposite"
		],
		"description": "return:bool des: Sets whether the Collider will be used or not used by a CompositeCollider2D."
	}
,
	"Collider2D.usedByEffector": {
		"prefix": "Collider2D.usedByEffector",
		"body": [
			"usedByEffector"
		],
		"description": "return:bool des: Whether the collider is used by an attached effector or not."
	}
,
	"Collider2D.Cast": {
		"prefix": "Collider2D.Cast",
		"body": [
			"Cast($1)"
		],
		"description": "public int Cast(Vector2 direction, RaycastHit2D[] results, float distance = Mathf.Infinity, bool ignoreSiblingColliders = true); public int Cast(Vector2 direction, ContactFilter2D contactFilter, RaycastHit2D[] results, float distance = Mathf.Infinity, bool ignoreSiblingColliders = true); des: Casts the collider shape into the scene starting at the collider position ignoring the collider itself."
	}
,
	"Collider2D.Distance": {
		"prefix": "Collider2D.Distance",
		"body": [
			"Distance($1)"
		],
		"description": "public ColliderDistance2D Distance(Collider2D collider); des: Calculates the minimum separation of this collider against another collider."
	}
,
	"Collider2D.GetContacts": {
		"prefix": "Collider2D.GetContacts",
		"body": [
			"GetContacts($1)"
		],
		"description": "public int GetContacts(ContactPoint2D[] contacts); public int GetContacts(Collider2D[] colliders); public int GetContacts(ContactFilter2D contactFilter, ContactPoint2D[] contacts); public int GetContacts(ContactFilter2D contactFilter, Collider2D[] colliders); des: Retrieves all contact points for this collider."
	}
,
	"Collider2D.IsTouching": {
		"prefix": "Collider2D.IsTouching",
		"body": [
			"IsTouching($1)"
		],
		"description": "public bool IsTouching(Collider2D collider); public bool IsTouching(Collider2D collider, ContactFilter2D contactFilter); public bool IsTouching(ContactFilter2D contactFilter); des: Check whether this collider is touching the collider or not."
	}
,
	"Collider2D.IsTouchingLayers": {
		"prefix": "Collider2D.IsTouchingLayers",
		"body": [
			"IsTouchingLayers($1)"
		],
		"description": "public bool IsTouchingLayers(int layerMask = Physics2D.AllLayers); des: Checks whether this collider is touching any colliders on the specified layerMask or not."
	}
,
	"Collider2D.OverlapCollider": {
		"prefix": "Collider2D.OverlapCollider",
		"body": [
			"OverlapCollider($1)"
		],
		"description": "public int OverlapCollider(ContactFilter2D contactFilter, Collider2D[] results); des: Get a list of all colliders that overlap this collider."
	}
,
	"Collider2D.OverlapPoint": {
		"prefix": "Collider2D.OverlapPoint",
		"body": [
			"OverlapPoint($1)"
		],
		"description": "public bool OverlapPoint(Vector2 point); des: Check if a collider overlaps a point in space."
	}
,
	"Collider2D.Raycast": {
		"prefix": "Collider2D.Raycast",
		"body": [
			"Raycast($1)"
		],
		"description": "public int Raycast(Vector2 direction, RaycastHit2D[] results, float distance = Mathf.Infinity, int layerMask = Physics2D.AllLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); public int Raycast(Vector2 direction, ContactFilter2D contactFilter, RaycastHit2D[] results, float distance = Mathf.Infinity); des: Casts a ray into the scene starting at the collider position ignoring the collider itself."
	}
,
	"Collider2D.OnCollisionEnter2D": {
		"prefix": "Collider2D.OnCollisionEnter2D",
		"body": [
			"OnCollisionEnter2D"
		],
		"description": "Sent when an incoming collider makes contact with this object's collider (2D physics only)."
	}
,
	"Collider2D.OnCollisionExit2D": {
		"prefix": "Collider2D.OnCollisionExit2D",
		"body": [
			"OnCollisionExit2D"
		],
		"description": "Sent when a collider on another object stops touching this object's collider (2D physics only)."
	}
,
	"Collider2D.OnCollisionStay2D": {
		"prefix": "Collider2D.OnCollisionStay2D",
		"body": [
			"OnCollisionStay2D"
		],
		"description": "Sent each frame where a collider on another object is touching this object's collider (2D physics only)."
	}
,
	"Collider2D.OnTriggerEnter2D": {
		"prefix": "Collider2D.OnTriggerEnter2D",
		"body": [
			"OnTriggerEnter2D"
		],
		"description": "Sent when another object enters a trigger collider attached to this object (2D physics only)."
	}
,
	"Collider2D.OnTriggerExit2D": {
		"prefix": "Collider2D.OnTriggerExit2D",
		"body": [
			"OnTriggerExit2D"
		],
		"description": "Sent when another object leaves a trigger collider attached to this object (2D physics only)."
	}
,
	"Collider2D.OnTriggerStay2D": {
		"prefix": "Collider2D.OnTriggerStay2D",
		"body": [
			"OnTriggerStay2D"
		],
		"description": "Sent each frame where another object is within a trigger collider attached to this object (2D physics only)."
	}
,
	"Collider2D.enabled": {
		"prefix": "Collider2D.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"Collider2D.isActiveAndEnabled": {
		"prefix": "Collider2D.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"Collider2D.gameObject": {
		"prefix": "Collider2D.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"Collider2D.tag": {
		"prefix": "Collider2D.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"Collider2D.transform": {
		"prefix": "Collider2D.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"Collider2D.hideFlags": {
		"prefix": "Collider2D.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Collider2D.name": {
		"prefix": "Collider2D.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Collider2D.BroadcastMessage": {
		"prefix": "Collider2D.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"Collider2D.CompareTag": {
		"prefix": "Collider2D.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"Collider2D.GetComponent": {
		"prefix": "Collider2D.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"Collider2D.GetComponentInChildren": {
		"prefix": "Collider2D.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"Collider2D.GetComponentInParent": {
		"prefix": "Collider2D.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"Collider2D.GetComponents": {
		"prefix": "Collider2D.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"Collider2D.GetComponentsInChildren": {
		"prefix": "Collider2D.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"Collider2D.GetComponentsInParent": {
		"prefix": "Collider2D.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"Collider2D.SendMessage": {
		"prefix": "Collider2D.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"Collider2D.SendMessageUpwards": {
		"prefix": "Collider2D.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"Collider2D.GetInstanceID": {
		"prefix": "Collider2D.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Collider2D.ToString": {
		"prefix": "Collider2D.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Collider2D.Destroy": {
		"prefix": "Collider2D.Destroy",
		"body": [
			"Collider2D.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Collider2D.DestroyImmediate": {
		"prefix": "Collider2D.DestroyImmediate",
		"body": [
			"Collider2D.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Collider2D.DontDestroyOnLoad": {
		"prefix": "Collider2D.DontDestroyOnLoad",
		"body": [
			"Collider2D.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Collider2D.FindObjectOfType": {
		"prefix": "Collider2D.FindObjectOfType",
		"body": [
			"Collider2D.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Collider2D.FindObjectsOfType": {
		"prefix": "Collider2D.FindObjectsOfType",
		"body": [
			"Collider2D.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Collider2D.Instantiate": {
		"prefix": "Collider2D.Instantiate",
		"body": [
			"Collider2D.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"ColliderDistance2D.distance": {
		"prefix": "ColliderDistance2D.distance",
		"body": [
			"distance"
		],
		"description": "return:float des: Gets the distance between two colliders."
	}
,
	"ColliderDistance2D.isOverlapped": {
		"prefix": "ColliderDistance2D.isOverlapped",
		"body": [
			"isOverlapped"
		],
		"description": "return:bool des: Gets whether the distance represents an overlap or not."
	}
,
	"ColliderDistance2D.isValid": {
		"prefix": "ColliderDistance2D.isValid",
		"body": [
			"isValid"
		],
		"description": "return:bool des: Gets whether the distance is valid or not."
	}
,
	"ColliderDistance2D.normal": {
		"prefix": "ColliderDistance2D.normal",
		"body": [
			"normal"
		],
		"description": "return:Vector2 des: A normalized vector that points from pointB to pointA."
	}
,
	"ColliderDistance2D.pointA": {
		"prefix": "ColliderDistance2D.pointA",
		"body": [
			"pointA"
		],
		"description": "return:Vector2 des: A point on a Collider2D that is a specific distance away from pointB."
	}
,
	"ColliderDistance2D.pointB": {
		"prefix": "ColliderDistance2D.pointB",
		"body": [
			"pointB"
		],
		"description": "return:Vector2 des: A point on a Collider2D that is a specific distance away from pointA."
	}
,
	"Collision.collider": {
		"prefix": "Collision.collider",
		"body": [
			"collider"
		],
		"description": "return:Collider des: The Collider we hit (Read Only)."
	}
,
	"Collision.contacts": {
		"prefix": "Collision.contacts",
		"body": [
			"contacts"
		],
		"description": "return:ContactPoint[] des: The contact points generated by the physics engine."
	}
,
	"Collision.gameObject": {
		"prefix": "Collision.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The GameObject whose collider you are colliding with. (Read Only)."
	}
,
	"Collision.impulse": {
		"prefix": "Collision.impulse",
		"body": [
			"impulse"
		],
		"description": "return:Vector3 des: The total impulse applied to this contact pair to resolve the collision."
	}
,
	"Collision.relativeVelocity": {
		"prefix": "Collision.relativeVelocity",
		"body": [
			"relativeVelocity"
		],
		"description": "return:Vector3 des: The relative linear velocity of the two colliding objects (Read Only)."
	}
,
	"Collision.rigidbody": {
		"prefix": "Collision.rigidbody",
		"body": [
			"rigidbody"
		],
		"description": "return:Rigidbody des: The Rigidbody we hit (Read Only). This is null if the object we hit is a collider with no rigidbody attached."
	}
,
	"Collision.transform": {
		"prefix": "Collision.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform of the object we hit (Read Only)."
	}
,
	"Collision2D.collider": {
		"prefix": "Collision2D.collider",
		"body": [
			"collider"
		],
		"description": "return:Collider2D des: The incoming Collider2D involved in the collision with the otherCollider."
	}
,
	"Collision2D.contactCount": {
		"prefix": "Collision2D.contactCount",
		"body": [
			"contactCount"
		],
		"description": "return:int des: Gets the number of contacts for this collision."
	}
,
	"Collision2D.contacts": {
		"prefix": "Collision2D.contacts",
		"body": [
			"contacts"
		],
		"description": "return:ContactPoint2D[] des: The specific points of contact with the incoming Collider2D. You should avoid using this as it produces memory garbage. Use GetContact or GetContacts instead."
	}
,
	"Collision2D.enabled": {
		"prefix": "Collision2D.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Indicates whether the collision response or reaction is enabled or disabled."
	}
,
	"Collision2D.gameObject": {
		"prefix": "Collision2D.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The incoming GameObject involved in the collision."
	}
,
	"Collision2D.otherCollider": {
		"prefix": "Collision2D.otherCollider",
		"body": [
			"otherCollider"
		],
		"description": "return:Collider2D des: The other Collider2D involved in the collision with the collider."
	}
,
	"Collision2D.otherRigidbody": {
		"prefix": "Collision2D.otherRigidbody",
		"body": [
			"otherRigidbody"
		],
		"description": "return:Rigidbody2D des: The other Rigidbody2D involved in the collision with the rigidbody."
	}
,
	"Collision2D.relativeVelocity": {
		"prefix": "Collision2D.relativeVelocity",
		"body": [
			"relativeVelocity"
		],
		"description": "return:Vector2 des: The relative linear velocity of the two colliding objects (Read Only)."
	}
,
	"Collision2D.rigidbody": {
		"prefix": "Collision2D.rigidbody",
		"body": [
			"rigidbody"
		],
		"description": "return:Rigidbody2D des: The incoming Rigidbody2D involved in the collision with the otherRigidbody."
	}
,
	"Collision2D.transform": {
		"prefix": "Collision2D.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform of the incoming object involved in the collision."
	}
,
	"Collision2D.GetContact": {
		"prefix": "Collision2D.GetContact",
		"body": [
			"GetContact($1)"
		],
		"description": "public ContactPoint2D GetContact(int index); des: Gets the contact point at the specified index."
	}
,
	"Collision2D.GetContacts": {
		"prefix": "Collision2D.GetContacts",
		"body": [
			"GetContacts($1)"
		],
		"description": "public int GetContacts(ContactPoint2D[] contacts); des: Retrieves all contact points in for contacts between collider and otherCollider."
	}
,
	"Color.a": {
		"prefix": "Color.a",
		"body": [
			"a"
		],
		"description": "return:flot des: Alpha component of the color (0 is transparent, 1 is opaque)."
	}
,
	"Color.b": {
		"prefix": "Color.b",
		"body": [
			"b"
		],
		"description": "return:float des: Blue component of the color."
	}
,
	"Color.g": {
		"prefix": "Color.g",
		"body": [
			"g"
		],
		"description": "return:float des: Green component of the color."
	}
,
	"Color.gamma": {
		"prefix": "Color.gamma",
		"body": [
			"gamma"
		],
		"description": "return:Color des: A version of the color that has had the gamma curve applied."
	}
,
	"Color.grayscale": {
		"prefix": "Color.grayscale",
		"body": [
			"grayscale"
		],
		"description": "return:float des: The grayscale value of the color. (Read Only)"
	}
,
	"Color.linear": {
		"prefix": "Color.linear",
		"body": [
			"linear"
		],
		"description": "return:Color des: A linear value of an sRGB color."
	}
,
	"Color.maxColorComponent": {
		"prefix": "Color.maxColorComponent",
		"body": [
			"maxColorComponent"
		],
		"description": "return:float des: Returns the maximum color component value: Max(r,g,b)."
	}
,
	"Color.r": {
		"prefix": "Color.r",
		"body": [
			"r"
		],
		"description": "return:float des: Red component of the color."
	}
,
	"Color.this[int]": {
		"prefix": "Color.this[int]",
		"body": [
			"this[int]"
		],
		"description": "return:float des: Access the r, g, b,a components using [0], [1], [2], [3] respectively."
	}
,
	"Color.ToString": {
		"prefix": "Color.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); public string ToString(string format); des: Returns a nicely formatted string of this color."
	}
,
	"Color.HSVToRGB": {
		"prefix": "Color.HSVToRGB",
		"body": [
			"Color.HSVToRGB"
		],
		"description": "public static Color HSVToRGB(float H, float S, float V); public static Color HSVToRGB(float H, float S, float V, bool hdr); des: Creates an RGB colour from HSV input."
	}
,
	"Color.Lerp": {
		"prefix": "Color.Lerp",
		"body": [
			"Color.Lerp"
		],
		"description": "public static Color Lerp(Color a, Color b, float t); des: Linearly interpolates between colors a and b by t."
	}
,
	"Color.LerpUnclamped": {
		"prefix": "Color.LerpUnclamped",
		"body": [
			"Color.LerpUnclamped"
		],
		"description": "public static Color LerpUnclamped(Color a, Color b, float t); des: Linearly interpolates between colors a and b by t."
	}
,
	"Color.RGBToHSV": {
		"prefix": "Color.RGBToHSV",
		"body": [
			"Color.RGBToHSV"
		],
		"description": "public static void RGBToHSV(Color rgbColor, out float H, out float S, out float V); des: Calculates the hue, saturation and value of an RGB input color."
	}
,
	"Color32.a": {
		"prefix": "Color32.a",
		"body": [
			"a"
		],
		"description": "return:byte des: Alpha component of the color."
	}
,
	"Color32.b": {
		"prefix": "Color32.b",
		"body": [
			"b"
		],
		"description": "return:yte des: Blue component of the color."
	}
,
	"Color32.g": {
		"prefix": "Color32.g",
		"body": [
			"g"
		],
		"description": "return:byte des: Green component of the color."
	}
,
	"Color32.r": {
		"prefix": "Color32.r",
		"body": [
			"r"
		],
		"description": "return:byte des: Red component of the color."
	}
,
	"Color32.ToString": {
		"prefix": "Color32.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); public string ToString(string format); des: Returns a nicely formatted string of this color."
	}
,
	"Color32.Lerp": {
		"prefix": "Color32.Lerp",
		"body": [
			"Color32.Lerp"
		],
		"description": "public static Color32 Lerp(Color32 a, Color32 b, float t); des: Linearly interpolates between colors a and b by t."
	}
,
	"Color32.LerpUnclamped": {
		"prefix": "Color32.LerpUnclamped",
		"body": [
			"Color32.LerpUnclamped"
		],
		"description": "public static Color32 LerpUnclamped(Color32 a, Color32 b, float t); des: Linearly interpolates between colors a and b by t."
	}
,
	"ColorUtility.ToHtmlStringRGB": {
		"prefix": "ColorUtility.ToHtmlStringRGB",
		"body": [
			"ColorUtility.ToHtmlStringRGB"
		],
		"description": "public static string ToHtmlStringRGB(Color color); des: Returns the color as a hexadecimal string in the format \"RRGGBB\"."
	}
,
	"ColorUtility.ToHtmlStringRGBA": {
		"prefix": "ColorUtility.ToHtmlStringRGBA",
		"body": [
			"ColorUtility.ToHtmlStringRGBA"
		],
		"description": "public static string ToHtmlStringRGBA(Color color); des: Returns the color as a hexadecimal string in the format \"RRGGBBAA\"."
	}
,
	"ColorUtility.TryParseHtmlString": {
		"prefix": "ColorUtility.TryParseHtmlString",
		"body": [
			"ColorUtility.TryParseHtmlString"
		],
		"description": "public static bool TryParseHtmlString(string htmlString, out Color color); des: Attempts to convert a html color string."
	}
,
	"CombineInstance.lightmapScaleOffset": {
		"prefix": "CombineInstance.lightmapScaleOffset",
		"body": [
			"lightmapScaleOffset"
		],
		"description": "return:Vector4 des: The baked lightmap UV scale and offset applied to the Mesh."
	}
,
	"CombineInstance.mesh": {
		"prefix": "CombineInstance.mesh",
		"body": [
			"mesh"
		],
		"description": "return:Mesh des: Mesh to combine."
	}
,
	"CombineInstance.realtimeLightmapScaleOffset": {
		"prefix": "CombineInstance.realtimeLightmapScaleOffset",
		"body": [
			"realtimeLightmapScaleOffset"
		],
		"description": "return:Vector4 des: The realtime lightmap UV scale and offset applied to the Mesh."
	}
,
	"CombineInstance.subMeshIndex": {
		"prefix": "CombineInstance.subMeshIndex",
		"body": [
			"subMeshIndex"
		],
		"description": "return:int des: Sub-Mesh index of the Mesh."
	}
,
	"CombineInstance.transform": {
		"prefix": "CombineInstance.transform",
		"body": [
			"transform"
		],
		"description": "return:Matrix4x4 des: Matrix to transform the Mesh with before combining."
	}
,
	"Compass.enabled": {
		"prefix": "Compass.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Used to enable or disable compass. Note, that if you want Input.compass.trueHeading property to contain a valid value, you must also enable location updates by calling Input.location.Start()."
	}
,
	"Compass.headingAccuracy": {
		"prefix": "Compass.headingAccuracy",
		"body": [
			"headingAccuracy"
		],
		"description": "return:float des: Accuracy of heading reading in degrees."
	}
,
	"Compass.magneticHeading": {
		"prefix": "Compass.magneticHeading",
		"body": [
			"magneticHeading"
		],
		"description": "return:float des: The heading in degrees relative to the magnetic North Pole. (Read Only)"
	}
,
	"Compass.rawVector": {
		"prefix": "Compass.rawVector",
		"body": [
			"rawVector"
		],
		"description": "return:Vector3 des: The raw geomagnetic data measured in microteslas. (Read Only)"
	}
,
	"Compass.timestamp": {
		"prefix": "Compass.timestamp",
		"body": [
			"timestamp"
		],
		"description": "return:double des: Timestamp (in seconds since 1970) when the heading was last time updated. (Read Only)"
	}
,
	"Compass.trueHeading": {
		"prefix": "Compass.trueHeading",
		"body": [
			"trueHeading"
		],
		"description": "return:float des: The heading in degrees relative to the geographic North Pole. (Read Only)"
	}
,
	"Component.gameObject": {
		"prefix": "Component.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"Component.tag": {
		"prefix": "Component.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"Component.transform": {
		"prefix": "Component.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"Component.BroadcastMessage": {
		"prefix": "Component.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"Component.CompareTag": {
		"prefix": "Component.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"Component.GetComponent": {
		"prefix": "Component.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"Component.GetComponentInChildren": {
		"prefix": "Component.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"Component.GetComponentInParent": {
		"prefix": "Component.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"Component.GetComponents": {
		"prefix": "Component.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"Component.GetComponentsInChildren": {
		"prefix": "Component.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"Component.GetComponentsInParent": {
		"prefix": "Component.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"Component.SendMessage": {
		"prefix": "Component.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"Component.SendMessageUpwards": {
		"prefix": "Component.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"Component.hideFlags": {
		"prefix": "Component.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Component.name": {
		"prefix": "Component.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Component.GetInstanceID": {
		"prefix": "Component.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Component.ToString": {
		"prefix": "Component.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Component.Destroy": {
		"prefix": "Component.Destroy",
		"body": [
			"Component.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Component.DestroyImmediate": {
		"prefix": "Component.DestroyImmediate",
		"body": [
			"Component.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Component.DontDestroyOnLoad": {
		"prefix": "Component.DontDestroyOnLoad",
		"body": [
			"Component.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Component.FindObjectOfType": {
		"prefix": "Component.FindObjectOfType",
		"body": [
			"Component.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Component.FindObjectsOfType": {
		"prefix": "Component.FindObjectsOfType",
		"body": [
			"Component.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Component.Instantiate": {
		"prefix": "Component.Instantiate",
		"body": [
			"Component.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"CompositeCollider2D.edgeRadius": {
		"prefix": "CompositeCollider2D.edgeRadius",
		"body": [
			"edgeRadius"
		],
		"description": "return:float des: Controls the radius of all edges created by the Collider."
	}
,
	"CompositeCollider2D.generationType": {
		"prefix": "CompositeCollider2D.generationType",
		"body": [
			"generationType"
		],
		"description": "return:CompositeCollider2D.GenerationType des: Specifies when to generate the Composite Collider geometry."
	}
,
	"CompositeCollider2D.geometryType": {
		"prefix": "CompositeCollider2D.geometryType",
		"body": [
			"geometryType"
		],
		"description": "return:CompositeCollider2D.GeometryType des: Specifies the type of geometry the Composite Collider should generate."
	}
,
	"CompositeCollider2D.pathCount": {
		"prefix": "CompositeCollider2D.pathCount",
		"body": [
			"pathCount"
		],
		"description": "return:int des: The number of paths in the Collider."
	}
,
	"CompositeCollider2D.pointCount": {
		"prefix": "CompositeCollider2D.pointCount",
		"body": [
			"pointCount"
		],
		"description": "return:int des: Gets the total number of points in all the paths within the Collider."
	}
,
	"CompositeCollider2D.vertexDistance": {
		"prefix": "CompositeCollider2D.vertexDistance",
		"body": [
			"vertexDistance"
		],
		"description": "return:float des: Controls the minimum distance allowed between generated vertices."
	}
,
	"CompositeCollider2D.GenerateGeometry": {
		"prefix": "CompositeCollider2D.GenerateGeometry",
		"body": [
			"GenerateGeometry($1)"
		],
		"description": "public void GenerateGeometry(); des: Regenerates the Composite Collider geometry."
	}
,
	"CompositeCollider2D.GetPath": {
		"prefix": "CompositeCollider2D.GetPath",
		"body": [
			"GetPath($1)"
		],
		"description": "public int GetPath(int index, Vector2[] points); des: Gets a path from the Collider by its index."
	}
,
	"CompositeCollider2D.GetPathPointCount": {
		"prefix": "CompositeCollider2D.GetPathPointCount",
		"body": [
			"GetPathPointCount($1)"
		],
		"description": "public int GetPathPointCount(int index); des: Gets the number of points in the specified path from the Collider by its index."
	}
,
	"CompositeCollider2D.enabled": {
		"prefix": "CompositeCollider2D.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"CompositeCollider2D.isActiveAndEnabled": {
		"prefix": "CompositeCollider2D.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"CompositeCollider2D.attachedRigidbody": {
		"prefix": "CompositeCollider2D.attachedRigidbody",
		"body": [
			"attachedRigidbody"
		],
		"description": "return:Rigidbody2D des: The Rigidbody2D attached to the Collider2D."
	}
,
	"CompositeCollider2D.bounciness": {
		"prefix": "CompositeCollider2D.bounciness",
		"body": [
			"bounciness"
		],
		"description": "return:float des: Get the bounciness used by the collider."
	}
,
	"CompositeCollider2D.bounds": {
		"prefix": "CompositeCollider2D.bounds",
		"body": [
			"bounds"
		],
		"description": "return:Bounds des: The world space bounding area of the collider."
	}
,
	"CompositeCollider2D.composite": {
		"prefix": "CompositeCollider2D.composite",
		"body": [
			"composite"
		],
		"description": "return:CompositeCollider2D des: Get the CompositeCollider2D that is available to be attached to the collider."
	}
,
	"CompositeCollider2D.density": {
		"prefix": "CompositeCollider2D.density",
		"body": [
			"density"
		],
		"description": "return:float des: The density of the collider used to calculate its mass (when auto mass is enabled)."
	}
,
	"CompositeCollider2D.friction": {
		"prefix": "CompositeCollider2D.friction",
		"body": [
			"friction"
		],
		"description": "return:float des: Get the friction used by the collider."
	}
,
	"CompositeCollider2D.isTrigger": {
		"prefix": "CompositeCollider2D.isTrigger",
		"body": [
			"isTrigger"
		],
		"description": "return:bool des: Is this collider configured as a trigger?"
	}
,
	"CompositeCollider2D.offset": {
		"prefix": "CompositeCollider2D.offset",
		"body": [
			"offset"
		],
		"description": "return:Vector2 des: The local offset of the collider geometry."
	}
,
	"CompositeCollider2D.shapeCount": {
		"prefix": "CompositeCollider2D.shapeCount",
		"body": [
			"shapeCount"
		],
		"description": "return:int des: The number of separate shaped regions in the collider."
	}
,
	"CompositeCollider2D.sharedMaterial": {
		"prefix": "CompositeCollider2D.sharedMaterial",
		"body": [
			"sharedMaterial"
		],
		"description": "return:PhysicsMaterial2D des: The PhysicsMaterial2D that is applied to this collider."
	}
,
	"CompositeCollider2D.usedByComposite": {
		"prefix": "CompositeCollider2D.usedByComposite",
		"body": [
			"usedByComposite"
		],
		"description": "return:bool des: Sets whether the Collider will be used or not used by a CompositeCollider2D."
	}
,
	"CompositeCollider2D.usedByEffector": {
		"prefix": "CompositeCollider2D.usedByEffector",
		"body": [
			"usedByEffector"
		],
		"description": "return:bool des: Whether the collider is used by an attached effector or not."
	}
,
	"CompositeCollider2D.gameObject": {
		"prefix": "CompositeCollider2D.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"CompositeCollider2D.tag": {
		"prefix": "CompositeCollider2D.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"CompositeCollider2D.transform": {
		"prefix": "CompositeCollider2D.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"CompositeCollider2D.hideFlags": {
		"prefix": "CompositeCollider2D.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"CompositeCollider2D.name": {
		"prefix": "CompositeCollider2D.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"CompositeCollider2D.Cast": {
		"prefix": "CompositeCollider2D.Cast",
		"body": [
			"Cast($1)"
		],
		"description": "public int Cast(Vector2 direction, RaycastHit2D[] results, float distance = Mathf.Infinity, bool ignoreSiblingColliders = true); public int Cast(Vector2 direction, ContactFilter2D contactFilter, RaycastHit2D[] results, float distance = Mathf.Infinity, bool ignoreSiblingColliders = true); des: Casts the collider shape into the scene starting at the collider position ignoring the collider itself."
	}
,
	"CompositeCollider2D.Distance": {
		"prefix": "CompositeCollider2D.Distance",
		"body": [
			"Distance($1)"
		],
		"description": "public ColliderDistance2D Distance(Collider2D collider); des: Calculates the minimum separation of this collider against another collider."
	}
,
	"CompositeCollider2D.GetContacts": {
		"prefix": "CompositeCollider2D.GetContacts",
		"body": [
			"GetContacts($1)"
		],
		"description": "public int GetContacts(ContactPoint2D[] contacts); public int GetContacts(Collider2D[] colliders); public int GetContacts(ContactFilter2D contactFilter, ContactPoint2D[] contacts); public int GetContacts(ContactFilter2D contactFilter, Collider2D[] colliders); des: Retrieves all contact points for this collider."
	}
,
	"CompositeCollider2D.IsTouching": {
		"prefix": "CompositeCollider2D.IsTouching",
		"body": [
			"IsTouching($1)"
		],
		"description": "public bool IsTouching(Collider2D collider); public bool IsTouching(Collider2D collider, ContactFilter2D contactFilter); public bool IsTouching(ContactFilter2D contactFilter); des: Check whether this collider is touching the collider or not."
	}
,
	"CompositeCollider2D.IsTouchingLayers": {
		"prefix": "CompositeCollider2D.IsTouchingLayers",
		"body": [
			"IsTouchingLayers($1)"
		],
		"description": "public bool IsTouchingLayers(int layerMask = Physics2D.AllLayers); des: Checks whether this collider is touching any colliders on the specified layerMask or not."
	}
,
	"CompositeCollider2D.OverlapCollider": {
		"prefix": "CompositeCollider2D.OverlapCollider",
		"body": [
			"OverlapCollider($1)"
		],
		"description": "public int OverlapCollider(ContactFilter2D contactFilter, Collider2D[] results); des: Get a list of all colliders that overlap this collider."
	}
,
	"CompositeCollider2D.OverlapPoint": {
		"prefix": "CompositeCollider2D.OverlapPoint",
		"body": [
			"OverlapPoint($1)"
		],
		"description": "public bool OverlapPoint(Vector2 point); des: Check if a collider overlaps a point in space."
	}
,
	"CompositeCollider2D.Raycast": {
		"prefix": "CompositeCollider2D.Raycast",
		"body": [
			"Raycast($1)"
		],
		"description": "public int Raycast(Vector2 direction, RaycastHit2D[] results, float distance = Mathf.Infinity, int layerMask = Physics2D.AllLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); public int Raycast(Vector2 direction, ContactFilter2D contactFilter, RaycastHit2D[] results, float distance = Mathf.Infinity); des: Casts a ray into the scene starting at the collider position ignoring the collider itself."
	}
,
	"CompositeCollider2D.BroadcastMessage": {
		"prefix": "CompositeCollider2D.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"CompositeCollider2D.CompareTag": {
		"prefix": "CompositeCollider2D.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"CompositeCollider2D.GetComponent": {
		"prefix": "CompositeCollider2D.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"CompositeCollider2D.GetComponentInChildren": {
		"prefix": "CompositeCollider2D.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"CompositeCollider2D.GetComponentInParent": {
		"prefix": "CompositeCollider2D.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"CompositeCollider2D.GetComponents": {
		"prefix": "CompositeCollider2D.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"CompositeCollider2D.GetComponentsInChildren": {
		"prefix": "CompositeCollider2D.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"CompositeCollider2D.GetComponentsInParent": {
		"prefix": "CompositeCollider2D.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"CompositeCollider2D.SendMessage": {
		"prefix": "CompositeCollider2D.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"CompositeCollider2D.SendMessageUpwards": {
		"prefix": "CompositeCollider2D.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"CompositeCollider2D.GetInstanceID": {
		"prefix": "CompositeCollider2D.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"CompositeCollider2D.ToString": {
		"prefix": "CompositeCollider2D.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"CompositeCollider2D.Destroy": {
		"prefix": "CompositeCollider2D.Destroy",
		"body": [
			"CompositeCollider2D.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"CompositeCollider2D.DestroyImmediate": {
		"prefix": "CompositeCollider2D.DestroyImmediate",
		"body": [
			"CompositeCollider2D.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"CompositeCollider2D.DontDestroyOnLoad": {
		"prefix": "CompositeCollider2D.DontDestroyOnLoad",
		"body": [
			"CompositeCollider2D.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"CompositeCollider2D.FindObjectOfType": {
		"prefix": "CompositeCollider2D.FindObjectOfType",
		"body": [
			"CompositeCollider2D.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"CompositeCollider2D.FindObjectsOfType": {
		"prefix": "CompositeCollider2D.FindObjectsOfType",
		"body": [
			"CompositeCollider2D.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"CompositeCollider2D.Instantiate": {
		"prefix": "CompositeCollider2D.Instantiate",
		"body": [
			"CompositeCollider2D.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"CompositeCollider2D.OnCollisionEnter2D": {
		"prefix": "CompositeCollider2D.OnCollisionEnter2D",
		"body": [
			"OnCollisionEnter2D"
		],
		"description": "Sent when an incoming collider makes contact with this object's collider (2D physics only)."
	}
,
	"CompositeCollider2D.OnCollisionExit2D": {
		"prefix": "CompositeCollider2D.OnCollisionExit2D",
		"body": [
			"OnCollisionExit2D"
		],
		"description": "Sent when a collider on another object stops touching this object's collider (2D physics only)."
	}
,
	"CompositeCollider2D.OnCollisionStay2D": {
		"prefix": "CompositeCollider2D.OnCollisionStay2D",
		"body": [
			"OnCollisionStay2D"
		],
		"description": "Sent each frame where a collider on another object is touching this object's collider (2D physics only)."
	}
,
	"CompositeCollider2D.OnTriggerEnter2D": {
		"prefix": "CompositeCollider2D.OnTriggerEnter2D",
		"body": [
			"OnTriggerEnter2D"
		],
		"description": "Sent when another object enters a trigger collider attached to this object (2D physics only)."
	}
,
	"CompositeCollider2D.OnTriggerExit2D": {
		"prefix": "CompositeCollider2D.OnTriggerExit2D",
		"body": [
			"OnTriggerExit2D"
		],
		"description": "Sent when another object leaves a trigger collider attached to this object (2D physics only)."
	}
,
	"CompositeCollider2D.OnTriggerStay2D": {
		"prefix": "CompositeCollider2D.OnTriggerStay2D",
		"body": [
			"OnTriggerStay2D"
		],
		"description": "Sent each frame where another object is within a trigger collider attached to this object (2D physics only)."
	}
,
	"CompositeCollider2D.GenerationType.Synchronous": {
		"prefix": "CompositeCollider2D.GenerationType.Synchronous",
		"body": [
			"Synchronous"
		],
		"description": "return: des: Sets the Composite Collider geometry to update synchronously immediately when a Collider used by the Composite Collider changes."
	}
,
	"CompositeCollider2D.GenerationType.Manual": {
		"prefix": "CompositeCollider2D.GenerationType.Manual",
		"body": [
			"Manual"
		],
		"description": "return: des: Sets the Composite Collider geometry to not automatically update when a Collider used by the Composite Collider changes."
	}
,
	"CompositeCollider2D.GeometryType.Outlines": {
		"prefix": "CompositeCollider2D.GeometryType.Outlines",
		"body": [
			"Outlines"
		],
		"description": "return: des: Sets the Composite Collider to generate closed outlines for the merged Collider geometry consisting of only edges."
	}
,
	"CompositeCollider2D.GeometryType.Polygons": {
		"prefix": "CompositeCollider2D.GeometryType.Polygons",
		"body": [
			"Polygons"
		],
		"description": "return: des: Sets the Composite Collider to generate closed outlines for the merged Collider geometry consisting of convex polygon shapes."
	}
,
	"ComputeBuffer.count": {
		"prefix": "ComputeBuffer.count",
		"body": [
			"count"
		],
		"description": "return:int des: Number of elements in the buffer (Read Only)."
	}
,
	"ComputeBuffer.stride": {
		"prefix": "ComputeBuffer.stride",
		"body": [
			"stride"
		],
		"description": "return:int des: Size of one element in the buffer (Read Only)."
	}
,
	"ComputeBuffer.GetData": {
		"prefix": "ComputeBuffer.GetData",
		"body": [
			"GetData($1)"
		],
		"description": "public void GetData(Array data); public void GetData(Array data, int managedBufferStartIndex, int computeBufferStartIndex, int count); des: Read data values from the buffer into an array. The array can only use blittable types."
	}
,
	"ComputeBuffer.GetNativeBufferPtr": {
		"prefix": "ComputeBuffer.GetNativeBufferPtr",
		"body": [
			"GetNativeBufferPtr($1)"
		],
		"description": "public IntPtr GetNativeBufferPtr(); des: Retrieve a native (underlying graphics API) pointer to the buffer."
	}
,
	"ComputeBuffer.IsValid": {
		"prefix": "ComputeBuffer.IsValid",
		"body": [
			"IsValid($1)"
		],
		"description": "public bool IsValid(); des: Returns true if this compute buffer is valid and false otherwise."
	}
,
	"ComputeBuffer.Release": {
		"prefix": "ComputeBuffer.Release",
		"body": [
			"Release($1)"
		],
		"description": "public void Release(); des: Release a Compute Buffer."
	}
,
	"ComputeBuffer.SetCounterValue": {
		"prefix": "ComputeBuffer.SetCounterValue",
		"body": [
			"SetCounterValue($1)"
		],
		"description": "public void SetCounterValue(uint counterValue); des: Sets counter value of append/consume buffer."
	}
,
	"ComputeBuffer.SetData": {
		"prefix": "ComputeBuffer.SetData",
		"body": [
			"SetData($1)"
		],
		"description": "public void SetData(Array data); public void SetData(Array data, int managedBufferStartIndex, int computeBufferStartIndex, int count); des: Set the buffer with values from an array."
	}
,
	"ComputeBuffer.CopyCount": {
		"prefix": "ComputeBuffer.CopyCount",
		"body": [
			"ComputeBuffer.CopyCount"
		],
		"description": "public static void CopyCount(ComputeBuffer src, ComputeBuffer dst, int dstOffsetBytes); des: Copy counter value of append/consume buffer into another buffer."
	}
,
	"ComputeShader.Dispatch": {
		"prefix": "ComputeShader.Dispatch",
		"body": [
			"Dispatch($1)"
		],
		"description": "public void Dispatch(int kernelIndex, int threadGroupsX, int threadGroupsY, int threadGroupsZ); des: Execute a compute shader."
	}
,
	"ComputeShader.DispatchIndirect": {
		"prefix": "ComputeShader.DispatchIndirect",
		"body": [
			"DispatchIndirect($1)"
		],
		"description": "public void DispatchIndirect(int kernelIndex, ComputeBuffer argsBuffer, uint argsOffset = 0); des: Execute a compute shader."
	}
,
	"ComputeShader.FindKernel": {
		"prefix": "ComputeShader.FindKernel",
		"body": [
			"FindKernel($1)"
		],
		"description": "public int FindKernel(string name); des: Find ComputeShader kernel index."
	}
,
	"ComputeShader.GetKernelThreadGroupSizes": {
		"prefix": "ComputeShader.GetKernelThreadGroupSizes",
		"body": [
			"GetKernelThreadGroupSizes($1)"
		],
		"description": "public void GetKernelThreadGroupSizes(int kernelIndex, out uint x, out uint y, out uint z); des: Get kernel thread group sizes."
	}
,
	"ComputeShader.HasKernel": {
		"prefix": "ComputeShader.HasKernel",
		"body": [
			"HasKernel($1)"
		],
		"description": "public bool HasKernel(string name); des: Checks whether a shader contains a given kernel."
	}
,
	"ComputeShader.SetBool": {
		"prefix": "ComputeShader.SetBool",
		"body": [
			"SetBool($1)"
		],
		"description": "public void SetBool(string name, bool val); public void SetBool(int nameID, bool val); des: Set a bool parameter."
	}
,
	"ComputeShader.SetBuffer": {
		"prefix": "ComputeShader.SetBuffer",
		"body": [
			"SetBuffer($1)"
		],
		"description": "public void SetBuffer(int kernelIndex, string name, ComputeBuffer buffer); public void SetBuffer(int kernelIndex, int nameID, ComputeBuffer buffer); des: Sets an input or output compute buffer."
	}
,
	"ComputeShader.SetFloat": {
		"prefix": "ComputeShader.SetFloat",
		"body": [
			"SetFloat($1)"
		],
		"description": "public void SetFloat(string name, float val); public void SetFloat(int nameID, float val); des: Set a float parameter."
	}
,
	"ComputeShader.SetFloats": {
		"prefix": "ComputeShader.SetFloats",
		"body": [
			"SetFloats($1)"
		],
		"description": "public void SetFloats(string name, params float[] values); public void SetFloats(int nameID, params float[] values); des: Set multiple consecutive float parameters at once."
	}
,
	"ComputeShader.SetInt": {
		"prefix": "ComputeShader.SetInt",
		"body": [
			"SetInt($1)"
		],
		"description": "public void SetInt(string name, int val); public void SetInt(int nameID, int val); des: Set an integer parameter."
	}
,
	"ComputeShader.SetInts": {
		"prefix": "ComputeShader.SetInts",
		"body": [
			"SetInts($1)"
		],
		"description": "public void SetInts(string name, params int[] values); public void SetInts(int nameID, params int[] values); des: Set multiple consecutive integer parameters at once."
	}
,
	"ComputeShader.SetMatrix": {
		"prefix": "ComputeShader.SetMatrix",
		"body": [
			"SetMatrix($1)"
		],
		"description": "public void SetMatrix(string name, Matrix4x4 val); public void SetMatrix(int nameID, Matrix4x4 val); des: Set a Matrix parameter."
	}
,
	"ComputeShader.SetMatrixArray": {
		"prefix": "ComputeShader.SetMatrixArray",
		"body": [
			"SetMatrixArray($1)"
		],
		"description": "public void SetMatrixArray(string name, Matrix4x4[] values); public void SetMatrixArray(int nameID, Matrix4x4[] values); des: Set a Matrix array parameter."
	}
,
	"ComputeShader.SetTexture": {
		"prefix": "ComputeShader.SetTexture",
		"body": [
			"SetTexture($1)"
		],
		"description": "public void SetTexture(int kernelIndex, string name, Texture texture); public void SetTexture(int kernelIndex, int nameID, Texture texture); des: Set a texture parameter."
	}
,
	"ComputeShader.SetTextureFromGlobal": {
		"prefix": "ComputeShader.SetTextureFromGlobal",
		"body": [
			"SetTextureFromGlobal($1)"
		],
		"description": "public void SetTextureFromGlobal(int kernelIndex, string name, string globalTextureName); public void SetTextureFromGlobal(int kernelIndex, int nameID, int globalTextureNameID); des: Set a texture parameter from a global texture property."
	}
,
	"ComputeShader.SetVector": {
		"prefix": "ComputeShader.SetVector",
		"body": [
			"SetVector($1)"
		],
		"description": "public void SetVector(string name, Vector4 val); public void SetVector(int nameID, Vector4 val); des: Set a vector parameter."
	}
,
	"ComputeShader.SetVectorArray": {
		"prefix": "ComputeShader.SetVectorArray",
		"body": [
			"SetVectorArray($1)"
		],
		"description": "public void SetVectorArray(string name, Vector4[] values); public void SetVectorArray(int nameID, Vector4[] values); des: Set a vector array parameter."
	}
,
	"ComputeShader.hideFlags": {
		"prefix": "ComputeShader.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"ComputeShader.name": {
		"prefix": "ComputeShader.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"ComputeShader.GetInstanceID": {
		"prefix": "ComputeShader.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"ComputeShader.ToString": {
		"prefix": "ComputeShader.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"ComputeShader.Destroy": {
		"prefix": "ComputeShader.Destroy",
		"body": [
			"ComputeShader.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"ComputeShader.DestroyImmediate": {
		"prefix": "ComputeShader.DestroyImmediate",
		"body": [
			"ComputeShader.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"ComputeShader.DontDestroyOnLoad": {
		"prefix": "ComputeShader.DontDestroyOnLoad",
		"body": [
			"ComputeShader.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"ComputeShader.FindObjectOfType": {
		"prefix": "ComputeShader.FindObjectOfType",
		"body": [
			"ComputeShader.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"ComputeShader.FindObjectsOfType": {
		"prefix": "ComputeShader.FindObjectsOfType",
		"body": [
			"ComputeShader.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"ComputeShader.Instantiate": {
		"prefix": "ComputeShader.Instantiate",
		"body": [
			"ComputeShader.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"ConfigurableJoint.angularXDrive": {
		"prefix": "ConfigurableJoint.angularXDrive",
		"body": [
			"angularXDrive"
		],
		"description": "return:JointDrive des: Definition of how the joint's rotation will behave around its local X axis. Only used if Rotation Drive Mode is Swing & Twist."
	}
,
	"ConfigurableJoint.angularXLimitSpring": {
		"prefix": "ConfigurableJoint.angularXLimitSpring",
		"body": [
			"angularXLimitSpring"
		],
		"description": "return:SoftJointLimitSpring des: The configuration of the spring attached to the angular X limit of the joint."
	}
,
	"ConfigurableJoint.angularXMotion": {
		"prefix": "ConfigurableJoint.angularXMotion",
		"body": [
			"angularXMotion"
		],
		"description": "return:ConfigurableJointMotion des: Allow rotation around the X axis to be Free, completely Locked, or Limited according to Low and High Angular XLimit."
	}
,
	"ConfigurableJoint.angularYLimit": {
		"prefix": "ConfigurableJoint.angularYLimit",
		"body": [
			"angularYLimit"
		],
		"description": "return:SoftJointLimit des: Boundary defining rotation restriction, based on delta from original rotation."
	}
,
	"ConfigurableJoint.angularYMotion": {
		"prefix": "ConfigurableJoint.angularYMotion",
		"body": [
			"angularYMotion"
		],
		"description": "return:ConfigurableJointMotion des: Allow rotation around the Y axis to be Free, completely Locked, or Limited according to Angular YLimit."
	}
,
	"ConfigurableJoint.angularYZDrive": {
		"prefix": "ConfigurableJoint.angularYZDrive",
		"body": [
			"angularYZDrive"
		],
		"description": "return:JointDrive des: Definition of how the joint's rotation will behave around its local Y and Z axes. Only used if Rotation Drive Mode is Swing & Twist."
	}
,
	"ConfigurableJoint.angularYZLimitSpring": {
		"prefix": "ConfigurableJoint.angularYZLimitSpring",
		"body": [
			"angularYZLimitSpring"
		],
		"description": "return:SoftJointLimitSpring des: The configuration of the spring attached to the angular Y and angular Z limits of the joint."
	}
,
	"ConfigurableJoint.angularZLimit": {
		"prefix": "ConfigurableJoint.angularZLimit",
		"body": [
			"angularZLimit"
		],
		"description": "return:SoftJointLimit des: Boundary defining rotation restriction, based on delta from original rotation."
	}
,
	"ConfigurableJoint.angularZMotion": {
		"prefix": "ConfigurableJoint.angularZMotion",
		"body": [
			"angularZMotion"
		],
		"description": "return:ConfigurableJointMotion des: Allow rotation around the Z axis to be Free, completely Locked, or Limited according to Angular ZLimit."
	}
,
	"ConfigurableJoint.configuredInWorldSpace": {
		"prefix": "ConfigurableJoint.configuredInWorldSpace",
		"body": [
			"configuredInWorldSpace"
		],
		"description": "return:bool des: If enabled, all Target values will be calculated in world space instead of the object's local space."
	}
,
	"ConfigurableJoint.highAngularXLimit": {
		"prefix": "ConfigurableJoint.highAngularXLimit",
		"body": [
			"highAngularXLimit"
		],
		"description": "return:SoftJointLimit des: Boundary defining upper rotation restriction, based on delta from original rotation."
	}
,
	"ConfigurableJoint.linearLimit": {
		"prefix": "ConfigurableJoint.linearLimit",
		"body": [
			"linearLimit"
		],
		"description": "return:SoftJointLimit des: Boundary defining movement restriction, based on distance from the joint's origin."
	}
,
	"ConfigurableJoint.linearLimitSpring": {
		"prefix": "ConfigurableJoint.linearLimitSpring",
		"body": [
			"linearLimitSpring"
		],
		"description": "return:SoftJointLimitSpring des: The configuration of the spring attached to the linear limit of the joint."
	}
,
	"ConfigurableJoint.lowAngularXLimit": {
		"prefix": "ConfigurableJoint.lowAngularXLimit",
		"body": [
			"lowAngularXLimit"
		],
		"description": "return:SoftJointLimit des: Boundary defining lower rotation restriction, based on delta from original rotation."
	}
,
	"ConfigurableJoint.projectionAngle": {
		"prefix": "ConfigurableJoint.projectionAngle",
		"body": [
			"projectionAngle"
		],
		"description": "return:float des: Set the angular tolerance threshold (in degrees) for projection.If the joint deviates by more than this angle around its locked angular degrees of freedom, the solver will move the bodies to close the angle.Setting a very small tolerance may result in simulation jitter or other artifacts.Sometimes it is not possible to project (for example when the joints form a cycle)."
	}
,
	"ConfigurableJoint.projectionDistance": {
		"prefix": "ConfigurableJoint.projectionDistance",
		"body": [
			"projectionDistance"
		],
		"description": "return:float des: Set the linear tolerance threshold for projection.If the joint separates by more than this distance along its locked degrees of freedom, the solver will move the bodies to close the distance.Setting a very small tolerance may result in simulation jitter or other artifacts.Sometimes it is not possible to project (for example when the joints form a cycle)."
	}
,
	"ConfigurableJoint.projectionMode": {
		"prefix": "ConfigurableJoint.projectionMode",
		"body": [
			"projectionMode"
		],
		"description": "return:JointProjectionMode des: Brings violated constraints back into alignment even when the solver fails. Projection is not a physical process and does not preserve momentum or respect collision geometry. It is best avoided if practical, but can be useful in improving simulation quality where joint separation results in unacceptable artifacts."
	}
,
	"ConfigurableJoint.rotationDriveMode": {
		"prefix": "ConfigurableJoint.rotationDriveMode",
		"body": [
			"rotationDriveMode"
		],
		"description": "return:RotationDriveMode des: Control the object's rotation with either X & YZ or Slerp Drive by itself."
	}
,
	"ConfigurableJoint.secondaryAxis": {
		"prefix": "ConfigurableJoint.secondaryAxis",
		"body": [
			"secondaryAxis"
		],
		"description": "return:Vector3 des: The joint's secondary axis."
	}
,
	"ConfigurableJoint.slerpDrive": {
		"prefix": "ConfigurableJoint.slerpDrive",
		"body": [
			"slerpDrive"
		],
		"description": "return:JointDrive des: Definition of how the joint's rotation will behave around all local axes. Only used if Rotation Drive Mode is Slerp Only."
	}
,
	"ConfigurableJoint.swapBodies": {
		"prefix": "ConfigurableJoint.swapBodies",
		"body": [
			"swapBodies"
		],
		"description": "return:bool des: If enabled, the two connected rigidbodies will be swapped, as if the joint was attached to the other body."
	}
,
	"ConfigurableJoint.targetAngularVelocity": {
		"prefix": "ConfigurableJoint.targetAngularVelocity",
		"body": [
			"targetAngularVelocity"
		],
		"description": "return:Vector3 des: This is a Vector3. It defines the desired angular velocity that the joint should rotate into."
	}
,
	"ConfigurableJoint.targetPosition": {
		"prefix": "ConfigurableJoint.targetPosition",
		"body": [
			"targetPosition"
		],
		"description": "return:Vector3 des: The desired position that the joint should move into."
	}
,
	"ConfigurableJoint.targetRotation": {
		"prefix": "ConfigurableJoint.targetRotation",
		"body": [
			"targetRotation"
		],
		"description": "return:Quaternion des: This is a Quaternion. It defines the desired rotation that the joint should rotate into."
	}
,
	"ConfigurableJoint.targetVelocity": {
		"prefix": "ConfigurableJoint.targetVelocity",
		"body": [
			"targetVelocity"
		],
		"description": "return:Vector3 des: The desired velocity that the joint should move along."
	}
,
	"ConfigurableJoint.xDrive": {
		"prefix": "ConfigurableJoint.xDrive",
		"body": [
			"xDrive"
		],
		"description": "return:JointDrive des: Definition of how the joint's movement will behave along its local X axis."
	}
,
	"ConfigurableJoint.xMotion": {
		"prefix": "ConfigurableJoint.xMotion",
		"body": [
			"xMotion"
		],
		"description": "return:ConfigurableJointMotion des: Allow movement along the X axis to be Free, completely Locked, or Limited according to Linear Limit."
	}
,
	"ConfigurableJoint.yDrive": {
		"prefix": "ConfigurableJoint.yDrive",
		"body": [
			"yDrive"
		],
		"description": "return:JointDrive des: Definition of how the joint's movement will behave along its local Y axis."
	}
,
	"ConfigurableJoint.yMotion": {
		"prefix": "ConfigurableJoint.yMotion",
		"body": [
			"yMotion"
		],
		"description": "return:ConfigurableJointMotion des: Allow movement along the Y axis to be Free, completely Locked, or Limited according to Linear Limit."
	}
,
	"ConfigurableJoint.zDrive": {
		"prefix": "ConfigurableJoint.zDrive",
		"body": [
			"zDrive"
		],
		"description": "return:JointDrive des: Definition of how the joint's movement will behave along its local Z axis."
	}
,
	"ConfigurableJoint.zMotion": {
		"prefix": "ConfigurableJoint.zMotion",
		"body": [
			"zMotion"
		],
		"description": "return:ConfigurableJointMotion des: Allow movement along the Z axis to be Free, completely Locked, or Limited according to Linear Limit."
	}
,
	"ConfigurableJoint.gameObject": {
		"prefix": "ConfigurableJoint.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"ConfigurableJoint.tag": {
		"prefix": "ConfigurableJoint.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"ConfigurableJoint.transform": {
		"prefix": "ConfigurableJoint.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"ConfigurableJoint.anchor": {
		"prefix": "ConfigurableJoint.anchor",
		"body": [
			"anchor"
		],
		"description": "return:Vector3 des: The Position of the anchor around which the joints motion is constrained."
	}
,
	"ConfigurableJoint.autoConfigureConnectedAnchor": {
		"prefix": "ConfigurableJoint.autoConfigureConnectedAnchor",
		"body": [
			"autoConfigureConnectedAnchor"
		],
		"description": "return:bool des: Should the connectedAnchor be calculated automatically?"
	}
,
	"ConfigurableJoint.axis": {
		"prefix": "ConfigurableJoint.axis",
		"body": [
			"axis"
		],
		"description": "return:Vector3 des: The Direction of the axis around which the body is constrained."
	}
,
	"ConfigurableJoint.breakForce": {
		"prefix": "ConfigurableJoint.breakForce",
		"body": [
			"breakForce"
		],
		"description": "return:float des: The force that needs to be applied for this joint to break."
	}
,
	"ConfigurableJoint.breakTorque": {
		"prefix": "ConfigurableJoint.breakTorque",
		"body": [
			"breakTorque"
		],
		"description": "return:float des: The torque that needs to be applied for this joint to break."
	}
,
	"ConfigurableJoint.connectedAnchor": {
		"prefix": "ConfigurableJoint.connectedAnchor",
		"body": [
			"connectedAnchor"
		],
		"description": "return:Vector3 des: Position of the anchor relative to the connected Rigidbody."
	}
,
	"ConfigurableJoint.connectedBody": {
		"prefix": "ConfigurableJoint.connectedBody",
		"body": [
			"connectedBody"
		],
		"description": "return:Rigidbody des: A reference to another rigidbody this joint connects to."
	}
,
	"ConfigurableJoint.connectedMassScale": {
		"prefix": "ConfigurableJoint.connectedMassScale",
		"body": [
			"connectedMassScale"
		],
		"description": "return:float des: The scale to apply to the inverse mass and inertia tensor of the connected body prior to solving the constraints."
	}
,
	"ConfigurableJoint.currentForce": {
		"prefix": "ConfigurableJoint.currentForce",
		"body": [
			"currentForce"
		],
		"description": "return:Vector3 des: The force applied by the solver to satisfy all constraints."
	}
,
	"ConfigurableJoint.currentTorque": {
		"prefix": "ConfigurableJoint.currentTorque",
		"body": [
			"currentTorque"
		],
		"description": "return:Vector3 des: The torque applied by the solver to satisfy all constraints."
	}
,
	"ConfigurableJoint.enableCollision": {
		"prefix": "ConfigurableJoint.enableCollision",
		"body": [
			"enableCollision"
		],
		"description": "return:bool des: Enable collision between bodies connected with the joint."
	}
,
	"ConfigurableJoint.enablePreprocessing": {
		"prefix": "ConfigurableJoint.enablePreprocessing",
		"body": [
			"enablePreprocessing"
		],
		"description": "return:bool des: Toggle preprocessing for this joint."
	}
,
	"ConfigurableJoint.massScale": {
		"prefix": "ConfigurableJoint.massScale",
		"body": [
			"massScale"
		],
		"description": "return:float des: The scale to apply to the inverse mass and inertia tensor of the body prior to solving the constraints."
	}
,
	"ConfigurableJoint.hideFlags": {
		"prefix": "ConfigurableJoint.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"ConfigurableJoint.name": {
		"prefix": "ConfigurableJoint.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"ConfigurableJoint.BroadcastMessage": {
		"prefix": "ConfigurableJoint.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"ConfigurableJoint.CompareTag": {
		"prefix": "ConfigurableJoint.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"ConfigurableJoint.GetComponent": {
		"prefix": "ConfigurableJoint.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"ConfigurableJoint.GetComponentInChildren": {
		"prefix": "ConfigurableJoint.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"ConfigurableJoint.GetComponentInParent": {
		"prefix": "ConfigurableJoint.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"ConfigurableJoint.GetComponents": {
		"prefix": "ConfigurableJoint.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"ConfigurableJoint.GetComponentsInChildren": {
		"prefix": "ConfigurableJoint.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"ConfigurableJoint.GetComponentsInParent": {
		"prefix": "ConfigurableJoint.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"ConfigurableJoint.SendMessage": {
		"prefix": "ConfigurableJoint.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"ConfigurableJoint.SendMessageUpwards": {
		"prefix": "ConfigurableJoint.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"ConfigurableJoint.GetInstanceID": {
		"prefix": "ConfigurableJoint.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"ConfigurableJoint.ToString": {
		"prefix": "ConfigurableJoint.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"ConfigurableJoint.Destroy": {
		"prefix": "ConfigurableJoint.Destroy",
		"body": [
			"ConfigurableJoint.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"ConfigurableJoint.DestroyImmediate": {
		"prefix": "ConfigurableJoint.DestroyImmediate",
		"body": [
			"ConfigurableJoint.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"ConfigurableJoint.DontDestroyOnLoad": {
		"prefix": "ConfigurableJoint.DontDestroyOnLoad",
		"body": [
			"ConfigurableJoint.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"ConfigurableJoint.FindObjectOfType": {
		"prefix": "ConfigurableJoint.FindObjectOfType",
		"body": [
			"ConfigurableJoint.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"ConfigurableJoint.FindObjectsOfType": {
		"prefix": "ConfigurableJoint.FindObjectsOfType",
		"body": [
			"ConfigurableJoint.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"ConfigurableJoint.Instantiate": {
		"prefix": "ConfigurableJoint.Instantiate",
		"body": [
			"ConfigurableJoint.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"ConfigurableJoint.OnJointBreak": {
		"prefix": "ConfigurableJoint.OnJointBreak",
		"body": [
			"OnJointBreak"
		],
		"description": "Called when a joint attached to the same game object broke."
	}
,
	"ConstantForce.force": {
		"prefix": "ConstantForce.force",
		"body": [
			"force"
		],
		"description": "return:Vector3 des: The force applied to the rigidbody every frame."
	}
,
	"ConstantForce.relativeForce": {
		"prefix": "ConstantForce.relativeForce",
		"body": [
			"relativeForce"
		],
		"description": "return:Vector3 des: The force - relative to the rigid bodies coordinate system - applied every frame."
	}
,
	"ConstantForce.relativeTorque": {
		"prefix": "ConstantForce.relativeTorque",
		"body": [
			"relativeTorque"
		],
		"description": "return:Vector3 des: The torque - relative to the rigid bodies coordinate system - applied every frame."
	}
,
	"ConstantForce.torque": {
		"prefix": "ConstantForce.torque",
		"body": [
			"torque"
		],
		"description": "return:Vector3 des: The torque applied to the rigidbody every frame."
	}
,
	"ConstantForce.enabled": {
		"prefix": "ConstantForce.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"ConstantForce.isActiveAndEnabled": {
		"prefix": "ConstantForce.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"ConstantForce.gameObject": {
		"prefix": "ConstantForce.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"ConstantForce.tag": {
		"prefix": "ConstantForce.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"ConstantForce.transform": {
		"prefix": "ConstantForce.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"ConstantForce.hideFlags": {
		"prefix": "ConstantForce.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"ConstantForce.name": {
		"prefix": "ConstantForce.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"ConstantForce.BroadcastMessage": {
		"prefix": "ConstantForce.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"ConstantForce.CompareTag": {
		"prefix": "ConstantForce.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"ConstantForce.GetComponent": {
		"prefix": "ConstantForce.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"ConstantForce.GetComponentInChildren": {
		"prefix": "ConstantForce.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"ConstantForce.GetComponentInParent": {
		"prefix": "ConstantForce.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"ConstantForce.GetComponents": {
		"prefix": "ConstantForce.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"ConstantForce.GetComponentsInChildren": {
		"prefix": "ConstantForce.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"ConstantForce.GetComponentsInParent": {
		"prefix": "ConstantForce.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"ConstantForce.SendMessage": {
		"prefix": "ConstantForce.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"ConstantForce.SendMessageUpwards": {
		"prefix": "ConstantForce.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"ConstantForce.GetInstanceID": {
		"prefix": "ConstantForce.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"ConstantForce.ToString": {
		"prefix": "ConstantForce.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"ConstantForce.Destroy": {
		"prefix": "ConstantForce.Destroy",
		"body": [
			"ConstantForce.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"ConstantForce.DestroyImmediate": {
		"prefix": "ConstantForce.DestroyImmediate",
		"body": [
			"ConstantForce.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"ConstantForce.DontDestroyOnLoad": {
		"prefix": "ConstantForce.DontDestroyOnLoad",
		"body": [
			"ConstantForce.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"ConstantForce.FindObjectOfType": {
		"prefix": "ConstantForce.FindObjectOfType",
		"body": [
			"ConstantForce.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"ConstantForce.FindObjectsOfType": {
		"prefix": "ConstantForce.FindObjectsOfType",
		"body": [
			"ConstantForce.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"ConstantForce.Instantiate": {
		"prefix": "ConstantForce.Instantiate",
		"body": [
			"ConstantForce.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"ConstantForce2D.force": {
		"prefix": "ConstantForce2D.force",
		"body": [
			"force"
		],
		"description": "return:Vector2 des: The linear force applied to the rigidbody each physics update."
	}
,
	"ConstantForce2D.relativeForce": {
		"prefix": "ConstantForce2D.relativeForce",
		"body": [
			"relativeForce"
		],
		"description": "return:Vector2 des: The linear force, relative to the rigid-body coordinate system, applied each physics update."
	}
,
	"ConstantForce2D.torque": {
		"prefix": "ConstantForce2D.torque",
		"body": [
			"torque"
		],
		"description": "return:float des: The torque applied to the rigidbody each physics update."
	}
,
	"ConstantForce2D.enabled": {
		"prefix": "ConstantForce2D.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"ConstantForce2D.isActiveAndEnabled": {
		"prefix": "ConstantForce2D.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"ConstantForce2D.gameObject": {
		"prefix": "ConstantForce2D.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"ConstantForce2D.tag": {
		"prefix": "ConstantForce2D.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"ConstantForce2D.transform": {
		"prefix": "ConstantForce2D.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"ConstantForce2D.hideFlags": {
		"prefix": "ConstantForce2D.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"ConstantForce2D.name": {
		"prefix": "ConstantForce2D.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"ConstantForce2D.BroadcastMessage": {
		"prefix": "ConstantForce2D.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"ConstantForce2D.CompareTag": {
		"prefix": "ConstantForce2D.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"ConstantForce2D.GetComponent": {
		"prefix": "ConstantForce2D.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"ConstantForce2D.GetComponentInChildren": {
		"prefix": "ConstantForce2D.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"ConstantForce2D.GetComponentInParent": {
		"prefix": "ConstantForce2D.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"ConstantForce2D.GetComponents": {
		"prefix": "ConstantForce2D.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"ConstantForce2D.GetComponentsInChildren": {
		"prefix": "ConstantForce2D.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"ConstantForce2D.GetComponentsInParent": {
		"prefix": "ConstantForce2D.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"ConstantForce2D.SendMessage": {
		"prefix": "ConstantForce2D.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"ConstantForce2D.SendMessageUpwards": {
		"prefix": "ConstantForce2D.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"ConstantForce2D.GetInstanceID": {
		"prefix": "ConstantForce2D.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"ConstantForce2D.ToString": {
		"prefix": "ConstantForce2D.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"ConstantForce2D.Destroy": {
		"prefix": "ConstantForce2D.Destroy",
		"body": [
			"ConstantForce2D.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"ConstantForce2D.DestroyImmediate": {
		"prefix": "ConstantForce2D.DestroyImmediate",
		"body": [
			"ConstantForce2D.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"ConstantForce2D.DontDestroyOnLoad": {
		"prefix": "ConstantForce2D.DontDestroyOnLoad",
		"body": [
			"ConstantForce2D.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"ConstantForce2D.FindObjectOfType": {
		"prefix": "ConstantForce2D.FindObjectOfType",
		"body": [
			"ConstantForce2D.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"ConstantForce2D.FindObjectsOfType": {
		"prefix": "ConstantForce2D.FindObjectsOfType",
		"body": [
			"ConstantForce2D.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"ConstantForce2D.Instantiate": {
		"prefix": "ConstantForce2D.Instantiate",
		"body": [
			"ConstantForce2D.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"ContactFilter2D.isFiltering": {
		"prefix": "ContactFilter2D.isFiltering",
		"body": [
			"isFiltering"
		],
		"description": "return:bool des: Given the current state of the contact filter, determine whether it would filter anything."
	}
,
	"ContactFilter2D.layerMask": {
		"prefix": "ContactFilter2D.layerMask",
		"body": [
			"layerMask"
		],
		"description": "return:LayerMask des: Sets the contact filter to filter the results that only include Collider2D on the layers defined by the layer mask."
	}
,
	"ContactFilter2D.maxDepth": {
		"prefix": "ContactFilter2D.maxDepth",
		"body": [
			"maxDepth"
		],
		"description": "return:float des: Sets the contact filter to filter the results to only include Collider2D with a Z coordinate (depth) less than this value."
	}
,
	"ContactFilter2D.maxNormalAngle": {
		"prefix": "ContactFilter2D.maxNormalAngle",
		"body": [
			"maxNormalAngle"
		],
		"description": "return:float des: Sets the contact filter to filter the results to only include contacts with collision normal angles that are less than this angle."
	}
,
	"ContactFilter2D.minDepth": {
		"prefix": "ContactFilter2D.minDepth",
		"body": [
			"minDepth"
		],
		"description": "return:float des: Sets the contact filter to filter the results to only include Collider2D with a Z coordinate (depth) greater than this value."
	}
,
	"ContactFilter2D.minNormalAngle": {
		"prefix": "ContactFilter2D.minNormalAngle",
		"body": [
			"minNormalAngle"
		],
		"description": "return:float des: Sets the contact filter to filter the results to only include contacts with collision normal angles that are greater than this angle."
	}
,
	"ContactFilter2D.useDepth": {
		"prefix": "ContactFilter2D.useDepth",
		"body": [
			"useDepth"
		],
		"description": "return:bool des: Sets the contact filter to filter the results by depth using minDepth and maxDepth."
	}
,
	"ContactFilter2D.useLayerMask": {
		"prefix": "ContactFilter2D.useLayerMask",
		"body": [
			"useLayerMask"
		],
		"description": "return:bool des: Sets the contact filter to filter results by layer mask."
	}
,
	"ContactFilter2D.useNormalAngle": {
		"prefix": "ContactFilter2D.useNormalAngle",
		"body": [
			"useNormalAngle"
		],
		"description": "return:bool des: Sets the contact filter to filter the results by the collision's normal angle using minNormalAngle and maxNormalAngle."
	}
,
	"ContactFilter2D.useOutsideDepth": {
		"prefix": "ContactFilter2D.useOutsideDepth",
		"body": [
			"useOutsideDepth"
		],
		"description": "return:bool des: Sets the contact filter to filter within the minDepth and maxDepth range, or outside that range."
	}
,
	"ContactFilter2D.useOutsideNormalAngle": {
		"prefix": "ContactFilter2D.useOutsideNormalAngle",
		"body": [
			"useOutsideNormalAngle"
		],
		"description": "return:bool des: Sets the contact filter to filter within the minNormalAngle and maxNormalAngle range, or outside that range."
	}
,
	"ContactFilter2D.useTriggers": {
		"prefix": "ContactFilter2D.useTriggers",
		"body": [
			"useTriggers"
		],
		"description": "return:bool des: Sets to filter contact results based on trigger collider involvement."
	}
,
	"ContactFilter2D.ClearDepth": {
		"prefix": "ContactFilter2D.ClearDepth",
		"body": [
			"ClearDepth($1)"
		],
		"description": "public void ClearDepth(); des: Turns off depth filtering by setting useDepth to false. The associated values of minDepth and maxDepth are not changed."
	}
,
	"ContactFilter2D.ClearLayerMask": {
		"prefix": "ContactFilter2D.ClearLayerMask",
		"body": [
			"ClearLayerMask($1)"
		],
		"description": "public void ClearLayerMask(); des: Turns off layer mask filtering by setting useLayerMask to false. The associated value of layerMask is not changed."
	}
,
	"ContactFilter2D.ClearNormalAngle": {
		"prefix": "ContactFilter2D.ClearNormalAngle",
		"body": [
			"ClearNormalAngle($1)"
		],
		"description": "public void ClearNormalAngle(); des: Turns off normal angle filtering by setting useNormalAngle to false. The associated values of minNormalAngle and maxNormalAngle are not changed."
	}
,
	"ContactFilter2D.IsFilteringDepth": {
		"prefix": "ContactFilter2D.IsFilteringDepth",
		"body": [
			"IsFilteringDepth($1)"
		],
		"description": "public bool IsFilteringDepth(GameObject obj); des: Checks if the Transform for obj is within the depth range to be filtered."
	}
,
	"ContactFilter2D.IsFilteringLayerMask": {
		"prefix": "ContactFilter2D.IsFilteringLayerMask",
		"body": [
			"IsFilteringLayerMask($1)"
		],
		"description": "public bool IsFilteringLayerMask(GameObject obj); des: Checks if the GameObject.layer for obj is included in the layerMask to be filtered."
	}
,
	"ContactFilter2D.IsFilteringNormalAngle": {
		"prefix": "ContactFilter2D.IsFilteringNormalAngle",
		"body": [
			"IsFilteringNormalAngle($1)"
		],
		"description": "public bool IsFilteringNormalAngle(Vector2 normal); public bool IsFilteringNormalAngle(float angle); des: Checks if the angle of normal is within the normal angle range to be filtered."
	}
,
	"ContactFilter2D.IsFilteringTrigger": {
		"prefix": "ContactFilter2D.IsFilteringTrigger",
		"body": [
			"IsFilteringTrigger($1)"
		],
		"description": "public bool IsFilteringTrigger(Collider2D collider); des: Checks if the collider is a trigger and should be filtered by the useTriggers to be filtered."
	}
,
	"ContactFilter2D.NoFilter": {
		"prefix": "ContactFilter2D.NoFilter",
		"body": [
			"NoFilter($1)"
		],
		"description": "public ContactFilter2D NoFilter(); des: Sets the contact filter to not filter any ContactPoint2D."
	}
,
	"ContactFilter2D.SetDepth": {
		"prefix": "ContactFilter2D.SetDepth",
		"body": [
			"SetDepth($1)"
		],
		"description": "public void SetDepth(float minDepth, float maxDepth); des: Sets the minDepth and maxDepth filter properties and turns on depth filtering by setting useDepth to true."
	}
,
	"ContactFilter2D.SetLayerMask": {
		"prefix": "ContactFilter2D.SetLayerMask",
		"body": [
			"SetLayerMask($1)"
		],
		"description": "public void SetLayerMask(LayerMask layerMask); des: Sets the layerMask filter property using the layerMask parameter provided and also enables layer mask filtering by setting useLayerMask to true."
	}
,
	"ContactFilter2D.SetNormalAngle": {
		"prefix": "ContactFilter2D.SetNormalAngle",
		"body": [
			"SetNormalAngle($1)"
		],
		"description": "public void SetNormalAngle(float minNormalAngle, float maxNormalAngle); des: Sets the minNormalAngle and maxNormalAngle filter properties and turns on normal angle filtering by setting useNormalAngle to true."
	}
,
	"ContactPoint.normal": {
		"prefix": "ContactPoint.normal",
		"body": [
			"normal"
		],
		"description": "return:Vector3 des: Normal of the contact point."
	}
,
	"ContactPoint.otherCollider": {
		"prefix": "ContactPoint.otherCollider",
		"body": [
			"otherCollider"
		],
		"description": "return:Collider des: The other collider in contact at the point."
	}
,
	"ContactPoint.point": {
		"prefix": "ContactPoint.point",
		"body": [
			"point"
		],
		"description": "return:Vector3 des: The point of contact."
	}
,
	"ContactPoint.separation": {
		"prefix": "ContactPoint.separation",
		"body": [
			"separation"
		],
		"description": "return:float des: The distance between the colliders at the contact point."
	}
,
	"ContactPoint.thisCollider": {
		"prefix": "ContactPoint.thisCollider",
		"body": [
			"thisCollider"
		],
		"description": "return:Collider des: The first collider in contact at the point."
	}
,
	"ContactPoint2D.collider": {
		"prefix": "ContactPoint2D.collider",
		"body": [
			"collider"
		],
		"description": "return:Collider2D des: The incoming Collider2D involved in the collision with the otherCollider."
	}
,
	"ContactPoint2D.enabled": {
		"prefix": "ContactPoint2D.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Indicates whether the collision response or reaction is enabled or disabled."
	}
,
	"ContactPoint2D.normal": {
		"prefix": "ContactPoint2D.normal",
		"body": [
			"normal"
		],
		"description": "return:Vector2 des: Surface normal at the contact point."
	}
,
	"ContactPoint2D.normalImpulse": {
		"prefix": "ContactPoint2D.normalImpulse",
		"body": [
			"normalImpulse"
		],
		"description": "return:float des: Gets the impulse force applied at the contact point along the ContactPoint2D.normal."
	}
,
	"ContactPoint2D.otherCollider": {
		"prefix": "ContactPoint2D.otherCollider",
		"body": [
			"otherCollider"
		],
		"description": "return:Collider2D des: The other Collider2D involved in the collision with the collider."
	}
,
	"ContactPoint2D.otherRigidbody": {
		"prefix": "ContactPoint2D.otherRigidbody",
		"body": [
			"otherRigidbody"
		],
		"description": "return:Rigidbody2D des: The other Rigidbody2D involved in the collision with the rigidbody."
	}
,
	"ContactPoint2D.point": {
		"prefix": "ContactPoint2D.point",
		"body": [
			"point"
		],
		"description": "return:Vector2 des: The point of contact between the two colliders in world space."
	}
,
	"ContactPoint2D.relativeVelocity": {
		"prefix": "ContactPoint2D.relativeVelocity",
		"body": [
			"relativeVelocity"
		],
		"description": "return:Vector2 des: Gets the relative velocity of the two colliders at the contact point (Read Only)."
	}
,
	"ContactPoint2D.rigidbody": {
		"prefix": "ContactPoint2D.rigidbody",
		"body": [
			"rigidbody"
		],
		"description": "return:Rigidbody2D des: The incoming Rigidbody2D involved in the collision with the otherRigidbody."
	}
,
	"ContactPoint2D.separation": {
		"prefix": "ContactPoint2D.separation",
		"body": [
			"separation"
		],
		"description": "return:float des: Gets the distance between the colliders at the contact point."
	}
,
	"ContactPoint2D.tangentImpulse": {
		"prefix": "ContactPoint2D.tangentImpulse",
		"body": [
			"tangentImpulse"
		],
		"description": "return:float des: Gets the impulse force applied at the contact point which is perpendicular to the ContactPoint2D.normal."
	}
,
	"ControllerColliderHit.collider": {
		"prefix": "ControllerColliderHit.collider",
		"body": [
			"collider"
		],
		"description": "return:Collider des: The collider that was hit by the controller."
	}
,
	"ControllerColliderHit.controller": {
		"prefix": "ControllerColliderHit.controller",
		"body": [
			"controller"
		],
		"description": "return:characterController des: The controller that hit the collider."
	}
,
	"ControllerColliderHit.gameObject": {
		"prefix": "ControllerColliderHit.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object that was hit by the controller."
	}
,
	"ControllerColliderHit.moveDirection": {
		"prefix": "ControllerColliderHit.moveDirection",
		"body": [
			"moveDirection"
		],
		"description": "return:Vector3 des: The direction the CharacterController was moving in when the collision occured."
	}
,
	"ControllerColliderHit.moveLength": {
		"prefix": "ControllerColliderHit.moveLength",
		"body": [
			"moveLength"
		],
		"description": "return:float des: How far the character has travelled until it hit the collider."
	}
,
	"ControllerColliderHit.normal": {
		"prefix": "ControllerColliderHit.normal",
		"body": [
			"normal"
		],
		"description": "return:Vector3 des: The normal of the surface we collided with in world space."
	}
,
	"ControllerColliderHit.point": {
		"prefix": "ControllerColliderHit.point",
		"body": [
			"point"
		],
		"description": "return:Vector3 des: The impact point in world space."
	}
,
	"ControllerColliderHit.rigidbody": {
		"prefix": "ControllerColliderHit.rigidbody",
		"body": [
			"rigidbody"
		],
		"description": "return:Rigidbody des: The rigidbody that was hit by the controller."
	}
,
	"ControllerColliderHit.transform": {
		"prefix": "ControllerColliderHit.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The transform that was hit by the controller."
	}
,
	"CrashReport.text": {
		"prefix": "CrashReport.text",
		"body": [
			"text"
		],
		"description": "return:string des: Crash report data as formatted text."
	}
,
	"CrashReport.time": {
		"prefix": "CrashReport.time",
		"body": [
			"time"
		],
		"description": "return:DateTime des: Time, when the crash occured."
	}
,
	"CrashReport.Remove": {
		"prefix": "CrashReport.Remove",
		"body": [
			"Remove($1)"
		],
		"description": "public void Remove(); des: Remove report from available reports list."
	}
,
	"CrashReport.RemoveAll": {
		"prefix": "CrashReport.RemoveAll",
		"body": [
			"CrashReport.RemoveAll"
		],
		"description": "public static void RemoveAll(); des: Remove all reports from available reports list."
	}
,
	"Cubemap.format": {
		"prefix": "Cubemap.format",
		"body": [
			"format"
		],
		"description": "return:TextureFormat des: The format of the pixel data in the texture (Read Only)."
	}
,
	"Cubemap.mipmapCount": {
		"prefix": "Cubemap.mipmapCount",
		"body": [
			"mipmapCount"
		],
		"description": "return:int des: How many mipmap levels are in this texture (Read Only)."
	}
,
	"Cubemap.Apply": {
		"prefix": "Cubemap.Apply",
		"body": [
			"Apply($1)"
		],
		"description": "public void Apply(bool updateMipmaps = true, bool makeNoLongerReadable = false); des: Actually apply all previous SetPixel and SetPixels changes."
	}
,
	"Cubemap.GetPixel": {
		"prefix": "Cubemap.GetPixel",
		"body": [
			"GetPixel($1)"
		],
		"description": "public Color GetPixel(CubemapFace face, int x, int y); des: Returns pixel color at coordinates (face, x, y)."
	}
,
	"Cubemap.GetPixels": {
		"prefix": "Cubemap.GetPixels",
		"body": [
			"GetPixels($1)"
		],
		"description": "public Color[] GetPixels(CubemapFace face, int miplevel = 0); des: Returns pixel colors of a cubemap face."
	}
,
	"Cubemap.SetPixel": {
		"prefix": "Cubemap.SetPixel",
		"body": [
			"SetPixel($1)"
		],
		"description": "public void SetPixel(CubemapFace face, int x, int y, Color color); des: Sets pixel color at coordinates (face, x, y)."
	}
,
	"Cubemap.SetPixels": {
		"prefix": "Cubemap.SetPixels",
		"body": [
			"SetPixels($1)"
		],
		"description": "public void SetPixels(Color[] colors, CubemapFace face, int miplevel = 0); des: Sets pixel colors of a cubemap face."
	}
,
	"Cubemap.SmoothEdges": {
		"prefix": "Cubemap.SmoothEdges",
		"body": [
			"SmoothEdges($1)"
		],
		"description": "public void SmoothEdges(int smoothRegionWidthInPixels = 1); des: Performs smoothing of near edge regions."
	}
,
	"Cubemap.CreateExternalTexture": {
		"prefix": "Cubemap.CreateExternalTexture",
		"body": [
			"Cubemap.CreateExternalTexture"
		],
		"description": "public static Cubemap CreateExternalTexture(int width, TextureFormat format, bool mipmap, IntPtr nativeTex); des: Creates a Unity cubemap out of externally created native cubemap object."
	}
,
	"Cubemap.hideFlags": {
		"prefix": "Cubemap.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Cubemap.name": {
		"prefix": "Cubemap.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Cubemap.anisoLevel": {
		"prefix": "Cubemap.anisoLevel",
		"body": [
			"anisoLevel"
		],
		"description": "return:int des: Anisotropic filtering level of the texture."
	}
,
	"Cubemap.dimension": {
		"prefix": "Cubemap.dimension",
		"body": [
			"dimension"
		],
		"description": "return:Rendering.TextureDimension des: Dimensionality (type) of the texture (Read Only)."
	}
,
	"Cubemap.filterMode": {
		"prefix": "Cubemap.filterMode",
		"body": [
			"filterMode"
		],
		"description": "return:FilterMode des: Filtering mode of the texture."
	}
,
	"Cubemap.height": {
		"prefix": "Cubemap.height",
		"body": [
			"height"
		],
		"description": "return:int des: Height of the texture in pixels. (Read Only)"
	}
,
	"Cubemap.imageContentsHash": {
		"prefix": "Cubemap.imageContentsHash",
		"body": [
			"imageContentsHash"
		],
		"description": "return:Hash128 des: The hash value of the Texture."
	}
,
	"Cubemap.mipMapBias": {
		"prefix": "Cubemap.mipMapBias",
		"body": [
			"mipMapBias"
		],
		"description": "return:float des: Mip map bias of the texture."
	}
,
	"Cubemap.updateCount": {
		"prefix": "Cubemap.updateCount",
		"body": [
			"updateCount"
		],
		"description": "return:uint des: This counter is incremented when the texture is updated."
	}
,
	"Cubemap.width": {
		"prefix": "Cubemap.width",
		"body": [
			"width"
		],
		"description": "return:int des: Width of the texture in pixels. (Read Only)"
	}
,
	"Cubemap.wrapMode": {
		"prefix": "Cubemap.wrapMode",
		"body": [
			"wrapMode"
		],
		"description": "return:TextureWrapMode des: Texture coordinate wrapping mode."
	}
,
	"Cubemap.wrapModeU": {
		"prefix": "Cubemap.wrapModeU",
		"body": [
			"wrapModeU"
		],
		"description": "return:TextureWrapMode des: Texture U coordinate wrapping mode."
	}
,
	"Cubemap.wrapModeV": {
		"prefix": "Cubemap.wrapModeV",
		"body": [
			"wrapModeV"
		],
		"description": "return:TextureWrapMode des: Texture V coordinate wrapping mode."
	}
,
	"Cubemap.wrapModeW": {
		"prefix": "Cubemap.wrapModeW",
		"body": [
			"wrapModeW"
		],
		"description": "return:TextureWrapMode des: Texture W coordinate wrapping mode for Texture3D."
	}
,
	"Cubemap.GetInstanceID": {
		"prefix": "Cubemap.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Cubemap.ToString": {
		"prefix": "Cubemap.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Cubemap.GetNativeTexturePtr": {
		"prefix": "Cubemap.GetNativeTexturePtr",
		"body": [
			"GetNativeTexturePtr($1)"
		],
		"description": "public IntPtr GetNativeTexturePtr(); des: Retrieve a native (underlying graphics API) pointer to the texture resource."
	}
,
	"Cubemap.IncrementUpdateCount": {
		"prefix": "Cubemap.IncrementUpdateCount",
		"body": [
			"IncrementUpdateCount($1)"
		],
		"description": "public void IncrementUpdateCount(); des: Increment the update counter."
	}
,
	"Cubemap.Destroy": {
		"prefix": "Cubemap.Destroy",
		"body": [
			"Cubemap.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Cubemap.DestroyImmediate": {
		"prefix": "Cubemap.DestroyImmediate",
		"body": [
			"Cubemap.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Cubemap.DontDestroyOnLoad": {
		"prefix": "Cubemap.DontDestroyOnLoad",
		"body": [
			"Cubemap.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Cubemap.FindObjectOfType": {
		"prefix": "Cubemap.FindObjectOfType",
		"body": [
			"Cubemap.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Cubemap.FindObjectsOfType": {
		"prefix": "Cubemap.FindObjectsOfType",
		"body": [
			"Cubemap.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Cubemap.Instantiate": {
		"prefix": "Cubemap.Instantiate",
		"body": [
			"Cubemap.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"Cubemap.SetGlobalAnisotropicFilteringLimits": {
		"prefix": "Cubemap.SetGlobalAnisotropicFilteringLimits",
		"body": [
			"Cubemap.SetGlobalAnisotropicFilteringLimits"
		],
		"description": "public static void SetGlobalAnisotropicFilteringLimits(int forcedMin, int globalMax); des: Sets Anisotropic limits."
	}
,
	"Cubemap.SetStreamingTextureMaterialDebugProperties": {
		"prefix": "Cubemap.SetStreamingTextureMaterialDebugProperties",
		"body": [
			"Cubemap.SetStreamingTextureMaterialDebugProperties"
		],
		"description": "public static void SetStreamingTextureMaterialDebugProperties(); des: Uploads additional debug information to materials using textures set to stream mip maps."
	}
,
	"CubemapArray.cubemapCount": {
		"prefix": "CubemapArray.cubemapCount",
		"body": [
			"cubemapCount"
		],
		"description": "return:int des: Number of cubemaps in the array (Read Only)."
	}
,
	"CubemapArray.format": {
		"prefix": "CubemapArray.format",
		"body": [
			"format"
		],
		"description": "return:TextureFormat des: Texture format (Read Only)."
	}
,
	"CubemapArray.Apply": {
		"prefix": "CubemapArray.Apply",
		"body": [
			"Apply($1)"
		],
		"description": "public void Apply(bool updateMipmaps = true, bool makeNoLongerReadable = false); des: Actually apply all previous SetPixels changes."
	}
,
	"CubemapArray.GetPixels": {
		"prefix": "CubemapArray.GetPixels",
		"body": [
			"GetPixels($1)"
		],
		"description": "public Color[] GetPixels(CubemapFace face, int arrayElement, int miplevel = 0); des: Returns pixel colors of a single array slice/face."
	}
,
	"CubemapArray.GetPixels32": {
		"prefix": "CubemapArray.GetPixels32",
		"body": [
			"GetPixels32($1)"
		],
		"description": "public Color32[] GetPixels32(CubemapFace face, int arrayElement, int miplevel = 0); des: Returns pixel colors of a single array slice/face."
	}
,
	"CubemapArray.SetPixels": {
		"prefix": "CubemapArray.SetPixels",
		"body": [
			"SetPixels($1)"
		],
		"description": "public void SetPixels(Color[] colors, CubemapFace face, int arrayElement, int miplevel = 0); des: Set pixel colors for a single array slice/face."
	}
,
	"CubemapArray.SetPixels32": {
		"prefix": "CubemapArray.SetPixels32",
		"body": [
			"SetPixels32($1)"
		],
		"description": "public void SetPixels32(Color32[] colors, CubemapFace face, int arrayElement, int miplevel = 0); des: Set pixel colors for a single array slice/face."
	}
,
	"CubemapArray.hideFlags": {
		"prefix": "CubemapArray.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"CubemapArray.name": {
		"prefix": "CubemapArray.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"CubemapArray.anisoLevel": {
		"prefix": "CubemapArray.anisoLevel",
		"body": [
			"anisoLevel"
		],
		"description": "return:int des: Anisotropic filtering level of the texture."
	}
,
	"CubemapArray.dimension": {
		"prefix": "CubemapArray.dimension",
		"body": [
			"dimension"
		],
		"description": "return:Rendering.TextureDimension des: Dimensionality (type) of the texture (Read Only)."
	}
,
	"CubemapArray.filterMode": {
		"prefix": "CubemapArray.filterMode",
		"body": [
			"filterMode"
		],
		"description": "return:FilterMode des: Filtering mode of the texture."
	}
,
	"CubemapArray.height": {
		"prefix": "CubemapArray.height",
		"body": [
			"height"
		],
		"description": "return:int des: Height of the texture in pixels. (Read Only)"
	}
,
	"CubemapArray.imageContentsHash": {
		"prefix": "CubemapArray.imageContentsHash",
		"body": [
			"imageContentsHash"
		],
		"description": "return:Hash128 des: The hash value of the Texture."
	}
,
	"CubemapArray.mipMapBias": {
		"prefix": "CubemapArray.mipMapBias",
		"body": [
			"mipMapBias"
		],
		"description": "return:float des: Mip map bias of the texture."
	}
,
	"CubemapArray.updateCount": {
		"prefix": "CubemapArray.updateCount",
		"body": [
			"updateCount"
		],
		"description": "return:uint des: This counter is incremented when the texture is updated."
	}
,
	"CubemapArray.width": {
		"prefix": "CubemapArray.width",
		"body": [
			"width"
		],
		"description": "return:int des: Width of the texture in pixels. (Read Only)"
	}
,
	"CubemapArray.wrapMode": {
		"prefix": "CubemapArray.wrapMode",
		"body": [
			"wrapMode"
		],
		"description": "return:TextureWrapMode des: Texture coordinate wrapping mode."
	}
,
	"CubemapArray.wrapModeU": {
		"prefix": "CubemapArray.wrapModeU",
		"body": [
			"wrapModeU"
		],
		"description": "return:TextureWrapMode des: Texture U coordinate wrapping mode."
	}
,
	"CubemapArray.wrapModeV": {
		"prefix": "CubemapArray.wrapModeV",
		"body": [
			"wrapModeV"
		],
		"description": "return:TextureWrapMode des: Texture V coordinate wrapping mode."
	}
,
	"CubemapArray.wrapModeW": {
		"prefix": "CubemapArray.wrapModeW",
		"body": [
			"wrapModeW"
		],
		"description": "return:TextureWrapMode des: Texture W coordinate wrapping mode for Texture3D."
	}
,
	"CubemapArray.GetInstanceID": {
		"prefix": "CubemapArray.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"CubemapArray.ToString": {
		"prefix": "CubemapArray.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"CubemapArray.GetNativeTexturePtr": {
		"prefix": "CubemapArray.GetNativeTexturePtr",
		"body": [
			"GetNativeTexturePtr($1)"
		],
		"description": "public IntPtr GetNativeTexturePtr(); des: Retrieve a native (underlying graphics API) pointer to the texture resource."
	}
,
	"CubemapArray.IncrementUpdateCount": {
		"prefix": "CubemapArray.IncrementUpdateCount",
		"body": [
			"IncrementUpdateCount($1)"
		],
		"description": "public void IncrementUpdateCount(); des: Increment the update counter."
	}
,
	"CubemapArray.Destroy": {
		"prefix": "CubemapArray.Destroy",
		"body": [
			"CubemapArray.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"CubemapArray.DestroyImmediate": {
		"prefix": "CubemapArray.DestroyImmediate",
		"body": [
			"CubemapArray.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"CubemapArray.DontDestroyOnLoad": {
		"prefix": "CubemapArray.DontDestroyOnLoad",
		"body": [
			"CubemapArray.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"CubemapArray.FindObjectOfType": {
		"prefix": "CubemapArray.FindObjectOfType",
		"body": [
			"CubemapArray.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"CubemapArray.FindObjectsOfType": {
		"prefix": "CubemapArray.FindObjectsOfType",
		"body": [
			"CubemapArray.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"CubemapArray.Instantiate": {
		"prefix": "CubemapArray.Instantiate",
		"body": [
			"CubemapArray.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"CubemapArray.SetGlobalAnisotropicFilteringLimits": {
		"prefix": "CubemapArray.SetGlobalAnisotropicFilteringLimits",
		"body": [
			"CubemapArray.SetGlobalAnisotropicFilteringLimits"
		],
		"description": "public static void SetGlobalAnisotropicFilteringLimits(int forcedMin, int globalMax); des: Sets Anisotropic limits."
	}
,
	"CubemapArray.SetStreamingTextureMaterialDebugProperties": {
		"prefix": "CubemapArray.SetStreamingTextureMaterialDebugProperties",
		"body": [
			"CubemapArray.SetStreamingTextureMaterialDebugProperties"
		],
		"description": "public static void SetStreamingTextureMaterialDebugProperties(); des: Uploads additional debug information to materials using textures set to stream mip maps."
	}
,
	"CullingGroup.enabled": {
		"prefix": "CullingGroup.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Pauses culling group execution."
	}
,
	"CullingGroup.onStateChanged": {
		"prefix": "CullingGroup.onStateChanged",
		"body": [
			"onStateChanged"
		],
		"description": "return:CullingGroup.StateChanged des: Sets the callback that will be called when a sphere's visibility and/or distance state has changed."
	}
,
	"CullingGroup.targetCamera": {
		"prefix": "CullingGroup.targetCamera",
		"body": [
			"targetCamera"
		],
		"description": "return:Camera des: Locks the CullingGroup to a specific camera."
	}
,
	"CullingGroup.Dispose": {
		"prefix": "CullingGroup.Dispose",
		"body": [
			"Dispose($1)"
		],
		"description": "public void Dispose(); des: Clean up all memory used by the CullingGroup immediately."
	}
,
	"CullingGroup.EraseSwapBack": {
		"prefix": "CullingGroup.EraseSwapBack",
		"body": [
			"EraseSwapBack($1)"
		],
		"description": "public void EraseSwapBack(int index); public static void EraseSwapBack(int index, T[] myArray, ref int size); des: Erase a given bounding sphere by moving the final sphere on top of it."
	}
,
	"CullingGroup.GetDistance": {
		"prefix": "CullingGroup.GetDistance",
		"body": [
			"GetDistance($1)"
		],
		"description": "public int GetDistance(int index); des: Get the current distance band index of a given sphere."
	}
,
	"CullingGroup.IsVisible": {
		"prefix": "CullingGroup.IsVisible",
		"body": [
			"IsVisible($1)"
		],
		"description": "public bool IsVisible(int index); des: Returns true if the bounding sphere at index is currently visible from any of the contributing cameras."
	}
,
	"CullingGroup.QueryIndices": {
		"prefix": "CullingGroup.QueryIndices",
		"body": [
			"QueryIndices($1)"
		],
		"description": "public int QueryIndices(bool visible, int[] result, int firstIndex); public int QueryIndices(int distanceIndex, int[] result, int firstIndex); public int QueryIndices(bool visible, int distanceIndex, int[] result, int firstIndex); des: Retrieve the indices of spheres that have particular visibility and/or distance states."
	}
,
	"CullingGroup.SetBoundingDistances": {
		"prefix": "CullingGroup.SetBoundingDistances",
		"body": [
			"SetBoundingDistances($1)"
		],
		"description": "public void SetBoundingDistances(float[] distances); des: Set bounding distances for 'distance bands' the group should compute, as well as options for how spheres falling into each distance band should be treated."
	}
,
	"CullingGroup.SetBoundingSphereCount": {
		"prefix": "CullingGroup.SetBoundingSphereCount",
		"body": [
			"SetBoundingSphereCount($1)"
		],
		"description": "public void SetBoundingSphereCount(int count); des: Sets the number of bounding spheres in the bounding spheres array that are actually being used."
	}
,
	"CullingGroup.SetBoundingSpheres": {
		"prefix": "CullingGroup.SetBoundingSpheres",
		"body": [
			"SetBoundingSpheres($1)"
		],
		"description": "public void SetBoundingSpheres(BoundingSphere[] array); des: Sets the array of bounding sphere definitions that the CullingGroup should compute culling for."
	}
,
	"CullingGroup.SetDistanceReferencePoint": {
		"prefix": "CullingGroup.SetDistanceReferencePoint",
		"body": [
			"SetDistanceReferencePoint($1)"
		],
		"description": "public void SetDistanceReferencePoint(Vector3 point); public void SetDistanceReferencePoint(Transform transform); des: Set the reference point from which distance bands are measured."
	}
,
	"CullingGroupEvent.currentDistance": {
		"prefix": "CullingGroupEvent.currentDistance",
		"body": [
			"currentDistance"
		],
		"description": "return:int des: The current distance band index of the sphere, after the most recent culling pass."
	}
,
	"CullingGroupEvent.hasBecomeInvisible": {
		"prefix": "CullingGroupEvent.hasBecomeInvisible",
		"body": [
			"hasBecomeInvisible"
		],
		"description": "return:bool des: Did this sphere change from being visible to being invisible in the most recent culling pass?"
	}
,
	"CullingGroupEvent.hasBecomeVisible": {
		"prefix": "CullingGroupEvent.hasBecomeVisible",
		"body": [
			"hasBecomeVisible"
		],
		"description": "return:bool des: Did this sphere change from being invisible to being visible in the most recent culling pass?"
	}
,
	"CullingGroupEvent.index": {
		"prefix": "CullingGroupEvent.index",
		"body": [
			"index"
		],
		"description": "return:int des: The index of the sphere that has changed."
	}
,
	"CullingGroupEvent.isVisible": {
		"prefix": "CullingGroupEvent.isVisible",
		"body": [
			"isVisible"
		],
		"description": "return:bool des: Was the sphere considered visible by the most recent culling pass?"
	}
,
	"CullingGroupEvent.previousDistance": {
		"prefix": "CullingGroupEvent.previousDistance",
		"body": [
			"previousDistance"
		],
		"description": "return:int des: The distance band index of the sphere before the most recent culling pass."
	}
,
	"CullingGroupEvent.wasVisible": {
		"prefix": "CullingGroupEvent.wasVisible",
		"body": [
			"wasVisible"
		],
		"description": "return:bool des: Was the sphere visible before the most recent culling pass?"
	}
,
	"Cursor.SetCursor": {
		"prefix": "Cursor.SetCursor",
		"body": [
			"Cursor.SetCursor"
		],
		"description": " public static void SetCursor(Texture2D texture, Vector2 hotspot, CursorMode cursorMode); des: Sets the mouse cursor to the given texture."
	}
,
	"CustomRenderTexture.cubemapFaceMask": {
		"prefix": "CustomRenderTexture.cubemapFaceMask",
		"body": [
			"cubemapFaceMask"
		],
		"description": "return:uint des: Bitfield that allows to enable or disable update on each of the cubemap faces. Order from least significant bit is +X, -X, +Y, -Y, +Z, -Z."
	}
,
	"CustomRenderTexture.doubleBuffered": {
		"prefix": "CustomRenderTexture.doubleBuffered",
		"body": [
			"doubleBuffered"
		],
		"description": "return:bool des: If true, the Custom Render Texture is double buffered so that you can access it during its own update. otherwise the Custom Render Texture will be not be double buffered."
	}
,
	"CustomRenderTexture.initializationColor": {
		"prefix": "CustomRenderTexture.initializationColor",
		"body": [
			"initializationColor"
		],
		"description": "return:Color des: Color with which the Custom Render Texture is initialized. This parameter will be ignored if an initializationMaterial is set."
	}
,
	"CustomRenderTexture.initializationMaterial": {
		"prefix": "CustomRenderTexture.initializationMaterial",
		"body": [
			"initializationMaterial"
		],
		"description": "return:Material des: Material with which the Custom Render Texture is initialized. Initialization texture and color are ignored if this parameter is set."
	}
,
	"CustomRenderTexture.initializationMode": {
		"prefix": "CustomRenderTexture.initializationMode",
		"body": [
			"initializationMode"
		],
		"description": "return:CustomRenderTextureUpdateMode des: Specify how the texture should be initialized."
	}
,
	"CustomRenderTexture.initializationSource": {
		"prefix": "CustomRenderTexture.initializationSource",
		"body": [
			"initializationSource"
		],
		"description": "return:CustomRenderTextureInitializationSource des: Specify if the texture should be initialized with a Texture and a Color or a Material."
	}
,
	"CustomRenderTexture.initializationTexture": {
		"prefix": "CustomRenderTexture.initializationTexture",
		"body": [
			"initializationTexture"
		],
		"description": "return:Texture des: Texture with which the Custom Render Texture is initialized (multiplied by the initialization color). This parameter will be ignored if an initializationMaterial is set."
	}
,
	"CustomRenderTexture.material": {
		"prefix": "CustomRenderTexture.material",
		"body": [
			"material"
		],
		"description": "return:Material des: Material with which the content of the Custom Render Texture is updated."
	}
,
	"CustomRenderTexture.shaderPass": {
		"prefix": "CustomRenderTexture.shaderPass",
		"body": [
			"shaderPass"
		],
		"description": "return:int des: Shader Pass used to update the Custom Render Texture."
	}
,
	"CustomRenderTexture.updateMode": {
		"prefix": "CustomRenderTexture.updateMode",
		"body": [
			"updateMode"
		],
		"description": "return:CustomRenderTextureUpdateMode des: Specify how the texture should be updated."
	}
,
	"CustomRenderTexture.updateZoneSpace": {
		"prefix": "CustomRenderTexture.updateZoneSpace",
		"body": [
			"updateZoneSpace"
		],
		"description": "return:CustomRenderTextureUpdateZoneSpace des: Space in which the update zones are expressed (Normalized or Pixel space)."
	}
,
	"CustomRenderTexture.wrapUpdateZones": {
		"prefix": "CustomRenderTexture.wrapUpdateZones",
		"body": [
			"wrapUpdateZones"
		],
		"description": "return:bool des: If true, Update zones will wrap around the border of the Custom Render Texture. Otherwise, Update zones will be clamped at the border of the Custom Render Texture."
	}
,
	"CustomRenderTexture.ClearUpdateZones": {
		"prefix": "CustomRenderTexture.ClearUpdateZones",
		"body": [
			"ClearUpdateZones($1)"
		],
		"description": "public void ClearUpdateZones(); des: Clear all Update Zones."
	}
,
	"CustomRenderTexture.GetUpdateZones": {
		"prefix": "CustomRenderTexture.GetUpdateZones",
		"body": [
			"GetUpdateZones($1)"
		],
		"description": "public void GetUpdateZones(List<CustomRenderTextureUpdateZone> updateZones); des: Returns the list of Update Zones."
	}
,
	"CustomRenderTexture.Initialize": {
		"prefix": "CustomRenderTexture.Initialize",
		"body": [
			"Initialize($1)"
		],
		"description": "public void Initialize(); des: Triggers an initialization of the Custom Render Texture."
	}
,
	"CustomRenderTexture.SetUpdateZones": {
		"prefix": "CustomRenderTexture.SetUpdateZones",
		"body": [
			"SetUpdateZones($1)"
		],
		"description": "public void SetUpdateZones(CustomRenderTextureUpdateZone[] updateZones); des: Setup the list of Update Zones for the Custom Render Texture."
	}
,
	"CustomRenderTexture.Update": {
		"prefix": "CustomRenderTexture.Update",
		"body": [
			"Update($1)"
		],
		"description": "public void Update(int count = 1); des: Triggers the update of the Custom Render Texture."
	}
,
	"CustomRenderTexture.hideFlags": {
		"prefix": "CustomRenderTexture.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"CustomRenderTexture.name": {
		"prefix": "CustomRenderTexture.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"CustomRenderTexture.antiAliasing": {
		"prefix": "CustomRenderTexture.antiAliasing",
		"body": [
			"antiAliasing"
		],
		"description": "return:int des: The antialiasing level for the RenderTexture."
	}
,
	"CustomRenderTexture.autoGenerateMips": {
		"prefix": "CustomRenderTexture.autoGenerateMips",
		"body": [
			"autoGenerateMips"
		],
		"description": "return:bool des: Mipmap levels are generated automatically when this flag is set."
	}
,
	"CustomRenderTexture.bindTextureMS": {
		"prefix": "CustomRenderTexture.bindTextureMS",
		"body": [
			"bindTextureMS"
		],
		"description": "return:bool des: If true and antiAliasing is greater than 1, the render texture will not be resolved by default. Use this if the render texture needs to be bound as a multisampled texture in a shader."
	}
,
	"CustomRenderTexture.colorBuffer": {
		"prefix": "CustomRenderTexture.colorBuffer",
		"body": [
			"colorBuffer"
		],
		"description": "return:RenderBuffer des: Color buffer of the render texture (Read Only)."
	}
,
	"CustomRenderTexture.depth": {
		"prefix": "CustomRenderTexture.depth",
		"body": [
			"depth"
		],
		"description": "return:int des: The precision of the render texture's depth buffer in bits (0, 16, 24/32 are supported)."
	}
,
	"CustomRenderTexture.depthBuffer": {
		"prefix": "CustomRenderTexture.depthBuffer",
		"body": [
			"depthBuffer"
		],
		"description": "return:RenderBuffer des: Depth/stencil buffer of the render texture (Read Only)."
	}
,
	"CustomRenderTexture.descriptor": {
		"prefix": "CustomRenderTexture.descriptor",
		"body": [
			"descriptor"
		],
		"description": "return:RenderTextureDescriptor des: This struct contains all the information required to create a RenderTexture. It can be copied, cached, and reused to easily create RenderTextures that all share the same properties."
	}
,
	"CustomRenderTexture.enableRandomWrite": {
		"prefix": "CustomRenderTexture.enableRandomWrite",
		"body": [
			"enableRandomWrite"
		],
		"description": "return:bool des: Enable random access write into this render texture on Shader Model 5.0 level shaders."
	}
,
	"CustomRenderTexture.format": {
		"prefix": "CustomRenderTexture.format",
		"body": [
			"format"
		],
		"description": "return:RenderTextureFormat des: The color format of the render texture."
	}
,
	"CustomRenderTexture.memorylessMode": {
		"prefix": "CustomRenderTexture.memorylessMode",
		"body": [
			"memorylessMode"
		],
		"description": "return:RenderTextureMemoryless des: The render texture memoryless mode property."
	}
,
	"CustomRenderTexture.sRGB": {
		"prefix": "CustomRenderTexture.sRGB",
		"body": [
			"sRGB"
		],
		"description": "return:bool des: Does this render texture use sRGB read/write conversions? (Read Only)."
	}
,
	"CustomRenderTexture.useDynamicScale": {
		"prefix": "CustomRenderTexture.useDynamicScale",
		"body": [
			"useDynamicScale"
		],
		"description": "return:bool des: Is the render texture marked to be scaled by the Dynamic Resolution system."
	}
,
	"CustomRenderTexture.useMipMap": {
		"prefix": "CustomRenderTexture.useMipMap",
		"body": [
			"useMipMap"
		],
		"description": "return:bool des: Render texture has mipmaps when this flag is set."
	}
,
	"CustomRenderTexture.volumeDepth": {
		"prefix": "CustomRenderTexture.volumeDepth",
		"body": [
			"volumeDepth"
		],
		"description": "return:int des: Volume extent of a 3D render texture or number of slices of array texture."
	}
,
	"CustomRenderTexture.vrUsage": {
		"prefix": "CustomRenderTexture.vrUsage",
		"body": [
			"vrUsage"
		],
		"description": "return:VRTextureUsage des: If this RenderTexture is a VR eye texture used in stereoscopic rendering, this property decides what special rendering occurs, if any."
	}
,
	"CustomRenderTexture.anisoLevel": {
		"prefix": "CustomRenderTexture.anisoLevel",
		"body": [
			"anisoLevel"
		],
		"description": "return:int des: Anisotropic filtering level of the texture."
	}
,
	"CustomRenderTexture.dimension": {
		"prefix": "CustomRenderTexture.dimension",
		"body": [
			"dimension"
		],
		"description": "return:Rendering.TextureDimension des: Dimensionality (type) of the texture (Read Only)."
	}
,
	"CustomRenderTexture.filterMode": {
		"prefix": "CustomRenderTexture.filterMode",
		"body": [
			"filterMode"
		],
		"description": "return:FilterMode des: Filtering mode of the texture."
	}
,
	"CustomRenderTexture.height": {
		"prefix": "CustomRenderTexture.height",
		"body": [
			"height"
		],
		"description": "return:int des: Height of the texture in pixels. (Read Only)"
	}
,
	"CustomRenderTexture.imageContentsHash": {
		"prefix": "CustomRenderTexture.imageContentsHash",
		"body": [
			"imageContentsHash"
		],
		"description": "return:Hash128 des: The hash value of the Texture."
	}
,
	"CustomRenderTexture.mipMapBias": {
		"prefix": "CustomRenderTexture.mipMapBias",
		"body": [
			"mipMapBias"
		],
		"description": "return:float des: Mip map bias of the texture."
	}
,
	"CustomRenderTexture.updateCount": {
		"prefix": "CustomRenderTexture.updateCount",
		"body": [
			"updateCount"
		],
		"description": "return:uint des: This counter is incremented when the texture is updated."
	}
,
	"CustomRenderTexture.width": {
		"prefix": "CustomRenderTexture.width",
		"body": [
			"width"
		],
		"description": "return:int des: Width of the texture in pixels. (Read Only)"
	}
,
	"CustomRenderTexture.wrapMode": {
		"prefix": "CustomRenderTexture.wrapMode",
		"body": [
			"wrapMode"
		],
		"description": "return:TextureWrapMode des: Texture coordinate wrapping mode."
	}
,
	"CustomRenderTexture.wrapModeU": {
		"prefix": "CustomRenderTexture.wrapModeU",
		"body": [
			"wrapModeU"
		],
		"description": "return:TextureWrapMode des: Texture U coordinate wrapping mode."
	}
,
	"CustomRenderTexture.wrapModeV": {
		"prefix": "CustomRenderTexture.wrapModeV",
		"body": [
			"wrapModeV"
		],
		"description": "return:TextureWrapMode des: Texture V coordinate wrapping mode."
	}
,
	"CustomRenderTexture.wrapModeW": {
		"prefix": "CustomRenderTexture.wrapModeW",
		"body": [
			"wrapModeW"
		],
		"description": "return:TextureWrapMode des: Texture W coordinate wrapping mode for Texture3D."
	}
,
	"CustomRenderTexture.GetInstanceID": {
		"prefix": "CustomRenderTexture.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"CustomRenderTexture.ToString": {
		"prefix": "CustomRenderTexture.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"CustomRenderTexture.ConvertToEquirect": {
		"prefix": "CustomRenderTexture.ConvertToEquirect",
		"body": [
			"ConvertToEquirect($1)"
		],
		"description": "public void ConvertToEquirect(RenderTexture equirect, Camera.MonoOrStereoscopicEye eye); des: Converts the render texture to equirectangular format (both stereoscopic or monoscopic equirect). The left eye will occupy the top half and the right eye will occupy the bottom. The monoscopic version will occupy the whole texture. Texture dimension must be of type TextureDimension.Cube."
	}
,
	"CustomRenderTexture.Create": {
		"prefix": "CustomRenderTexture.Create",
		"body": [
			"Create($1)"
		],
		"description": "public bool Create(); des: Actually creates the RenderTexture."
	}
,
	"CustomRenderTexture.DiscardContents": {
		"prefix": "CustomRenderTexture.DiscardContents",
		"body": [
			"DiscardContents($1)"
		],
		"description": "public void DiscardContents(); public void DiscardContents(bool discardColor, bool discardDepth); des: Hint the GPU driver that the contents of the RenderTexture will not be used."
	}
,
	"CustomRenderTexture.GenerateMips": {
		"prefix": "CustomRenderTexture.GenerateMips",
		"body": [
			"GenerateMips($1)"
		],
		"description": "public void GenerateMips(); des: Generate mipmap levels of a render texture."
	}
,
	"CustomRenderTexture.GetNativeDepthBufferPtr": {
		"prefix": "CustomRenderTexture.GetNativeDepthBufferPtr",
		"body": [
			"GetNativeDepthBufferPtr($1)"
		],
		"description": "public IntPtr GetNativeDepthBufferPtr(); des: Retrieve a native (underlying graphics API) pointer to the depth buffer resource."
	}
,
	"CustomRenderTexture.IsCreated": {
		"prefix": "CustomRenderTexture.IsCreated",
		"body": [
			"IsCreated($1)"
		],
		"description": "public bool IsCreated(); des: Is the render texture actually created?"
	}
,
	"CustomRenderTexture.MarkRestoreExpected": {
		"prefix": "CustomRenderTexture.MarkRestoreExpected",
		"body": [
			"MarkRestoreExpected($1)"
		],
		"description": "public void MarkRestoreExpected(); des: Indicate that there's a RenderTexture restore operation expected."
	}
,
	"CustomRenderTexture.Release": {
		"prefix": "CustomRenderTexture.Release",
		"body": [
			"Release($1)"
		],
		"description": "public void Release(); des: Releases the RenderTexture."
	}
,
	"CustomRenderTexture.ResolveAntiAliasedSurface": {
		"prefix": "CustomRenderTexture.ResolveAntiAliasedSurface",
		"body": [
			"ResolveAntiAliasedSurface($1)"
		],
		"description": "public void ResolveAntiAliasedSurface(); public void ResolveAntiAliasedSurface(RenderTexture target); des: Force an antialiased render texture to be resolved."
	}
,
	"CustomRenderTexture.SetGlobalShaderProperty": {
		"prefix": "CustomRenderTexture.SetGlobalShaderProperty",
		"body": [
			"SetGlobalShaderProperty($1)"
		],
		"description": "public void SetGlobalShaderProperty(string propertyName); des: Assigns this RenderTexture as a global shader property named propertyName."
	}
,
	"CustomRenderTexture.GetNativeTexturePtr": {
		"prefix": "CustomRenderTexture.GetNativeTexturePtr",
		"body": [
			"GetNativeTexturePtr($1)"
		],
		"description": "public IntPtr GetNativeTexturePtr(); des: Retrieve a native (underlying graphics API) pointer to the texture resource."
	}
,
	"CustomRenderTexture.IncrementUpdateCount": {
		"prefix": "CustomRenderTexture.IncrementUpdateCount",
		"body": [
			"IncrementUpdateCount($1)"
		],
		"description": "public void IncrementUpdateCount(); des: Increment the update counter."
	}
,
	"CustomRenderTexture.Destroy": {
		"prefix": "CustomRenderTexture.Destroy",
		"body": [
			"CustomRenderTexture.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"CustomRenderTexture.DestroyImmediate": {
		"prefix": "CustomRenderTexture.DestroyImmediate",
		"body": [
			"CustomRenderTexture.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"CustomRenderTexture.DontDestroyOnLoad": {
		"prefix": "CustomRenderTexture.DontDestroyOnLoad",
		"body": [
			"CustomRenderTexture.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"CustomRenderTexture.FindObjectOfType": {
		"prefix": "CustomRenderTexture.FindObjectOfType",
		"body": [
			"CustomRenderTexture.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"CustomRenderTexture.FindObjectsOfType": {
		"prefix": "CustomRenderTexture.FindObjectsOfType",
		"body": [
			"CustomRenderTexture.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"CustomRenderTexture.Instantiate": {
		"prefix": "CustomRenderTexture.Instantiate",
		"body": [
			"CustomRenderTexture.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"CustomRenderTexture.GetTemporary": {
		"prefix": "CustomRenderTexture.GetTemporary",
		"body": [
			"CustomRenderTexture.GetTemporary"
		],
		"description": "public static RenderTexture GetTemporary(RenderTextureDescriptor desc); public static RenderTexture GetTemporary(int width, int height, int depthBuffer = 0, RenderTextureFormat format = RenderTextureFormat.Default, RenderTextureReadWrite readWrite = RenderTextureReadWrite.Default, int antiAliasing = 1, RenderTextureMemoryless memorylessMode = RenderTextureMemoryless.None, VRTextureUsage vrUsage = VRTextureUsage.None, bool useDynamicScale = false); des: Allocate a temporary render texture."
	}
,
	"CustomRenderTexture.ReleaseTemporary": {
		"prefix": "CustomRenderTexture.ReleaseTemporary",
		"body": [
			"CustomRenderTexture.ReleaseTemporary"
		],
		"description": "public static void ReleaseTemporary(RenderTexture temp); des: Release a temporary texture allocated with GetTemporary."
	}
,
	"CustomRenderTexture.SupportsStencil": {
		"prefix": "CustomRenderTexture.SupportsStencil",
		"body": [
			"CustomRenderTexture.SupportsStencil"
		],
		"description": "public static bool SupportsStencil(RenderTexture rt); des: Does a RenderTexture have stencil buffer?"
	}
,
	"CustomRenderTexture.SetGlobalAnisotropicFilteringLimits": {
		"prefix": "CustomRenderTexture.SetGlobalAnisotropicFilteringLimits",
		"body": [
			"CustomRenderTexture.SetGlobalAnisotropicFilteringLimits"
		],
		"description": "public static void SetGlobalAnisotropicFilteringLimits(int forcedMin, int globalMax); des: Sets Anisotropic limits."
	}
,
	"CustomRenderTexture.SetStreamingTextureMaterialDebugProperties": {
		"prefix": "CustomRenderTexture.SetStreamingTextureMaterialDebugProperties",
		"body": [
			"CustomRenderTexture.SetStreamingTextureMaterialDebugProperties"
		],
		"description": "public static void SetStreamingTextureMaterialDebugProperties(); des: Uploads additional debug information to materials using textures set to stream mip maps."
	}
,
	"CustomRenderTextureUpdateZone.needSwap": {
		"prefix": "CustomRenderTextureUpdateZone.needSwap",
		"body": [
			"needSwap"
		],
		"description": "return:bool des: If true, and if the texture is double buffered, a request is made to swap the buffers before the next update. Otherwise, the buffers will not be swapped."
	}
,
	"CustomRenderTextureUpdateZone.passIndex": {
		"prefix": "CustomRenderTextureUpdateZone.passIndex",
		"body": [
			"passIndex"
		],
		"description": "return:int des: Shader Pass used to update the Custom Render Texture for this Update Zone."
	}
,
	"CustomRenderTextureUpdateZone.rotation": {
		"prefix": "CustomRenderTextureUpdateZone.rotation",
		"body": [
			"rotation"
		],
		"description": "return:float des: Rotation of the Update Zone."
	}
,
	"CustomRenderTextureUpdateZone.updateZoneCenter": {
		"prefix": "CustomRenderTextureUpdateZone.updateZoneCenter",
		"body": [
			"updateZoneCenter"
		],
		"description": "return:Vector3 des: Position of the center of the Update Zone within the Custom Render Texture."
	}
,
	"CustomRenderTextureUpdateZone.updateZoneSize": {
		"prefix": "CustomRenderTextureUpdateZone.updateZoneSize",
		"body": [
			"updateZoneSize"
		],
		"description": "return:Vector3 des: Size of the Update Zone."
	}
,
	"CustomYieldInstruction.keepWaiting": {
		"prefix": "CustomYieldInstruction.keepWaiting",
		"body": [
			"keepWaiting"
		],
		"description": "return:bool des: Indicates if coroutine should be kept suspended."
	}
,
	"Debug.Assert": {
		"prefix": "Debug.Assert",
		"body": [
			"Debug.Assert"
		],
		"description": "public static void Assert(bool condition); public static void Assert(bool condition, Object context); public static void Assert(bool condition, object message); public static void Assert(bool condition, object message, Object context); des: Assert a condition and logs an error message to the Unity console on failure."
	}
,
	"Debug.AssertFormat": {
		"prefix": "Debug.AssertFormat",
		"body": [
			"Debug.AssertFormat"
		],
		"description": "public static void AssertFormat(bool condition, string format, params object[] args); public static void AssertFormat(bool condition, Object context, string format, params object[] args); des: Assert a condition and logs a formatted error message to the Unity console on failure."
	}
,
	"Debug.Break": {
		"prefix": "Debug.Break",
		"body": [
			"Debug.Break"
		],
		"description": "public static void Break(); des: Pauses the editor."
	}
,
	"Debug.ClearDeveloperConsole": {
		"prefix": "Debug.ClearDeveloperConsole",
		"body": [
			"Debug.ClearDeveloperConsole"
		],
		"description": "public static void ClearDeveloperConsole(); des: Clears errors from the developer console."
	}
,
	"Debug.DrawLine": {
		"prefix": "Debug.DrawLine",
		"body": [
			"Debug.DrawLine"
		],
		"description": "public static void DrawLine(Vector3 start, Vector3 end, Color color = Color.white, float duration = 0.0f, bool depthTest = true); des: Draws a line between specified start and end points."
	}
,
	"Debug.DrawRay": {
		"prefix": "Debug.DrawRay",
		"body": [
			"Debug.DrawRay"
		],
		"description": "public static void DrawRay(Vector3 start, Vector3 dir, Color color = Color.white, float duration = 0.0f, bool depthTest = true); des: Draws a line from start to start + dir in world coordinates."
	}
,
	"Debug.Log": {
		"prefix": "Debug.Log",
		"body": [
			"Debug.Log"
		],
		"description": "public static void Log(object message); public static void Log(object message, Object context); des: Logs message to the Unity Console."
	}
,
	"Debug.LogAssertion": {
		"prefix": "Debug.LogAssertion",
		"body": [
			"Debug.LogAssertion"
		],
		"description": "public static void LogAssertion(object message); public static void LogAssertion(object message, Object context); des: A variant of Debug.Log that logs an assertion message to the console."
	}
,
	"Debug.LogAssertionFormat": {
		"prefix": "Debug.LogAssertionFormat",
		"body": [
			"Debug.LogAssertionFormat"
		],
		"description": "public static void LogAssertionFormat(string format, params object[] args); public static void LogAssertionFormat(Object context, string format, params object[] args); des: Logs a formatted assertion message to the Unity console."
	}
,
	"Debug.LogError": {
		"prefix": "Debug.LogError",
		"body": [
			"Debug.LogError"
		],
		"description": "public static void LogError(object message); public static void LogError(object message, Object context); des: A variant of Debug.Log that logs an error message to the console."
	}
,
	"Debug.LogErrorFormat": {
		"prefix": "Debug.LogErrorFormat",
		"body": [
			"Debug.LogErrorFormat"
		],
		"description": "public static void LogErrorFormat(string format, params object[] args); public static void LogErrorFormat(Object context, string format, params object[] args); des: Logs a formatted error message to the Unity console."
	}
,
	"Debug.LogException": {
		"prefix": "Debug.LogException",
		"body": [
			"Debug.LogException"
		],
		"description": "public static void LogException(Exception exception); public static void LogException(Exception exception, Object context); des: A variant of Debug.Log that logs an error message to the console."
	}
,
	"Debug.LogFormat": {
		"prefix": "Debug.LogFormat",
		"body": [
			"Debug.LogFormat"
		],
		"description": "public static void LogFormat(string format, params object[] args); public static void LogFormat(Object context, string format, params object[] args); des: Logs a formatted message to the Unity Console."
	}
,
	"Debug.LogWarning": {
		"prefix": "Debug.LogWarning",
		"body": [
			"Debug.LogWarning"
		],
		"description": "public static void LogWarning(object message); public static void LogWarning(object message, Object context); des: A variant of Debug.Log that logs a warning message to the console."
	}
,
	"Debug.LogWarningFormat": {
		"prefix": "Debug.LogWarningFormat",
		"body": [
			"Debug.LogWarningFormat"
		],
		"description": "public static void LogWarningFormat(string format, params object[] args); public static void LogWarningFormat(Object context, string format, params object[] args); des: Logs a formatted warning message to the Unity Console."
	}
,
	"DetailPrototype.bendFactor": {
		"prefix": "DetailPrototype.bendFactor",
		"body": [
			"bendFactor"
		],
		"description": "return:float des: Bend factor of the detailPrototype."
	}
,
	"DetailPrototype.dryColor": {
		"prefix": "DetailPrototype.dryColor",
		"body": [
			"dryColor"
		],
		"description": "return:Color des: Color when the DetailPrototypes are \"dry\"."
	}
,
	"DetailPrototype.healthyColor": {
		"prefix": "DetailPrototype.healthyColor",
		"body": [
			"healthyColor"
		],
		"description": "return:Color des: Color when the DetailPrototypes are \"healthy\"."
	}
,
	"DetailPrototype.maxHeight": {
		"prefix": "DetailPrototype.maxHeight",
		"body": [
			"maxHeight"
		],
		"description": "return:float des: Maximum height of the grass billboards (if render mode is GrassBillboard)."
	}
,
	"DetailPrototype.maxWidth": {
		"prefix": "DetailPrototype.maxWidth",
		"body": [
			"maxWidth"
		],
		"description": "return:float des: Maximum width of the grass billboards (if render mode is GrassBillboard)."
	}
,
	"DetailPrototype.minHeight": {
		"prefix": "DetailPrototype.minHeight",
		"body": [
			"minHeight"
		],
		"description": "return:float des: Minimum height of the grass billboards (if render mode is GrassBillboard)."
	}
,
	"DetailPrototype.minWidth": {
		"prefix": "DetailPrototype.minWidth",
		"body": [
			"minWidth"
		],
		"description": "return:float des: Minimum width of the grass billboards (if render mode is GrassBillboard)."
	}
,
	"DetailPrototype.noiseSpread": {
		"prefix": "DetailPrototype.noiseSpread",
		"body": [
			"noiseSpread"
		],
		"description": "return:float des: How spread out is the noise for the DetailPrototype."
	}
,
	"DetailPrototype.prototype": {
		"prefix": "DetailPrototype.prototype",
		"body": [
			"prototype"
		],
		"description": "return:GameObject des: GameObject used by the DetailPrototype."
	}
,
	"DetailPrototype.prototypeTexture": {
		"prefix": "DetailPrototype.prototypeTexture",
		"body": [
			"prototypeTexture"
		],
		"description": "return:Texture2D des: Texture used by the DetailPrototype."
	}
,
	"DetailPrototype.renderMode": {
		"prefix": "DetailPrototype.renderMode",
		"body": [
			"renderMode"
		],
		"description": "return:DetailRenderMode des: Render mode for the DetailPrototype."
	}
,
	"Display.active": {
		"prefix": "Display.active",
		"body": [
			"active"
		],
		"description": "return:bool des: Gets the state of the display and returns true if the display is active and false if otherwise."
	}
,
	"Display.colorBuffer": {
		"prefix": "Display.colorBuffer",
		"body": [
			"colorBuffer"
		],
		"description": "return:RenderBuffer des: Color RenderBuffer."
	}
,
	"Display.depthBuffer": {
		"prefix": "Display.depthBuffer",
		"body": [
			"depthBuffer"
		],
		"description": "return:RenderBuffer des: Depth RenderBuffer."
	}
,
	"Display.renderingHeight": {
		"prefix": "Display.renderingHeight",
		"body": [
			"renderingHeight"
		],
		"description": "return:int des: Vertical resolution that the display is rendering at."
	}
,
	"Display.renderingWidth": {
		"prefix": "Display.renderingWidth",
		"body": [
			"renderingWidth"
		],
		"description": "return:int des: Horizontal resolution that the display is rendering at."
	}
,
	"Display.systemHeight": {
		"prefix": "Display.systemHeight",
		"body": [
			"systemHeight"
		],
		"description": "return:int des: Vertical native display resolution."
	}
,
	"Display.systemWidth": {
		"prefix": "Display.systemWidth",
		"body": [
			"systemWidth"
		],
		"description": "return:int des: Horizontal native display resolution."
	}
,
	"Display.Activate": {
		"prefix": "Display.Activate",
		"body": [
			"Activate($1)"
		],
		"description": "public void Activate(); public void Activate(int width, int height, int refreshRate); des: Activate an external display. Eg. Secondary Monitors connected to the System."
	}
,
	"Display.SetParams": {
		"prefix": "Display.SetParams",
		"body": [
			"SetParams($1)"
		],
		"description": "public void SetParams(int width, int height, int x, int y); des: Set rendering size and position on screen (Windows only)."
	}
,
	"Display.SetRenderingResolution": {
		"prefix": "Display.SetRenderingResolution",
		"body": [
			"SetRenderingResolution($1)"
		],
		"description": "public void SetRenderingResolution(int w, int h); des: Sets rendering resolution for the display."
	}
,
	"Display.RelativeMouseAt": {
		"prefix": "Display.RelativeMouseAt",
		"body": [
			"Display.RelativeMouseAt"
		],
		"description": "public static Vector3 RelativeMouseAt(Vector3 inputMouseCoordinates); des: Query relative mouse coordinates."
	}
,
	"DistanceJoint2D.autoConfigureDistance": {
		"prefix": "DistanceJoint2D.autoConfigureDistance",
		"body": [
			"autoConfigureDistance"
		],
		"description": "return:bool des: Should the distance be calculated automatically?"
	}
,
	"DistanceJoint2D.distance": {
		"prefix": "DistanceJoint2D.distance",
		"body": [
			"distance"
		],
		"description": "return:float des: The distance separating the two ends of the joint."
	}
,
	"DistanceJoint2D.maxDistanceOnly": {
		"prefix": "DistanceJoint2D.maxDistanceOnly",
		"body": [
			"maxDistanceOnly"
		],
		"description": "return:bool des: Whether to maintain a maximum distance only or not. If not then the absolute distance will be maintained instead."
	}
,
	"DistanceJoint2D.anchor": {
		"prefix": "DistanceJoint2D.anchor",
		"body": [
			"anchor"
		],
		"description": "return:Vector2 des: The joint's anchor point on the object that has the joint component."
	}
,
	"DistanceJoint2D.autoConfigureConnectedAnchor": {
		"prefix": "DistanceJoint2D.autoConfigureConnectedAnchor",
		"body": [
			"autoConfigureConnectedAnchor"
		],
		"description": "return:bool des: Should the connectedAnchor be calculated automatically?"
	}
,
	"DistanceJoint2D.connectedAnchor": {
		"prefix": "DistanceJoint2D.connectedAnchor",
		"body": [
			"connectedAnchor"
		],
		"description": "return:Vector2 des: The joint's anchor point on the second object (ie, the one which doesn't have the joint component)."
	}
,
	"DistanceJoint2D.enabled": {
		"prefix": "DistanceJoint2D.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"DistanceJoint2D.isActiveAndEnabled": {
		"prefix": "DistanceJoint2D.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"DistanceJoint2D.gameObject": {
		"prefix": "DistanceJoint2D.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"DistanceJoint2D.tag": {
		"prefix": "DistanceJoint2D.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"DistanceJoint2D.transform": {
		"prefix": "DistanceJoint2D.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"DistanceJoint2D.attachedRigidbody": {
		"prefix": "DistanceJoint2D.attachedRigidbody",
		"body": [
			"attachedRigidbody"
		],
		"description": "return:Rigidbody2D des: The Rigidbody2D attached to the Joint2D."
	}
,
	"DistanceJoint2D.breakForce": {
		"prefix": "DistanceJoint2D.breakForce",
		"body": [
			"breakForce"
		],
		"description": "return:float des: The force that needs to be applied for this joint to break."
	}
,
	"DistanceJoint2D.breakTorque": {
		"prefix": "DistanceJoint2D.breakTorque",
		"body": [
			"breakTorque"
		],
		"description": "return:float des: The torque that needs to be applied for this joint to break."
	}
,
	"DistanceJoint2D.connectedBody": {
		"prefix": "DistanceJoint2D.connectedBody",
		"body": [
			"connectedBody"
		],
		"description": "return:Rigidbody2D des: The Rigidbody2D object to which the other end of the joint is attached (ie, the object without the joint component)."
	}
,
	"DistanceJoint2D.enableCollision": {
		"prefix": "DistanceJoint2D.enableCollision",
		"body": [
			"enableCollision"
		],
		"description": "return:bool des: Should the two rigid bodies connected with this joint collide with each other?"
	}
,
	"DistanceJoint2D.reactionForce": {
		"prefix": "DistanceJoint2D.reactionForce",
		"body": [
			"reactionForce"
		],
		"description": "return:Vector2 des: Gets the reaction force of the joint."
	}
,
	"DistanceJoint2D.reactionTorque": {
		"prefix": "DistanceJoint2D.reactionTorque",
		"body": [
			"reactionTorque"
		],
		"description": "return:float des: Gets the reaction torque of the joint."
	}
,
	"DistanceJoint2D.hideFlags": {
		"prefix": "DistanceJoint2D.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"DistanceJoint2D.name": {
		"prefix": "DistanceJoint2D.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"DistanceJoint2D.BroadcastMessage": {
		"prefix": "DistanceJoint2D.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"DistanceJoint2D.CompareTag": {
		"prefix": "DistanceJoint2D.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"DistanceJoint2D.GetComponent": {
		"prefix": "DistanceJoint2D.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"DistanceJoint2D.GetComponentInChildren": {
		"prefix": "DistanceJoint2D.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"DistanceJoint2D.GetComponentInParent": {
		"prefix": "DistanceJoint2D.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"DistanceJoint2D.GetComponents": {
		"prefix": "DistanceJoint2D.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"DistanceJoint2D.GetComponentsInChildren": {
		"prefix": "DistanceJoint2D.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"DistanceJoint2D.GetComponentsInParent": {
		"prefix": "DistanceJoint2D.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"DistanceJoint2D.SendMessage": {
		"prefix": "DistanceJoint2D.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"DistanceJoint2D.SendMessageUpwards": {
		"prefix": "DistanceJoint2D.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"DistanceJoint2D.GetReactionForce": {
		"prefix": "DistanceJoint2D.GetReactionForce",
		"body": [
			"GetReactionForce($1)"
		],
		"description": "public Vector2 GetReactionForce(float timeStep); des: Gets the reaction force of the joint given the specified timeStep."
	}
,
	"DistanceJoint2D.GetReactionTorque": {
		"prefix": "DistanceJoint2D.GetReactionTorque",
		"body": [
			"GetReactionTorque($1)"
		],
		"description": "public float GetReactionTorque(float timeStep); des: Gets the reaction torque of the joint given the specified timeStep."
	}
,
	"DistanceJoint2D.GetInstanceID": {
		"prefix": "DistanceJoint2D.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"DistanceJoint2D.ToString": {
		"prefix": "DistanceJoint2D.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"DistanceJoint2D.Destroy": {
		"prefix": "DistanceJoint2D.Destroy",
		"body": [
			"DistanceJoint2D.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"DistanceJoint2D.DestroyImmediate": {
		"prefix": "DistanceJoint2D.DestroyImmediate",
		"body": [
			"DistanceJoint2D.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"DistanceJoint2D.DontDestroyOnLoad": {
		"prefix": "DistanceJoint2D.DontDestroyOnLoad",
		"body": [
			"DistanceJoint2D.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"DistanceJoint2D.FindObjectOfType": {
		"prefix": "DistanceJoint2D.FindObjectOfType",
		"body": [
			"DistanceJoint2D.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"DistanceJoint2D.FindObjectsOfType": {
		"prefix": "DistanceJoint2D.FindObjectsOfType",
		"body": [
			"DistanceJoint2D.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"DistanceJoint2D.Instantiate": {
		"prefix": "DistanceJoint2D.Instantiate",
		"body": [
			"DistanceJoint2D.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"DistanceJoint2D.OnJointBreak2D": {
		"prefix": "DistanceJoint2D.OnJointBreak2D",
		"body": [
			"OnJointBreak2D"
		],
		"description": "Called when a Joint2D attached to the same game object breaks."
	}
,
	"DrivenRectTransformTracker.Add": {
		"prefix": "DrivenRectTransformTracker.Add",
		"body": [
			"Add($1)"
		],
		"description": "public void Add(Object driver, RectTransform rectTransform, DrivenTransformProperties drivenProperties); des: Add a RectTransform to be driven."
	}
,
	"DrivenRectTransformTracker.Clear": {
		"prefix": "DrivenRectTransformTracker.Clear",
		"body": [
			"Clear($1)"
		],
		"description": "public void Clear(); des: Clear the list of RectTransforms being driven."
	}
,
	"DrivenRectTransformTracker.StartRecordingUndo": {
		"prefix": "DrivenRectTransformTracker.StartRecordingUndo",
		"body": [
			"DrivenRectTransformTracker.StartRecordingUndo"
		],
		"description": "public static void StartRecordingUndo(); des: Resume recording undo of driven RectTransforms."
	}
,
	"DrivenRectTransformTracker.StopRecordingUndo": {
		"prefix": "DrivenRectTransformTracker.StopRecordingUndo",
		"body": [
			"DrivenRectTransformTracker.StopRecordingUndo"
		],
		"description": "public static void StopRecordingUndo(); des: Stop recording undo actions from driven RectTransforms."
	}
,
	"DynamicGI.SetEmissive": {
		"prefix": "DynamicGI.SetEmissive",
		"body": [
			"DynamicGI.SetEmissive"
		],
		"description": "public static void SetEmissive(Renderer renderer, Color color); des: Allows to set an emissive color for a given renderer quickly, without the need to render the emissive input for the entire system."
	}
,
	"DynamicGI.SetEnvironmentData": {
		"prefix": "DynamicGI.SetEnvironmentData",
		"body": [
			"DynamicGI.SetEnvironmentData"
		],
		"description": "public static void SetEnvironmentData(float[] input); des: Allows overriding the distant environment lighting for Realtime GI, without changing the Skybox Material."
	}
,
	"DynamicGI.UpdateEnvironment": {
		"prefix": "DynamicGI.UpdateEnvironment",
		"body": [
			"DynamicGI.UpdateEnvironment"
		],
		"description": "public static void UpdateEnvironment(); des: Schedules an update of the environment texture."
	}
,
	"DynamicGI.UpdateMaterials": {
		"prefix": "DynamicGI.UpdateMaterials",
		"body": [
			"DynamicGI.UpdateMaterials"
		],
		"description": "Obsolete public static void UpdateMaterials(Renderer renderer);   des: Schedules an update of the albedo and emissive textures of a system that contains the renderer or the terrain."
	}
,
	"EdgeCollider2D.edgeCount": {
		"prefix": "EdgeCollider2D.edgeCount",
		"body": [
			"edgeCount"
		],
		"description": "return:int des: Gets the number of edges."
	}
,
	"EdgeCollider2D.edgeRadius": {
		"prefix": "EdgeCollider2D.edgeRadius",
		"body": [
			"edgeRadius"
		],
		"description": "return:float des: Controls the radius of all edges created by the collider."
	}
,
	"EdgeCollider2D.pointCount": {
		"prefix": "EdgeCollider2D.pointCount",
		"body": [
			"pointCount"
		],
		"description": "return:int des: Gets the number of points."
	}
,
	"EdgeCollider2D.points": {
		"prefix": "EdgeCollider2D.points",
		"body": [
			"points"
		],
		"description": "return:Vector2[] des: Get or set the points defining multiple continuous edges."
	}
,
	"EdgeCollider2D.Reset": {
		"prefix": "EdgeCollider2D.Reset",
		"body": [
			"Reset($1)"
		],
		"description": "public void Reset(); des: Reset to a single edge consisting of two points."
	}
,
	"EdgeCollider2D.enabled": {
		"prefix": "EdgeCollider2D.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"EdgeCollider2D.isActiveAndEnabled": {
		"prefix": "EdgeCollider2D.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"EdgeCollider2D.attachedRigidbody": {
		"prefix": "EdgeCollider2D.attachedRigidbody",
		"body": [
			"attachedRigidbody"
		],
		"description": "return:Rigidbody2D des: The Rigidbody2D attached to the Collider2D."
	}
,
	"EdgeCollider2D.bounciness": {
		"prefix": "EdgeCollider2D.bounciness",
		"body": [
			"bounciness"
		],
		"description": "return:float des: Get the bounciness used by the collider."
	}
,
	"EdgeCollider2D.bounds": {
		"prefix": "EdgeCollider2D.bounds",
		"body": [
			"bounds"
		],
		"description": "return:Bounds des: The world space bounding area of the collider."
	}
,
	"EdgeCollider2D.composite": {
		"prefix": "EdgeCollider2D.composite",
		"body": [
			"composite"
		],
		"description": "return:CompositeCollider2D des: Get the CompositeCollider2D that is available to be attached to the collider."
	}
,
	"EdgeCollider2D.density": {
		"prefix": "EdgeCollider2D.density",
		"body": [
			"density"
		],
		"description": "return:float des: The density of the collider used to calculate its mass (when auto mass is enabled)."
	}
,
	"EdgeCollider2D.friction": {
		"prefix": "EdgeCollider2D.friction",
		"body": [
			"friction"
		],
		"description": "return:float des: Get the friction used by the collider."
	}
,
	"EdgeCollider2D.isTrigger": {
		"prefix": "EdgeCollider2D.isTrigger",
		"body": [
			"isTrigger"
		],
		"description": "return:bool des: Is this collider configured as a trigger?"
	}
,
	"EdgeCollider2D.offset": {
		"prefix": "EdgeCollider2D.offset",
		"body": [
			"offset"
		],
		"description": "return:Vector2 des: The local offset of the collider geometry."
	}
,
	"EdgeCollider2D.shapeCount": {
		"prefix": "EdgeCollider2D.shapeCount",
		"body": [
			"shapeCount"
		],
		"description": "return:int des: The number of separate shaped regions in the collider."
	}
,
	"EdgeCollider2D.sharedMaterial": {
		"prefix": "EdgeCollider2D.sharedMaterial",
		"body": [
			"sharedMaterial"
		],
		"description": "return:PhysicsMaterial2D des: The PhysicsMaterial2D that is applied to this collider."
	}
,
	"EdgeCollider2D.usedByComposite": {
		"prefix": "EdgeCollider2D.usedByComposite",
		"body": [
			"usedByComposite"
		],
		"description": "return:bool des: Sets whether the Collider will be used or not used by a CompositeCollider2D."
	}
,
	"EdgeCollider2D.usedByEffector": {
		"prefix": "EdgeCollider2D.usedByEffector",
		"body": [
			"usedByEffector"
		],
		"description": "return:bool des: Whether the collider is used by an attached effector or not."
	}
,
	"EdgeCollider2D.gameObject": {
		"prefix": "EdgeCollider2D.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"EdgeCollider2D.tag": {
		"prefix": "EdgeCollider2D.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"EdgeCollider2D.transform": {
		"prefix": "EdgeCollider2D.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"EdgeCollider2D.hideFlags": {
		"prefix": "EdgeCollider2D.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"EdgeCollider2D.name": {
		"prefix": "EdgeCollider2D.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"EdgeCollider2D.Cast": {
		"prefix": "EdgeCollider2D.Cast",
		"body": [
			"Cast($1)"
		],
		"description": "public int Cast(Vector2 direction, RaycastHit2D[] results, float distance = Mathf.Infinity, bool ignoreSiblingColliders = true); public int Cast(Vector2 direction, ContactFilter2D contactFilter, RaycastHit2D[] results, float distance = Mathf.Infinity, bool ignoreSiblingColliders = true); des: Casts the collider shape into the scene starting at the collider position ignoring the collider itself."
	}
,
	"EdgeCollider2D.Distance": {
		"prefix": "EdgeCollider2D.Distance",
		"body": [
			"Distance($1)"
		],
		"description": "public ColliderDistance2D Distance(Collider2D collider); des: Calculates the minimum separation of this collider against another collider."
	}
,
	"EdgeCollider2D.GetContacts": {
		"prefix": "EdgeCollider2D.GetContacts",
		"body": [
			"GetContacts($1)"
		],
		"description": "public int GetContacts(ContactPoint2D[] contacts); public int GetContacts(Collider2D[] colliders); public int GetContacts(ContactFilter2D contactFilter, ContactPoint2D[] contacts); public int GetContacts(ContactFilter2D contactFilter, Collider2D[] colliders); des: Retrieves all contact points for this collider."
	}
,
	"EdgeCollider2D.IsTouching": {
		"prefix": "EdgeCollider2D.IsTouching",
		"body": [
			"IsTouching($1)"
		],
		"description": "public bool IsTouching(Collider2D collider); public bool IsTouching(Collider2D collider, ContactFilter2D contactFilter); public bool IsTouching(ContactFilter2D contactFilter); des: Check whether this collider is touching the collider or not."
	}
,
	"EdgeCollider2D.IsTouchingLayers": {
		"prefix": "EdgeCollider2D.IsTouchingLayers",
		"body": [
			"IsTouchingLayers($1)"
		],
		"description": "public bool IsTouchingLayers(int layerMask = Physics2D.AllLayers); des: Checks whether this collider is touching any colliders on the specified layerMask or not."
	}
,
	"EdgeCollider2D.OverlapCollider": {
		"prefix": "EdgeCollider2D.OverlapCollider",
		"body": [
			"OverlapCollider($1)"
		],
		"description": "public int OverlapCollider(ContactFilter2D contactFilter, Collider2D[] results); des: Get a list of all colliders that overlap this collider."
	}
,
	"EdgeCollider2D.OverlapPoint": {
		"prefix": "EdgeCollider2D.OverlapPoint",
		"body": [
			"OverlapPoint($1)"
		],
		"description": "public bool OverlapPoint(Vector2 point); des: Check if a collider overlaps a point in space."
	}
,
	"EdgeCollider2D.Raycast": {
		"prefix": "EdgeCollider2D.Raycast",
		"body": [
			"Raycast($1)"
		],
		"description": "public int Raycast(Vector2 direction, RaycastHit2D[] results, float distance = Mathf.Infinity, int layerMask = Physics2D.AllLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); public int Raycast(Vector2 direction, ContactFilter2D contactFilter, RaycastHit2D[] results, float distance = Mathf.Infinity); des: Casts a ray into the scene starting at the collider position ignoring the collider itself."
	}
,
	"EdgeCollider2D.BroadcastMessage": {
		"prefix": "EdgeCollider2D.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"EdgeCollider2D.CompareTag": {
		"prefix": "EdgeCollider2D.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"EdgeCollider2D.GetComponent": {
		"prefix": "EdgeCollider2D.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"EdgeCollider2D.GetComponentInChildren": {
		"prefix": "EdgeCollider2D.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"EdgeCollider2D.GetComponentInParent": {
		"prefix": "EdgeCollider2D.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"EdgeCollider2D.GetComponents": {
		"prefix": "EdgeCollider2D.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"EdgeCollider2D.GetComponentsInChildren": {
		"prefix": "EdgeCollider2D.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"EdgeCollider2D.GetComponentsInParent": {
		"prefix": "EdgeCollider2D.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"EdgeCollider2D.SendMessage": {
		"prefix": "EdgeCollider2D.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"EdgeCollider2D.SendMessageUpwards": {
		"prefix": "EdgeCollider2D.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"EdgeCollider2D.GetInstanceID": {
		"prefix": "EdgeCollider2D.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"EdgeCollider2D.ToString": {
		"prefix": "EdgeCollider2D.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"EdgeCollider2D.Destroy": {
		"prefix": "EdgeCollider2D.Destroy",
		"body": [
			"EdgeCollider2D.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"EdgeCollider2D.DestroyImmediate": {
		"prefix": "EdgeCollider2D.DestroyImmediate",
		"body": [
			"EdgeCollider2D.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"EdgeCollider2D.DontDestroyOnLoad": {
		"prefix": "EdgeCollider2D.DontDestroyOnLoad",
		"body": [
			"EdgeCollider2D.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"EdgeCollider2D.FindObjectOfType": {
		"prefix": "EdgeCollider2D.FindObjectOfType",
		"body": [
			"EdgeCollider2D.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"EdgeCollider2D.FindObjectsOfType": {
		"prefix": "EdgeCollider2D.FindObjectsOfType",
		"body": [
			"EdgeCollider2D.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"EdgeCollider2D.Instantiate": {
		"prefix": "EdgeCollider2D.Instantiate",
		"body": [
			"EdgeCollider2D.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"EdgeCollider2D.OnCollisionEnter2D": {
		"prefix": "EdgeCollider2D.OnCollisionEnter2D",
		"body": [
			"OnCollisionEnter2D"
		],
		"description": "Sent when an incoming collider makes contact with this object's collider (2D physics only)."
	}
,
	"EdgeCollider2D.OnCollisionExit2D": {
		"prefix": "EdgeCollider2D.OnCollisionExit2D",
		"body": [
			"OnCollisionExit2D"
		],
		"description": "Sent when a collider on another object stops touching this object's collider (2D physics only)."
	}
,
	"EdgeCollider2D.OnCollisionStay2D": {
		"prefix": "EdgeCollider2D.OnCollisionStay2D",
		"body": [
			"OnCollisionStay2D"
		],
		"description": "Sent each frame where a collider on another object is touching this object's collider (2D physics only)."
	}
,
	"EdgeCollider2D.OnTriggerEnter2D": {
		"prefix": "EdgeCollider2D.OnTriggerEnter2D",
		"body": [
			"OnTriggerEnter2D"
		],
		"description": "Sent when another object enters a trigger collider attached to this object (2D physics only)."
	}
,
	"EdgeCollider2D.OnTriggerExit2D": {
		"prefix": "EdgeCollider2D.OnTriggerExit2D",
		"body": [
			"OnTriggerExit2D"
		],
		"description": "Sent when another object leaves a trigger collider attached to this object (2D physics only)."
	}
,
	"EdgeCollider2D.OnTriggerStay2D": {
		"prefix": "EdgeCollider2D.OnTriggerStay2D",
		"body": [
			"OnTriggerStay2D"
		],
		"description": "Sent each frame where another object is within a trigger collider attached to this object (2D physics only)."
	}
,
	"Effector2D.colliderMask": {
		"prefix": "Effector2D.colliderMask",
		"body": [
			"colliderMask"
		],
		"description": "return:int des: The mask used to select specific layers allowed to interact with the effector."
	}
,
	"Effector2D.useColliderMask": {
		"prefix": "Effector2D.useColliderMask",
		"body": [
			"useColliderMask"
		],
		"description": "return:bool des: Should the collider-mask be used or the global collision matrix?"
	}
,
	"Effector2D.enabled": {
		"prefix": "Effector2D.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"Effector2D.isActiveAndEnabled": {
		"prefix": "Effector2D.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"Effector2D.gameObject": {
		"prefix": "Effector2D.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"Effector2D.tag": {
		"prefix": "Effector2D.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"Effector2D.transform": {
		"prefix": "Effector2D.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"Effector2D.hideFlags": {
		"prefix": "Effector2D.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Effector2D.name": {
		"prefix": "Effector2D.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Effector2D.BroadcastMessage": {
		"prefix": "Effector2D.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"Effector2D.CompareTag": {
		"prefix": "Effector2D.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"Effector2D.GetComponent": {
		"prefix": "Effector2D.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"Effector2D.GetComponentInChildren": {
		"prefix": "Effector2D.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"Effector2D.GetComponentInParent": {
		"prefix": "Effector2D.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"Effector2D.GetComponents": {
		"prefix": "Effector2D.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"Effector2D.GetComponentsInChildren": {
		"prefix": "Effector2D.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"Effector2D.GetComponentsInParent": {
		"prefix": "Effector2D.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"Effector2D.SendMessage": {
		"prefix": "Effector2D.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"Effector2D.SendMessageUpwards": {
		"prefix": "Effector2D.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"Effector2D.GetInstanceID": {
		"prefix": "Effector2D.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Effector2D.ToString": {
		"prefix": "Effector2D.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Effector2D.Destroy": {
		"prefix": "Effector2D.Destroy",
		"body": [
			"Effector2D.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Effector2D.DestroyImmediate": {
		"prefix": "Effector2D.DestroyImmediate",
		"body": [
			"Effector2D.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Effector2D.DontDestroyOnLoad": {
		"prefix": "Effector2D.DontDestroyOnLoad",
		"body": [
			"Effector2D.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Effector2D.FindObjectOfType": {
		"prefix": "Effector2D.FindObjectOfType",
		"body": [
			"Effector2D.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Effector2D.FindObjectsOfType": {
		"prefix": "Effector2D.FindObjectsOfType",
		"body": [
			"Effector2D.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Effector2D.Instantiate": {
		"prefix": "Effector2D.Instantiate",
		"body": [
			"Effector2D.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"EllipsoidParticleEmitter.gameObject": {
		"prefix": "EllipsoidParticleEmitter.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"EllipsoidParticleEmitter.tag": {
		"prefix": "EllipsoidParticleEmitter.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"EllipsoidParticleEmitter.transform": {
		"prefix": "EllipsoidParticleEmitter.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"EllipsoidParticleEmitter.hideFlags": {
		"prefix": "EllipsoidParticleEmitter.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"EllipsoidParticleEmitter.name": {
		"prefix": "EllipsoidParticleEmitter.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"EllipsoidParticleEmitter.BroadcastMessage": {
		"prefix": "EllipsoidParticleEmitter.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"EllipsoidParticleEmitter.CompareTag": {
		"prefix": "EllipsoidParticleEmitter.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"EllipsoidParticleEmitter.GetComponent": {
		"prefix": "EllipsoidParticleEmitter.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"EllipsoidParticleEmitter.GetComponentInChildren": {
		"prefix": "EllipsoidParticleEmitter.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"EllipsoidParticleEmitter.GetComponentInParent": {
		"prefix": "EllipsoidParticleEmitter.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"EllipsoidParticleEmitter.GetComponents": {
		"prefix": "EllipsoidParticleEmitter.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"EllipsoidParticleEmitter.GetComponentsInChildren": {
		"prefix": "EllipsoidParticleEmitter.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"EllipsoidParticleEmitter.GetComponentsInParent": {
		"prefix": "EllipsoidParticleEmitter.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"EllipsoidParticleEmitter.SendMessage": {
		"prefix": "EllipsoidParticleEmitter.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"EllipsoidParticleEmitter.SendMessageUpwards": {
		"prefix": "EllipsoidParticleEmitter.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"EllipsoidParticleEmitter.GetInstanceID": {
		"prefix": "EllipsoidParticleEmitter.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"EllipsoidParticleEmitter.ToString": {
		"prefix": "EllipsoidParticleEmitter.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"EllipsoidParticleEmitter.Destroy": {
		"prefix": "EllipsoidParticleEmitter.Destroy",
		"body": [
			"EllipsoidParticleEmitter.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"EllipsoidParticleEmitter.DestroyImmediate": {
		"prefix": "EllipsoidParticleEmitter.DestroyImmediate",
		"body": [
			"EllipsoidParticleEmitter.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"EllipsoidParticleEmitter.DontDestroyOnLoad": {
		"prefix": "EllipsoidParticleEmitter.DontDestroyOnLoad",
		"body": [
			"EllipsoidParticleEmitter.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"EllipsoidParticleEmitter.FindObjectOfType": {
		"prefix": "EllipsoidParticleEmitter.FindObjectOfType",
		"body": [
			"EllipsoidParticleEmitter.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"EllipsoidParticleEmitter.FindObjectsOfType": {
		"prefix": "EllipsoidParticleEmitter.FindObjectsOfType",
		"body": [
			"EllipsoidParticleEmitter.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"EllipsoidParticleEmitter.Instantiate": {
		"prefix": "EllipsoidParticleEmitter.Instantiate",
		"body": [
			"EllipsoidParticleEmitter.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"Event.alt": {
		"prefix": "Event.alt",
		"body": [
			"alt"
		],
		"description": "return:bool des: Is Alt/Option key held down? (Read Only)"
	}
,
	"Event.button": {
		"prefix": "Event.button",
		"body": [
			"button"
		],
		"description": "return:int des: Which mouse button was pressed."
	}
,
	"Event.capsLock": {
		"prefix": "Event.capsLock",
		"body": [
			"capsLock"
		],
		"description": "return:bool des: Is Caps Lock on? (Read Only)"
	}
,
	"Event.character": {
		"prefix": "Event.character",
		"body": [
			"character"
		],
		"description": "return:char des: The character typed."
	}
,
	"Event.clickCount": {
		"prefix": "Event.clickCount",
		"body": [
			"clickCount"
		],
		"description": "return:int des: How many consecutive mouse clicks have we received."
	}
,
	"Event.command": {
		"prefix": "Event.command",
		"body": [
			"command"
		],
		"description": "return:bool des: Is Command/Windows key held down? (Read Only)"
	}
,
	"Event.commandName": {
		"prefix": "Event.commandName",
		"body": [
			"commandName"
		],
		"description": "return:string des: The name of an ExecuteCommand or ValidateCommand Event."
	}
,
	"Event.control": {
		"prefix": "Event.control",
		"body": [
			"control"
		],
		"description": "return:bool des: Is Control key held down? (Read Only)"
	}
,
	"Event.delta": {
		"prefix": "Event.delta",
		"body": [
			"delta"
		],
		"description": "return:Vector2 des: The relative movement of the mouse compared to last event."
	}
,
	"Event.displayIndex": {
		"prefix": "Event.displayIndex",
		"body": [
			"displayIndex"
		],
		"description": "return:int des: Index of display that the event belongs to."
	}
,
	"Event.functionKey": {
		"prefix": "Event.functionKey",
		"body": [
			"functionKey"
		],
		"description": "return:bool des: Is the current keypress a function key? (Read Only)"
	}
,
	"Event.isKey": {
		"prefix": "Event.isKey",
		"body": [
			"isKey"
		],
		"description": "return:bool des: Is this event a keyboard event? (Read Only)"
	}
,
	"Event.isMouse": {
		"prefix": "Event.isMouse",
		"body": [
			"isMouse"
		],
		"description": "return:bool des: Is this event a mouse event? (Read Only)"
	}
,
	"Event.keyCode": {
		"prefix": "Event.keyCode",
		"body": [
			"keyCode"
		],
		"description": "return:KeyCode des: The raw key code for keyboard events."
	}
,
	"Event.modifiers": {
		"prefix": "Event.modifiers",
		"body": [
			"modifiers"
		],
		"description": "return:EventModifiers des: Which modifier keys are held down."
	}
,
	"Event.mousePosition": {
		"prefix": "Event.mousePosition",
		"body": [
			"mousePosition"
		],
		"description": "return:Vector2 des: The mouse position."
	}
,
	"Event.numeric": {
		"prefix": "Event.numeric",
		"body": [
			"numeric"
		],
		"description": "return:bool des: Is the current keypress on the numeric keyboard? (Read Only)"
	}
,
	"Event.shift": {
		"prefix": "Event.shift",
		"body": [
			"shift"
		],
		"description": "return:bool des: Is Shift held down? (Read Only)"
	}
,
	"Event.type": {
		"prefix": "Event.type",
		"body": [
			"type"
		],
		"description": "return:EventType des: The type of event."
	}
,
	"Event.GetTypeForControl": {
		"prefix": "Event.GetTypeForControl",
		"body": [
			"GetTypeForControl($1)"
		],
		"description": "public EventType GetTypeForControl(int controlID); des: Get a filtered event type for a given control ID."
	}
,
	"Event.Use": {
		"prefix": "Event.Use",
		"body": [
			"Use($1)"
		],
		"description": "public void Use(); des: Use this event."
	}
,
	"Event.GetEventCount": {
		"prefix": "Event.GetEventCount",
		"body": [
			"Event.GetEventCount"
		],
		"description": "public static int GetEventCount(); des: Returns the current number of events that are stored in the event queue."
	}
,
	"Event.KeyboardEvent": {
		"prefix": "Event.KeyboardEvent",
		"body": [
			"Event.KeyboardEvent"
		],
		"description": "public static Event KeyboardEvent(string key); des: Create a keyboard event."
	}
,
	"Event.PopEvent": {
		"prefix": "Event.PopEvent",
		"body": [
			"Event.PopEvent"
		],
		"description": "public static bool PopEvent(Event outEvent); des: Get the next queued [Event] from the event system."
	}
,
	"ExposedReference_1.defaultValue": {
		"prefix": "ExposedReference_1.defaultValue",
		"body": [
			"defaultValue"
		],
		"description": "return:Object des: The default value, in case the value cannot be resolved."
	}
,
	"ExposedReference_1.exposedName": {
		"prefix": "ExposedReference_1.exposedName",
		"body": [
			"exposedName"
		],
		"description": "return:PropertyName des: The name of the ExposedReference."
	}
,
	"ExposedReference_1.Resolve": {
		"prefix": "ExposedReference_1.Resolve",
		"body": [
			"Resolve($1)"
		],
		"description": " des: Gets the value of the reference by resolving it given the ExposedPropertyResolver context object."
	}
,
	"FixedJoint.gameObject": {
		"prefix": "FixedJoint.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"FixedJoint.tag": {
		"prefix": "FixedJoint.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"FixedJoint.transform": {
		"prefix": "FixedJoint.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"FixedJoint.anchor": {
		"prefix": "FixedJoint.anchor",
		"body": [
			"anchor"
		],
		"description": "return:Vector3 des: The Position of the anchor around which the joints motion is constrained."
	}
,
	"FixedJoint.autoConfigureConnectedAnchor": {
		"prefix": "FixedJoint.autoConfigureConnectedAnchor",
		"body": [
			"autoConfigureConnectedAnchor"
		],
		"description": "return:bool des: Should the connectedAnchor be calculated automatically?"
	}
,
	"FixedJoint.axis": {
		"prefix": "FixedJoint.axis",
		"body": [
			"axis"
		],
		"description": "return:Vector3 des: The Direction of the axis around which the body is constrained."
	}
,
	"FixedJoint.breakForce": {
		"prefix": "FixedJoint.breakForce",
		"body": [
			"breakForce"
		],
		"description": "return:float des: The force that needs to be applied for this joint to break."
	}
,
	"FixedJoint.breakTorque": {
		"prefix": "FixedJoint.breakTorque",
		"body": [
			"breakTorque"
		],
		"description": "return:float des: The torque that needs to be applied for this joint to break."
	}
,
	"FixedJoint.connectedAnchor": {
		"prefix": "FixedJoint.connectedAnchor",
		"body": [
			"connectedAnchor"
		],
		"description": "return:Vector3 des: Position of the anchor relative to the connected Rigidbody."
	}
,
	"FixedJoint.connectedBody": {
		"prefix": "FixedJoint.connectedBody",
		"body": [
			"connectedBody"
		],
		"description": "return:Rigidbody des: A reference to another rigidbody this joint connects to."
	}
,
	"FixedJoint.connectedMassScale": {
		"prefix": "FixedJoint.connectedMassScale",
		"body": [
			"connectedMassScale"
		],
		"description": "return:float des: The scale to apply to the inverse mass and inertia tensor of the connected body prior to solving the constraints."
	}
,
	"FixedJoint.currentForce": {
		"prefix": "FixedJoint.currentForce",
		"body": [
			"currentForce"
		],
		"description": "return:Vector3 des: The force applied by the solver to satisfy all constraints."
	}
,
	"FixedJoint.currentTorque": {
		"prefix": "FixedJoint.currentTorque",
		"body": [
			"currentTorque"
		],
		"description": "return:Vector3 des: The torque applied by the solver to satisfy all constraints."
	}
,
	"FixedJoint.enableCollision": {
		"prefix": "FixedJoint.enableCollision",
		"body": [
			"enableCollision"
		],
		"description": "return:bool des: Enable collision between bodies connected with the joint."
	}
,
	"FixedJoint.enablePreprocessing": {
		"prefix": "FixedJoint.enablePreprocessing",
		"body": [
			"enablePreprocessing"
		],
		"description": "return:bool des: Toggle preprocessing for this joint."
	}
,
	"FixedJoint.massScale": {
		"prefix": "FixedJoint.massScale",
		"body": [
			"massScale"
		],
		"description": "return:float des: The scale to apply to the inverse mass and inertia tensor of the body prior to solving the constraints."
	}
,
	"FixedJoint.hideFlags": {
		"prefix": "FixedJoint.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"FixedJoint.name": {
		"prefix": "FixedJoint.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"FixedJoint.BroadcastMessage": {
		"prefix": "FixedJoint.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"FixedJoint.CompareTag": {
		"prefix": "FixedJoint.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"FixedJoint.GetComponent": {
		"prefix": "FixedJoint.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"FixedJoint.GetComponentInChildren": {
		"prefix": "FixedJoint.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"FixedJoint.GetComponentInParent": {
		"prefix": "FixedJoint.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"FixedJoint.GetComponents": {
		"prefix": "FixedJoint.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"FixedJoint.GetComponentsInChildren": {
		"prefix": "FixedJoint.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"FixedJoint.GetComponentsInParent": {
		"prefix": "FixedJoint.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"FixedJoint.SendMessage": {
		"prefix": "FixedJoint.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"FixedJoint.SendMessageUpwards": {
		"prefix": "FixedJoint.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"FixedJoint.GetInstanceID": {
		"prefix": "FixedJoint.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"FixedJoint.ToString": {
		"prefix": "FixedJoint.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"FixedJoint.Destroy": {
		"prefix": "FixedJoint.Destroy",
		"body": [
			"FixedJoint.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"FixedJoint.DestroyImmediate": {
		"prefix": "FixedJoint.DestroyImmediate",
		"body": [
			"FixedJoint.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"FixedJoint.DontDestroyOnLoad": {
		"prefix": "FixedJoint.DontDestroyOnLoad",
		"body": [
			"FixedJoint.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"FixedJoint.FindObjectOfType": {
		"prefix": "FixedJoint.FindObjectOfType",
		"body": [
			"FixedJoint.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"FixedJoint.FindObjectsOfType": {
		"prefix": "FixedJoint.FindObjectsOfType",
		"body": [
			"FixedJoint.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"FixedJoint.Instantiate": {
		"prefix": "FixedJoint.Instantiate",
		"body": [
			"FixedJoint.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"FixedJoint.OnJointBreak": {
		"prefix": "FixedJoint.OnJointBreak",
		"body": [
			"OnJointBreak"
		],
		"description": "Called when a joint attached to the same game object broke."
	}
,
	"FixedJoint2D.dampingRatio": {
		"prefix": "FixedJoint2D.dampingRatio",
		"body": [
			"dampingRatio"
		],
		"description": "return:float des: The amount by which the spring force is reduced in proportion to the movement speed."
	}
,
	"FixedJoint2D.frequency": {
		"prefix": "FixedJoint2D.frequency",
		"body": [
			"frequency"
		],
		"description": "return:float des: The frequency at which the spring oscillates around the distance between the objects."
	}
,
	"FixedJoint2D.referenceAngle": {
		"prefix": "FixedJoint2D.referenceAngle",
		"body": [
			"referenceAngle"
		],
		"description": "return:float des: The angle referenced between the two bodies used as the constraint for the joint."
	}
,
	"FixedJoint2D.anchor": {
		"prefix": "FixedJoint2D.anchor",
		"body": [
			"anchor"
		],
		"description": "return:Vector2 des: The joint's anchor point on the object that has the joint component."
	}
,
	"FixedJoint2D.autoConfigureConnectedAnchor": {
		"prefix": "FixedJoint2D.autoConfigureConnectedAnchor",
		"body": [
			"autoConfigureConnectedAnchor"
		],
		"description": "return:bool des: Should the connectedAnchor be calculated automatically?"
	}
,
	"FixedJoint2D.connectedAnchor": {
		"prefix": "FixedJoint2D.connectedAnchor",
		"body": [
			"connectedAnchor"
		],
		"description": "return:Vector2 des: The joint's anchor point on the second object (ie, the one which doesn't have the joint component)."
	}
,
	"FixedJoint2D.enabled": {
		"prefix": "FixedJoint2D.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"FixedJoint2D.isActiveAndEnabled": {
		"prefix": "FixedJoint2D.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"FixedJoint2D.gameObject": {
		"prefix": "FixedJoint2D.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"FixedJoint2D.tag": {
		"prefix": "FixedJoint2D.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"FixedJoint2D.transform": {
		"prefix": "FixedJoint2D.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"FixedJoint2D.attachedRigidbody": {
		"prefix": "FixedJoint2D.attachedRigidbody",
		"body": [
			"attachedRigidbody"
		],
		"description": "return:Rigidbody2D des: The Rigidbody2D attached to the Joint2D."
	}
,
	"FixedJoint2D.breakForce": {
		"prefix": "FixedJoint2D.breakForce",
		"body": [
			"breakForce"
		],
		"description": "return:float des: The force that needs to be applied for this joint to break."
	}
,
	"FixedJoint2D.breakTorque": {
		"prefix": "FixedJoint2D.breakTorque",
		"body": [
			"breakTorque"
		],
		"description": "return:float des: The torque that needs to be applied for this joint to break."
	}
,
	"FixedJoint2D.connectedBody": {
		"prefix": "FixedJoint2D.connectedBody",
		"body": [
			"connectedBody"
		],
		"description": "return:Rigidbody2D des: The Rigidbody2D object to which the other end of the joint is attached (ie, the object without the joint component)."
	}
,
	"FixedJoint2D.enableCollision": {
		"prefix": "FixedJoint2D.enableCollision",
		"body": [
			"enableCollision"
		],
		"description": "return:bool des: Should the two rigid bodies connected with this joint collide with each other?"
	}
,
	"FixedJoint2D.reactionForce": {
		"prefix": "FixedJoint2D.reactionForce",
		"body": [
			"reactionForce"
		],
		"description": "return:Vector2 des: Gets the reaction force of the joint."
	}
,
	"FixedJoint2D.reactionTorque": {
		"prefix": "FixedJoint2D.reactionTorque",
		"body": [
			"reactionTorque"
		],
		"description": "return:float des: Gets the reaction torque of the joint."
	}
,
	"FixedJoint2D.hideFlags": {
		"prefix": "FixedJoint2D.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"FixedJoint2D.name": {
		"prefix": "FixedJoint2D.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"FixedJoint2D.BroadcastMessage": {
		"prefix": "FixedJoint2D.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"FixedJoint2D.CompareTag": {
		"prefix": "FixedJoint2D.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"FixedJoint2D.GetComponent": {
		"prefix": "FixedJoint2D.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"FixedJoint2D.GetComponentInChildren": {
		"prefix": "FixedJoint2D.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"FixedJoint2D.GetComponentInParent": {
		"prefix": "FixedJoint2D.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"FixedJoint2D.GetComponents": {
		"prefix": "FixedJoint2D.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"FixedJoint2D.GetComponentsInChildren": {
		"prefix": "FixedJoint2D.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"FixedJoint2D.GetComponentsInParent": {
		"prefix": "FixedJoint2D.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"FixedJoint2D.SendMessage": {
		"prefix": "FixedJoint2D.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"FixedJoint2D.SendMessageUpwards": {
		"prefix": "FixedJoint2D.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"FixedJoint2D.GetReactionForce": {
		"prefix": "FixedJoint2D.GetReactionForce",
		"body": [
			"GetReactionForce($1)"
		],
		"description": "public Vector2 GetReactionForce(float timeStep); des: Gets the reaction force of the joint given the specified timeStep."
	}
,
	"FixedJoint2D.GetReactionTorque": {
		"prefix": "FixedJoint2D.GetReactionTorque",
		"body": [
			"GetReactionTorque($1)"
		],
		"description": "public float GetReactionTorque(float timeStep); des: Gets the reaction torque of the joint given the specified timeStep."
	}
,
	"FixedJoint2D.GetInstanceID": {
		"prefix": "FixedJoint2D.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"FixedJoint2D.ToString": {
		"prefix": "FixedJoint2D.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"FixedJoint2D.Destroy": {
		"prefix": "FixedJoint2D.Destroy",
		"body": [
			"FixedJoint2D.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"FixedJoint2D.DestroyImmediate": {
		"prefix": "FixedJoint2D.DestroyImmediate",
		"body": [
			"FixedJoint2D.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"FixedJoint2D.DontDestroyOnLoad": {
		"prefix": "FixedJoint2D.DontDestroyOnLoad",
		"body": [
			"FixedJoint2D.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"FixedJoint2D.FindObjectOfType": {
		"prefix": "FixedJoint2D.FindObjectOfType",
		"body": [
			"FixedJoint2D.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"FixedJoint2D.FindObjectsOfType": {
		"prefix": "FixedJoint2D.FindObjectsOfType",
		"body": [
			"FixedJoint2D.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"FixedJoint2D.Instantiate": {
		"prefix": "FixedJoint2D.Instantiate",
		"body": [
			"FixedJoint2D.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"FixedJoint2D.OnJointBreak2D": {
		"prefix": "FixedJoint2D.OnJointBreak2D",
		"body": [
			"OnJointBreak2D"
		],
		"description": "Called when a Joint2D attached to the same game object breaks."
	}
,
	"Flare.hideFlags": {
		"prefix": "Flare.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Flare.name": {
		"prefix": "Flare.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Flare.GetInstanceID": {
		"prefix": "Flare.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Flare.ToString": {
		"prefix": "Flare.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Flare.Destroy": {
		"prefix": "Flare.Destroy",
		"body": [
			"Flare.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Flare.DestroyImmediate": {
		"prefix": "Flare.DestroyImmediate",
		"body": [
			"Flare.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Flare.DontDestroyOnLoad": {
		"prefix": "Flare.DontDestroyOnLoad",
		"body": [
			"Flare.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Flare.FindObjectOfType": {
		"prefix": "Flare.FindObjectOfType",
		"body": [
			"Flare.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Flare.FindObjectsOfType": {
		"prefix": "Flare.FindObjectsOfType",
		"body": [
			"Flare.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Flare.Instantiate": {
		"prefix": "Flare.Instantiate",
		"body": [
			"Flare.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"FlareLayer.enabled": {
		"prefix": "FlareLayer.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"FlareLayer.isActiveAndEnabled": {
		"prefix": "FlareLayer.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"FlareLayer.gameObject": {
		"prefix": "FlareLayer.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"FlareLayer.tag": {
		"prefix": "FlareLayer.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"FlareLayer.transform": {
		"prefix": "FlareLayer.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"FlareLayer.hideFlags": {
		"prefix": "FlareLayer.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"FlareLayer.name": {
		"prefix": "FlareLayer.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"FlareLayer.BroadcastMessage": {
		"prefix": "FlareLayer.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"FlareLayer.CompareTag": {
		"prefix": "FlareLayer.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"FlareLayer.GetComponent": {
		"prefix": "FlareLayer.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"FlareLayer.GetComponentInChildren": {
		"prefix": "FlareLayer.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"FlareLayer.GetComponentInParent": {
		"prefix": "FlareLayer.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"FlareLayer.GetComponents": {
		"prefix": "FlareLayer.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"FlareLayer.GetComponentsInChildren": {
		"prefix": "FlareLayer.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"FlareLayer.GetComponentsInParent": {
		"prefix": "FlareLayer.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"FlareLayer.SendMessage": {
		"prefix": "FlareLayer.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"FlareLayer.SendMessageUpwards": {
		"prefix": "FlareLayer.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"FlareLayer.GetInstanceID": {
		"prefix": "FlareLayer.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"FlareLayer.ToString": {
		"prefix": "FlareLayer.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"FlareLayer.Destroy": {
		"prefix": "FlareLayer.Destroy",
		"body": [
			"FlareLayer.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"FlareLayer.DestroyImmediate": {
		"prefix": "FlareLayer.DestroyImmediate",
		"body": [
			"FlareLayer.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"FlareLayer.DontDestroyOnLoad": {
		"prefix": "FlareLayer.DontDestroyOnLoad",
		"body": [
			"FlareLayer.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"FlareLayer.FindObjectOfType": {
		"prefix": "FlareLayer.FindObjectOfType",
		"body": [
			"FlareLayer.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"FlareLayer.FindObjectsOfType": {
		"prefix": "FlareLayer.FindObjectsOfType",
		"body": [
			"FlareLayer.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"FlareLayer.Instantiate": {
		"prefix": "FlareLayer.Instantiate",
		"body": [
			"FlareLayer.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"Font.ascent": {
		"prefix": "Font.ascent",
		"body": [
			"ascent"
		],
		"description": "return:int des: The ascent of the font."
	}
,
	"Font.characterInfo": {
		"prefix": "Font.characterInfo",
		"body": [
			"characterInfo"
		],
		"description": "return:[] des: Access an array of all characters contained in the font texture."
	}
,
	"Font.dynamic": {
		"prefix": "Font.dynamic",
		"body": [
			"dynamic"
		],
		"description": "return:bool des: Is the font a dynamic font."
	}
,
	"Font.fontSize": {
		"prefix": "Font.fontSize",
		"body": [
			"fontSize"
		],
		"description": "return:int des: The default size of the font."
	}
,
	"Font.lineHeight": {
		"prefix": "Font.lineHeight",
		"body": [
			"lineHeight"
		],
		"description": "return:int des: The line height of the font."
	}
,
	"Font.material": {
		"prefix": "Font.material",
		"body": [
			"material"
		],
		"description": "return:Material des: The material used for the font display."
	}
,
	"Font.GetCharacterInfo": {
		"prefix": "Font.GetCharacterInfo",
		"body": [
			"GetCharacterInfo($1)"
		],
		"description": "public bool GetCharacterInfo(char ch, out characterInfo info, int size = 0, FontStyle style = FontStyle.Normal); des: Get rendering info for a specific character."
	}
,
	"Font.HasCharacter": {
		"prefix": "Font.HasCharacter",
		"body": [
			"HasCharacter($1)"
		],
		"description": "public bool HasCharacter(char c); des: Does this font have a specific character?"
	}
,
	"Font.RequestCharactersInTexture": {
		"prefix": "Font.RequestCharactersInTexture",
		"body": [
			"RequestCharactersInTexture($1)"
		],
		"description": "public void RequestCharactersInTexture(string characters, int size = 0, FontStyle style = FontStyle.Normal); des: Request characters to be added to the font texture (dynamic fonts only)."
	}
,
	"Font.CreateDynamicFontFromOSFont": {
		"prefix": "Font.CreateDynamicFontFromOSFont",
		"body": [
			"Font.CreateDynamicFontFromOSFont"
		],
		"description": "public static Font CreateDynamicFontFromOSFont(string fontname, int size); public static Font CreateDynamicFontFromOSFont(string[] fontnames, int size); des: Creates a Font object which lets you render a font installed on the user machine."
	}
,
	"Font.GetMaxVertsForString": {
		"prefix": "Font.GetMaxVertsForString",
		"body": [
			"Font.GetMaxVertsForString"
		],
		"description": "public static int GetMaxVertsForString(string str); des: Returns the maximum number of verts that the text generator may return for a given string."
	}
,
	"Font.GetOSInstalledFontNames": {
		"prefix": "Font.GetOSInstalledFontNames",
		"body": [
			"Font.GetOSInstalledFontNames"
		],
		"description": "public static string[] GetOSInstalledFontNames(); des: Get names of fonts installed on the machine."
	}
,
	"Font.hideFlags": {
		"prefix": "Font.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Font.name": {
		"prefix": "Font.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Font.GetInstanceID": {
		"prefix": "Font.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Font.ToString": {
		"prefix": "Font.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Font.Destroy": {
		"prefix": "Font.Destroy",
		"body": [
			"Font.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Font.DestroyImmediate": {
		"prefix": "Font.DestroyImmediate",
		"body": [
			"Font.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Font.DontDestroyOnLoad": {
		"prefix": "Font.DontDestroyOnLoad",
		"body": [
			"Font.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Font.FindObjectOfType": {
		"prefix": "Font.FindObjectOfType",
		"body": [
			"Font.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Font.FindObjectsOfType": {
		"prefix": "Font.FindObjectsOfType",
		"body": [
			"Font.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Font.Instantiate": {
		"prefix": "Font.Instantiate",
		"body": [
			"Font.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"FrameTiming.cpuFrameTime": {
		"prefix": "FrameTiming.cpuFrameTime",
		"body": [
			"cpuFrameTime"
		],
		"description": "return:double des: The CPU time for a given frame, in ms."
	}
,
	"FrameTiming.cpuTimeFrameComplete": {
		"prefix": "FrameTiming.cpuTimeFrameComplete",
		"body": [
			"cpuTimeFrameComplete"
		],
		"description": "return:ulong des: This is the CPU clock time at the point GPU finished rendering the frame and interrupted the CPU."
	}
,
	"FrameTiming.cpuTimePresentCalled": {
		"prefix": "FrameTiming.cpuTimePresentCalled",
		"body": [
			"cpuTimePresentCalled"
		],
		"description": "return:ulong des: This is the CPU clock time at the point Present was called for the current frame."
	}
,
	"FrameTiming.gpuFrameTime": {
		"prefix": "FrameTiming.gpuFrameTime",
		"body": [
			"gpuFrameTime"
		],
		"description": "return:double des: The GPU time for a given frame, in ms."
	}
,
	"FrameTiming.heightScale": {
		"prefix": "FrameTiming.heightScale",
		"body": [
			"heightScale"
		],
		"description": "return:float des: This was the height scale factor of the Dynamic Resolution system(if used) for the given frame and the linked frame timings."
	}
,
	"FrameTiming.syncInterval": {
		"prefix": "FrameTiming.syncInterval",
		"body": [
			"syncInterval"
		],
		"description": "return:uint des: This was the vsync mode for the given frame and the linked frame timings."
	}
,
	"FrameTiming.widthScale": {
		"prefix": "FrameTiming.widthScale",
		"body": [
			"widthScale"
		],
		"description": "return:float des: This was the width scale factor of the Dynamic Resolution system(if used) for the given frame and the linked frame timings."
	}
,
	"FrameTimingManager.CaptureFrameTimings": {
		"prefix": "FrameTimingManager.CaptureFrameTimings",
		"body": [
			"FrameTimingManager.CaptureFrameTimings"
		],
		"description": "public static void CaptureFrameTimings(); des: This function triggers the FrameTimingManager to capture a snapshot of FrameTiming's data, that can then be accessed by the user."
	}
,
	"FrameTimingManager.GetCpuTimerFrequency": {
		"prefix": "FrameTimingManager.GetCpuTimerFrequency",
		"body": [
			"FrameTimingManager.GetCpuTimerFrequency"
		],
		"description": "public static ulong GetCpuTimerFrequency(); des: This returns the frequency of CPU timer on the current platform, used to interpret timing results. If the platform does not support returning this value it will return 0."
	}
,
	"FrameTimingManager.GetGpuTimerFrequency": {
		"prefix": "FrameTimingManager.GetGpuTimerFrequency",
		"body": [
			"FrameTimingManager.GetGpuTimerFrequency"
		],
		"description": "public static ulong GetGpuTimerFrequency(); des: This returns the frequency of GPU timer on the current platform, used to interpret timing results. If the platform does not support returning this value it will return 0."
	}
,
	"FrameTimingManager.GetLatestTimings": {
		"prefix": "FrameTimingManager.GetLatestTimings",
		"body": [
			"FrameTimingManager.GetLatestTimings"
		],
		"description": "public static uint GetLatestTimings(uint numFrames, FrameTiming[] timings); des: Allows the user to access the currently captured FrameTimings."
	}
,
	"FrameTimingManager.GetVSyncsPerSecond": {
		"prefix": "FrameTimingManager.GetVSyncsPerSecond",
		"body": [
			"FrameTimingManager.GetVSyncsPerSecond"
		],
		"description": "public static float GetVSyncsPerSecond(); des: This returns the number of vsyncs per second on the current platform, used to interpret timing results. If the platform does not support returning this value it will return 0."
	}
,
	"FrictionJoint2D.maxForce": {
		"prefix": "FrictionJoint2D.maxForce",
		"body": [
			"maxForce"
		],
		"description": "return:float des: The maximum force that can be generated when trying to maintain the friction joint constraint."
	}
,
	"FrictionJoint2D.maxTorque": {
		"prefix": "FrictionJoint2D.maxTorque",
		"body": [
			"maxTorque"
		],
		"description": "return:float des: The maximum torque that can be generated when trying to maintain the friction joint constraint."
	}
,
	"FrictionJoint2D.anchor": {
		"prefix": "FrictionJoint2D.anchor",
		"body": [
			"anchor"
		],
		"description": "return:Vector2 des: The joint's anchor point on the object that has the joint component."
	}
,
	"FrictionJoint2D.autoConfigureConnectedAnchor": {
		"prefix": "FrictionJoint2D.autoConfigureConnectedAnchor",
		"body": [
			"autoConfigureConnectedAnchor"
		],
		"description": "return:bool des: Should the connectedAnchor be calculated automatically?"
	}
,
	"FrictionJoint2D.connectedAnchor": {
		"prefix": "FrictionJoint2D.connectedAnchor",
		"body": [
			"connectedAnchor"
		],
		"description": "return:Vector2 des: The joint's anchor point on the second object (ie, the one which doesn't have the joint component)."
	}
,
	"FrictionJoint2D.enabled": {
		"prefix": "FrictionJoint2D.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"FrictionJoint2D.isActiveAndEnabled": {
		"prefix": "FrictionJoint2D.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"FrictionJoint2D.gameObject": {
		"prefix": "FrictionJoint2D.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"FrictionJoint2D.tag": {
		"prefix": "FrictionJoint2D.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"FrictionJoint2D.transform": {
		"prefix": "FrictionJoint2D.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"FrictionJoint2D.attachedRigidbody": {
		"prefix": "FrictionJoint2D.attachedRigidbody",
		"body": [
			"attachedRigidbody"
		],
		"description": "return:Rigidbody2D des: The Rigidbody2D attached to the Joint2D."
	}
,
	"FrictionJoint2D.breakForce": {
		"prefix": "FrictionJoint2D.breakForce",
		"body": [
			"breakForce"
		],
		"description": "return:float des: The force that needs to be applied for this joint to break."
	}
,
	"FrictionJoint2D.breakTorque": {
		"prefix": "FrictionJoint2D.breakTorque",
		"body": [
			"breakTorque"
		],
		"description": "return:float des: The torque that needs to be applied for this joint to break."
	}
,
	"FrictionJoint2D.connectedBody": {
		"prefix": "FrictionJoint2D.connectedBody",
		"body": [
			"connectedBody"
		],
		"description": "return:Rigidbody2D des: The Rigidbody2D object to which the other end of the joint is attached (ie, the object without the joint component)."
	}
,
	"FrictionJoint2D.enableCollision": {
		"prefix": "FrictionJoint2D.enableCollision",
		"body": [
			"enableCollision"
		],
		"description": "return:bool des: Should the two rigid bodies connected with this joint collide with each other?"
	}
,
	"FrictionJoint2D.reactionForce": {
		"prefix": "FrictionJoint2D.reactionForce",
		"body": [
			"reactionForce"
		],
		"description": "return:Vector2 des: Gets the reaction force of the joint."
	}
,
	"FrictionJoint2D.reactionTorque": {
		"prefix": "FrictionJoint2D.reactionTorque",
		"body": [
			"reactionTorque"
		],
		"description": "return:float des: Gets the reaction torque of the joint."
	}
,
	"FrictionJoint2D.hideFlags": {
		"prefix": "FrictionJoint2D.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"FrictionJoint2D.name": {
		"prefix": "FrictionJoint2D.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"FrictionJoint2D.BroadcastMessage": {
		"prefix": "FrictionJoint2D.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"FrictionJoint2D.CompareTag": {
		"prefix": "FrictionJoint2D.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"FrictionJoint2D.GetComponent": {
		"prefix": "FrictionJoint2D.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"FrictionJoint2D.GetComponentInChildren": {
		"prefix": "FrictionJoint2D.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"FrictionJoint2D.GetComponentInParent": {
		"prefix": "FrictionJoint2D.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"FrictionJoint2D.GetComponents": {
		"prefix": "FrictionJoint2D.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"FrictionJoint2D.GetComponentsInChildren": {
		"prefix": "FrictionJoint2D.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"FrictionJoint2D.GetComponentsInParent": {
		"prefix": "FrictionJoint2D.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"FrictionJoint2D.SendMessage": {
		"prefix": "FrictionJoint2D.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"FrictionJoint2D.SendMessageUpwards": {
		"prefix": "FrictionJoint2D.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"FrictionJoint2D.GetReactionForce": {
		"prefix": "FrictionJoint2D.GetReactionForce",
		"body": [
			"GetReactionForce($1)"
		],
		"description": "public Vector2 GetReactionForce(float timeStep); des: Gets the reaction force of the joint given the specified timeStep."
	}
,
	"FrictionJoint2D.GetReactionTorque": {
		"prefix": "FrictionJoint2D.GetReactionTorque",
		"body": [
			"GetReactionTorque($1)"
		],
		"description": "public float GetReactionTorque(float timeStep); des: Gets the reaction torque of the joint given the specified timeStep."
	}
,
	"FrictionJoint2D.GetInstanceID": {
		"prefix": "FrictionJoint2D.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"FrictionJoint2D.ToString": {
		"prefix": "FrictionJoint2D.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"FrictionJoint2D.Destroy": {
		"prefix": "FrictionJoint2D.Destroy",
		"body": [
			"FrictionJoint2D.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"FrictionJoint2D.DestroyImmediate": {
		"prefix": "FrictionJoint2D.DestroyImmediate",
		"body": [
			"FrictionJoint2D.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"FrictionJoint2D.DontDestroyOnLoad": {
		"prefix": "FrictionJoint2D.DontDestroyOnLoad",
		"body": [
			"FrictionJoint2D.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"FrictionJoint2D.FindObjectOfType": {
		"prefix": "FrictionJoint2D.FindObjectOfType",
		"body": [
			"FrictionJoint2D.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"FrictionJoint2D.FindObjectsOfType": {
		"prefix": "FrictionJoint2D.FindObjectsOfType",
		"body": [
			"FrictionJoint2D.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"FrictionJoint2D.Instantiate": {
		"prefix": "FrictionJoint2D.Instantiate",
		"body": [
			"FrictionJoint2D.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"FrictionJoint2D.OnJointBreak2D": {
		"prefix": "FrictionJoint2D.OnJointBreak2D",
		"body": [
			"OnJointBreak2D"
		],
		"description": "Called when a Joint2D attached to the same game object breaks."
	}
,
	"FrustumPlanes.bottom": {
		"prefix": "FrustumPlanes.bottom",
		"body": [
			"bottom"
		],
		"description": "return:float des: Position in view space of the bottom side of the near projection plane."
	}
,
	"FrustumPlanes.left": {
		"prefix": "FrustumPlanes.left",
		"body": [
			"left"
		],
		"description": "return:float des: Position in view space of the left side of the near projection plane."
	}
,
	"FrustumPlanes.right": {
		"prefix": "FrustumPlanes.right",
		"body": [
			"right"
		],
		"description": "return:float des: Position in view space of the right side of the near projection plane."
	}
,
	"FrustumPlanes.top": {
		"prefix": "FrustumPlanes.top",
		"body": [
			"top"
		],
		"description": "return:float des: Position in view space of the top side of the near projection plane."
	}
,
	"FrustumPlanes.zFar": {
		"prefix": "FrustumPlanes.zFar",
		"body": [
			"zFar"
		],
		"description": "return:float des: Z distance from the origin of view space to the far projection plane."
	}
,
	"FrustumPlanes.zNear": {
		"prefix": "FrustumPlanes.zNear",
		"body": [
			"zNear"
		],
		"description": "return:float des: Z distance from the origin of view space to the near projection plane."
	}
,
	"GameObject.activeInHierarchy": {
		"prefix": "GameObject.activeInHierarchy",
		"body": [
			"activeInHierarchy"
		],
		"description": "return:bool des: Defines whether the GameObject is active in the Scene."
	}
,
	"GameObject.activeSelf": {
		"prefix": "GameObject.activeSelf",
		"body": [
			"activeSelf"
		],
		"description": "return:bool des: The local active state of this GameObject. (Read Only)"
	}
,
	"GameObject.isStatic": {
		"prefix": "GameObject.isStatic",
		"body": [
			"isStatic"
		],
		"description": "return:bool des: Editor only API that specifies if a game object is static."
	}
,
	"GameObject.layer": {
		"prefix": "GameObject.layer",
		"body": [
			"layer"
		],
		"description": "return:int des: The layer the game object is in."
	}
,
	"GameObject.scene": {
		"prefix": "GameObject.scene",
		"body": [
			"scene"
		],
		"description": "return:SceneManagement.Scene des: Scene that the GameObject is part of."
	}
,
	"GameObject.tag": {
		"prefix": "GameObject.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"GameObject.transform": {
		"prefix": "GameObject.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"GameObject.AddComponent": {
		"prefix": "GameObject.AddComponent",
		"body": [
			"AddComponent($1)"
		],
		"description": "Obsolete public Component AddComponent(string className); public Component AddComponent(Type componentType); public T AddComponent(); des: Adds a component class named className to the game object."
	}
,
	"GameObject.BroadcastMessage": {
		"prefix": "GameObject.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"GameObject.CompareTag": {
		"prefix": "GameObject.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"GameObject.GetComponent": {
		"prefix": "GameObject.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"GameObject.GetComponentInChildren": {
		"prefix": "GameObject.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type type); public Component GetComponentInChildren(Type type, bool includeInactive); public T GetComponentInChildren(bool includeInactive = false); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"GameObject.GetComponentInParent": {
		"prefix": "GameObject.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type type); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"GameObject.GetComponents": {
		"prefix": "GameObject.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); public void GetComponents(Type type, List<Component> results); public void GetComponents(List<T> results); des: Returns all components of Type type in the GameObject."
	}
,
	"GameObject.GetComponentsInChildren": {
		"prefix": "GameObject.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type type, bool includeInactive = false); public T[] GetComponentsInChildren(); public T[] GetComponentsInChildren(bool includeInactive); public void GetComponentsInChildren(List<T> results); public void GetComponentsInChildren(bool includeInactive, List<T> results); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"GameObject.GetComponentsInParent": {
		"prefix": "GameObject.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type type, bool includeInactive = false); public T[] GetComponentsInParent(); public T[] GetComponentsInParent(bool includeInactive); public void GetComponentsInParent(bool includeInactive, List<T> results); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"GameObject.SendMessage": {
		"prefix": "GameObject.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"GameObject.SendMessageUpwards": {
		"prefix": "GameObject.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"GameObject.SetActive": {
		"prefix": "GameObject.SetActive",
		"body": [
			"SetActive($1)"
		],
		"description": "public void SetActive(bool value); des: Activates/Deactivates the GameObject."
	}
,
	"GameObject.CreatePrimitive": {
		"prefix": "GameObject.CreatePrimitive",
		"body": [
			"GameObject.CreatePrimitive"
		],
		"description": "public static GameObject CreatePrimitive(PrimitiveType type); des: Creates a game object with a primitive mesh renderer and appropriate collider."
	}
,
	"GameObject.Find": {
		"prefix": "GameObject.Find",
		"body": [
			"GameObject.Find"
		],
		"description": "public static GameObject Find(string name); des: Finds a GameObject by name and returns it."
	}
,
	"GameObject.FindGameObjectsWithTag": {
		"prefix": "GameObject.FindGameObjectsWithTag",
		"body": [
			"GameObject.FindGameObjectsWithTag"
		],
		"description": "public static GameObject[] FindGameObjectsWithTag(string tag); des: Returns a list of active GameObjects tagged tag. Returns empty array if no GameObject was found."
	}
,
	"GameObject.FindWithTag": {
		"prefix": "GameObject.FindWithTag",
		"body": [
			"GameObject.FindWithTag"
		],
		"description": "public static GameObject FindWithTag(string tag); des: Returns one active GameObject tagged tag. Returns null if no GameObject was found."
	}
,
	"GameObject.hideFlags": {
		"prefix": "GameObject.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"GameObject.name": {
		"prefix": "GameObject.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"GameObject.GetInstanceID": {
		"prefix": "GameObject.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"GameObject.ToString": {
		"prefix": "GameObject.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"GameObject.Destroy": {
		"prefix": "GameObject.Destroy",
		"body": [
			"GameObject.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"GameObject.DestroyImmediate": {
		"prefix": "GameObject.DestroyImmediate",
		"body": [
			"GameObject.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"GameObject.DontDestroyOnLoad": {
		"prefix": "GameObject.DontDestroyOnLoad",
		"body": [
			"GameObject.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"GameObject.FindObjectOfType": {
		"prefix": "GameObject.FindObjectOfType",
		"body": [
			"GameObject.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"GameObject.FindObjectsOfType": {
		"prefix": "GameObject.FindObjectsOfType",
		"body": [
			"GameObject.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"GameObject.Instantiate": {
		"prefix": "GameObject.Instantiate",
		"body": [
			"GameObject.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"GeometryUtility.CalculateBounds": {
		"prefix": "GeometryUtility.CalculateBounds",
		"body": [
			"GeometryUtility.CalculateBounds"
		],
		"description": "public static Bounds CalculateBounds(Vector3[] positions, Matrix4x4 transform); des: Calculates a bounding box given an array of positions and a transformation matrix."
	}
,
	"GeometryUtility.CalculateFrustumPlanes": {
		"prefix": "GeometryUtility.CalculateFrustumPlanes",
		"body": [
			"GeometryUtility.CalculateFrustumPlanes"
		],
		"description": "public static Plane[] CalculateFrustumPlanes(Camera camera); public static void CalculateFrustumPlanes(Camera camera, Plane[] planes); public static Plane[] CalculateFrustumPlanes(Matrix4x4 worldToProjectionMatrix); public static void CalculateFrustumPlanes(Matrix4x4 worldToProjectionMatrix, Plane[] planes); des: Calculates frustum planes."
	}
,
	"GeometryUtility.TestPlanesAABB": {
		"prefix": "GeometryUtility.TestPlanesAABB",
		"body": [
			"GeometryUtility.TestPlanesAABB"
		],
		"description": "public static bool TestPlanesAABB(Plane[] planes, Bounds bounds); des: Returns true if bounds are inside the plane array."
	}
,
	"GeometryUtility.TryCreatePlaneFromPolygon": {
		"prefix": "GeometryUtility.TryCreatePlaneFromPolygon",
		"body": [
			"GeometryUtility.TryCreatePlaneFromPolygon"
		],
		"description": "public static bool TryCreatePlaneFromPolygon(Vector3[] vertices, out Plane plane); des: Creates a plane from a given list of vertices. Works for concave polygons and polygons that have multiple aligned vertices."
	}
,
	"Gizmos.DrawCube": {
		"prefix": "Gizmos.DrawCube",
		"body": [
			"Gizmos.DrawCube"
		],
		"description": "public static void DrawCube(Vector3 center, Vector3 size); des: Draw a solid box with center and size."
	}
,
	"Gizmos.DrawFrustum": {
		"prefix": "Gizmos.DrawFrustum",
		"body": [
			"Gizmos.DrawFrustum"
		],
		"description": "public static void DrawFrustum(Vector3 center, float fov, float maxRange, float minRange, float aspect); des: Draw a camera frustum using the currently set Gizmos.matrix for it's location and rotation."
	}
,
	"Gizmos.DrawGUITexture": {
		"prefix": "Gizmos.DrawGUITexture",
		"body": [
			"Gizmos.DrawGUITexture"
		],
		"description": "public static void DrawGUITexture(Rect screenRect, Texture texture, Material mat = null); public static void DrawGUITexture(Rect screenRect, Texture texture, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Material mat = null); des: Draw a texture in the Scene."
	}
,
	"Gizmos.DrawIcon": {
		"prefix": "Gizmos.DrawIcon",
		"body": [
			"Gizmos.DrawIcon"
		],
		"description": "public static void DrawIcon(Vector3 center, string name, bool allowScaling = true); des: Draw an icon at a position in the Scene view."
	}
,
	"Gizmos.DrawLine": {
		"prefix": "Gizmos.DrawLine",
		"body": [
			"Gizmos.DrawLine"
		],
		"description": "public static void DrawLine(Vector3 from, Vector3 to); des: Draws a line starting at from towards to."
	}
,
	"Gizmos.DrawMesh": {
		"prefix": "Gizmos.DrawMesh",
		"body": [
			"Gizmos.DrawMesh"
		],
		"description": "public static void DrawMesh(Mesh mesh, Vector3 position = Vector3.zero, Quaternion rotation = Quaternion.identity, Vector3 scale = Vector3.one); public static void DrawMesh(Mesh mesh, int submeshIndex, Vector3 position = Vector3.zero, Quaternion rotation = Quaternion.identity, Vector3 scale = Vector3.one); des: Draws a mesh."
	}
,
	"Gizmos.DrawRay": {
		"prefix": "Gizmos.DrawRay",
		"body": [
			"Gizmos.DrawRay"
		],
		"description": "public static void DrawRay(Ray r); public static void DrawRay(Vector3 from, Vector3 direction); des: Draws a ray starting at from to from + direction."
	}
,
	"Gizmos.DrawSphere": {
		"prefix": "Gizmos.DrawSphere",
		"body": [
			"Gizmos.DrawSphere"
		],
		"description": "public static void DrawSphere(Vector3 center, float radius); des: Draws a solid sphere with center and radius."
	}
,
	"Gizmos.DrawWireCube": {
		"prefix": "Gizmos.DrawWireCube",
		"body": [
			"Gizmos.DrawWireCube"
		],
		"description": "public static void DrawWireCube(Vector3 center, Vector3 size); des: Draw a wireframe box with center and size."
	}
,
	"Gizmos.DrawWireMesh": {
		"prefix": "Gizmos.DrawWireMesh",
		"body": [
			"Gizmos.DrawWireMesh"
		],
		"description": "public static void DrawWireMesh(Mesh mesh, Vector3 position = Vector3.zero, Quaternion rotation = Quaternion.identity, Vector3 scale = Vector3.one); public static void DrawWireMesh(Mesh mesh, int submeshIndex, Vector3 position = Vector3.zero, Quaternion rotation = Quaternion.identity, Vector3 scale = Vector3.one); des: Draws a wireframe mesh."
	}
,
	"Gizmos.DrawWireSphere": {
		"prefix": "Gizmos.DrawWireSphere",
		"body": [
			"Gizmos.DrawWireSphere"
		],
		"description": "public static void DrawWireSphere(Vector3 center, float radius); des: Draws a wireframe sphere with center and radius."
	}
,
	"GL.Begin": {
		"prefix": "GL.Begin",
		"body": [
			"GL.Begin"
		],
		"description": "public static void Begin(int mode); des: Begin drawing 3D primitives."
	}
,
	"GL.Clear": {
		"prefix": "GL.Clear",
		"body": [
			"GL.Clear"
		],
		"description": "public static void Clear(bool clearDepth, bool clearColor, Color backgroundColor, float depth = 1.0f); des: Clear the current render buffer."
	}
,
	"GL.ClearWithSkybox": {
		"prefix": "GL.ClearWithSkybox",
		"body": [
			"GL.ClearWithSkybox"
		],
		"description": "public static void ClearWithSkybox(bool clearDepth, Camera camera); des: Clear the current render buffer with camera's skybox."
	}
,
	"GL.Color": {
		"prefix": "GL.Color",
		"body": [
			"GL.Color"
		],
		"description": "public static void Color(Color c); des: Sets current vertex color."
	}
,
	"GL.End": {
		"prefix": "GL.End",
		"body": [
			"GL.End"
		],
		"description": "public static void End(); des: End drawing 3D primitives."
	}
,
	"GL.Flush": {
		"prefix": "GL.Flush",
		"body": [
			"GL.Flush"
		],
		"description": "public static void Flush(); des: Sends queued-up commands in the driver's command buffer to the GPU."
	}
,
	"GL.GetGPUProjectionMatrix": {
		"prefix": "GL.GetGPUProjectionMatrix",
		"body": [
			"GL.GetGPUProjectionMatrix"
		],
		"description": "public static Matrix4x4 GetGPUProjectionMatrix(Matrix4x4 proj, bool renderIntoTexture); des: Compute GPU projection matrix from camera's projection matrix."
	}
,
	"GL.InvalidateState": {
		"prefix": "GL.InvalidateState",
		"body": [
			"GL.InvalidateState"
		],
		"description": "public static void InvalidateState(); des: Invalidate the internally cached render state."
	}
,
	"GL.IssuePluginEvent": {
		"prefix": "GL.IssuePluginEvent",
		"body": [
			"GL.IssuePluginEvent"
		],
		"description": "Obsolete public static void IssuePluginEvent(int eventID); public static void IssuePluginEvent(IntPtr callback, int eventID); des: Send a user-defined event to a native code plugin."
	}
,
	"GL.LoadIdentity": {
		"prefix": "GL.LoadIdentity",
		"body": [
			"GL.LoadIdentity"
		],
		"description": "public static void LoadIdentity(); des: Load the identity matrix to the current modelview matrix."
	}
,
	"GL.LoadOrtho": {
		"prefix": "GL.LoadOrtho",
		"body": [
			"GL.LoadOrtho"
		],
		"description": "public static void LoadOrtho(); des: Helper function to set up an ortho perspective transform."
	}
,
	"GL.LoadPixelMatrix": {
		"prefix": "GL.LoadPixelMatrix",
		"body": [
			"GL.LoadPixelMatrix"
		],
		"description": "public static void LoadPixelMatrix(); public static void LoadPixelMatrix(float left, float right, float bottom, float top); des: Setup a matrix for pixel-correct rendering."
	}
,
	"GL.LoadProjectionMatrix": {
		"prefix": "GL.LoadProjectionMatrix",
		"body": [
			"GL.LoadProjectionMatrix"
		],
		"description": "public static void LoadProjectionMatrix(Matrix4x4 mat); des: Load an arbitrary matrix to the current projection matrix."
	}
,
	"GL.MultiTexCoord": {
		"prefix": "GL.MultiTexCoord",
		"body": [
			"GL.MultiTexCoord"
		],
		"description": "public static void MultiTexCoord(int unit, Vector3 v); des: Sets current texture coordinate (v.x,v.y,v.z) to the actual texture unit."
	}
,
	"GL.MultiTexCoord2": {
		"prefix": "GL.MultiTexCoord2",
		"body": [
			"GL.MultiTexCoord2"
		],
		"description": "public static void MultiTexCoord2(int unit, float x, float y); des: Sets current texture coordinate (x,y) for the actual texture unit."
	}
,
	"GL.MultiTexCoord3": {
		"prefix": "GL.MultiTexCoord3",
		"body": [
			"GL.MultiTexCoord3"
		],
		"description": "public static void MultiTexCoord3(int unit, float x, float y, float z); des: Sets current texture coordinate (x,y,z) to the actual texture unit."
	}
,
	"GL.MultMatrix": {
		"prefix": "GL.MultMatrix",
		"body": [
			"GL.MultMatrix"
		],
		"description": "public static void MultMatrix(Matrix4x4 m); des: Sets the current modelview matrix to the one specified."
	}
,
	"GL.PopMatrix": {
		"prefix": "GL.PopMatrix",
		"body": [
			"GL.PopMatrix"
		],
		"description": "public static void PopMatrix(); des: Restores both projection and modelview matrices off the top of the matrix stack."
	}
,
	"GL.PushMatrix": {
		"prefix": "GL.PushMatrix",
		"body": [
			"GL.PushMatrix"
		],
		"description": "public static void PushMatrix(); des: Saves both projection and modelview matrices to the matrix stack."
	}
,
	"GL.RenderTargetBarrier": {
		"prefix": "GL.RenderTargetBarrier",
		"body": [
			"GL.RenderTargetBarrier"
		],
		"description": "public static void RenderTargetBarrier(); des: Resolves the render target for subsequent operations sampling from it."
	}
,
	"GL.TexCoord": {
		"prefix": "GL.TexCoord",
		"body": [
			"GL.TexCoord"
		],
		"description": "public static void TexCoord(Vector3 v); des: Sets current texture coordinate (v.x,v.y,v.z) for all texture units."
	}
,
	"GL.TexCoord2": {
		"prefix": "GL.TexCoord2",
		"body": [
			"GL.TexCoord2"
		],
		"description": "public static void TexCoord2(float x, float y); des: Sets current texture coordinate (x,y) for all texture units."
	}
,
	"GL.TexCoord3": {
		"prefix": "GL.TexCoord3",
		"body": [
			"GL.TexCoord3"
		],
		"description": "public static void TexCoord3(float x, float y, float z); des: Sets current texture coordinate (x,y,z) for all texture units."
	}
,
	"GL.Vertex": {
		"prefix": "GL.Vertex",
		"body": [
			"GL.Vertex"
		],
		"description": "public static void Vertex(Vector3 v); des: Submit a vertex."
	}
,
	"GL.Vertex3": {
		"prefix": "GL.Vertex3",
		"body": [
			"GL.Vertex3"
		],
		"description": "public static void Vertex3(float x, float y, float z); des: Submit a vertex."
	}
,
	"GL.Viewport": {
		"prefix": "GL.Viewport",
		"body": [
			"GL.Viewport"
		],
		"description": "public static void Viewport(Rect pixelRect); des: Set the rendering viewport."
	}
,
	"Gradient.alphaKeys": {
		"prefix": "Gradient.alphaKeys",
		"body": [
			"alphaKeys"
		],
		"description": "return:GradientAlphaKey[] des: All alpha keys defined in the gradient."
	}
,
	"Gradient.colorKeys": {
		"prefix": "Gradient.colorKeys",
		"body": [
			"colorKeys"
		],
		"description": "return:GradientColorKey[] des: All color keys defined in the gradient."
	}
,
	"Gradient.mode": {
		"prefix": "Gradient.mode",
		"body": [
			"mode"
		],
		"description": "return:GradientMode des: Control how the gradient is evaluated."
	}
,
	"Gradient.Evaluate": {
		"prefix": "Gradient.Evaluate",
		"body": [
			"Evaluate($1)"
		],
		"description": "public Color Evaluate(float time); des: Calculate color at a given time."
	}
,
	"Gradient.SetKeys": {
		"prefix": "Gradient.SetKeys",
		"body": [
			"SetKeys($1)"
		],
		"description": "public void SetKeys(GradientColorKey[] colorKeys, GradientAlphaKey[] alphaKeys); des: Setup Gradient with an array of color keys and alpha keys."
	}
,
	"GradientAlphaKey.alpha": {
		"prefix": "GradientAlphaKey.alpha",
		"body": [
			"alpha"
		],
		"description": "return:float des: Alpha channel of key."
	}
,
	"GradientAlphaKey.time": {
		"prefix": "GradientAlphaKey.time",
		"body": [
			"time"
		],
		"description": "return:float des: Time of the key (0 - 1)."
	}
,
	"GradientColorKey.color": {
		"prefix": "GradientColorKey.color",
		"body": [
			"color"
		],
		"description": "return:Color des: Color of key."
	}
,
	"GradientColorKey.time": {
		"prefix": "GradientColorKey.time",
		"body": [
			"time"
		],
		"description": "return:float des: Time of the key (0 - 1)."
	}
,
	"Graphics.Blit": {
		"prefix": "Graphics.Blit",
		"body": [
			"Graphics.Blit"
		],
		"description": "public static void Blit(Texture source, RenderTexture dest); public static void Blit(Texture source, RenderTexture dest, Material mat, int pass = -1); public static void Blit(Texture source, Material mat, int pass = -1); public static void Blit(Texture source, RenderTexture dest, Vector2 scale, Vector2 offset); des: Copies source texture into destination render texture with a shader."
	}
,
	"Graphics.BlitMultiTap": {
		"prefix": "Graphics.BlitMultiTap",
		"body": [
			"Graphics.BlitMultiTap"
		],
		"description": "public static void BlitMultiTap(Texture source, RenderTexture dest, Material mat, params Vector2[] offsets); des: Copies source texture into destination, for multi-tap shader."
	}
,
	"Graphics.ClearRandomWriteTargets": {
		"prefix": "Graphics.ClearRandomWriteTargets",
		"body": [
			"Graphics.ClearRandomWriteTargets"
		],
		"description": "public static void ClearRandomWriteTargets(); des: Clear random write targets for Shader Model 4.5 level pixel shaders."
	}
,
	"Graphics.ConvertTexture": {
		"prefix": "Graphics.ConvertTexture",
		"body": [
			"Graphics.ConvertTexture"
		],
		"description": "public static bool ConvertTexture(Texture src, Texture dst); public static bool ConvertTexture(Texture src, int srcElement, Texture dst, int dstElement); des: This function provides an efficient way to convert between textures of different formats and dimensions. The destination texture format should be uncompressed and correspond to a supported RenderTextureFormat."
	}
,
	"Graphics.CopyTexture": {
		"prefix": "Graphics.CopyTexture",
		"body": [
			"Graphics.CopyTexture"
		],
		"description": "public static void CopyTexture(Texture src, Texture dst); public static void CopyTexture(Texture src, int srcElement, int srcMip, Texture dst, int dstElement, int dstMip); public static void CopyTexture(Texture src, int srcElement, int srcMip, int srcX, int srcY, int srcWidth, int srcHeight, Texture dst, int dstElement, int dstMip, int dstX, int dstY); des: Copy texture contents."
	}
,
	"Graphics.CreateGPUFence": {
		"prefix": "Graphics.CreateGPUFence",
		"body": [
			"Graphics.CreateGPUFence"
		],
		"description": "public static Rendering.GPUFence CreateGPUFence(Rendering.SynchronisationStage stage = SynchronisationStage.PixelProcessing); des: Creates a GPUFence which will be passed after the last Blit, Clear, Draw, Dispatch or Texture Copy command prior to this call has been completed on the GPU."
	}
,
	"Graphics.DrawMesh": {
		"prefix": "Graphics.DrawMesh",
		"body": [
			"Graphics.DrawMesh"
		],
		"description": "public static void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera = null, int submeshIndex = 0, MaterialPropertyBlock properties = null, bool castShadows = true, bool receiveShadows = true, bool useLightProbes = true); public static void DrawMesh(Mesh mesh, Vector3 position, Quaternion rotation, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, Rendering.ShadowCastingMode castShadows, bool receiveShadows = true, Transform probeAnchor = null, bool useLightProbes = true); public static void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera = null, int submeshIndex = 0, MaterialPropertyBlock properties = null, bool castShadows = true, bool receiveShadows = true, bool useLightProbes = true); public static void DrawMesh(Mesh mesh, Matrix4x4 matrix, Material material, int layer, Camera camera, int submeshIndex, MaterialPropertyBlock properties, Rendering.ShadowCastingMode castShadows, bool receiveShadows = true, Transform probeAnchor = null, bool useLightProbes = true); des: Draw a mesh."
	}
,
	"Graphics.DrawMeshInstanced": {
		"prefix": "Graphics.DrawMeshInstanced",
		"body": [
			"Graphics.DrawMeshInstanced"
		],
		"description": "public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, Matrix4x4[] matrices, int count = matrices.Length, MaterialPropertyBlock properties = null, Rendering.ShadowCastingMode castShadows = ShadowCastingMode.On, bool receiveShadows = true, int layer = 0, Camera camera = null, Rendering.LightProbeUsage lightProbeUsage = LightProbeUsage.BlendProbes, LightProbeProxyVolume lightProbeProxyVolume = null); public static void DrawMeshInstanced(Mesh mesh, int submeshIndex, Material material, List<Matrix4x4> matrices, MaterialPropertyBlock properties = null, Rendering.ShadowCastingMode castShadows = ShadowCastingMode.On, bool receiveShadows = true, int layer = 0, Camera camera = null, Rendering.LightProbeUsage lightProbeUsage = LightProbeUsage.BlendProbes, LightProbeProxyVolume lightProbeProxyVolume = null); des: Draw the same mesh multiple times using GPU instancing."
	}
,
	"Graphics.DrawMeshInstancedIndirect": {
		"prefix": "Graphics.DrawMeshInstancedIndirect",
		"body": [
			"Graphics.DrawMeshInstancedIndirect"
		],
		"description": "public static void DrawMeshInstancedIndirect(Mesh mesh, int submeshIndex, Material material, Bounds bounds, ComputeBuffer bufferWithArgs, int argsOffset = 0, MaterialPropertyBlock properties = null, Rendering.ShadowCastingMode castShadows = ShadowCastingMode.On, bool receiveShadows = true, int layer = 0, Camera camera = null, Rendering.LightProbeUsage lightProbeUsage = LightProbeUsage.BlendProbes, LightProbeProxyVolume lightProbeProxyVolume = null); des: Draw the same mesh multiple times using GPU instancing."
	}
,
	"Graphics.DrawMeshNow": {
		"prefix": "Graphics.DrawMeshNow",
		"body": [
			"Graphics.DrawMeshNow"
		],
		"description": "public static void DrawMeshNow(Mesh mesh, Vector3 position, Quaternion rotation); public static void DrawMeshNow(Mesh mesh, Vector3 position, Quaternion rotation, int materialIndex); public static void DrawMeshNow(Mesh mesh, Matrix4x4 matrix); public static void DrawMeshNow(Mesh mesh, Matrix4x4 matrix, int materialIndex); des: Draw a mesh immediately."
	}
,
	"Graphics.DrawProcedural": {
		"prefix": "Graphics.DrawProcedural",
		"body": [
			"Graphics.DrawProcedural"
		],
		"description": "public static void DrawProcedural(MeshTopology topology, int vertexCount, int instanceCount = 1); des: Draws a fully procedural geometry on the GPU."
	}
,
	"Graphics.DrawProceduralIndirect": {
		"prefix": "Graphics.DrawProceduralIndirect",
		"body": [
			"Graphics.DrawProceduralIndirect"
		],
		"description": "public static void DrawProceduralIndirect(MeshTopology topology, ComputeBuffer bufferWithArgs, int argsOffset = 0); des: Draws a fully procedural geometry on the GPU."
	}
,
	"Graphics.DrawTexture": {
		"prefix": "Graphics.DrawTexture",
		"body": [
			"Graphics.DrawTexture"
		],
		"description": "public static void DrawTexture(Rect screenRect, Texture texture, Material mat = null, int pass = -1); public static void DrawTexture(Rect screenRect, Texture texture, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Material mat = null, int pass = -1); public static void DrawTexture(Rect screenRect, Texture texture, Rect sourceRect, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Material mat = null, int pass = -1); public static void DrawTexture(Rect screenRect, Texture texture, Rect sourceRect, int leftBorder, int rightBorder, int topBorder, int bottomBorder, Color color, Material mat = null, int pass = -1); des: Draw a texture in screen coordinates."
	}
,
	"Graphics.ExecuteCommandBuffer": {
		"prefix": "Graphics.ExecuteCommandBuffer",
		"body": [
			"Graphics.ExecuteCommandBuffer"
		],
		"description": "public static void ExecuteCommandBuffer(Rendering.CommandBuffer buffer); des: Execute a command buffer."
	}
,
	"Graphics.ExecuteCommandBufferAsync": {
		"prefix": "Graphics.ExecuteCommandBufferAsync",
		"body": [
			"Graphics.ExecuteCommandBufferAsync"
		],
		"description": "public static void ExecuteCommandBufferAsync(Rendering.CommandBuffer buffer, Rendering.ComputeQueueType queueType); des: Executes a command buffer on an async compute queue with the queue selected based on the ComputeQueueType parameter passed."
	}
,
	"Graphics.SetRandomWriteTarget": {
		"prefix": "Graphics.SetRandomWriteTarget",
		"body": [
			"Graphics.SetRandomWriteTarget"
		],
		"description": "public static void SetRandomWriteTarget(int index, ComputeBuffer uav, bool preserveCounterValue = false); public static void SetRandomWriteTarget(int index, RenderTexture uav); des: Set random write target for Shader Model 4.5 level pixel shaders."
	}
,
	"Graphics.SetRenderTarget": {
		"prefix": "Graphics.SetRenderTarget",
		"body": [
			"Graphics.SetRenderTarget"
		],
		"description": "public static void SetRenderTarget(RenderTexture rt, int mipLevel = 0, CubemapFace face = CubemapFace.Unknown, int depthSlice = 0); public static void SetRenderTarget(RenderBuffer[] colorBuffers, RenderBuffer depthBuffer); public static void SetRenderTarget(RenderBuffer colorBuffer, RenderBuffer depthBuffer, int mipLevel = 0, CubemapFace face = CubemapFace.Unknown, int depthSlice = 0); public static void SetRenderTarget(RenderTargetSetup setup); des: Sets current render target."
	}
,
	"Graphics.WaitOnGPUFence": {
		"prefix": "Graphics.WaitOnGPUFence",
		"body": [
			"Graphics.WaitOnGPUFence"
		],
		"description": "public static void WaitOnGPUFence(Rendering.GPUFence fence, Rendering.SynchronisationStage stage = SynchronisationStage.VertexProcessing); des: Instructs the GPU's processing of the graphics queue to wait until the given GPUFence is passed."
	}
,
	"Grid.cellGap": {
		"prefix": "Grid.cellGap",
		"body": [
			"cellGap"
		],
		"description": "return:Vector3 des: The size of the gap between each cell in the Grid."
	}
,
	"Grid.cellLayout": {
		"prefix": "Grid.cellLayout",
		"body": [
			"cellLayout"
		],
		"description": "return:GridLayout.CellLayout des: The layout of the cells in the Grid."
	}
,
	"Grid.cellSize": {
		"prefix": "Grid.cellSize",
		"body": [
			"cellSize"
		],
		"description": "return:Vector3 des: The size of each cell in the Grid."
	}
,
	"Grid.cellSwizzle": {
		"prefix": "Grid.cellSwizzle",
		"body": [
			"cellSwizzle"
		],
		"description": "return:GridLayout.CellSwizzle des: The cell swizzle for the Grid."
	}
,
	"Grid.GetCellCenterLocal": {
		"prefix": "Grid.GetCellCenterLocal",
		"body": [
			"GetCellCenterLocal($1)"
		],
		"description": "public Vector3 GetCellCenterLocal(Vector3Int position); des: Get the logical center coordinate of a grid cell in local space."
	}
,
	"Grid.GetCellCenterWorld": {
		"prefix": "Grid.GetCellCenterWorld",
		"body": [
			"GetCellCenterWorld($1)"
		],
		"description": "public Vector3 GetCellCenterWorld(Vector3Int position); des: Get the logical center coordinate of a grid cell in world space."
	}
,
	"Grid.InverseSwizzle": {
		"prefix": "Grid.InverseSwizzle",
		"body": [
			"Grid.InverseSwizzle"
		],
		"description": "public static Vector3 InverseSwizzle(GridLayout.CellSwizzle swizzle, Vector3 position); des: Does the inverse swizzle of the given position for given swizzle order."
	}
,
	"Grid.Swizzle": {
		"prefix": "Grid.Swizzle",
		"body": [
			"Grid.Swizzle"
		],
		"description": "public static Vector3 Swizzle(GridLayout.CellSwizzle swizzle, Vector3 position); des: Swizzles the given position with the given swizzle order."
	}
,
	"Grid.enabled": {
		"prefix": "Grid.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"Grid.isActiveAndEnabled": {
		"prefix": "Grid.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"Grid.gameObject": {
		"prefix": "Grid.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"Grid.tag": {
		"prefix": "Grid.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"Grid.transform": {
		"prefix": "Grid.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"Grid.hideFlags": {
		"prefix": "Grid.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Grid.name": {
		"prefix": "Grid.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Grid.BroadcastMessage": {
		"prefix": "Grid.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"Grid.CompareTag": {
		"prefix": "Grid.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"Grid.GetComponent": {
		"prefix": "Grid.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"Grid.GetComponentInChildren": {
		"prefix": "Grid.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"Grid.GetComponentInParent": {
		"prefix": "Grid.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"Grid.GetComponents": {
		"prefix": "Grid.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"Grid.GetComponentsInChildren": {
		"prefix": "Grid.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"Grid.GetComponentsInParent": {
		"prefix": "Grid.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"Grid.SendMessage": {
		"prefix": "Grid.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"Grid.SendMessageUpwards": {
		"prefix": "Grid.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"Grid.CellToLocal": {
		"prefix": "Grid.CellToLocal",
		"body": [
			"CellToLocal($1)"
		],
		"description": "public Vector3 CellToLocal(Vector3Int cellPosition); des: Converts a cell position to local position space."
	}
,
	"Grid.CellToLocalInterpolated": {
		"prefix": "Grid.CellToLocalInterpolated",
		"body": [
			"CellToLocalInterpolated($1)"
		],
		"description": "public Vector3 CellToLocalInterpolated(Vector3 cellPosition); des: Converts an interpolated cell position in floats to local position space."
	}
,
	"Grid.CellToWorld": {
		"prefix": "Grid.CellToWorld",
		"body": [
			"CellToWorld($1)"
		],
		"description": "public Vector3 CellToWorld(Vector3Int cellPosition); des: Converts a cell position to world position space."
	}
,
	"Grid.GetBoundsLocal": {
		"prefix": "Grid.GetBoundsLocal",
		"body": [
			"GetBoundsLocal($1)"
		],
		"description": "public Bounds GetBoundsLocal(Vector3Int cellPosition); des: Returns the local bounds for a cell at the location."
	}
,
	"Grid.GetLayoutCellCenter": {
		"prefix": "Grid.GetLayoutCellCenter",
		"body": [
			"GetLayoutCellCenter($1)"
		],
		"description": "public Vector3 GetLayoutCellCenter(); des: Get the default center coordinate of a cell for the set layout of the Grid."
	}
,
	"Grid.LocalToCell": {
		"prefix": "Grid.LocalToCell",
		"body": [
			"LocalToCell($1)"
		],
		"description": "public Vector3Int LocalToCell(Vector3 localPosition); des: Converts a local position to cell position."
	}
,
	"Grid.LocalToCellInterpolated": {
		"prefix": "Grid.LocalToCellInterpolated",
		"body": [
			"LocalToCellInterpolated($1)"
		],
		"description": "public Vector3 LocalToCellInterpolated(Vector3 localPosition); des: Converts a local position to cell position."
	}
,
	"Grid.LocalToWorld": {
		"prefix": "Grid.LocalToWorld",
		"body": [
			"LocalToWorld($1)"
		],
		"description": "public Vector3 LocalToWorld(Vector3 localPosition); des: Converts a local position to world position."
	}
,
	"Grid.WorldToCell": {
		"prefix": "Grid.WorldToCell",
		"body": [
			"WorldToCell($1)"
		],
		"description": "public Vector3Int WorldToCell(Vector3 worldPosition); des: Converts a world position to cell position."
	}
,
	"Grid.WorldToLocal": {
		"prefix": "Grid.WorldToLocal",
		"body": [
			"WorldToLocal($1)"
		],
		"description": "public Vector3 WorldToLocal(Vector3 worldPosition); des: Converts a world position to local position."
	}
,
	"Grid.GetInstanceID": {
		"prefix": "Grid.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Grid.ToString": {
		"prefix": "Grid.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Grid.Destroy": {
		"prefix": "Grid.Destroy",
		"body": [
			"Grid.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Grid.DestroyImmediate": {
		"prefix": "Grid.DestroyImmediate",
		"body": [
			"Grid.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Grid.DontDestroyOnLoad": {
		"prefix": "Grid.DontDestroyOnLoad",
		"body": [
			"Grid.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Grid.FindObjectOfType": {
		"prefix": "Grid.FindObjectOfType",
		"body": [
			"Grid.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Grid.FindObjectsOfType": {
		"prefix": "Grid.FindObjectsOfType",
		"body": [
			"Grid.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Grid.Instantiate": {
		"prefix": "Grid.Instantiate",
		"body": [
			"Grid.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"GridBrushBase.BoxErase": {
		"prefix": "GridBrushBase.BoxErase",
		"body": [
			"BoxErase($1)"
		],
		"description": "public void BoxErase(GridLayout gridLayout, GameObject brushTarget, BoundsInt position); des: Erases data on a grid within the given bounds."
	}
,
	"GridBrushBase.BoxFill": {
		"prefix": "GridBrushBase.BoxFill",
		"body": [
			"BoxFill($1)"
		],
		"description": "public void BoxFill(GridLayout gridLayout, GameObject brushTarget, BoundsInt position); des: Box fills tiles and GameObjects into given bounds within the selected layers."
	}
,
	"GridBrushBase.Erase": {
		"prefix": "GridBrushBase.Erase",
		"body": [
			"Erase($1)"
		],
		"description": "public void Erase(GridLayout gridLayout, GameObject brushTarget, Vector3Int position); des: Erases data on a grid within the given bounds."
	}
,
	"GridBrushBase.Flip": {
		"prefix": "GridBrushBase.Flip",
		"body": [
			"Flip($1)"
		],
		"description": "public void Flip(GridBrushBase.FlipAxis flip, GridLayout.CellLayout layout); des: Flips the grid brush in the given FlipAxis."
	}
,
	"GridBrushBase.FloodFill": {
		"prefix": "GridBrushBase.FloodFill",
		"body": [
			"FloodFill($1)"
		],
		"description": "public void FloodFill(GridLayout gridLayout, GameObject brushTarget, Vector3Int position); des: Flood fills data onto a grid given the starting coordinates of the cell."
	}
,
	"GridBrushBase.Move": {
		"prefix": "GridBrushBase.Move",
		"body": [
			"Move($1)"
		],
		"description": "public void Move(GridLayout gridLayout, GameObject brushTarget, BoundsInt from, BoundsInt to); des: Move is called when user moves the area previously selected with the selection marquee."
	}
,
	"GridBrushBase.MoveEnd": {
		"prefix": "GridBrushBase.MoveEnd",
		"body": [
			"MoveEnd($1)"
		],
		"description": "public void MoveEnd(GridLayout gridLayout, GameObject brushTarget, BoundsInt position); des: MoveEnd is called when user has ended the move of the area previously selected with the selection marquee."
	}
,
	"GridBrushBase.MoveStart": {
		"prefix": "GridBrushBase.MoveStart",
		"body": [
			"MoveStart($1)"
		],
		"description": "public void MoveStart(GridLayout gridLayout, GameObject brushTarget, BoundsInt position); des: MoveEnd is called when user starts moving the area previously selected with the selection marquee."
	}
,
	"GridBrushBase.Paint": {
		"prefix": "GridBrushBase.Paint",
		"body": [
			"Paint($1)"
		],
		"description": "public void Paint(GridLayout gridLayout, GameObject brushTarget, Vector3Int position); des: Paints data into a grid within the given bounds."
	}
,
	"GridBrushBase.Pick": {
		"prefix": "GridBrushBase.Pick",
		"body": [
			"Pick($1)"
		],
		"description": "public void Pick(GridLayout gridLayout, GameObject brushTarget, BoundsInt position, Vector3Int pivot); des: Picks data from a grid given the coordinates of the cells."
	}
,
	"GridBrushBase.Rotate": {
		"prefix": "GridBrushBase.Rotate",
		"body": [
			"Rotate($1)"
		],
		"description": "public void Rotate(GridBrushBase.RotationDirection direction, GridLayout.CellLayout layout); des: Rotates all tiles on the grid brush with the given RotationDirection."
	}
,
	"GridBrushBase.Select": {
		"prefix": "GridBrushBase.Select",
		"body": [
			"Select($1)"
		],
		"description": "public void Select(GridLayout gridLayout, GameObject brushTarget, BoundsInt position); des: Select an area of a grid."
	}
,
	"GridBrushBase.hideFlags": {
		"prefix": "GridBrushBase.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"GridBrushBase.name": {
		"prefix": "GridBrushBase.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"GridBrushBase.GetInstanceID": {
		"prefix": "GridBrushBase.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"GridBrushBase.ToString": {
		"prefix": "GridBrushBase.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"GridBrushBase.Destroy": {
		"prefix": "GridBrushBase.Destroy",
		"body": [
			"GridBrushBase.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"GridBrushBase.DestroyImmediate": {
		"prefix": "GridBrushBase.DestroyImmediate",
		"body": [
			"GridBrushBase.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"GridBrushBase.DontDestroyOnLoad": {
		"prefix": "GridBrushBase.DontDestroyOnLoad",
		"body": [
			"GridBrushBase.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"GridBrushBase.FindObjectOfType": {
		"prefix": "GridBrushBase.FindObjectOfType",
		"body": [
			"GridBrushBase.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"GridBrushBase.FindObjectsOfType": {
		"prefix": "GridBrushBase.FindObjectsOfType",
		"body": [
			"GridBrushBase.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"GridBrushBase.Instantiate": {
		"prefix": "GridBrushBase.Instantiate",
		"body": [
			"GridBrushBase.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"GridBrushBase.CreateInstance": {
		"prefix": "GridBrushBase.CreateInstance",
		"body": [
			"GridBrushBase.CreateInstance"
		],
		"description": "public static ScriptableObject CreateInstance(string className); public static ScriptableObject CreateInstance(Type type); public static T CreateInstance(); des: Creates an instance of a scriptable object."
	}
,
	"GridBrushBase.Awake": {
		"prefix": "GridBrushBase.Awake",
		"body": [
			"Awake"
		],
		"description": "This function is called when the ScriptableObject script is started."
	}
,
	"GridBrushBase.OnDestroy": {
		"prefix": "GridBrushBase.OnDestroy",
		"body": [
			"OnDestroy"
		],
		"description": "This function is called when the scriptable object will be destroyed."
	}
,
	"GridBrushBase.OnDisable": {
		"prefix": "GridBrushBase.OnDisable",
		"body": [
			"OnDisable"
		],
		"description": "This function is called when the scriptable object goes out of scope."
	}
,
	"GridBrushBase.OnEnable": {
		"prefix": "GridBrushBase.OnEnable",
		"body": [
			"OnEnable"
		],
		"description": "This function is called when the object is loaded."
	}
,
	"GridBrushBase.FlipAxis.X": {
		"prefix": "GridBrushBase.FlipAxis.X",
		"body": [
			"X"
		],
		"description": "return: des: Flip the brush in the X Axis."
	}
,
	"GridBrushBase.FlipAxis.Y": {
		"prefix": "GridBrushBase.FlipAxis.Y",
		"body": [
			"Y"
		],
		"description": "return: des: Flip the brush in the Y Axis."
	}
,
	"GridBrushBase.RotationDirection.Clockwise": {
		"prefix": "GridBrushBase.RotationDirection.Clockwise",
		"body": [
			"Clockwise"
		],
		"description": "return: des: Rotates tiles clockwise."
	}
,
	"GridBrushBase.RotationDirection.CounterClockwise": {
		"prefix": "GridBrushBase.RotationDirection.CounterClockwise",
		"body": [
			"CounterClockwise"
		],
		"description": "return: des: Rotates tiles counter-clockwise."
	}
,
	"GridBrushBase.Tool.Select": {
		"prefix": "GridBrushBase.Tool.Select",
		"body": [
			"Select"
		],
		"description": "return: des: Select."
	}
,
	"GridBrushBase.Tool.Move": {
		"prefix": "GridBrushBase.Tool.Move",
		"body": [
			"Move"
		],
		"description": "return: des: Move."
	}
,
	"GridBrushBase.Tool.Paint": {
		"prefix": "GridBrushBase.Tool.Paint",
		"body": [
			"Paint"
		],
		"description": "return: des: Paint."
	}
,
	"GridBrushBase.Tool.Box": {
		"prefix": "GridBrushBase.Tool.Box",
		"body": [
			"Box"
		],
		"description": "return: des: Box Fill."
	}
,
	"GridBrushBase.Tool.Pick": {
		"prefix": "GridBrushBase.Tool.Pick",
		"body": [
			"Pick"
		],
		"description": "return: des: Pick."
	}
,
	"GridBrushBase.Tool.Erase": {
		"prefix": "GridBrushBase.Tool.Erase",
		"body": [
			"Erase"
		],
		"description": "return: des: Erase."
	}
,
	"GridBrushBase.Tool.FloodFill": {
		"prefix": "GridBrushBase.Tool.FloodFill",
		"body": [
			"FloodFill"
		],
		"description": "return: des: Flood Fill."
	}
,
	"GridLayout.cellGap": {
		"prefix": "GridLayout.cellGap",
		"body": [
			"cellGap"
		],
		"description": "return:Vector3 des: The size of the gap between each cell in the layout."
	}
,
	"GridLayout.cellLayout": {
		"prefix": "GridLayout.cellLayout",
		"body": [
			"cellLayout"
		],
		"description": "return:GridLayout.CellLayout des: The layout of the cells."
	}
,
	"GridLayout.cellSize": {
		"prefix": "GridLayout.cellSize",
		"body": [
			"cellSize"
		],
		"description": "return:Vector3 des: The size of each cell in the layout."
	}
,
	"GridLayout.cellSwizzle": {
		"prefix": "GridLayout.cellSwizzle",
		"body": [
			"cellSwizzle"
		],
		"description": "return:GridLayout.CellSwizzle des: The cell swizzle for the layout."
	}
,
	"GridLayout.CellToLocal": {
		"prefix": "GridLayout.CellToLocal",
		"body": [
			"CellToLocal($1)"
		],
		"description": "public Vector3 CellToLocal(Vector3Int cellPosition); des: Converts a cell position to local position space."
	}
,
	"GridLayout.CellToLocalInterpolated": {
		"prefix": "GridLayout.CellToLocalInterpolated",
		"body": [
			"CellToLocalInterpolated($1)"
		],
		"description": "public Vector3 CellToLocalInterpolated(Vector3 cellPosition); des: Converts an interpolated cell position in floats to local position space."
	}
,
	"GridLayout.CellToWorld": {
		"prefix": "GridLayout.CellToWorld",
		"body": [
			"CellToWorld($1)"
		],
		"description": "public Vector3 CellToWorld(Vector3Int cellPosition); des: Converts a cell position to world position space."
	}
,
	"GridLayout.GetBoundsLocal": {
		"prefix": "GridLayout.GetBoundsLocal",
		"body": [
			"GetBoundsLocal($1)"
		],
		"description": "public Bounds GetBoundsLocal(Vector3Int cellPosition); des: Returns the local bounds for a cell at the location."
	}
,
	"GridLayout.GetLayoutCellCenter": {
		"prefix": "GridLayout.GetLayoutCellCenter",
		"body": [
			"GetLayoutCellCenter($1)"
		],
		"description": "public Vector3 GetLayoutCellCenter(); des: Get the default center coordinate of a cell for the set layout of the Grid."
	}
,
	"GridLayout.LocalToCell": {
		"prefix": "GridLayout.LocalToCell",
		"body": [
			"LocalToCell($1)"
		],
		"description": "public Vector3Int LocalToCell(Vector3 localPosition); des: Converts a local position to cell position."
	}
,
	"GridLayout.LocalToCellInterpolated": {
		"prefix": "GridLayout.LocalToCellInterpolated",
		"body": [
			"LocalToCellInterpolated($1)"
		],
		"description": "public Vector3 LocalToCellInterpolated(Vector3 localPosition); des: Converts a local position to cell position."
	}
,
	"GridLayout.LocalToWorld": {
		"prefix": "GridLayout.LocalToWorld",
		"body": [
			"LocalToWorld($1)"
		],
		"description": "public Vector3 LocalToWorld(Vector3 localPosition); des: Converts a local position to world position."
	}
,
	"GridLayout.WorldToCell": {
		"prefix": "GridLayout.WorldToCell",
		"body": [
			"WorldToCell($1)"
		],
		"description": "public Vector3Int WorldToCell(Vector3 worldPosition); des: Converts a world position to cell position."
	}
,
	"GridLayout.WorldToLocal": {
		"prefix": "GridLayout.WorldToLocal",
		"body": [
			"WorldToLocal($1)"
		],
		"description": "public Vector3 WorldToLocal(Vector3 worldPosition); des: Converts a world position to local position."
	}
,
	"GridLayout.enabled": {
		"prefix": "GridLayout.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"GridLayout.isActiveAndEnabled": {
		"prefix": "GridLayout.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"GridLayout.gameObject": {
		"prefix": "GridLayout.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"GridLayout.tag": {
		"prefix": "GridLayout.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"GridLayout.transform": {
		"prefix": "GridLayout.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"GridLayout.hideFlags": {
		"prefix": "GridLayout.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"GridLayout.name": {
		"prefix": "GridLayout.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"GridLayout.BroadcastMessage": {
		"prefix": "GridLayout.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"GridLayout.CompareTag": {
		"prefix": "GridLayout.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"GridLayout.GetComponent": {
		"prefix": "GridLayout.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"GridLayout.GetComponentInChildren": {
		"prefix": "GridLayout.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"GridLayout.GetComponentInParent": {
		"prefix": "GridLayout.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"GridLayout.GetComponents": {
		"prefix": "GridLayout.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"GridLayout.GetComponentsInChildren": {
		"prefix": "GridLayout.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"GridLayout.GetComponentsInParent": {
		"prefix": "GridLayout.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"GridLayout.SendMessage": {
		"prefix": "GridLayout.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"GridLayout.SendMessageUpwards": {
		"prefix": "GridLayout.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"GridLayout.GetInstanceID": {
		"prefix": "GridLayout.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"GridLayout.ToString": {
		"prefix": "GridLayout.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"GridLayout.Destroy": {
		"prefix": "GridLayout.Destroy",
		"body": [
			"GridLayout.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"GridLayout.DestroyImmediate": {
		"prefix": "GridLayout.DestroyImmediate",
		"body": [
			"GridLayout.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"GridLayout.DontDestroyOnLoad": {
		"prefix": "GridLayout.DontDestroyOnLoad",
		"body": [
			"GridLayout.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"GridLayout.FindObjectOfType": {
		"prefix": "GridLayout.FindObjectOfType",
		"body": [
			"GridLayout.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"GridLayout.FindObjectsOfType": {
		"prefix": "GridLayout.FindObjectsOfType",
		"body": [
			"GridLayout.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"GridLayout.Instantiate": {
		"prefix": "GridLayout.Instantiate",
		"body": [
			"GridLayout.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"GridLayout.CellLayout.Rectangle": {
		"prefix": "GridLayout.CellLayout.Rectangle",
		"body": [
			"Rectangle"
		],
		"description": "return: des: Rectangular layout for cells in the GridLayout."
	}
,
	"GridLayout.CellLayout.Hexagon": {
		"prefix": "GridLayout.CellLayout.Hexagon",
		"body": [
			"Hexagon"
		],
		"description": "return: des: Hexagonal layout for cells in the GridLayout."
	}
,
	"GridLayout.CellSwizzle.XYZ": {
		"prefix": "GridLayout.CellSwizzle.XYZ",
		"body": [
			"XYZ"
		],
		"description": "return: des: Keeps the cell positions at XYZ."
	}
,
	"GridLayout.CellSwizzle.XZY": {
		"prefix": "GridLayout.CellSwizzle.XZY",
		"body": [
			"XZY"
		],
		"description": "return: des: Swizzles the cell positions from XYZ to XZY."
	}
,
	"GridLayout.CellSwizzle.YXZ": {
		"prefix": "GridLayout.CellSwizzle.YXZ",
		"body": [
			"YXZ"
		],
		"description": "return: des: Swizzles the cell positions from XYZ to YXZ."
	}
,
	"GridLayout.CellSwizzle.YZX": {
		"prefix": "GridLayout.CellSwizzle.YZX",
		"body": [
			"YZX"
		],
		"description": "return: des: Swizzles the cell positions from XYZ to YZX."
	}
,
	"GridLayout.CellSwizzle.ZXY": {
		"prefix": "GridLayout.CellSwizzle.ZXY",
		"body": [
			"ZXY"
		],
		"description": "return: des: Swizzles the cell positions from XYZ to ZXY."
	}
,
	"GridLayout.CellSwizzle.ZYX": {
		"prefix": "GridLayout.CellSwizzle.ZYX",
		"body": [
			"ZYX"
		],
		"description": "return: des: Swizzles the cell positions from XYZ to ZYX."
	}
,
	"GUI.BeginGroup": {
		"prefix": "GUI.BeginGroup",
		"body": [
			"GUI.BeginGroup"
		],
		"description": "public static void BeginGroup(Rect position); public static void BeginGroup(Rect position, string text); public static void BeginGroup(Rect position, Texture image); public static void BeginGroup(Rect position, GUIContent content); public static void BeginGroup(Rect position, GUIStyle style); public static void BeginGroup(Rect position, string text, GUIStyle style); public static void BeginGroup(Rect position, Texture image, GUIStyle style); public static void BeginGroup(Rect position, GUIContent content, GUIStyle style); des: Begin a group. Must be matched with a call to EndGroup."
	}
,
	"GUI.BeginScrollView": {
		"prefix": "GUI.BeginScrollView",
		"body": [
			"GUI.BeginScrollView"
		],
		"description": "public static Vector2 BeginScrollView(Rect position, Vector2 scrollPosition, Rect viewRect); public static Vector2 BeginScrollView(Rect position, Vector2 scrollPosition, Rect viewRect, bool alwaysShowHorizontal, bool alwaysShowVertical); public static Vector2 BeginScrollView(Rect position, Vector2 scrollPosition, Rect viewRect, GUIStyle horizontalScrollbar, GUIStyle verticalScrollbar); public static Vector2 BeginScrollView(Rect position, Vector2 scrollPosition, Rect viewRect, bool alwaysShowHorizontal, bool alwaysShowVertical, GUIStyle horizontalScrollbar, GUIStyle verticalScrollbar); des: Begin a scrolling view inside your GUI."
	}
,
	"GUI.Box": {
		"prefix": "GUI.Box",
		"body": [
			"GUI.Box"
		],
		"description": "public static void Box(Rect position, string text); public static void Box(Rect position, Texture image); public static void Box(Rect position, GUIContent content); public static void Box(Rect position, string text, GUIStyle style); public static void Box(Rect position, Texture image, GUIStyle style); public static void Box(Rect position, GUIContent content, GUIStyle style); des: Create a Box on the GUI Layer."
	}
,
	"GUI.BringWindowToBack": {
		"prefix": "GUI.BringWindowToBack",
		"body": [
			"GUI.BringWindowToBack"
		],
		"description": "public static void BringWindowToBack(int windowID); des: Bring a specific window to back of the floating windows."
	}
,
	"GUI.BringWindowToFront": {
		"prefix": "GUI.BringWindowToFront",
		"body": [
			"GUI.BringWindowToFront"
		],
		"description": "public static void BringWindowToFront(int windowID); des: Bring a specific window to front of the floating windows."
	}
,
	"GUI.Button": {
		"prefix": "GUI.Button",
		"body": [
			"GUI.Button"
		],
		"description": "public static bool Button(Rect position, string text); public static bool Button(Rect position, Texture image); public static bool Button(Rect position, GUIContent content); public static bool Button(Rect position, string text, GUIStyle style); public static bool Button(Rect position, Texture image, GUIStyle style); public static bool Button(Rect position, GUIContent content, GUIStyle style); des: Make a single press button. The user clicks them and something happens immediately."
	}
,
	"GUI.DragWindow": {
		"prefix": "GUI.DragWindow",
		"body": [
			"GUI.DragWindow"
		],
		"description": "public static void DragWindow(Rect position); public static void DragWindow(); des: Make a window draggable."
	}
,
	"GUI.DrawTexture": {
		"prefix": "GUI.DrawTexture",
		"body": [
			"GUI.DrawTexture"
		],
		"description": "public static void DrawTexture(Rect position, Texture image); public static void DrawTexture(Rect position, Texture image, ScaleMode scaleMode); public static void DrawTexture(Rect position, Texture image, ScaleMode scaleMode, bool alphaBlend); public static void DrawTexture(Rect position, Texture image, ScaleMode scaleMode, bool alphaBlend, float imageAspect); public static void DrawTexture(Rect position, Texture image, ScaleMode scaleMode, bool alphaBlend, float imageAspect, Color color, float borderWidth, float borderRadius); public static void DrawTexture(Rect position, Texture image, ScaleMode scaleMode, bool alphaBlend, float imageAspect, Color color, Vector4 borderWidths, float borderRadius); des: Draw a texture within a rectangle."
	}
,
	"GUI.DrawTextureWithTexCoords": {
		"prefix": "GUI.DrawTextureWithTexCoords",
		"body": [
			"GUI.DrawTextureWithTexCoords"
		],
		"description": "public static void DrawTextureWithTexCoords(Rect position, Texture image, Rect texCoords); public static void DrawTextureWithTexCoords(Rect position, Texture image, Rect texCoords, bool alphaBlend); des: Draw a texture within a rectangle with the given texture coordinates."
	}
,
	"GUI.EndGroup": {
		"prefix": "GUI.EndGroup",
		"body": [
			"GUI.EndGroup"
		],
		"description": "public static void EndGroup(); des: End a group."
	}
,
	"GUI.EndScrollView": {
		"prefix": "GUI.EndScrollView",
		"body": [
			"GUI.EndScrollView"
		],
		"description": "public static void EndScrollView(); public static void EndScrollView(bool handleScrollWheel); des: Ends a scrollview started with a call to BeginScrollView."
	}
,
	"GUI.FocusControl": {
		"prefix": "GUI.FocusControl",
		"body": [
			"GUI.FocusControl"
		],
		"description": "public static void FocusControl(string name); des: Move keyboard focus to a named control."
	}
,
	"GUI.FocusWindow": {
		"prefix": "GUI.FocusWindow",
		"body": [
			"GUI.FocusWindow"
		],
		"description": "public static void FocusWindow(int windowID); des: Make a window become the active window."
	}
,
	"GUI.GetNameOfFocusedControl": {
		"prefix": "GUI.GetNameOfFocusedControl",
		"body": [
			"GUI.GetNameOfFocusedControl"
		],
		"description": "public static string GetNameOfFocusedControl(); des: Get the name of named control that has focus."
	}
,
	"GUI.HorizontalScrollbar": {
		"prefix": "GUI.HorizontalScrollbar",
		"body": [
			"GUI.HorizontalScrollbar"
		],
		"description": "public static float HorizontalScrollbar(Rect position, float value, float size, float leftValue, float rightValue); public static float HorizontalScrollbar(Rect position, float value, float size, float leftValue, float rightValue, GUIStyle style); des: Make a horizontal scrollbar. Scrollbars are what you use to scroll through a document. Most likely, you want to use scrollViews instead."
	}
,
	"GUI.HorizontalSlider": {
		"prefix": "GUI.HorizontalSlider",
		"body": [
			"GUI.HorizontalSlider"
		],
		"description": "public static float HorizontalSlider(Rect position, float value, float leftValue, float rightValue); public static float HorizontalSlider(Rect position, float value, float leftValue, float rightValue, GUIStyle slider, GUIStyle thumb); des: A horizontal slider the user can drag to change a value between a min and a max."
	}
,
	"GUI.Label": {
		"prefix": "GUI.Label",
		"body": [
			"GUI.Label"
		],
		"description": "public static void Label(Rect position, string text); public static void Label(Rect position, Texture image); public static void Label(Rect position, GUIContent content); public static void Label(Rect position, string text, GUIStyle style); public static void Label(Rect position, Texture image, GUIStyle style); public static void Label(Rect position, GUIContent content, GUIStyle style); des: Make a text or texture label on screen."
	}
,
	"GUI.ModalWindow": {
		"prefix": "GUI.ModalWindow",
		"body": [
			"GUI.ModalWindow"
		],
		"description": "public static Rect ModalWindow(int id, Rect clientRect, GUI.WindowFunction func, string text); public static Rect ModalWindow(int id, Rect clientRect, GUI.WindowFunction func, Texture image); public static Rect ModalWindow(int id, Rect clientRect, GUI.WindowFunction func, GUIContent content); public static Rect ModalWindow(int id, Rect clientRect, GUI.WindowFunction func, string text, GUIStyle style); public static Rect ModalWindow(int id, Rect clientRect, GUI.WindowFunction func, Texture image, GUIStyle style); public static Rect ModalWindow(int id, Rect clientRect, GUI.WindowFunction func, GUIContent content, GUIStyle style);   des: Show a Modal Window."
	}
,
	"GUI.PasswordField": {
		"prefix": "GUI.PasswordField",
		"body": [
			"GUI.PasswordField"
		],
		"description": "public static string PasswordField(Rect position, string password, char maskChar); public static string PasswordField(Rect position, string password, char maskChar, int maxLength); public static string PasswordField(Rect position, string password, char maskChar, GUIStyle style); public static string PasswordField(Rect position, string password, char maskChar, int maxLength, GUIStyle style); des: Make a text field where the user can enter a password."
	}
,
	"GUI.RepeatButton": {
		"prefix": "GUI.RepeatButton",
		"body": [
			"GUI.RepeatButton"
		],
		"description": "public static bool RepeatButton(Rect position, string text); public static bool RepeatButton(Rect position, Texture image); public static bool RepeatButton(Rect position, GUIContent content); public static bool RepeatButton(Rect position, string text, GUIStyle style); public static bool RepeatButton(Rect position, Texture image, GUIStyle style); public static bool RepeatButton(Rect position, GUIContent content, GUIStyle style); des: Make a button that is active as long as the user holds it down."
	}
,
	"GUI.ScrollTo": {
		"prefix": "GUI.ScrollTo",
		"body": [
			"GUI.ScrollTo"
		],
		"description": "public static void ScrollTo(Rect position); des: Scrolls all enclosing scrollviews so they try to make position visible."
	}
,
	"GUI.SelectionGrid": {
		"prefix": "GUI.SelectionGrid",
		"body": [
			"GUI.SelectionGrid"
		],
		"description": "public static int SelectionGrid(Rect position, int selected, string[] texts, int xCount); public static int SelectionGrid(Rect position, int selected, Texture[] images, int xCount); public static int SelectionGrid(Rect position, int selected, GUIContent[] content, int xCount); public static int SelectionGrid(Rect position, int selected, string[] texts, int xCount, GUIStyle style); public static int SelectionGrid(Rect position, int selected, Texture[] images, int xCount, GUIStyle style); public static int SelectionGrid(Rect position, int selected, GUIContent[] contents, int xCount, GUIStyle style); des: Make a grid of buttons."
	}
,
	"GUI.SetNextControlName": {
		"prefix": "GUI.SetNextControlName",
		"body": [
			"GUI.SetNextControlName"
		],
		"description": "public static void SetNextControlName(string name); des: Set the name of the next control."
	}
,
	"GUI.TextArea": {
		"prefix": "GUI.TextArea",
		"body": [
			"GUI.TextArea"
		],
		"description": "public static string TextArea(Rect position, string text); public static string TextArea(Rect position, string text, int maxLength); public static string TextArea(Rect position, string text, GUIStyle style); public static string TextArea(Rect position, string text, int maxLength, GUIStyle style); des: Make a Multi-line text area where the user can edit a string."
	}
,
	"GUI.TextField": {
		"prefix": "GUI.TextField",
		"body": [
			"GUI.TextField"
		],
		"description": "public static string TextField(Rect position, string text); public static string TextField(Rect position, string text, int maxLength); public static string TextField(Rect position, string text, GUIStyle style); public static string TextField(Rect position, string text, int maxLength, GUIStyle style); des: Make a single-line text field where the user can edit a string."
	}
,
	"GUI.Toggle": {
		"prefix": "GUI.Toggle",
		"body": [
			"GUI.Toggle"
		],
		"description": "public static bool Toggle(Rect position, bool value, string text); public static bool Toggle(Rect position, bool value, Texture image); public static bool Toggle(Rect position, bool value, GUIContent content); public static bool Toggle(Rect position, bool value, string text, GUIStyle style); public static bool Toggle(Rect position, bool value, Texture image, GUIStyle style); public static bool Toggle(Rect position, bool value, GUIContent content, GUIStyle style); des: Make an on/off toggle button."
	}
,
	"GUI.Toolbar": {
		"prefix": "GUI.Toolbar",
		"body": [
			"GUI.Toolbar"
		],
		"description": "public static int Toolbar(Rect position, int selected, string[] texts); public static int Toolbar(Rect position, int selected, Texture[] images); public static int Toolbar(Rect position, int selected, GUIContent[] contents); public static int Toolbar(Rect position, int selected, string[] texts, GUIStyle style); public static int Toolbar(Rect position, int selected, Texture[] images, GUIStyle style); public static int Toolbar(Rect position, int selected, GUIContent[] contents, GUIStyle style); public static int Toolbar(Rect position, int selected, GUIContent[] contents, GUIStyle style, GUI.ToolbarButtonSize buttonSize); des: Make a toolbar."
	}
,
	"GUI.UnfocusWindow": {
		"prefix": "GUI.UnfocusWindow",
		"body": [
			"GUI.UnfocusWindow"
		],
		"description": "public static void UnfocusWindow(); des: Remove focus from all windows."
	}
,
	"GUI.VerticalScrollbar": {
		"prefix": "GUI.VerticalScrollbar",
		"body": [
			"GUI.VerticalScrollbar"
		],
		"description": "public static float VerticalScrollbar(Rect position, float value, float size, float topValue, float bottomValue); public static float VerticalScrollbar(Rect position, float value, float size, float topValue, float bottomValue, GUIStyle style); des: Make a vertical scrollbar. Scrollbars are what you use to scroll through a document. Most likely, you want to use scrollViews instead."
	}
,
	"GUI.VerticalSlider": {
		"prefix": "GUI.VerticalSlider",
		"body": [
			"GUI.VerticalSlider"
		],
		"description": "public static float VerticalSlider(Rect position, float value, float topValue, float bottomValue); public static float VerticalSlider(Rect position, float value, float topValue, float bottomValue, GUIStyle slider, GUIStyle thumb); des: A vertical slider the user can drag to change a value between a min and a max."
	}
,
	"GUI.Window": {
		"prefix": "GUI.Window",
		"body": [
			"GUI.Window"
		],
		"description": "public static Rect Window(int id, Rect clientRect, GUI.WindowFunction func, string text); public static Rect Window(int id, Rect clientRect, GUI.WindowFunction func, Texture image); public static Rect Window(int id, Rect clientRect, GUI.WindowFunction func, GUIContent content); public static Rect Window(int id, Rect clientRect, GUI.WindowFunction func, string text, GUIStyle style); public static Rect Window(int id, Rect clientRect, GUI.WindowFunction func, Texture image, GUIStyle style); public static Rect Window(int id, Rect clientRect, GUI.WindowFunction func, GUIContent title, GUIStyle style); des: Make a popup window."
	}
,
	"GUI.ScrollViewScope.handleScrollWheel": {
		"prefix": "GUI.ScrollViewScope.handleScrollWheel",
		"body": [
			"handleScrollWheel"
		],
		"description": "return:bool des: Whether this ScrollView should handle scroll wheel events. (default: true)."
	}
,
	"GUI.ScrollViewScope.scrollPosition": {
		"prefix": "GUI.ScrollViewScope.scrollPosition",
		"body": [
			"scrollPosition"
		],
		"description": "return:Vector2 des: The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example."
	}
,
	"GUI.ToolbarButtonSize.Fixed": {
		"prefix": "GUI.ToolbarButtonSize.Fixed",
		"body": [
			"Fixed"
		],
		"description": "return: des: Calculates the button size by dividing the available width by the number of buttons. The minimum size is the maximum content width."
	}
,
	"GUI.ToolbarButtonSize.FitToContents": {
		"prefix": "GUI.ToolbarButtonSize.FitToContents",
		"body": [
			"FitToContents"
		],
		"description": "return: des: The width of each toolbar button is calculated based on the width of its content."
	}
,
	"GUIContent.image": {
		"prefix": "GUIContent.image",
		"body": [
			"image"
		],
		"description": "return:Texture des: The icon image contained."
	}
,
	"GUIContent.text": {
		"prefix": "GUIContent.text",
		"body": [
			"text"
		],
		"description": "return:string des: The text contained."
	}
,
	"GUIContent.tooltip": {
		"prefix": "GUIContent.tooltip",
		"body": [
			"tooltip"
		],
		"description": "return:string des: The tooltip of this element."
	}
,
	"GUIElement.GetScreenRect": {
		"prefix": "GUIElement.GetScreenRect",
		"body": [
			"GetScreenRect($1)"
		],
		"description": "public Rect GetScreenRect(Camera camera = null); des: Returns bounding rectangle of GUIElement in screen coordinates."
	}
,
	"GUIElement.HitTest": {
		"prefix": "GUIElement.HitTest",
		"body": [
			"HitTest($1)"
		],
		"description": "public bool HitTest(Vector3 screenPosition, Camera camera = null); des: Is a point on screen inside the element?"
	}
,
	"GUIElement.enabled": {
		"prefix": "GUIElement.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"GUIElement.isActiveAndEnabled": {
		"prefix": "GUIElement.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"GUIElement.gameObject": {
		"prefix": "GUIElement.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"GUIElement.tag": {
		"prefix": "GUIElement.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"GUIElement.transform": {
		"prefix": "GUIElement.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"GUIElement.hideFlags": {
		"prefix": "GUIElement.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"GUIElement.name": {
		"prefix": "GUIElement.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"GUIElement.BroadcastMessage": {
		"prefix": "GUIElement.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"GUIElement.CompareTag": {
		"prefix": "GUIElement.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"GUIElement.GetComponent": {
		"prefix": "GUIElement.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"GUIElement.GetComponentInChildren": {
		"prefix": "GUIElement.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"GUIElement.GetComponentInParent": {
		"prefix": "GUIElement.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"GUIElement.GetComponents": {
		"prefix": "GUIElement.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"GUIElement.GetComponentsInChildren": {
		"prefix": "GUIElement.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"GUIElement.GetComponentsInParent": {
		"prefix": "GUIElement.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"GUIElement.SendMessage": {
		"prefix": "GUIElement.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"GUIElement.SendMessageUpwards": {
		"prefix": "GUIElement.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"GUIElement.GetInstanceID": {
		"prefix": "GUIElement.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"GUIElement.ToString": {
		"prefix": "GUIElement.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"GUIElement.Destroy": {
		"prefix": "GUIElement.Destroy",
		"body": [
			"GUIElement.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"GUIElement.DestroyImmediate": {
		"prefix": "GUIElement.DestroyImmediate",
		"body": [
			"GUIElement.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"GUIElement.DontDestroyOnLoad": {
		"prefix": "GUIElement.DontDestroyOnLoad",
		"body": [
			"GUIElement.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"GUIElement.FindObjectOfType": {
		"prefix": "GUIElement.FindObjectOfType",
		"body": [
			"GUIElement.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"GUIElement.FindObjectsOfType": {
		"prefix": "GUIElement.FindObjectsOfType",
		"body": [
			"GUIElement.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"GUIElement.Instantiate": {
		"prefix": "GUIElement.Instantiate",
		"body": [
			"GUIElement.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"GUILayer.enabled": {
		"prefix": "GUILayer.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"GUILayer.isActiveAndEnabled": {
		"prefix": "GUILayer.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"GUILayer.gameObject": {
		"prefix": "GUILayer.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"GUILayer.tag": {
		"prefix": "GUILayer.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"GUILayer.transform": {
		"prefix": "GUILayer.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"GUILayer.hideFlags": {
		"prefix": "GUILayer.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"GUILayer.name": {
		"prefix": "GUILayer.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"GUILayer.BroadcastMessage": {
		"prefix": "GUILayer.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"GUILayer.CompareTag": {
		"prefix": "GUILayer.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"GUILayer.GetComponent": {
		"prefix": "GUILayer.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"GUILayer.GetComponentInChildren": {
		"prefix": "GUILayer.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"GUILayer.GetComponentInParent": {
		"prefix": "GUILayer.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"GUILayer.GetComponents": {
		"prefix": "GUILayer.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"GUILayer.GetComponentsInChildren": {
		"prefix": "GUILayer.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"GUILayer.GetComponentsInParent": {
		"prefix": "GUILayer.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"GUILayer.SendMessage": {
		"prefix": "GUILayer.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"GUILayer.SendMessageUpwards": {
		"prefix": "GUILayer.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"GUILayer.GetInstanceID": {
		"prefix": "GUILayer.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"GUILayer.ToString": {
		"prefix": "GUILayer.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"GUILayer.Destroy": {
		"prefix": "GUILayer.Destroy",
		"body": [
			"GUILayer.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"GUILayer.DestroyImmediate": {
		"prefix": "GUILayer.DestroyImmediate",
		"body": [
			"GUILayer.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"GUILayer.DontDestroyOnLoad": {
		"prefix": "GUILayer.DontDestroyOnLoad",
		"body": [
			"GUILayer.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"GUILayer.FindObjectOfType": {
		"prefix": "GUILayer.FindObjectOfType",
		"body": [
			"GUILayer.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"GUILayer.FindObjectsOfType": {
		"prefix": "GUILayer.FindObjectsOfType",
		"body": [
			"GUILayer.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"GUILayer.Instantiate": {
		"prefix": "GUILayer.Instantiate",
		"body": [
			"GUILayer.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"GUILayout.BeginArea": {
		"prefix": "GUILayout.BeginArea",
		"body": [
			"GUILayout.BeginArea"
		],
		"description": "public static void BeginArea(Rect screenRect); public static void BeginArea(Rect screenRect, string text); public static void BeginArea(Rect screenRect, Texture image); public static void BeginArea(Rect screenRect, GUIContent content); public static void BeginArea(Rect screenRect, GUIStyle style); public static void BeginArea(Rect screenRect, string text, GUIStyle style); public static void BeginArea(Rect screenRect, Texture image, GUIStyle style); public static void BeginArea(Rect screenRect, GUIContent content, GUIStyle style); des: Begin a GUILayout block of GUI controls in a fixed screen area."
	}
,
	"GUILayout.BeginHorizontal": {
		"prefix": "GUILayout.BeginHorizontal",
		"body": [
			"GUILayout.BeginHorizontal"
		],
		"description": "public static void BeginHorizontal(params GUILayoutOption[] options); public static void BeginHorizontal(GUIStyle style, params GUILayoutOption[] options); public static void BeginHorizontal(string text, GUIStyle style, params GUILayoutOption[] options); public static void BeginHorizontal(Texture image, GUIStyle style, params GUILayoutOption[] options); public static void BeginHorizontal(GUIContent content, GUIStyle style, params GUILayoutOption[] options); des: Begin a Horizontal control group."
	}
,
	"GUILayout.BeginScrollView": {
		"prefix": "GUILayout.BeginScrollView",
		"body": [
			"GUILayout.BeginScrollView"
		],
		"description": "public static Vector2 BeginScrollView(Vector2 scrollPosition, params GUILayoutOption[] options); public static Vector2 BeginScrollView(Vector2 scrollPosition, bool alwaysShowHorizontal, bool alwaysShowVertical, params GUILayoutOption[] options); public static Vector2 BeginScrollView(Vector2 scrollPosition, GUIStyle horizontalScrollbar, GUIStyle verticalScrollbar, params GUILayoutOption[] options); public static Vector2 BeginScrollView(Vector2 scrollPosition, GUIStyle style); public static Vector2 BeginScrollView(Vector2 scrollPosition, GUIStyle style, params GUILayoutOption[] options); public static Vector2 BeginScrollView(Vector2 scrollPosition, bool alwaysShowHorizontal, bool alwaysShowVertical, GUIStyle horizontalScrollbar, GUIStyle verticalScrollbar, params GUILayoutOption[] options); public static Vector2 BeginScrollView(Vector2 scrollPosition, bool alwaysShowHorizontal, bool alwaysShowVertical, GUIStyle horizontalScrollbar, GUIStyle verticalScrollbar, GUIStyle background, params GUILayoutOption[] options); des: Begin an automatically laid out scrollview."
	}
,
	"GUILayout.BeginVertical": {
		"prefix": "GUILayout.BeginVertical",
		"body": [
			"GUILayout.BeginVertical"
		],
		"description": "public static void BeginVertical(params GUILayoutOption[] options); public static void BeginVertical(GUIStyle style, params GUILayoutOption[] options); public static void BeginVertical(string text, GUIStyle style, params GUILayoutOption[] options); public static void BeginVertical(Texture image, GUIStyle style, params GUILayoutOption[] options); public static void BeginVertical(GUIContent content, GUIStyle style, params GUILayoutOption[] options); des: Begin a vertical control group."
	}
,
	"GUILayout.Box": {
		"prefix": "GUILayout.Box",
		"body": [
			"GUILayout.Box"
		],
		"description": "public static void Box(Texture image, params GUILayoutOption[] options); public static void Box(string text, params GUILayoutOption[] options); public static void Box(GUIContent content, params GUILayoutOption[] options); public static void Box(Texture image, GUIStyle style, params GUILayoutOption[] options); public static void Box(string text, GUIStyle style, params GUILayoutOption[] options); public static void Box(GUIContent content, GUIStyle style, params GUILayoutOption[] options); des: Make an auto-layout box."
	}
,
	"GUILayout.Button": {
		"prefix": "GUILayout.Button",
		"body": [
			"GUILayout.Button"
		],
		"description": "public static bool Button(Texture image, params GUILayoutOption[] options); public static bool Button(string text, params GUILayoutOption[] options); public static bool Button(GUIContent content, params GUILayoutOption[] options); public static bool Button(Texture image, GUIStyle style, params GUILayoutOption[] options); public static bool Button(string text, GUIStyle style, params GUILayoutOption[] options); public static bool Button(GUIContent content, GUIStyle style, params GUILayoutOption[] options); des: Make a single press button."
	}
,
	"GUILayout.EndArea": {
		"prefix": "GUILayout.EndArea",
		"body": [
			"GUILayout.EndArea"
		],
		"description": "public static void EndArea(); des: Close a GUILayout block started with BeginArea."
	}
,
	"GUILayout.EndHorizontal": {
		"prefix": "GUILayout.EndHorizontal",
		"body": [
			"GUILayout.EndHorizontal"
		],
		"description": "public static void EndHorizontal(); des: Close a group started with BeginHorizontal."
	}
,
	"GUILayout.EndScrollView": {
		"prefix": "GUILayout.EndScrollView",
		"body": [
			"GUILayout.EndScrollView"
		],
		"description": "public static void EndScrollView(); des: End a scroll view begun with a call to BeginScrollView."
	}
,
	"GUILayout.EndVertical": {
		"prefix": "GUILayout.EndVertical",
		"body": [
			"GUILayout.EndVertical"
		],
		"description": "public static void EndVertical(); des: Close a group started with BeginVertical."
	}
,
	"GUILayout.ExpandHeight": {
		"prefix": "GUILayout.ExpandHeight",
		"body": [
			"GUILayout.ExpandHeight"
		],
		"description": "public static GUILayoutOption ExpandHeight(bool expand); des: Option passed to a control to allow or disallow vertical expansion."
	}
,
	"GUILayout.ExpandWidth": {
		"prefix": "GUILayout.ExpandWidth",
		"body": [
			"GUILayout.ExpandWidth"
		],
		"description": "public static GUILayoutOption ExpandWidth(bool expand); des: Option passed to a control to allow or disallow horizontal expansion."
	}
,
	"GUILayout.FlexibleSpace": {
		"prefix": "GUILayout.FlexibleSpace",
		"body": [
			"GUILayout.FlexibleSpace"
		],
		"description": "public static void FlexibleSpace(); des: Insert a flexible space element."
	}
,
	"GUILayout.Height": {
		"prefix": "GUILayout.Height",
		"body": [
			"GUILayout.Height"
		],
		"description": "public static GUILayoutOption Height(float height); des: Option passed to a control to give it an absolute height."
	}
,
	"GUILayout.HorizontalScrollbar": {
		"prefix": "GUILayout.HorizontalScrollbar",
		"body": [
			"GUILayout.HorizontalScrollbar"
		],
		"description": "public static float HorizontalScrollbar(float value, float size, float leftValue, float rightValue, params GUILayoutOption[] options); public static float HorizontalScrollbar(float value, float size, float leftValue, float rightValue, GUIStyle style, params GUILayoutOption[] options); des: Make a horizontal scrollbar."
	}
,
	"GUILayout.HorizontalSlider": {
		"prefix": "GUILayout.HorizontalSlider",
		"body": [
			"GUILayout.HorizontalSlider"
		],
		"description": "public static float HorizontalSlider(float value, float leftValue, float rightValue, params GUILayoutOption[] options); public static float HorizontalSlider(float value, float leftValue, float rightValue, GUIStyle slider, GUIStyle thumb, params GUILayoutOption[] options); des: A horizontal slider the user can drag to change a value between a min and a max."
	}
,
	"GUILayout.Label": {
		"prefix": "GUILayout.Label",
		"body": [
			"GUILayout.Label"
		],
		"description": "public static void Label(Texture image, params GUILayoutOption[] options); public static void Label(string text, params GUILayoutOption[] options); public static void Label(GUIContent content, params GUILayoutOption[] options); public static void Label(Texture image, GUIStyle style, params GUILayoutOption[] options); public static void Label(string text, GUIStyle style, params GUILayoutOption[] options); public static void Label(GUIContent content, GUIStyle style, params GUILayoutOption[] options); des: Make an auto-layout label."
	}
,
	"GUILayout.MaxHeight": {
		"prefix": "GUILayout.MaxHeight",
		"body": [
			"GUILayout.MaxHeight"
		],
		"description": "public static GUILayoutOption MaxHeight(float maxHeight); des: Option passed to a control to specify a maximum height."
	}
,
	"GUILayout.MaxWidth": {
		"prefix": "GUILayout.MaxWidth",
		"body": [
			"GUILayout.MaxWidth"
		],
		"description": "public static GUILayoutOption MaxWidth(float maxWidth); des: Option passed to a control to specify a maximum width."
	}
,
	"GUILayout.MinHeight": {
		"prefix": "GUILayout.MinHeight",
		"body": [
			"GUILayout.MinHeight"
		],
		"description": "public static GUILayoutOption MinHeight(float minHeight); des: Option passed to a control to specify a minimum height."
	}
,
	"GUILayout.MinWidth": {
		"prefix": "GUILayout.MinWidth",
		"body": [
			"GUILayout.MinWidth"
		],
		"description": "public static GUILayoutOption MinWidth(float minWidth); des: Option passed to a control to specify a minimum width."
	}
,
	"GUILayout.PasswordField": {
		"prefix": "GUILayout.PasswordField",
		"body": [
			"GUILayout.PasswordField"
		],
		"description": "public static string PasswordField(string password, char maskChar, params GUILayoutOption[] options); public static string PasswordField(string password, char maskChar, int maxLength, params GUILayoutOption[] options); public static string PasswordField(string password, char maskChar, GUIStyle style, params GUILayoutOption[] options); public static string PasswordField(string password, char maskChar, int maxLength, GUIStyle style, params GUILayoutOption[] options); des: Make a text field where the user can enter a password."
	}
,
	"GUILayout.RepeatButton": {
		"prefix": "GUILayout.RepeatButton",
		"body": [
			"GUILayout.RepeatButton"
		],
		"description": "public static bool RepeatButton(Texture image, params GUILayoutOption[] options); public static bool RepeatButton(string text, params GUILayoutOption[] options); public static bool RepeatButton(GUIContent content, params GUILayoutOption[] options); public static bool RepeatButton(Texture image, GUIStyle style, params GUILayoutOption[] options); public static bool RepeatButton(string text, GUIStyle style, params GUILayoutOption[] options); public static bool RepeatButton(GUIContent content, GUIStyle style, params GUILayoutOption[] options); des: Make a repeating button. The button returns true as long as the user holds down the mouse."
	}
,
	"GUILayout.SelectionGrid": {
		"prefix": "GUILayout.SelectionGrid",
		"body": [
			"GUILayout.SelectionGrid"
		],
		"description": "public static int SelectionGrid(int selected, string[] texts, int xCount, params GUILayoutOption[] options); public static int SelectionGrid(int selected, Texture[] images, int xCount, params GUILayoutOption[] options); public static int SelectionGrid(int selected, GUIContent[] content, int xCount, params GUILayoutOption[] options); public static int SelectionGrid(int selected, string[] texts, int xCount, GUIStyle style, params GUILayoutOption[] options); public static int SelectionGrid(int selected, Texture[] images, int xCount, GUIStyle style, params GUILayoutOption[] options); public static int SelectionGrid(int selected, GUIContent[] contents, int xCount, GUIStyle style, params GUILayoutOption[] options); des: Make a Selection Grid."
	}
,
	"GUILayout.Space": {
		"prefix": "GUILayout.Space",
		"body": [
			"GUILayout.Space"
		],
		"description": "public static void Space(float pixels); des: Insert a space in the current layout group."
	}
,
	"GUILayout.TextArea": {
		"prefix": "GUILayout.TextArea",
		"body": [
			"GUILayout.TextArea"
		],
		"description": "public static string TextArea(string text, params GUILayoutOption[] options); public static string TextArea(string text, int maxLength, params GUILayoutOption[] options); public static string TextArea(string text, GUIStyle style, params GUILayoutOption[] options); public static string TextArea(string text, int maxLength, GUIStyle style, params GUILayoutOption[] options); des: Make a multi-line text field where the user can edit a string."
	}
,
	"GUILayout.TextField": {
		"prefix": "GUILayout.TextField",
		"body": [
			"GUILayout.TextField"
		],
		"description": "public static string TextField(string text, params GUILayoutOption[] options); public static string TextField(string text, int maxLength, params GUILayoutOption[] options); public static string TextField(string text, GUIStyle style, params GUILayoutOption[] options); public static string TextField(string text, int maxLength, GUIStyle style, params GUILayoutOption[] options); des: Make a single-line text field where the user can edit a string."
	}
,
	"GUILayout.Toggle": {
		"prefix": "GUILayout.Toggle",
		"body": [
			"GUILayout.Toggle"
		],
		"description": "public static bool Toggle(bool value, Texture image, params GUILayoutOption[] options); public static bool Toggle(bool value, string text, params GUILayoutOption[] options); public static bool Toggle(bool value, GUIContent content, params GUILayoutOption[] options); public static bool Toggle(bool value, Texture image, GUIStyle style, params GUILayoutOption[] options); public static bool Toggle(bool value, string text, GUIStyle style, params GUILayoutOption[] options); public static bool Toggle(bool value, GUIContent content, GUIStyle style, params GUILayoutOption[] options); des: Make an on/off toggle button."
	}
,
	"GUILayout.Toolbar": {
		"prefix": "GUILayout.Toolbar",
		"body": [
			"GUILayout.Toolbar"
		],
		"description": "public static int Toolbar(int selected, string[] texts, params GUILayoutOption[] options); public static int Toolbar(int selected, Texture[] images, params GUILayoutOption[] options); public static int Toolbar(int selected, GUIContent[] contents, params GUILayoutOption[] options); public static int Toolbar(int selected, string[] texts, GUIStyle style, params GUILayoutOption[] options); public static int Toolbar(int selected, Texture[] images, GUIStyle style, params GUILayoutOption[] options); public static int Toolbar(int selected, GUIContent[] contents, GUIStyle style, params GUILayoutOption[] options); public static int Toolbar(int selected, string[] texts, GUIStyle style, GUI.ToolbarButtonSize buttonSize, params GUILayoutOption[] options); public static int Toolbar(int selected, Texture[] images, GUIStyle style, GUI.ToolbarButtonSize buttonSize, params GUILayoutOption[] options); public static int Toolbar(int selected, GUIContent[] contents, GUIStyle style, GUI.ToolbarButtonSize buttonSize, params GUILayoutOption[] options); des: Make a toolbar."
	}
,
	"GUILayout.VerticalScrollbar": {
		"prefix": "GUILayout.VerticalScrollbar",
		"body": [
			"GUILayout.VerticalScrollbar"
		],
		"description": "public static float VerticalScrollbar(float value, float size, float topValue, float bottomValue, params GUILayoutOption[] options); public static float VerticalScrollbar(float value, float size, float topValue, float bottomValue, GUIStyle style, params GUILayoutOption[] options); des: Make a vertical scrollbar."
	}
,
	"GUILayout.VerticalSlider": {
		"prefix": "GUILayout.VerticalSlider",
		"body": [
			"GUILayout.VerticalSlider"
		],
		"description": "public static float VerticalSlider(float value, float leftValue, float rightValue, params GUILayoutOption[] options); public static float VerticalSlider(float value, float leftValue, float rightValue, GUIStyle slider, GUIStyle thumb, params GUILayoutOption[] options); des: A vertical slider the user can drag to change a value between a min and a max."
	}
,
	"GUILayout.Width": {
		"prefix": "GUILayout.Width",
		"body": [
			"GUILayout.Width"
		],
		"description": "public static GUILayoutOption Width(float width); des: Option passed to a control to give it an absolute width."
	}
,
	"GUILayout.Window": {
		"prefix": "GUILayout.Window",
		"body": [
			"GUILayout.Window"
		],
		"description": "public static Rect Window(int id, Rect screenRect, GUI.WindowFunction func, string text, params GUILayoutOption[] options); public static Rect Window(int id, Rect screenRect, GUI.WindowFunction func, Texture image, params GUILayoutOption[] options); public static Rect Window(int id, Rect screenRect, GUI.WindowFunction func, GUIContent content, params GUILayoutOption[] options); public static Rect Window(int id, Rect screenRect, GUI.WindowFunction func, string text, GUIStyle style, params GUILayoutOption[] options); public static Rect Window(int id, Rect screenRect, GUI.WindowFunction func, Texture image, GUIStyle style, params GUILayoutOption[] options); public static Rect Window(int id, Rect screenRect, GUI.WindowFunction func, GUIContent content, GUIStyle style, params GUILayoutOption[] options); des: Make a popup window that layouts its contents automatically."
	}
,
	"GUILayout.ScrollViewScope.handleScrollWheel": {
		"prefix": "GUILayout.ScrollViewScope.handleScrollWheel",
		"body": [
			"handleScrollWheel"
		],
		"description": "return:bool des: Whether this ScrollView should handle scroll wheel events. (default: true)."
	}
,
	"GUILayout.ScrollViewScope.scrollPosition": {
		"prefix": "GUILayout.ScrollViewScope.scrollPosition",
		"body": [
			"scrollPosition"
		],
		"description": "return:Vector2 des: The modified scrollPosition. Feed this back into the variable you pass in, as shown in the example."
	}
,
	"GUILayoutUtility.GetAspectRect": {
		"prefix": "GUILayoutUtility.GetAspectRect",
		"body": [
			"GUILayoutUtility.GetAspectRect"
		],
		"description": "public static Rect GetAspectRect(float aspect); public static Rect GetAspectRect(float aspect, GUIStyle style); public static Rect GetAspectRect(float aspect, params GUILayoutOption[] options); public static Rect GetAspectRect(float aspect, GUIStyle style, params GUILayoutOption[] options); des: Reserve layout space for a rectangle with a specific aspect ratio."
	}
,
	"GUILayoutUtility.GetLastRect": {
		"prefix": "GUILayoutUtility.GetLastRect",
		"body": [
			"GUILayoutUtility.GetLastRect"
		],
		"description": "public static Rect GetLastRect(); des: Get the rectangle last used by GUILayout for a control."
	}
,
	"GUILayoutUtility.GetRect": {
		"prefix": "GUILayoutUtility.GetRect",
		"body": [
			"GUILayoutUtility.GetRect"
		],
		"description": "public static Rect GetRect(GUIContent content, GUIStyle style); public static Rect GetRect(GUIContent content, GUIStyle style, params GUILayoutOption[] options); public static Rect GetRect(float width, float height); public static Rect GetRect(float width, float height, GUIStyle style); public static Rect GetRect(float width, float height, params GUILayoutOption[] options); public static Rect GetRect(float width, float height, GUIStyle style, params GUILayoutOption[] options); public static Rect GetRect(float minWidth, float maxWidth, float minHeight, float maxHeight); public static Rect GetRect(float minWidth, float maxWidth, float minHeight, float maxHeight, GUIStyle style); public static Rect GetRect(float minWidth, float maxWidth, float minHeight, float maxHeight, params GUILayoutOption[] options); public static Rect GetRect(float minWidth, float maxWidth, float minHeight, float maxHeight, GUIStyle style, params GUILayoutOption[] options); des: Reserve layout space for a rectangle for displaying some contents with a specific style."
	}
,
	"GUISettings.cursorColor": {
		"prefix": "GUISettings.cursorColor",
		"body": [
			"cursorColor"
		],
		"description": "return:Color des: The color of the cursor in text fields."
	}
,
	"GUISettings.cursorFlashSpeed": {
		"prefix": "GUISettings.cursorFlashSpeed",
		"body": [
			"cursorFlashSpeed"
		],
		"description": "return:float des: The speed of text field cursor flashes."
	}
,
	"GUISettings.doubleClickSelectsWord": {
		"prefix": "GUISettings.doubleClickSelectsWord",
		"body": [
			"doubleClickSelectsWord"
		],
		"description": "return:bool des: Should double-clicking select words in text fields."
	}
,
	"GUISettings.selectionColor": {
		"prefix": "GUISettings.selectionColor",
		"body": [
			"selectionColor"
		],
		"description": "return:Color des: The color of the selection rect in text fields."
	}
,
	"GUISettings.tripleClickSelectsLine": {
		"prefix": "GUISettings.tripleClickSelectsLine",
		"body": [
			"tripleClickSelectsLine"
		],
		"description": "return:bool des: Should triple-clicking select whole text in text fields."
	}
,
	"GUISkin.box": {
		"prefix": "GUISkin.box",
		"body": [
			"box"
		],
		"description": "return:GUIStyle des: Style used by default for GUI.Box controls."
	}
,
	"GUISkin.button": {
		"prefix": "GUISkin.button",
		"body": [
			"button"
		],
		"description": "return:GUIStyle des: Style used by default for GUI.Button controls."
	}
,
	"GUISkin.customStyles": {
		"prefix": "GUISkin.customStyles",
		"body": [
			"customStyles"
		],
		"description": "return:GUIStyle[] des: Array of GUI styles for specific needs."
	}
,
	"GUISkin.font": {
		"prefix": "GUISkin.font",
		"body": [
			"font"
		],
		"description": "return:Font des: The default font to use for all styles."
	}
,
	"GUISkin.horizontalScrollbar": {
		"prefix": "GUISkin.horizontalScrollbar",
		"body": [
			"horizontalScrollbar"
		],
		"description": "return:GUIStyle des: Style used by default for the background part of GUI.HorizontalScrollbar controls."
	}
,
	"GUISkin.horizontalScrollbarLeftButton": {
		"prefix": "GUISkin.horizontalScrollbarLeftButton",
		"body": [
			"horizontalScrollbarLeftButton"
		],
		"description": "return:GUIStyle des: Style used by default for the left button on GUI.HorizontalScrollbar controls."
	}
,
	"GUISkin.horizontalScrollbarRightButton": {
		"prefix": "GUISkin.horizontalScrollbarRightButton",
		"body": [
			"horizontalScrollbarRightButton"
		],
		"description": "return:GUIStyle des: Style used by default for the right button on GUI.HorizontalScrollbar controls."
	}
,
	"GUISkin.horizontalScrollbarThumb": {
		"prefix": "GUISkin.horizontalScrollbarThumb",
		"body": [
			"horizontalScrollbarThumb"
		],
		"description": "return:GUIStyle des: Style used by default for the thumb that is dragged in GUI.HorizontalScrollbar controls."
	}
,
	"GUISkin.horizontalSlider": {
		"prefix": "GUISkin.horizontalSlider",
		"body": [
			"horizontalSlider"
		],
		"description": "return:GUIStyle des: Style used by default for the background part of GUI.HorizontalSlider controls."
	}
,
	"GUISkin.horizontalSliderThumb": {
		"prefix": "GUISkin.horizontalSliderThumb",
		"body": [
			"horizontalSliderThumb"
		],
		"description": "return:GUIStyle des: Style used by default for the thumb that is dragged in GUI.HorizontalSlider controls."
	}
,
	"GUISkin.label": {
		"prefix": "GUISkin.label",
		"body": [
			"label"
		],
		"description": "return:GUIStyle des: Style used by default for GUI.Label controls."
	}
,
	"GUISkin.scrollView": {
		"prefix": "GUISkin.scrollView",
		"body": [
			"scrollView"
		],
		"description": "return:GUIStyle des: Style used by default for the background of ScrollView controls (see GUI.BeginScrollView)."
	}
,
	"GUISkin.settings": {
		"prefix": "GUISkin.settings",
		"body": [
			"settings"
		],
		"description": "return:GUISettings des: Generic settings for how controls should behave with this skin."
	}
,
	"GUISkin.textArea": {
		"prefix": "GUISkin.textArea",
		"body": [
			"textArea"
		],
		"description": "return:GUIStyle des: Style used by default for GUI.TextArea controls."
	}
,
	"GUISkin.textField": {
		"prefix": "GUISkin.textField",
		"body": [
			"textField"
		],
		"description": "return:GUIStyle des: Style used by default for GUI.TextField controls."
	}
,
	"GUISkin.toggle": {
		"prefix": "GUISkin.toggle",
		"body": [
			"toggle"
		],
		"description": "return:GUIStyle des: Style used by default for GUI.Toggle controls."
	}
,
	"GUISkin.verticalScrollbar": {
		"prefix": "GUISkin.verticalScrollbar",
		"body": [
			"verticalScrollbar"
		],
		"description": "return:GUIStyle des: Style used by default for the background part of GUI.VerticalScrollbar controls."
	}
,
	"GUISkin.verticalScrollbarDownButton": {
		"prefix": "GUISkin.verticalScrollbarDownButton",
		"body": [
			"verticalScrollbarDownButton"
		],
		"description": "return:GUIStyle des: Style used by default for the down button on GUI.VerticalScrollbar controls."
	}
,
	"GUISkin.verticalScrollbarThumb": {
		"prefix": "GUISkin.verticalScrollbarThumb",
		"body": [
			"verticalScrollbarThumb"
		],
		"description": "return:GUIStyle des: Style used by default for the thumb that is dragged in GUI.VerticalScrollbar controls."
	}
,
	"GUISkin.verticalScrollbarUpButton": {
		"prefix": "GUISkin.verticalScrollbarUpButton",
		"body": [
			"verticalScrollbarUpButton"
		],
		"description": "return:GUIStyle des: Style used by default for the up button on GUI.VerticalScrollbar controls."
	}
,
	"GUISkin.verticalSlider": {
		"prefix": "GUISkin.verticalSlider",
		"body": [
			"verticalSlider"
		],
		"description": "return:GUIStyle des: Style used by default for the background part of GUI.VerticalSlider controls."
	}
,
	"GUISkin.verticalSliderThumb": {
		"prefix": "GUISkin.verticalSliderThumb",
		"body": [
			"verticalSliderThumb"
		],
		"description": "return:GUIStyle des: Style used by default for the thumb that is dragged in GUI.VerticalSlider controls."
	}
,
	"GUISkin.window": {
		"prefix": "GUISkin.window",
		"body": [
			"window"
		],
		"description": "return:GUIStyle des: Style used by default for Window controls (SA GUI.Window)."
	}
,
	"GUISkin.FindStyle": {
		"prefix": "GUISkin.FindStyle",
		"body": [
			"FindStyle($1)"
		],
		"description": "public GUIStyle FindStyle(string styleName); des: Try to search for a GUIStyle. This functions returns NULL and does not give an error."
	}
,
	"GUISkin.GetStyle": {
		"prefix": "GUISkin.GetStyle",
		"body": [
			"GetStyle($1)"
		],
		"description": "public GUIStyle GetStyle(string styleName); des: Get a named GUIStyle."
	}
,
	"GUISkin.hideFlags": {
		"prefix": "GUISkin.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"GUISkin.name": {
		"prefix": "GUISkin.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"GUISkin.GetInstanceID": {
		"prefix": "GUISkin.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"GUISkin.ToString": {
		"prefix": "GUISkin.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"GUISkin.Destroy": {
		"prefix": "GUISkin.Destroy",
		"body": [
			"GUISkin.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"GUISkin.DestroyImmediate": {
		"prefix": "GUISkin.DestroyImmediate",
		"body": [
			"GUISkin.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"GUISkin.DontDestroyOnLoad": {
		"prefix": "GUISkin.DontDestroyOnLoad",
		"body": [
			"GUISkin.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"GUISkin.FindObjectOfType": {
		"prefix": "GUISkin.FindObjectOfType",
		"body": [
			"GUISkin.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"GUISkin.FindObjectsOfType": {
		"prefix": "GUISkin.FindObjectsOfType",
		"body": [
			"GUISkin.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"GUISkin.Instantiate": {
		"prefix": "GUISkin.Instantiate",
		"body": [
			"GUISkin.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"GUISkin.CreateInstance": {
		"prefix": "GUISkin.CreateInstance",
		"body": [
			"GUISkin.CreateInstance"
		],
		"description": "public static ScriptableObject CreateInstance(string className); public static ScriptableObject CreateInstance(Type type); public static T CreateInstance(); des: Creates an instance of a scriptable object."
	}
,
	"GUISkin.Awake": {
		"prefix": "GUISkin.Awake",
		"body": [
			"Awake"
		],
		"description": "This function is called when the ScriptableObject script is started."
	}
,
	"GUISkin.OnDestroy": {
		"prefix": "GUISkin.OnDestroy",
		"body": [
			"OnDestroy"
		],
		"description": "This function is called when the scriptable object will be destroyed."
	}
,
	"GUISkin.OnDisable": {
		"prefix": "GUISkin.OnDisable",
		"body": [
			"OnDisable"
		],
		"description": "This function is called when the scriptable object goes out of scope."
	}
,
	"GUISkin.OnEnable": {
		"prefix": "GUISkin.OnEnable",
		"body": [
			"OnEnable"
		],
		"description": "This function is called when the object is loaded."
	}
,
	"GUIStyle.active": {
		"prefix": "GUIStyle.active",
		"body": [
			"active"
		],
		"description": "return:GUIStyleState des: Rendering settings for when the control is pressed down."
	}
,
	"GUIStyle.alignment": {
		"prefix": "GUIStyle.alignment",
		"body": [
			"alignment"
		],
		"description": "return:TextAnchor des: Text alignment."
	}
,
	"GUIStyle.border": {
		"prefix": "GUIStyle.border",
		"body": [
			"border"
		],
		"description": "return:RectOffset des: The borders of all background images."
	}
,
	"GUIStyle.clipping": {
		"prefix": "GUIStyle.clipping",
		"body": [
			"clipping"
		],
		"description": "return:TextClipping des: What to do when the contents to be rendered is too large to fit within the area given."
	}
,
	"GUIStyle.contentOffset": {
		"prefix": "GUIStyle.contentOffset",
		"body": [
			"contentOffset"
		],
		"description": "return:Vector2 des: Pixel offset to apply to the content of this GUIstyle."
	}
,
	"GUIStyle.fixedHeight": {
		"prefix": "GUIStyle.fixedHeight",
		"body": [
			"fixedHeight"
		],
		"description": "return:float des: If non-0, any GUI elements rendered with this style will have the height specified here."
	}
,
	"GUIStyle.fixedWidth": {
		"prefix": "GUIStyle.fixedWidth",
		"body": [
			"fixedWidth"
		],
		"description": "return:float des: If non-0, any GUI elements rendered with this style will have the width specified here."
	}
,
	"GUIStyle.focused": {
		"prefix": "GUIStyle.focused",
		"body": [
			"focused"
		],
		"description": "return:GUIStyleState des: Rendering settings for when the element has keyboard focus."
	}
,
	"GUIStyle.font": {
		"prefix": "GUIStyle.font",
		"body": [
			"font"
		],
		"description": "return:Font des: The font to use for rendering. If null, the default font for the current GUISkin is used instead."
	}
,
	"GUIStyle.fontSize": {
		"prefix": "GUIStyle.fontSize",
		"body": [
			"fontSize"
		],
		"description": "return:int des: The font size to use (for dynamic fonts)."
	}
,
	"GUIStyle.fontStyle": {
		"prefix": "GUIStyle.fontStyle",
		"body": [
			"fontStyle"
		],
		"description": "return:FontStyle des: The font style to use (for dynamic fonts)."
	}
,
	"GUIStyle.hover": {
		"prefix": "GUIStyle.hover",
		"body": [
			"hover"
		],
		"description": "return:GUIStyleState des: Rendering settings for when the mouse is hovering over the control."
	}
,
	"GUIStyle.imagePosition": {
		"prefix": "GUIStyle.imagePosition",
		"body": [
			"imagePosition"
		],
		"description": "return:ImagePosition des: How image and text of the GUIContent is combined."
	}
,
	"GUIStyle.lineHeight": {
		"prefix": "GUIStyle.lineHeight",
		"body": [
			"lineHeight"
		],
		"description": "return:float des: The height of one line of text with this style, measured in pixels. (Read Only)"
	}
,
	"GUIStyle.margin": {
		"prefix": "GUIStyle.margin",
		"body": [
			"margin"
		],
		"description": "return:RectOffset des: The margins between elements rendered in this style and any other GUI elements."
	}
,
	"GUIStyle.name": {
		"prefix": "GUIStyle.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of this GUIStyle. Used for getting them based on name."
	}
,
	"GUIStyle.normal": {
		"prefix": "GUIStyle.normal",
		"body": [
			"normal"
		],
		"description": "return:GUIStyleState des: Rendering settings for when the component is displayed normally."
	}
,
	"GUIStyle.onActive": {
		"prefix": "GUIStyle.onActive",
		"body": [
			"onActive"
		],
		"description": "return:GUIStyleState des: Rendering settings for when the element is turned on and pressed down."
	}
,
	"GUIStyle.onFocused": {
		"prefix": "GUIStyle.onFocused",
		"body": [
			"onFocused"
		],
		"description": "return:GUIStyleState des: Rendering settings for when the element has keyboard and is turned on."
	}
,
	"GUIStyle.onHover": {
		"prefix": "GUIStyle.onHover",
		"body": [
			"onHover"
		],
		"description": "return:GUIStyleState des: Rendering settings for when the control is turned on and the mouse is hovering it."
	}
,
	"GUIStyle.onNormal": {
		"prefix": "GUIStyle.onNormal",
		"body": [
			"onNormal"
		],
		"description": "return:GUIStyleState des: Rendering settings for when the control is turned on."
	}
,
	"GUIStyle.overflow": {
		"prefix": "GUIStyle.overflow",
		"body": [
			"overflow"
		],
		"description": "return:RectOffset des: Extra space to be added to the background image."
	}
,
	"GUIStyle.padding": {
		"prefix": "GUIStyle.padding",
		"body": [
			"padding"
		],
		"description": "return:RectOffset des: Space from the edge of GUIStyle to the start of the contents."
	}
,
	"GUIStyle.richText": {
		"prefix": "GUIStyle.richText",
		"body": [
			"richText"
		],
		"description": "return:bool des: Enable HTML-style tags for Text Formatting Markup."
	}
,
	"GUIStyle.stretchHeight": {
		"prefix": "GUIStyle.stretchHeight",
		"body": [
			"stretchHeight"
		],
		"description": "return:bool des: Can GUI elements of this style be stretched vertically for better layout?"
	}
,
	"GUIStyle.stretchWidth": {
		"prefix": "GUIStyle.stretchWidth",
		"body": [
			"stretchWidth"
		],
		"description": "return:bool des: Can GUI elements of this style be stretched horizontally for better layouting?"
	}
,
	"GUIStyle.wordWrap": {
		"prefix": "GUIStyle.wordWrap",
		"body": [
			"wordWrap"
		],
		"description": "return:bool des: Should the text be wordwrapped?"
	}
,
	"GUIStyle.CalcHeight": {
		"prefix": "GUIStyle.CalcHeight",
		"body": [
			"CalcHeight($1)"
		],
		"description": "public float CalcHeight(GUIContent content, float width); des: How tall this element will be when rendered with content and a specific width."
	}
,
	"GUIStyle.CalcMinMaxWidth": {
		"prefix": "GUIStyle.CalcMinMaxWidth",
		"body": [
			"CalcMinMaxWidth($1)"
		],
		"description": "public void CalcMinMaxWidth(GUIContent content, out float minWidth, out float maxWidth); des: Calculate the minimum and maximum widths for this style rendered with content."
	}
,
	"GUIStyle.CalcScreenSize": {
		"prefix": "GUIStyle.CalcScreenSize",
		"body": [
			"CalcScreenSize($1)"
		],
		"description": "public Vector2 CalcScreenSize(Vector2 contentSize); des: Calculate the size of an element formatted with this style, and a given space to content."
	}
,
	"GUIStyle.CalcSize": {
		"prefix": "GUIStyle.CalcSize",
		"body": [
			"CalcSize($1)"
		],
		"description": "public Vector2 CalcSize(GUIContent content); des: Calculate the size of some content if it is rendered with this style."
	}
,
	"GUIStyle.Draw": {
		"prefix": "GUIStyle.Draw",
		"body": [
			"Draw($1)"
		],
		"description": "public void Draw(Rect position, bool isHover, bool isActive, bool on, bool hasKeyboardFocus); public void Draw(Rect position, string text, bool isHover, bool isActive, bool on, bool hasKeyboardFocus); public void Draw(Rect position, Texture image, bool isHover, bool isActive, bool on, bool hasKeyboardFocus); public void Draw(Rect position, GUIContent content, int controlID); public void Draw(Rect position, GUIContent content, int controlID, bool on); public void Draw(Rect position, GUIContent content, bool isHover, bool isActive, bool on, bool hasKeyboardFocus); des: Draw this GUIStyle on to the screen, internal version."
	}
,
	"GUIStyle.DrawCursor": {
		"prefix": "GUIStyle.DrawCursor",
		"body": [
			"DrawCursor($1)"
		],
		"description": "public void DrawCursor(Rect position, GUIContent content, int controlID, int character); des: Draw this GUIStyle with selected content."
	}
,
	"GUIStyle.DrawWithTextSelection": {
		"prefix": "GUIStyle.DrawWithTextSelection",
		"body": [
			"DrawWithTextSelection($1)"
		],
		"description": "public void DrawWithTextSelection(Rect position, GUIContent content, int controlID, int firstSelectedCharacter, int lastSelectedCharacter); des: Draw this GUIStyle with selected content."
	}
,
	"GUIStyle.GetCursorPixelPosition": {
		"prefix": "GUIStyle.GetCursorPixelPosition",
		"body": [
			"GetCursorPixelPosition($1)"
		],
		"description": "public Vector2 GetCursorPixelPosition(Rect position, GUIContent content, int cursorStringIndex); des: Get the pixel position of a given string index."
	}
,
	"GUIStyle.GetCursorStringIndex": {
		"prefix": "GUIStyle.GetCursorStringIndex",
		"body": [
			"GetCursorStringIndex($1)"
		],
		"description": "public int GetCursorStringIndex(Rect position, GUIContent content, Vector2 cursorPixelPosition); des: Get the cursor position (indexing into contents.text) when the user clicked at cursorPixelPosition."
	}
,
	"GUIStyleState.background": {
		"prefix": "GUIStyleState.background",
		"body": [
			"background"
		],
		"description": "return:Texture2D des: The background image used by GUI elements in this given state."
	}
,
	"GUIStyleState.scaledBackgrounds": {
		"prefix": "GUIStyleState.scaledBackgrounds",
		"body": [
			"scaledBackgrounds"
		],
		"description": "return:Texture2D[] des: Background images used by this state when on a high-resolution screen. It should either be left empty, or contain a single image that is exactly twice the resolution of background. This is only used by the editor. The field is not copied to player data, and is not accessible from player code."
	}
,
	"GUIStyleState.textColor": {
		"prefix": "GUIStyleState.textColor",
		"body": [
			"textColor"
		],
		"description": "return:Color des: The text color used by GUI elements in this state."
	}
,
	"GUIText.enabled": {
		"prefix": "GUIText.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"GUIText.isActiveAndEnabled": {
		"prefix": "GUIText.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"GUIText.gameObject": {
		"prefix": "GUIText.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"GUIText.tag": {
		"prefix": "GUIText.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"GUIText.transform": {
		"prefix": "GUIText.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"GUIText.hideFlags": {
		"prefix": "GUIText.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"GUIText.name": {
		"prefix": "GUIText.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"GUIText.BroadcastMessage": {
		"prefix": "GUIText.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"GUIText.CompareTag": {
		"prefix": "GUIText.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"GUIText.GetComponent": {
		"prefix": "GUIText.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"GUIText.GetComponentInChildren": {
		"prefix": "GUIText.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"GUIText.GetComponentInParent": {
		"prefix": "GUIText.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"GUIText.GetComponents": {
		"prefix": "GUIText.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"GUIText.GetComponentsInChildren": {
		"prefix": "GUIText.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"GUIText.GetComponentsInParent": {
		"prefix": "GUIText.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"GUIText.SendMessage": {
		"prefix": "GUIText.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"GUIText.SendMessageUpwards": {
		"prefix": "GUIText.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"GUIText.GetScreenRect": {
		"prefix": "GUIText.GetScreenRect",
		"body": [
			"GetScreenRect($1)"
		],
		"description": "public Rect GetScreenRect(Camera camera = null); des: Returns bounding rectangle of GUIElement in screen coordinates."
	}
,
	"GUIText.HitTest": {
		"prefix": "GUIText.HitTest",
		"body": [
			"HitTest($1)"
		],
		"description": "public bool HitTest(Vector3 screenPosition, Camera camera = null); des: Is a point on screen inside the element?"
	}
,
	"GUIText.GetInstanceID": {
		"prefix": "GUIText.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"GUIText.ToString": {
		"prefix": "GUIText.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"GUIText.Destroy": {
		"prefix": "GUIText.Destroy",
		"body": [
			"GUIText.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"GUIText.DestroyImmediate": {
		"prefix": "GUIText.DestroyImmediate",
		"body": [
			"GUIText.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"GUIText.DontDestroyOnLoad": {
		"prefix": "GUIText.DontDestroyOnLoad",
		"body": [
			"GUIText.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"GUIText.FindObjectOfType": {
		"prefix": "GUIText.FindObjectOfType",
		"body": [
			"GUIText.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"GUIText.FindObjectsOfType": {
		"prefix": "GUIText.FindObjectsOfType",
		"body": [
			"GUIText.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"GUIText.Instantiate": {
		"prefix": "GUIText.Instantiate",
		"body": [
			"GUIText.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"GUITexture.enabled": {
		"prefix": "GUITexture.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"GUITexture.isActiveAndEnabled": {
		"prefix": "GUITexture.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"GUITexture.gameObject": {
		"prefix": "GUITexture.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"GUITexture.tag": {
		"prefix": "GUITexture.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"GUITexture.transform": {
		"prefix": "GUITexture.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"GUITexture.hideFlags": {
		"prefix": "GUITexture.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"GUITexture.name": {
		"prefix": "GUITexture.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"GUITexture.BroadcastMessage": {
		"prefix": "GUITexture.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"GUITexture.CompareTag": {
		"prefix": "GUITexture.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"GUITexture.GetComponent": {
		"prefix": "GUITexture.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"GUITexture.GetComponentInChildren": {
		"prefix": "GUITexture.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"GUITexture.GetComponentInParent": {
		"prefix": "GUITexture.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"GUITexture.GetComponents": {
		"prefix": "GUITexture.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"GUITexture.GetComponentsInChildren": {
		"prefix": "GUITexture.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"GUITexture.GetComponentsInParent": {
		"prefix": "GUITexture.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"GUITexture.SendMessage": {
		"prefix": "GUITexture.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"GUITexture.SendMessageUpwards": {
		"prefix": "GUITexture.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"GUITexture.GetScreenRect": {
		"prefix": "GUITexture.GetScreenRect",
		"body": [
			"GetScreenRect($1)"
		],
		"description": "public Rect GetScreenRect(Camera camera = null); des: Returns bounding rectangle of GUIElement in screen coordinates."
	}
,
	"GUITexture.HitTest": {
		"prefix": "GUITexture.HitTest",
		"body": [
			"HitTest($1)"
		],
		"description": "public bool HitTest(Vector3 screenPosition, Camera camera = null); des: Is a point on screen inside the element?"
	}
,
	"GUITexture.GetInstanceID": {
		"prefix": "GUITexture.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"GUITexture.ToString": {
		"prefix": "GUITexture.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"GUITexture.Destroy": {
		"prefix": "GUITexture.Destroy",
		"body": [
			"GUITexture.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"GUITexture.DestroyImmediate": {
		"prefix": "GUITexture.DestroyImmediate",
		"body": [
			"GUITexture.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"GUITexture.DontDestroyOnLoad": {
		"prefix": "GUITexture.DontDestroyOnLoad",
		"body": [
			"GUITexture.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"GUITexture.FindObjectOfType": {
		"prefix": "GUITexture.FindObjectOfType",
		"body": [
			"GUITexture.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"GUITexture.FindObjectsOfType": {
		"prefix": "GUITexture.FindObjectsOfType",
		"body": [
			"GUITexture.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"GUITexture.Instantiate": {
		"prefix": "GUITexture.Instantiate",
		"body": [
			"GUITexture.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"GUIUtility.AlignRectToDevice": {
		"prefix": "GUIUtility.AlignRectToDevice",
		"body": [
			"GUIUtility.AlignRectToDevice"
		],
		"description": "public static Rect AlignRectToDevice(Rect rect); public static Rect AlignRectToDevice(Rect rect, out int widthInPixels, out int heightInPixels); des: Align a local space rectangle to the pixel grid."
	}
,
	"GUIUtility.ExitGUI": {
		"prefix": "GUIUtility.ExitGUI",
		"body": [
			"GUIUtility.ExitGUI"
		],
		"description": "public static void ExitGUI(); des: Puts the GUI in a state that will prevent all subsequent immediate mode GUI functions from evaluating for the remainder of the GUI loop by throwing an ExitGUIException."
	}
,
	"GUIUtility.GetControlID": {
		"prefix": "GUIUtility.GetControlID",
		"body": [
			"GUIUtility.GetControlID"
		],
		"description": "public static int GetControlID(FocusType focus); public static int GetControlID(FocusType focus, Rect position); public static int GetControlID(int hint, FocusType focus); public static int GetControlID(int hint, FocusType focusType, Rect rect); public static int GetControlID(GUIContent contents, FocusType focus); public static int GetControlID(GUIContent contents, FocusType focus, Rect position); des: Get a unique ID for a control."
	}
,
	"GUIUtility.GetStateObject": {
		"prefix": "GUIUtility.GetStateObject",
		"body": [
			"GUIUtility.GetStateObject"
		],
		"description": "public static object GetStateObject(Type t, int controlID); des: Get a state object from a controlID."
	}
,
	"GUIUtility.GUIToScreenPoint": {
		"prefix": "GUIUtility.GUIToScreenPoint",
		"body": [
			"GUIUtility.GUIToScreenPoint"
		],
		"description": "public static Vector2 GUIToScreenPoint(Vector2 guiPoint); des: Convert a point from GUI position to screen space."
	}
,
	"GUIUtility.QueryStateObject": {
		"prefix": "GUIUtility.QueryStateObject",
		"body": [
			"GUIUtility.QueryStateObject"
		],
		"description": "public static object QueryStateObject(Type t, int controlID); des: Get an existing state object from a controlID."
	}
,
	"GUIUtility.RotateAroundPivot": {
		"prefix": "GUIUtility.RotateAroundPivot",
		"body": [
			"GUIUtility.RotateAroundPivot"
		],
		"description": "public static void RotateAroundPivot(float angle, Vector2 pivotPoint); des: Helper function to rotate the GUI around a point."
	}
,
	"GUIUtility.ScaleAroundPivot": {
		"prefix": "GUIUtility.ScaleAroundPivot",
		"body": [
			"GUIUtility.ScaleAroundPivot"
		],
		"description": "public static void ScaleAroundPivot(Vector2 scale, Vector2 pivotPoint); des: Helper function to scale the GUI around a point."
	}
,
	"GUIUtility.ScreenToGUIPoint": {
		"prefix": "GUIUtility.ScreenToGUIPoint",
		"body": [
			"GUIUtility.ScreenToGUIPoint"
		],
		"description": "public static Vector2 ScreenToGUIPoint(Vector2 screenPoint); des: Convert a point from screen space to GUI position."
	}
,
	"Gyroscope.attitude": {
		"prefix": "Gyroscope.attitude",
		"body": [
			"attitude"
		],
		"description": "return:Quaternion des: Returns the attitude (ie, orientation in space) of the device."
	}
,
	"Gyroscope.enabled": {
		"prefix": "Gyroscope.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Sets or retrieves the enabled status of this gyroscope."
	}
,
	"Gyroscope.gravity": {
		"prefix": "Gyroscope.gravity",
		"body": [
			"gravity"
		],
		"description": "return:Vector3 des: Returns the gravity acceleration vector expressed in the device's reference frame."
	}
,
	"Gyroscope.rotationRate": {
		"prefix": "Gyroscope.rotationRate",
		"body": [
			"rotationRate"
		],
		"description": "return:Vector3 des: Returns rotation rate as measured by the device's gyroscope."
	}
,
	"Gyroscope.rotationRateUnbiased": {
		"prefix": "Gyroscope.rotationRateUnbiased",
		"body": [
			"rotationRateUnbiased"
		],
		"description": "return:Vector3 des: Returns unbiased rotation rate as measured by the device's gyroscope."
	}
,
	"Gyroscope.updateInterval": {
		"prefix": "Gyroscope.updateInterval",
		"body": [
			"updateInterval"
		],
		"description": "return:float des: Sets or retrieves gyroscope interval in seconds."
	}
,
	"Gyroscope.userAcceleration": {
		"prefix": "Gyroscope.userAcceleration",
		"body": [
			"userAcceleration"
		],
		"description": "return:Vector3 des: Returns the acceleration that the user is giving to the device."
	}
,
	"Handheld.GetActivityIndicatorStyle": {
		"prefix": "Handheld.GetActivityIndicatorStyle",
		"body": [
			"Handheld.GetActivityIndicatorStyle"
		],
		"description": "public static int GetActivityIndicatorStyle(); des: Gets the current activity indicator style."
	}
,
	"Handheld.PlayFullScreenMovie": {
		"prefix": "Handheld.PlayFullScreenMovie",
		"body": [
			"Handheld.PlayFullScreenMovie"
		],
		"description": "public static bool PlayFullScreenMovie(string path, Color bgColor = Color.black, FullScreenMovieControlMode controlMode = FullScreenMovieControlMode.Full, FullScreenMovieScalingMode scalingMode = FullScreenMovieScalingMode.AspectFit); des: Plays a full-screen movie."
	}
,
	"Handheld.SetActivityIndicatorStyle": {
		"prefix": "Handheld.SetActivityIndicatorStyle",
		"body": [
			"Handheld.SetActivityIndicatorStyle"
		],
		"description": "public static void SetActivityIndicatorStyle(AndroidActivityIndicatorStyle style);  des: Sets the desired activity indicator style."
	}
,
	"Handheld.StartActivityIndicator": {
		"prefix": "Handheld.StartActivityIndicator",
		"body": [
			"Handheld.StartActivityIndicator"
		],
		"description": "public static void StartActivityIndicator(); des: Starts os activity indicator."
	}
,
	"Handheld.StopActivityIndicator": {
		"prefix": "Handheld.StopActivityIndicator",
		"body": [
			"Handheld.StopActivityIndicator"
		],
		"description": "public static void StopActivityIndicator(); des: Stops os activity indicator."
	}
,
	"Handheld.Vibrate": {
		"prefix": "Handheld.Vibrate",
		"body": [
			"Handheld.Vibrate"
		],
		"description": "public static void Vibrate(); des: Triggers device vibration."
	}
,
	"Hash128.isValid": {
		"prefix": "Hash128.isValid",
		"body": [
			"isValid"
		],
		"description": "return:bool des: Get if the hash value is valid or not. (Read Only)"
	}
,
	"Hash128.ToString": {
		"prefix": "Hash128.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Convert Hash128 to string."
	}
,
	"Hash128.Compute": {
		"prefix": "Hash128.Compute",
		"body": [
			"Hash128.Compute"
		],
		"description": "public static Hash128 Compute(string hashString); des: Compute a hash of the input string."
	}
,
	"Hash128.Parse": {
		"prefix": "Hash128.Parse",
		"body": [
			"Hash128.Parse"
		],
		"description": "public static Hash128 Parse(string hashString); des: Convert the input string to Hash128."
	}
,
	"HingeJoint.angle": {
		"prefix": "HingeJoint.angle",
		"body": [
			"angle"
		],
		"description": "return:float des: The current angle in degrees of the joint relative to its rest position. (Read Only)"
	}
,
	"HingeJoint.limits": {
		"prefix": "HingeJoint.limits",
		"body": [
			"limits"
		],
		"description": "return:JointLimits des: Limit of angular rotation (in degrees) on the hinge joint."
	}
,
	"HingeJoint.motor": {
		"prefix": "HingeJoint.motor",
		"body": [
			"motor"
		],
		"description": "return:JointMotor des: The motor will apply a force up to a maximum force to achieve the target velocity in degrees per second."
	}
,
	"HingeJoint.spring": {
		"prefix": "HingeJoint.spring",
		"body": [
			"spring"
		],
		"description": "return:JointSpring des: The spring attempts to reach a target angle by adding spring and damping forces."
	}
,
	"HingeJoint.useLimits": {
		"prefix": "HingeJoint.useLimits",
		"body": [
			"useLimits"
		],
		"description": "return:bool des: Enables the joint's limits. Disabled by default."
	}
,
	"HingeJoint.useMotor": {
		"prefix": "HingeJoint.useMotor",
		"body": [
			"useMotor"
		],
		"description": "return:bool des: Enables the joint's motor. Disabled by default."
	}
,
	"HingeJoint.useSpring": {
		"prefix": "HingeJoint.useSpring",
		"body": [
			"useSpring"
		],
		"description": "return:bool des: Enables the joint's spring. Disabled by default."
	}
,
	"HingeJoint.velocity": {
		"prefix": "HingeJoint.velocity",
		"body": [
			"velocity"
		],
		"description": "return:float des: The angular velocity of the joint in degrees per second. (Read Only)"
	}
,
	"HingeJoint.gameObject": {
		"prefix": "HingeJoint.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"HingeJoint.tag": {
		"prefix": "HingeJoint.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"HingeJoint.transform": {
		"prefix": "HingeJoint.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"HingeJoint.anchor": {
		"prefix": "HingeJoint.anchor",
		"body": [
			"anchor"
		],
		"description": "return:Vector3 des: The Position of the anchor around which the joints motion is constrained."
	}
,
	"HingeJoint.autoConfigureConnectedAnchor": {
		"prefix": "HingeJoint.autoConfigureConnectedAnchor",
		"body": [
			"autoConfigureConnectedAnchor"
		],
		"description": "return:bool des: Should the connectedAnchor be calculated automatically?"
	}
,
	"HingeJoint.axis": {
		"prefix": "HingeJoint.axis",
		"body": [
			"axis"
		],
		"description": "return:Vector3 des: The Direction of the axis around which the body is constrained."
	}
,
	"HingeJoint.breakForce": {
		"prefix": "HingeJoint.breakForce",
		"body": [
			"breakForce"
		],
		"description": "return:float des: The force that needs to be applied for this joint to break."
	}
,
	"HingeJoint.breakTorque": {
		"prefix": "HingeJoint.breakTorque",
		"body": [
			"breakTorque"
		],
		"description": "return:float des: The torque that needs to be applied for this joint to break."
	}
,
	"HingeJoint.connectedAnchor": {
		"prefix": "HingeJoint.connectedAnchor",
		"body": [
			"connectedAnchor"
		],
		"description": "return:Vector3 des: Position of the anchor relative to the connected Rigidbody."
	}
,
	"HingeJoint.connectedBody": {
		"prefix": "HingeJoint.connectedBody",
		"body": [
			"connectedBody"
		],
		"description": "return:Rigidbody des: A reference to another rigidbody this joint connects to."
	}
,
	"HingeJoint.connectedMassScale": {
		"prefix": "HingeJoint.connectedMassScale",
		"body": [
			"connectedMassScale"
		],
		"description": "return:float des: The scale to apply to the inverse mass and inertia tensor of the connected body prior to solving the constraints."
	}
,
	"HingeJoint.currentForce": {
		"prefix": "HingeJoint.currentForce",
		"body": [
			"currentForce"
		],
		"description": "return:Vector3 des: The force applied by the solver to satisfy all constraints."
	}
,
	"HingeJoint.currentTorque": {
		"prefix": "HingeJoint.currentTorque",
		"body": [
			"currentTorque"
		],
		"description": "return:Vector3 des: The torque applied by the solver to satisfy all constraints."
	}
,
	"HingeJoint.enableCollision": {
		"prefix": "HingeJoint.enableCollision",
		"body": [
			"enableCollision"
		],
		"description": "return:bool des: Enable collision between bodies connected with the joint."
	}
,
	"HingeJoint.enablePreprocessing": {
		"prefix": "HingeJoint.enablePreprocessing",
		"body": [
			"enablePreprocessing"
		],
		"description": "return:bool des: Toggle preprocessing for this joint."
	}
,
	"HingeJoint.massScale": {
		"prefix": "HingeJoint.massScale",
		"body": [
			"massScale"
		],
		"description": "return:float des: The scale to apply to the inverse mass and inertia tensor of the body prior to solving the constraints."
	}
,
	"HingeJoint.hideFlags": {
		"prefix": "HingeJoint.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"HingeJoint.name": {
		"prefix": "HingeJoint.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"HingeJoint.BroadcastMessage": {
		"prefix": "HingeJoint.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"HingeJoint.CompareTag": {
		"prefix": "HingeJoint.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"HingeJoint.GetComponent": {
		"prefix": "HingeJoint.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"HingeJoint.GetComponentInChildren": {
		"prefix": "HingeJoint.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"HingeJoint.GetComponentInParent": {
		"prefix": "HingeJoint.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"HingeJoint.GetComponents": {
		"prefix": "HingeJoint.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"HingeJoint.GetComponentsInChildren": {
		"prefix": "HingeJoint.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"HingeJoint.GetComponentsInParent": {
		"prefix": "HingeJoint.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"HingeJoint.SendMessage": {
		"prefix": "HingeJoint.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"HingeJoint.SendMessageUpwards": {
		"prefix": "HingeJoint.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"HingeJoint.GetInstanceID": {
		"prefix": "HingeJoint.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"HingeJoint.ToString": {
		"prefix": "HingeJoint.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"HingeJoint.Destroy": {
		"prefix": "HingeJoint.Destroy",
		"body": [
			"HingeJoint.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"HingeJoint.DestroyImmediate": {
		"prefix": "HingeJoint.DestroyImmediate",
		"body": [
			"HingeJoint.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"HingeJoint.DontDestroyOnLoad": {
		"prefix": "HingeJoint.DontDestroyOnLoad",
		"body": [
			"HingeJoint.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"HingeJoint.FindObjectOfType": {
		"prefix": "HingeJoint.FindObjectOfType",
		"body": [
			"HingeJoint.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"HingeJoint.FindObjectsOfType": {
		"prefix": "HingeJoint.FindObjectsOfType",
		"body": [
			"HingeJoint.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"HingeJoint.Instantiate": {
		"prefix": "HingeJoint.Instantiate",
		"body": [
			"HingeJoint.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"HingeJoint.OnJointBreak": {
		"prefix": "HingeJoint.OnJointBreak",
		"body": [
			"OnJointBreak"
		],
		"description": "Called when a joint attached to the same game object broke."
	}
,
	"HingeJoint2D.jointAngle": {
		"prefix": "HingeJoint2D.jointAngle",
		"body": [
			"jointAngle"
		],
		"description": "return:float des: The current joint angle (in degrees) with respect to the reference angle."
	}
,
	"HingeJoint2D.jointSpeed": {
		"prefix": "HingeJoint2D.jointSpeed",
		"body": [
			"jointSpeed"
		],
		"description": "return:float des: The current joint speed."
	}
,
	"HingeJoint2D.limits": {
		"prefix": "HingeJoint2D.limits",
		"body": [
			"limits"
		],
		"description": "return:JointAngleLimits2D des: Limit of angular rotation (in degrees) on the joint."
	}
,
	"HingeJoint2D.limitState": {
		"prefix": "HingeJoint2D.limitState",
		"body": [
			"limitState"
		],
		"description": "return:JointLimitState2D des: Gets the state of the joint limit."
	}
,
	"HingeJoint2D.motor": {
		"prefix": "HingeJoint2D.motor",
		"body": [
			"motor"
		],
		"description": "return:JointMotor2D des: Parameters for the motor force applied to the joint."
	}
,
	"HingeJoint2D.referenceAngle": {
		"prefix": "HingeJoint2D.referenceAngle",
		"body": [
			"referenceAngle"
		],
		"description": "return:float des: The angle (in degrees) referenced between the two bodies used as the constraint for the joint."
	}
,
	"HingeJoint2D.useLimits": {
		"prefix": "HingeJoint2D.useLimits",
		"body": [
			"useLimits"
		],
		"description": "return:bool des: Should limits be placed on the range of rotation?"
	}
,
	"HingeJoint2D.useMotor": {
		"prefix": "HingeJoint2D.useMotor",
		"body": [
			"useMotor"
		],
		"description": "return:bool des: Should the joint be rotated automatically by a motor torque?"
	}
,
	"HingeJoint2D.GetMotorTorque": {
		"prefix": "HingeJoint2D.GetMotorTorque",
		"body": [
			"GetMotorTorque($1)"
		],
		"description": "public float GetMotorTorque(float timeStep); des: Gets the motor torque of the joint given the specified timestep."
	}
,
	"HingeJoint2D.anchor": {
		"prefix": "HingeJoint2D.anchor",
		"body": [
			"anchor"
		],
		"description": "return:Vector2 des: The joint's anchor point on the object that has the joint component."
	}
,
	"HingeJoint2D.autoConfigureConnectedAnchor": {
		"prefix": "HingeJoint2D.autoConfigureConnectedAnchor",
		"body": [
			"autoConfigureConnectedAnchor"
		],
		"description": "return:bool des: Should the connectedAnchor be calculated automatically?"
	}
,
	"HingeJoint2D.connectedAnchor": {
		"prefix": "HingeJoint2D.connectedAnchor",
		"body": [
			"connectedAnchor"
		],
		"description": "return:Vector2 des: The joint's anchor point on the second object (ie, the one which doesn't have the joint component)."
	}
,
	"HingeJoint2D.enabled": {
		"prefix": "HingeJoint2D.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"HingeJoint2D.isActiveAndEnabled": {
		"prefix": "HingeJoint2D.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"HingeJoint2D.gameObject": {
		"prefix": "HingeJoint2D.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"HingeJoint2D.tag": {
		"prefix": "HingeJoint2D.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"HingeJoint2D.transform": {
		"prefix": "HingeJoint2D.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"HingeJoint2D.attachedRigidbody": {
		"prefix": "HingeJoint2D.attachedRigidbody",
		"body": [
			"attachedRigidbody"
		],
		"description": "return:Rigidbody2D des: The Rigidbody2D attached to the Joint2D."
	}
,
	"HingeJoint2D.breakForce": {
		"prefix": "HingeJoint2D.breakForce",
		"body": [
			"breakForce"
		],
		"description": "return:float des: The force that needs to be applied for this joint to break."
	}
,
	"HingeJoint2D.breakTorque": {
		"prefix": "HingeJoint2D.breakTorque",
		"body": [
			"breakTorque"
		],
		"description": "return:float des: The torque that needs to be applied for this joint to break."
	}
,
	"HingeJoint2D.connectedBody": {
		"prefix": "HingeJoint2D.connectedBody",
		"body": [
			"connectedBody"
		],
		"description": "return:Rigidbody2D des: The Rigidbody2D object to which the other end of the joint is attached (ie, the object without the joint component)."
	}
,
	"HingeJoint2D.enableCollision": {
		"prefix": "HingeJoint2D.enableCollision",
		"body": [
			"enableCollision"
		],
		"description": "return:bool des: Should the two rigid bodies connected with this joint collide with each other?"
	}
,
	"HingeJoint2D.reactionForce": {
		"prefix": "HingeJoint2D.reactionForce",
		"body": [
			"reactionForce"
		],
		"description": "return:Vector2 des: Gets the reaction force of the joint."
	}
,
	"HingeJoint2D.reactionTorque": {
		"prefix": "HingeJoint2D.reactionTorque",
		"body": [
			"reactionTorque"
		],
		"description": "return:float des: Gets the reaction torque of the joint."
	}
,
	"HingeJoint2D.hideFlags": {
		"prefix": "HingeJoint2D.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"HingeJoint2D.name": {
		"prefix": "HingeJoint2D.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"HingeJoint2D.BroadcastMessage": {
		"prefix": "HingeJoint2D.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"HingeJoint2D.CompareTag": {
		"prefix": "HingeJoint2D.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"HingeJoint2D.GetComponent": {
		"prefix": "HingeJoint2D.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"HingeJoint2D.GetComponentInChildren": {
		"prefix": "HingeJoint2D.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"HingeJoint2D.GetComponentInParent": {
		"prefix": "HingeJoint2D.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"HingeJoint2D.GetComponents": {
		"prefix": "HingeJoint2D.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"HingeJoint2D.GetComponentsInChildren": {
		"prefix": "HingeJoint2D.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"HingeJoint2D.GetComponentsInParent": {
		"prefix": "HingeJoint2D.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"HingeJoint2D.SendMessage": {
		"prefix": "HingeJoint2D.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"HingeJoint2D.SendMessageUpwards": {
		"prefix": "HingeJoint2D.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"HingeJoint2D.GetReactionForce": {
		"prefix": "HingeJoint2D.GetReactionForce",
		"body": [
			"GetReactionForce($1)"
		],
		"description": "public Vector2 GetReactionForce(float timeStep); des: Gets the reaction force of the joint given the specified timeStep."
	}
,
	"HingeJoint2D.GetReactionTorque": {
		"prefix": "HingeJoint2D.GetReactionTorque",
		"body": [
			"GetReactionTorque($1)"
		],
		"description": "public float GetReactionTorque(float timeStep); des: Gets the reaction torque of the joint given the specified timeStep."
	}
,
	"HingeJoint2D.GetInstanceID": {
		"prefix": "HingeJoint2D.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"HingeJoint2D.ToString": {
		"prefix": "HingeJoint2D.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"HingeJoint2D.Destroy": {
		"prefix": "HingeJoint2D.Destroy",
		"body": [
			"HingeJoint2D.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"HingeJoint2D.DestroyImmediate": {
		"prefix": "HingeJoint2D.DestroyImmediate",
		"body": [
			"HingeJoint2D.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"HingeJoint2D.DontDestroyOnLoad": {
		"prefix": "HingeJoint2D.DontDestroyOnLoad",
		"body": [
			"HingeJoint2D.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"HingeJoint2D.FindObjectOfType": {
		"prefix": "HingeJoint2D.FindObjectOfType",
		"body": [
			"HingeJoint2D.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"HingeJoint2D.FindObjectsOfType": {
		"prefix": "HingeJoint2D.FindObjectsOfType",
		"body": [
			"HingeJoint2D.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"HingeJoint2D.Instantiate": {
		"prefix": "HingeJoint2D.Instantiate",
		"body": [
			"HingeJoint2D.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"HingeJoint2D.OnJointBreak2D": {
		"prefix": "HingeJoint2D.OnJointBreak2D",
		"body": [
			"OnJointBreak2D"
		],
		"description": "Called when a Joint2D attached to the same game object breaks."
	}
,
	"HumanBone.boneName": {
		"prefix": "HumanBone.boneName",
		"body": [
			"boneName"
		],
		"description": "return:string des: The name of the bone to which the Mecanim human bone is mapped."
	}
,
	"HumanBone.humanName": {
		"prefix": "HumanBone.humanName",
		"body": [
			"humanName"
		],
		"description": "return:string des: The name of the Mecanim human bone to which the bone from the model is mapped."
	}
,
	"HumanBone.limit": {
		"prefix": "HumanBone.limit",
		"body": [
			"limit"
		],
		"description": "return:HumanLimit des: The rotation limits that define the muscle for this bone."
	}
,
	"HumanDescription.armStretch": {
		"prefix": "HumanDescription.armStretch",
		"body": [
			"armStretch"
		],
		"description": "return:float des: Amount by which the arm's length is allowed to stretch when using IK."
	}
,
	"HumanDescription.feetSpacing": {
		"prefix": "HumanDescription.feetSpacing",
		"body": [
			"feetSpacing"
		],
		"description": "return:float des: Modification to the minimum distance between the feet of a humanoid model."
	}
,
	"HumanDescription.hasTranslationDoF": {
		"prefix": "HumanDescription.hasTranslationDoF",
		"body": [
			"hasTranslationDoF"
		],
		"description": "return:bool des: True for any human that has a translation Degree of Freedom (DoF). It is set to false by default."
	}
,
	"HumanDescription.human": {
		"prefix": "HumanDescription.human",
		"body": [
			"human"
		],
		"description": "return:HumanBone[] des: Mapping between Mecanim bone names and bone names in the rig."
	}
,
	"HumanDescription.legStretch": {
		"prefix": "HumanDescription.legStretch",
		"body": [
			"legStretch"
		],
		"description": "return:float des: Amount by which the leg's length is allowed to stretch when using IK."
	}
,
	"HumanDescription.lowerArmTwist": {
		"prefix": "HumanDescription.lowerArmTwist",
		"body": [
			"lowerArmTwist"
		],
		"description": "return:float des: Defines how the lower arm's roll/twisting is distributed between the elbow and wrist joints."
	}
,
	"HumanDescription.lowerLegTwist": {
		"prefix": "HumanDescription.lowerLegTwist",
		"body": [
			"lowerLegTwist"
		],
		"description": "return:float des: Defines how the lower leg's roll/twisting is distributed between the knee and ankle."
	}
,
	"HumanDescription.skeleton": {
		"prefix": "HumanDescription.skeleton",
		"body": [
			"skeleton"
		],
		"description": "return:SkeletonBone[] des: List of bone Transforms to include in the model."
	}
,
	"HumanDescription.upperArmTwist": {
		"prefix": "HumanDescription.upperArmTwist",
		"body": [
			"upperArmTwist"
		],
		"description": "return:float des: Defines how the upper arm's roll/twisting is distributed between the shoulder and elbow joints."
	}
,
	"HumanDescription.upperLegTwist": {
		"prefix": "HumanDescription.upperLegTwist",
		"body": [
			"upperLegTwist"
		],
		"description": "return:float des: Defines how the upper leg's roll/twisting is distributed between the thigh and knee joints."
	}
,
	"HumanLimit.axisLength": {
		"prefix": "HumanLimit.axisLength",
		"body": [
			"axisLength"
		],
		"description": "return:float des: Length of the bone to which the limit is applied."
	}
,
	"HumanLimit.center": {
		"prefix": "HumanLimit.center",
		"body": [
			"center"
		],
		"description": "return:Vector3 des: The default orientation of a bone when no muscle action is applied."
	}
,
	"HumanLimit.max": {
		"prefix": "HumanLimit.max",
		"body": [
			"max"
		],
		"description": "return:Vector3 des: The maximum rotation away from the initial value that this muscle can apply."
	}
,
	"HumanLimit.min": {
		"prefix": "HumanLimit.min",
		"body": [
			"min"
		],
		"description": "return:Vector3 des: The maximum negative rotation away from the initial value that this muscle can apply."
	}
,
	"HumanLimit.useDefaultValues": {
		"prefix": "HumanLimit.useDefaultValues",
		"body": [
			"useDefaultValues"
		],
		"description": "return:bool des: Should this limit use the default values?"
	}
,
	"HumanPose.bodyPosition": {
		"prefix": "HumanPose.bodyPosition",
		"body": [
			"bodyPosition"
		],
		"description": "return:Vector3 des: The human body position for that pose."
	}
,
	"HumanPose.bodyRotation": {
		"prefix": "HumanPose.bodyRotation",
		"body": [
			"bodyRotation"
		],
		"description": "return:Quaternion des: The human body orientation for that pose."
	}
,
	"HumanPose.muscles": {
		"prefix": "HumanPose.muscles",
		"body": [
			"muscles"
		],
		"description": "return:float[] des: The array of muscle values for that pose."
	}
,
	"HumanPoseHandler.GetHumanPose": {
		"prefix": "HumanPoseHandler.GetHumanPose",
		"body": [
			"GetHumanPose($1)"
		],
		"description": "public void GetHumanPose(ref HumanPose humanPose); des: Gets a human pose from the handled avatar skeleton."
	}
,
	"HumanPoseHandler.SetHumanPose": {
		"prefix": "HumanPoseHandler.SetHumanPose",
		"body": [
			"SetHumanPose($1)"
		],
		"description": "public void SetHumanPose(ref HumanPose humanPose); des: Sets a human pose on the handled avatar skeleton."
	}
,
	"HumanTrait.BoneFromMuscle": {
		"prefix": "HumanTrait.BoneFromMuscle",
		"body": [
			"HumanTrait.BoneFromMuscle"
		],
		"description": "public static int BoneFromMuscle(int i); des: Return the bone to which a particular muscle is connected."
	}
,
	"HumanTrait.GetBoneDefaultHierarchyMass": {
		"prefix": "HumanTrait.GetBoneDefaultHierarchyMass",
		"body": [
			"HumanTrait.GetBoneDefaultHierarchyMass"
		],
		"description": "public static float GetBoneDefaultHierarchyMass(int i); des: Gets the bone hierarchy mass."
	}
,
	"HumanTrait.GetMuscleDefaultMax": {
		"prefix": "HumanTrait.GetMuscleDefaultMax",
		"body": [
			"HumanTrait.GetMuscleDefaultMax"
		],
		"description": "public static float GetMuscleDefaultMax(int i); des: Get the default maximum value of rotation for a muscle in degrees."
	}
,
	"HumanTrait.GetMuscleDefaultMin": {
		"prefix": "HumanTrait.GetMuscleDefaultMin",
		"body": [
			"HumanTrait.GetMuscleDefaultMin"
		],
		"description": "public static float GetMuscleDefaultMin(int i); des: Get the default minimum value of rotation for a muscle in degrees."
	}
,
	"HumanTrait.GetParentBone": {
		"prefix": "HumanTrait.GetParentBone",
		"body": [
			"HumanTrait.GetParentBone"
		],
		"description": "public static int GetParentBone(int i); des: Returns parent humanoid bone index of a bone."
	}
,
	"HumanTrait.MuscleFromBone": {
		"prefix": "HumanTrait.MuscleFromBone",
		"body": [
			"HumanTrait.MuscleFromBone"
		],
		"description": "public static int MuscleFromBone(int i, int dofIndex); des: Obtain the muscle index for a particular bone index and \"degree of freedom\"."
	}
,
	"HumanTrait.RequiredBone": {
		"prefix": "HumanTrait.RequiredBone",
		"body": [
			"HumanTrait.RequiredBone"
		],
		"description": "public static bool RequiredBone(int i); des: Is the bone a member of the minimal set of bones that Mecanim requires for a human model?"
	}
,
	"ImageConversion.EncodeToEXR": {
		"prefix": "ImageConversion.EncodeToEXR",
		"body": [
			"ImageConversion.EncodeToEXR"
		],
		"description": "public static byte[] EncodeToEXR(Texture2D tex, Texture2D.EXRFlags flags); des: Encodes this texture into the EXR format."
	}
,
	"ImageConversion.EncodeToJPG": {
		"prefix": "ImageConversion.EncodeToJPG",
		"body": [
			"ImageConversion.EncodeToJPG"
		],
		"description": "public static byte[] EncodeToJPG(Texture2D tex, int quality); public static byte[] EncodeToJPG(Texture2D tex); des: Encodes this texture into JPG format."
	}
,
	"ImageConversion.EncodeToPNG": {
		"prefix": "ImageConversion.EncodeToPNG",
		"body": [
			"ImageConversion.EncodeToPNG"
		],
		"description": "public static byte[] EncodeToPNG(Texture2D tex); des: Encodes this texture into PNG format."
	}
,
	"ImageConversion.LoadImage": {
		"prefix": "ImageConversion.LoadImage",
		"body": [
			"ImageConversion.LoadImage"
		],
		"description": "public static bool LoadImage(Texture2D tex, byte[] data, bool markNonReadable); des: Loads PNG/JPG image byte array into a texture."
	}
,
	"Input.GetAccelerationEvent": {
		"prefix": "Input.GetAccelerationEvent",
		"body": [
			"Input.GetAccelerationEvent"
		],
		"description": "public static AccelerationEvent GetAccelerationEvent(int index); des: Returns specific acceleration measurement which occurred during last frame. (Does not allocate temporary variables)."
	}
,
	"Input.GetAxis": {
		"prefix": "Input.GetAxis",
		"body": [
			"Input.GetAxis"
		],
		"description": "public static float GetAxis(string axisName); des: Returns the value of the virtual axis identified by axisName."
	}
,
	"Input.GetAxisRaw": {
		"prefix": "Input.GetAxisRaw",
		"body": [
			"Input.GetAxisRaw"
		],
		"description": "public static float GetAxisRaw(string axisName); des: Returns the value of the virtual axis identified by axisName with no smoothing filtering applied."
	}
,
	"Input.GetButton": {
		"prefix": "Input.GetButton",
		"body": [
			"Input.GetButton"
		],
		"description": "public static bool GetButton(string buttonName); des: Returns true while the virtual button identified by buttonName is held down."
	}
,
	"Input.GetButtonDown": {
		"prefix": "Input.GetButtonDown",
		"body": [
			"Input.GetButtonDown"
		],
		"description": "public static bool GetButtonDown(string buttonName); des: Returns true during the frame the user pressed down the virtual button identified by buttonName."
	}
,
	"Input.GetButtonUp": {
		"prefix": "Input.GetButtonUp",
		"body": [
			"Input.GetButtonUp"
		],
		"description": "public static bool GetButtonUp(string buttonName); des: Returns true the first frame the user releases the virtual button identified by buttonName."
	}
,
	"Input.GetJoystickNames": {
		"prefix": "Input.GetJoystickNames",
		"body": [
			"Input.GetJoystickNames"
		],
		"description": "public static string[] GetJoystickNames(); des: Returns an array of strings describing the connected joysticks."
	}
,
	"Input.GetKey": {
		"prefix": "Input.GetKey",
		"body": [
			"Input.GetKey"
		],
		"description": "public static bool GetKey(string name); public static bool GetKey(KeyCode key); des: Returns true while the user holds down the key identified by name."
	}
,
	"Input.GetKeyDown": {
		"prefix": "Input.GetKeyDown",
		"body": [
			"Input.GetKeyDown"
		],
		"description": "public static bool GetKeyDown(string name); public static bool GetKeyDown(KeyCode key); des: Returns true during the frame the user starts pressing down the key identified by name."
	}
,
	"Input.GetKeyUp": {
		"prefix": "Input.GetKeyUp",
		"body": [
			"Input.GetKeyUp"
		],
		"description": "public static bool GetKeyUp(string name); public static bool GetKeyUp(KeyCode key); des: Returns true during the frame the user releases the key identified by name."
	}
,
	"Input.GetMouseButton": {
		"prefix": "Input.GetMouseButton",
		"body": [
			"Input.GetMouseButton"
		],
		"description": "public static bool GetMouseButton(int button); des: Returns whether the given mouse button is held down."
	}
,
	"Input.GetMouseButtonDown": {
		"prefix": "Input.GetMouseButtonDown",
		"body": [
			"Input.GetMouseButtonDown"
		],
		"description": "public static bool GetMouseButtonDown(int button); des: Returns true during the frame the user pressed the given mouse button."
	}
,
	"Input.GetMouseButtonUp": {
		"prefix": "Input.GetMouseButtonUp",
		"body": [
			"Input.GetMouseButtonUp"
		],
		"description": "public static bool GetMouseButtonUp(int button); des: Returns true during the frame the user releases the given mouse button."
	}
,
	"Input.GetTouch": {
		"prefix": "Input.GetTouch",
		"body": [
			"Input.GetTouch"
		],
		"description": "public static Touch GetTouch(int index); des: Returns object representing status of a specific touch. (Does not allocate temporary variables)."
	}
,
	"Input.IsJoystickPreconfigured": {
		"prefix": "Input.IsJoystickPreconfigured",
		"body": [
			"Input.IsJoystickPreconfigured"
		],
		"description": "public static bool IsJoystickPreconfigured(string joystickName); des: Determine whether a particular joystick model has been preconfigured by Unity. (Linux-only)."
	}
,
	"Input.ResetInputAxes": {
		"prefix": "Input.ResetInputAxes",
		"body": [
			"Input.ResetInputAxes"
		],
		"description": "public static void ResetInputAxes(); des: Resets all input. After ResetInputAxes all axes return to 0 and all buttons return to 0 for one frame."
	}
,
	"Joint.anchor": {
		"prefix": "Joint.anchor",
		"body": [
			"anchor"
		],
		"description": "return:Vector3 des: The Position of the anchor around which the joints motion is constrained."
	}
,
	"Joint.autoConfigureConnectedAnchor": {
		"prefix": "Joint.autoConfigureConnectedAnchor",
		"body": [
			"autoConfigureConnectedAnchor"
		],
		"description": "return:bool des: Should the connectedAnchor be calculated automatically?"
	}
,
	"Joint.axis": {
		"prefix": "Joint.axis",
		"body": [
			"axis"
		],
		"description": "return:Vector3 des: The Direction of the axis around which the body is constrained."
	}
,
	"Joint.breakForce": {
		"prefix": "Joint.breakForce",
		"body": [
			"breakForce"
		],
		"description": "return:float des: The force that needs to be applied for this joint to break."
	}
,
	"Joint.breakTorque": {
		"prefix": "Joint.breakTorque",
		"body": [
			"breakTorque"
		],
		"description": "return:float des: The torque that needs to be applied for this joint to break."
	}
,
	"Joint.connectedAnchor": {
		"prefix": "Joint.connectedAnchor",
		"body": [
			"connectedAnchor"
		],
		"description": "return:Vector3 des: Position of the anchor relative to the connected Rigidbody."
	}
,
	"Joint.connectedBody": {
		"prefix": "Joint.connectedBody",
		"body": [
			"connectedBody"
		],
		"description": "return:Rigidbody des: A reference to another rigidbody this joint connects to."
	}
,
	"Joint.connectedMassScale": {
		"prefix": "Joint.connectedMassScale",
		"body": [
			"connectedMassScale"
		],
		"description": "return:float des: The scale to apply to the inverse mass and inertia tensor of the connected body prior to solving the constraints."
	}
,
	"Joint.currentForce": {
		"prefix": "Joint.currentForce",
		"body": [
			"currentForce"
		],
		"description": "return:Vector3 des: The force applied by the solver to satisfy all constraints."
	}
,
	"Joint.currentTorque": {
		"prefix": "Joint.currentTorque",
		"body": [
			"currentTorque"
		],
		"description": "return:Vector3 des: The torque applied by the solver to satisfy all constraints."
	}
,
	"Joint.enableCollision": {
		"prefix": "Joint.enableCollision",
		"body": [
			"enableCollision"
		],
		"description": "return:bool des: Enable collision between bodies connected with the joint."
	}
,
	"Joint.enablePreprocessing": {
		"prefix": "Joint.enablePreprocessing",
		"body": [
			"enablePreprocessing"
		],
		"description": "return:bool des: Toggle preprocessing for this joint."
	}
,
	"Joint.massScale": {
		"prefix": "Joint.massScale",
		"body": [
			"massScale"
		],
		"description": "return:float des: The scale to apply to the inverse mass and inertia tensor of the body prior to solving the constraints."
	}
,
	"Joint.OnJointBreak": {
		"prefix": "Joint.OnJointBreak",
		"body": [
			"OnJointBreak"
		],
		"description": "Called when a joint attached to the same game object broke."
	}
,
	"Joint.gameObject": {
		"prefix": "Joint.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"Joint.tag": {
		"prefix": "Joint.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"Joint.transform": {
		"prefix": "Joint.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"Joint.hideFlags": {
		"prefix": "Joint.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Joint.name": {
		"prefix": "Joint.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Joint.BroadcastMessage": {
		"prefix": "Joint.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"Joint.CompareTag": {
		"prefix": "Joint.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"Joint.GetComponent": {
		"prefix": "Joint.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"Joint.GetComponentInChildren": {
		"prefix": "Joint.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"Joint.GetComponentInParent": {
		"prefix": "Joint.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"Joint.GetComponents": {
		"prefix": "Joint.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"Joint.GetComponentsInChildren": {
		"prefix": "Joint.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"Joint.GetComponentsInParent": {
		"prefix": "Joint.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"Joint.SendMessage": {
		"prefix": "Joint.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"Joint.SendMessageUpwards": {
		"prefix": "Joint.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"Joint.GetInstanceID": {
		"prefix": "Joint.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Joint.ToString": {
		"prefix": "Joint.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Joint.Destroy": {
		"prefix": "Joint.Destroy",
		"body": [
			"Joint.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Joint.DestroyImmediate": {
		"prefix": "Joint.DestroyImmediate",
		"body": [
			"Joint.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Joint.DontDestroyOnLoad": {
		"prefix": "Joint.DontDestroyOnLoad",
		"body": [
			"Joint.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Joint.FindObjectOfType": {
		"prefix": "Joint.FindObjectOfType",
		"body": [
			"Joint.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Joint.FindObjectsOfType": {
		"prefix": "Joint.FindObjectsOfType",
		"body": [
			"Joint.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Joint.Instantiate": {
		"prefix": "Joint.Instantiate",
		"body": [
			"Joint.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"Joint2D.attachedRigidbody": {
		"prefix": "Joint2D.attachedRigidbody",
		"body": [
			"attachedRigidbody"
		],
		"description": "return:Rigidbody2D des: The Rigidbody2D attached to the Joint2D."
	}
,
	"Joint2D.breakForce": {
		"prefix": "Joint2D.breakForce",
		"body": [
			"breakForce"
		],
		"description": "return:float des: The force that needs to be applied for this joint to break."
	}
,
	"Joint2D.breakTorque": {
		"prefix": "Joint2D.breakTorque",
		"body": [
			"breakTorque"
		],
		"description": "return:float des: The torque that needs to be applied for this joint to break."
	}
,
	"Joint2D.connectedBody": {
		"prefix": "Joint2D.connectedBody",
		"body": [
			"connectedBody"
		],
		"description": "return:Rigidbody2D des: The Rigidbody2D object to which the other end of the joint is attached (ie, the object without the joint component)."
	}
,
	"Joint2D.enableCollision": {
		"prefix": "Joint2D.enableCollision",
		"body": [
			"enableCollision"
		],
		"description": "return:bool des: Should the two rigid bodies connected with this joint collide with each other?"
	}
,
	"Joint2D.reactionForce": {
		"prefix": "Joint2D.reactionForce",
		"body": [
			"reactionForce"
		],
		"description": "return:Vector2 des: Gets the reaction force of the joint."
	}
,
	"Joint2D.reactionTorque": {
		"prefix": "Joint2D.reactionTorque",
		"body": [
			"reactionTorque"
		],
		"description": "return:float des: Gets the reaction torque of the joint."
	}
,
	"Joint2D.GetReactionForce": {
		"prefix": "Joint2D.GetReactionForce",
		"body": [
			"GetReactionForce($1)"
		],
		"description": "public Vector2 GetReactionForce(float timeStep); des: Gets the reaction force of the joint given the specified timeStep."
	}
,
	"Joint2D.GetReactionTorque": {
		"prefix": "Joint2D.GetReactionTorque",
		"body": [
			"GetReactionTorque($1)"
		],
		"description": "public float GetReactionTorque(float timeStep); des: Gets the reaction torque of the joint given the specified timeStep."
	}
,
	"Joint2D.OnJointBreak2D": {
		"prefix": "Joint2D.OnJointBreak2D",
		"body": [
			"OnJointBreak2D"
		],
		"description": "Called when a Joint2D attached to the same game object breaks."
	}
,
	"Joint2D.enabled": {
		"prefix": "Joint2D.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"Joint2D.isActiveAndEnabled": {
		"prefix": "Joint2D.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"Joint2D.gameObject": {
		"prefix": "Joint2D.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"Joint2D.tag": {
		"prefix": "Joint2D.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"Joint2D.transform": {
		"prefix": "Joint2D.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"Joint2D.hideFlags": {
		"prefix": "Joint2D.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Joint2D.name": {
		"prefix": "Joint2D.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Joint2D.BroadcastMessage": {
		"prefix": "Joint2D.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"Joint2D.CompareTag": {
		"prefix": "Joint2D.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"Joint2D.GetComponent": {
		"prefix": "Joint2D.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"Joint2D.GetComponentInChildren": {
		"prefix": "Joint2D.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"Joint2D.GetComponentInParent": {
		"prefix": "Joint2D.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"Joint2D.GetComponents": {
		"prefix": "Joint2D.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"Joint2D.GetComponentsInChildren": {
		"prefix": "Joint2D.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"Joint2D.GetComponentsInParent": {
		"prefix": "Joint2D.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"Joint2D.SendMessage": {
		"prefix": "Joint2D.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"Joint2D.SendMessageUpwards": {
		"prefix": "Joint2D.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"Joint2D.GetInstanceID": {
		"prefix": "Joint2D.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Joint2D.ToString": {
		"prefix": "Joint2D.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Joint2D.Destroy": {
		"prefix": "Joint2D.Destroy",
		"body": [
			"Joint2D.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Joint2D.DestroyImmediate": {
		"prefix": "Joint2D.DestroyImmediate",
		"body": [
			"Joint2D.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Joint2D.DontDestroyOnLoad": {
		"prefix": "Joint2D.DontDestroyOnLoad",
		"body": [
			"Joint2D.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Joint2D.FindObjectOfType": {
		"prefix": "Joint2D.FindObjectOfType",
		"body": [
			"Joint2D.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Joint2D.FindObjectsOfType": {
		"prefix": "Joint2D.FindObjectsOfType",
		"body": [
			"Joint2D.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Joint2D.Instantiate": {
		"prefix": "Joint2D.Instantiate",
		"body": [
			"Joint2D.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"JointAngleLimits2D.max": {
		"prefix": "JointAngleLimits2D.max",
		"body": [
			"max"
		],
		"description": "return:float des: Upper angular limit of rotation."
	}
,
	"JointAngleLimits2D.min": {
		"prefix": "JointAngleLimits2D.min",
		"body": [
			"min"
		],
		"description": "return:float des: Lower angular limit of rotation."
	}
,
	"JointDrive.maximumForce": {
		"prefix": "JointDrive.maximumForce",
		"body": [
			"maximumForce"
		],
		"description": "return:float des: Amount of force applied to push the object toward the defined direction."
	}
,
	"JointDrive.positionDamper": {
		"prefix": "JointDrive.positionDamper",
		"body": [
			"positionDamper"
		],
		"description": "return:float des: Resistance strength against the Position Spring. Only used if mode includes Position."
	}
,
	"JointDrive.positionSpring": {
		"prefix": "JointDrive.positionSpring",
		"body": [
			"positionSpring"
		],
		"description": "return:float des: Strength of a rubber-band pull toward the defined direction. Only used if mode includes Position."
	}
,
	"JointLimits.bounceMinVelocity": {
		"prefix": "JointLimits.bounceMinVelocity",
		"body": [
			"bounceMinVelocity"
		],
		"description": "return:float des: The minimum impact velocity which will cause the joint to bounce."
	}
,
	"JointLimits.bounciness": {
		"prefix": "JointLimits.bounciness",
		"body": [
			"bounciness"
		],
		"description": "return:float des: Determines the size of the bounce when the joint hits it's limit. Also known as restitution."
	}
,
	"JointLimits.contactDistance": {
		"prefix": "JointLimits.contactDistance",
		"body": [
			"contactDistance"
		],
		"description": "return:float des: Distance inside the limit value at which the limit will be considered to be active by the solver."
	}
,
	"JointLimits.max": {
		"prefix": "JointLimits.max",
		"body": [
			"max"
		],
		"description": "return:float des: The upper angular limit (in degrees) of the joint."
	}
,
	"JointLimits.min": {
		"prefix": "JointLimits.min",
		"body": [
			"min"
		],
		"description": "return:float des: The lower angular limit (in degrees) of the joint."
	}
,
	"JointMotor.force": {
		"prefix": "JointMotor.force",
		"body": [
			"force"
		],
		"description": "return:float des: The motor will apply a force."
	}
,
	"JointMotor.freeSpin": {
		"prefix": "JointMotor.freeSpin",
		"body": [
			"freeSpin"
		],
		"description": "return:bool des: If freeSpin is enabled the motor will only accelerate but never slow down."
	}
,
	"JointMotor.targetVelocity": {
		"prefix": "JointMotor.targetVelocity",
		"body": [
			"targetVelocity"
		],
		"description": "return:float des: The motor will apply a force up to force to achieve targetVelocity."
	}
,
	"JointMotor2D.maxMotorTorque": {
		"prefix": "JointMotor2D.maxMotorTorque",
		"body": [
			"maxMotorTorque"
		],
		"description": "return:float des: The maximum force that can be applied to the Rigidbody2D at the joint to attain the target speed."
	}
,
	"JointMotor2D.motorSpeed": {
		"prefix": "JointMotor2D.motorSpeed",
		"body": [
			"motorSpeed"
		],
		"description": "return:float des: The desired speed for the Rigidbody2D to reach as it moves with the joint."
	}
,
	"JointSpring.damper": {
		"prefix": "JointSpring.damper",
		"body": [
			"damper"
		],
		"description": "return:float des: The damper force uses to dampen the spring."
	}
,
	"JointSpring.spring": {
		"prefix": "JointSpring.spring",
		"body": [
			"spring"
		],
		"description": "return:float des: The spring forces used to reach the target position."
	}
,
	"JointSpring.targetPosition": {
		"prefix": "JointSpring.targetPosition",
		"body": [
			"targetPosition"
		],
		"description": "return:float des: The target position the joint attempts to reach."
	}
,
	"JointSuspension2D.angle": {
		"prefix": "JointSuspension2D.angle",
		"body": [
			"angle"
		],
		"description": "return:float des: The world angle (in degrees) along which the suspension will move."
	}
,
	"JointSuspension2D.dampingRatio": {
		"prefix": "JointSuspension2D.dampingRatio",
		"body": [
			"dampingRatio"
		],
		"description": "return:float des: The amount by which the suspension spring force is reduced in proportion to the movement speed."
	}
,
	"JointSuspension2D.frequency": {
		"prefix": "JointSuspension2D.frequency",
		"body": [
			"frequency"
		],
		"description": "return:float des: The frequency at which the suspension spring oscillates."
	}
,
	"JointTranslationLimits2D.max": {
		"prefix": "JointTranslationLimits2D.max",
		"body": [
			"max"
		],
		"description": "return:float des: Maximum distance the Rigidbody2D object can move from the Slider Joint's anchor."
	}
,
	"JointTranslationLimits2D.min": {
		"prefix": "JointTranslationLimits2D.min",
		"body": [
			"min"
		],
		"description": "return:float des: Minimum distance the Rigidbody2D object can move from the Slider Joint's anchor."
	}
,
	"JsonUtility.FromJson": {
		"prefix": "JsonUtility.FromJson",
		"body": [
			"JsonUtility.FromJson"
		],
		"description": "public static T FromJson(string json); public static object FromJson(string json, Type type); des: Create an object from its JSON representation."
	}
,
	"JsonUtility.FromJsonOverwrite": {
		"prefix": "JsonUtility.FromJsonOverwrite",
		"body": [
			"JsonUtility.FromJsonOverwrite"
		],
		"description": "public static void FromJsonOverwrite(string json, object objectToOverwrite); des: Overwrite data in an object by reading from its JSON representation."
	}
,
	"JsonUtility.ToJson": {
		"prefix": "JsonUtility.ToJson",
		"body": [
			"JsonUtility.ToJson"
		],
		"description": "public static string ToJson(object obj); public static string ToJson(object obj, bool prettyPrint); des: Generate a JSON representation of the public fields of an object."
	}
,
	"Keyframe.inTangent": {
		"prefix": "Keyframe.inTangent",
		"body": [
			"inTangent"
		],
		"description": "return:float des: Sets the incoming tangent for this key. The incoming tangent affects the slope of the curve from the previous key to this key."
	}
,
	"Keyframe.inWeight": {
		"prefix": "Keyframe.inWeight",
		"body": [
			"inWeight"
		],
		"description": "return:float des: Sets the incoming weight for this key. The incoming weight affects the slope of the curve from the previous key to this key."
	}
,
	"Keyframe.outTangent": {
		"prefix": "Keyframe.outTangent",
		"body": [
			"outTangent"
		],
		"description": "return:float des: Sets the outgoing tangent for this key. The outgoing tangent affects the slope of the curve from this key to the next key."
	}
,
	"Keyframe.outWeight": {
		"prefix": "Keyframe.outWeight",
		"body": [
			"outWeight"
		],
		"description": "return:float des: Sets the outgoing weight for this key. The outgoing weight affects the slope of the curve from this key to the next key."
	}
,
	"Keyframe.time": {
		"prefix": "Keyframe.time",
		"body": [
			"time"
		],
		"description": "return:float des: The time of the keyframe."
	}
,
	"Keyframe.value": {
		"prefix": "Keyframe.value",
		"body": [
			"value"
		],
		"description": "return:float des: The value of the curve at keyframe."
	}
,
	"Keyframe.weightedMode": {
		"prefix": "Keyframe.weightedMode",
		"body": [
			"weightedMode"
		],
		"description": "return:WeightedMode des: Weighted mode for the keyframe."
	}
,
	"LayerMask.value": {
		"prefix": "LayerMask.value",
		"body": [
			"value"
		],
		"description": "return:int des: Converts a layer mask value to an integer value."
	}
,
	"LayerMask.GetMask": {
		"prefix": "LayerMask.GetMask",
		"body": [
			"LayerMask.GetMask"
		],
		"description": "public static int GetMask(params string[] layerNames); des: Given a set of layer names as defined by either a Builtin or a User Layer in the Tags and Layers manager, returns the equivalent layer mask for all of them."
	}
,
	"LayerMask.LayerToName": {
		"prefix": "LayerMask.LayerToName",
		"body": [
			"LayerMask.LayerToName"
		],
		"description": "public static string LayerToName(int layer); des: Given a layer number, returns the name of the layer as defined in either a Builtin or a User Layer in the Tags and Layers manager."
	}
,
	"LayerMask.NameToLayer": {
		"prefix": "LayerMask.NameToLayer",
		"body": [
			"LayerMask.NameToLayer"
		],
		"description": "public static int NameToLayer(string layerName); des: Given a layer name, returns the layer index as defined by either a Builtin or a User Layer in the Tags and Layers manager."
	}
,
	"LensFlare.brightness": {
		"prefix": "LensFlare.brightness",
		"body": [
			"brightness"
		],
		"description": "return:float des: The strength of the flare."
	}
,
	"LensFlare.color": {
		"prefix": "LensFlare.color",
		"body": [
			"color"
		],
		"description": "return:Color des: The color of the flare."
	}
,
	"LensFlare.fadeSpeed": {
		"prefix": "LensFlare.fadeSpeed",
		"body": [
			"fadeSpeed"
		],
		"description": "return:float des: The fade speed of the flare."
	}
,
	"LensFlare.flare": {
		"prefix": "LensFlare.flare",
		"body": [
			"flare"
		],
		"description": "return:Flare des: The flare asset to use."
	}
,
	"LensFlare.enabled": {
		"prefix": "LensFlare.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"LensFlare.isActiveAndEnabled": {
		"prefix": "LensFlare.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"LensFlare.gameObject": {
		"prefix": "LensFlare.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"LensFlare.tag": {
		"prefix": "LensFlare.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"LensFlare.transform": {
		"prefix": "LensFlare.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"LensFlare.hideFlags": {
		"prefix": "LensFlare.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"LensFlare.name": {
		"prefix": "LensFlare.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"LensFlare.BroadcastMessage": {
		"prefix": "LensFlare.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"LensFlare.CompareTag": {
		"prefix": "LensFlare.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"LensFlare.GetComponent": {
		"prefix": "LensFlare.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"LensFlare.GetComponentInChildren": {
		"prefix": "LensFlare.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"LensFlare.GetComponentInParent": {
		"prefix": "LensFlare.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"LensFlare.GetComponents": {
		"prefix": "LensFlare.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"LensFlare.GetComponentsInChildren": {
		"prefix": "LensFlare.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"LensFlare.GetComponentsInParent": {
		"prefix": "LensFlare.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"LensFlare.SendMessage": {
		"prefix": "LensFlare.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"LensFlare.SendMessageUpwards": {
		"prefix": "LensFlare.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"LensFlare.GetInstanceID": {
		"prefix": "LensFlare.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"LensFlare.ToString": {
		"prefix": "LensFlare.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"LensFlare.Destroy": {
		"prefix": "LensFlare.Destroy",
		"body": [
			"LensFlare.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"LensFlare.DestroyImmediate": {
		"prefix": "LensFlare.DestroyImmediate",
		"body": [
			"LensFlare.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"LensFlare.DontDestroyOnLoad": {
		"prefix": "LensFlare.DontDestroyOnLoad",
		"body": [
			"LensFlare.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"LensFlare.FindObjectOfType": {
		"prefix": "LensFlare.FindObjectOfType",
		"body": [
			"LensFlare.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"LensFlare.FindObjectsOfType": {
		"prefix": "LensFlare.FindObjectsOfType",
		"body": [
			"LensFlare.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"LensFlare.Instantiate": {
		"prefix": "LensFlare.Instantiate",
		"body": [
			"LensFlare.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"Light.areaSize": {
		"prefix": "Light.areaSize",
		"body": [
			"areaSize"
		],
		"description": "return:Vector2 des: The size of the area light."
	}
,
	"Light.bakingOutput": {
		"prefix": "Light.bakingOutput",
		"body": [
			"bakingOutput"
		],
		"description": "return:LightBakingOutput des: This property describes the output of the last Global Illumination bake."
	}
,
	"Light.bounceIntensity": {
		"prefix": "Light.bounceIntensity",
		"body": [
			"bounceIntensity"
		],
		"description": "return:float des: The multiplier that defines the strength of the bounce lighting."
	}
,
	"Light.color": {
		"prefix": "Light.color",
		"body": [
			"color"
		],
		"description": "return:Color des: The color of the light."
	}
,
	"Light.colorTemperature": {
		"prefix": "Light.colorTemperature",
		"body": [
			"colorTemperature"
		],
		"description": "return:float des: The color temperature of the light. Correlated Color Temperature (abbreviated as CCT) is multiplied with the color filter when calculating the final color of a light source. The color temperature of the electromagnetic radiation emitted from an ideal black body is defined as its surface temperature in Kelvin. White is 6500K according to the D65 standard. Candle light is 1800K. If you want to use lightsUseCCT, lightsUseLinearIntensity has to be enabled to ensure physically correct output. See Also: GraphicsSettings.lightsUseLinearIntensity, GraphicsSettings.lightsUseCCT."
	}
,
	"Light.commandBufferCount": {
		"prefix": "Light.commandBufferCount",
		"body": [
			"commandBufferCount"
		],
		"description": "return:int des: Number of command buffers set up on this light (Read Only)."
	}
,
	"Light.cookie": {
		"prefix": "Light.cookie",
		"body": [
			"cookie"
		],
		"description": "return:Texture des: The cookie texture projected by the light."
	}
,
	"Light.cookieSize": {
		"prefix": "Light.cookieSize",
		"body": [
			"cookieSize"
		],
		"description": "return:float des: The size of a directional light's cookie."
	}
,
	"Light.cullingMask": {
		"prefix": "Light.cullingMask",
		"body": [
			"cullingMask"
		],
		"description": "return:int des: This is used to light certain objects in the scene selectively."
	}
,
	"Light.flare": {
		"prefix": "Light.flare",
		"body": [
			"flare"
		],
		"description": "return:Flare des: The flare asset to use for this light."
	}
,
	"Light.intensity": {
		"prefix": "Light.intensity",
		"body": [
			"intensity"
		],
		"description": "return:float des: The Intensity of a light is multiplied with the Light color."
	}
,
	"Light.layerShadowCullDistances": {
		"prefix": "Light.layerShadowCullDistances",
		"body": [
			"layerShadowCullDistances"
		],
		"description": "return:float[] des: Per-light, per-layer shadow culling distances."
	}
,
	"Light.lightmapBakeType": {
		"prefix": "Light.lightmapBakeType",
		"body": [
			"lightmapBakeType"
		],
		"description": "return:LightmapBakeType des: This property describes what part of a light's contribution can be baked."
	}
,
	"Light.lightShadowCasterMode": {
		"prefix": "Light.lightShadowCasterMode",
		"body": [
			"lightShadowCasterMode"
		],
		"description": "return:LightShadowCasterMode des: Allows you to override the global Shadowmask Mode per light. Only use this with render pipelines that can handle per light Shadowmask modes. Incompatible with the legacy renderers."
	}
,
	"Light.range": {
		"prefix": "Light.range",
		"body": [
			"range"
		],
		"description": "return:float des: The range of the light."
	}
,
	"Light.renderMode": {
		"prefix": "Light.renderMode",
		"body": [
			"renderMode"
		],
		"description": "return:LightRenderMode des: How to render the light."
	}
,
	"Light.shadowAngle": {
		"prefix": "Light.shadowAngle",
		"body": [
			"shadowAngle"
		],
		"description": "return:float des: Controls the amount of artificial softening applied to the edges of shadows cast by directional lights."
	}
,
	"Light.shadowBias": {
		"prefix": "Light.shadowBias",
		"body": [
			"shadowBias"
		],
		"description": "return:float des: Shadow mapping constant bias."
	}
,
	"Light.shadowCustomResolution": {
		"prefix": "Light.shadowCustomResolution",
		"body": [
			"shadowCustomResolution"
		],
		"description": "return:int des: The custom resolution of the shadow map."
	}
,
	"Light.shadowNearPlane": {
		"prefix": "Light.shadowNearPlane",
		"body": [
			"shadowNearPlane"
		],
		"description": "return:float des: Near plane value to use for shadow frustums."
	}
,
	"Light.shadowNormalBias": {
		"prefix": "Light.shadowNormalBias",
		"body": [
			"shadowNormalBias"
		],
		"description": "return:float des: Shadow mapping normal-based bias."
	}
,
	"Light.shadowRadius": {
		"prefix": "Light.shadowRadius",
		"body": [
			"shadowRadius"
		],
		"description": "return:float des: Controls the amount of artificial softening applied to the edges of shadows cast by the Point or Spot light."
	}
,
	"Light.shadowResolution": {
		"prefix": "Light.shadowResolution",
		"body": [
			"shadowResolution"
		],
		"description": "return:Rendering.LightShadowResolution des: The resolution of the shadow map."
	}
,
	"Light.shadows": {
		"prefix": "Light.shadows",
		"body": [
			"shadows"
		],
		"description": "return:LightShadows des: How this light casts shadows"
	}
,
	"Light.shadowStrength": {
		"prefix": "Light.shadowStrength",
		"body": [
			"shadowStrength"
		],
		"description": "return:float des: Strength of light's shadows."
	}
,
	"Light.spotAngle": {
		"prefix": "Light.spotAngle",
		"body": [
			"spotAngle"
		],
		"description": "return:float des: The angle of the light's spotlight cone in degrees."
	}
,
	"Light.type": {
		"prefix": "Light.type",
		"body": [
			"type"
		],
		"description": "return:LightType des: The type of the light."
	}
,
	"Light.AddCommandBuffer": {
		"prefix": "Light.AddCommandBuffer",
		"body": [
			"AddCommandBuffer($1)"
		],
		"description": "public void AddCommandBuffer(Rendering.LightEvent evt, Rendering.CommandBuffer buffer); public void AddCommandBuffer(Rendering.LightEvent evt, Rendering.CommandBuffer buffer, Rendering.ShadowMapPass shadowPassMask); des: Add a command buffer to be executed at a specified place."
	}
,
	"Light.AddCommandBufferAsync": {
		"prefix": "Light.AddCommandBufferAsync",
		"body": [
			"AddCommandBufferAsync($1)"
		],
		"description": "public void AddCommandBufferAsync(Rendering.LightEvent evt, Rendering.CommandBuffer buffer, Rendering.ComputeQueueType queueType); public void AddCommandBufferAsync(Rendering.LightEvent evt, Rendering.CommandBuffer buffer, Rendering.ShadowMapPass shadowPassMask, Rendering.ComputeQueueType queueType); des: Adds a command buffer to the GPU's async compute queues and executes that command buffer when graphics processing reaches a given point."
	}
,
	"Light.GetCommandBuffers": {
		"prefix": "Light.GetCommandBuffers",
		"body": [
			"GetCommandBuffers($1)"
		],
		"description": "public CommandBuffer[] GetCommandBuffers(Rendering.LightEvent evt); des: Get command buffers to be executed at a specified place."
	}
,
	"Light.RemoveAllCommandBuffers": {
		"prefix": "Light.RemoveAllCommandBuffers",
		"body": [
			"RemoveAllCommandBuffers($1)"
		],
		"description": "public void RemoveAllCommandBuffers(); des: Remove all command buffers set on this light."
	}
,
	"Light.RemoveCommandBuffer": {
		"prefix": "Light.RemoveCommandBuffer",
		"body": [
			"RemoveCommandBuffer($1)"
		],
		"description": "public void RemoveCommandBuffer(Rendering.LightEvent evt, Rendering.CommandBuffer buffer); des: Remove command buffer from execution at a specified place."
	}
,
	"Light.RemoveCommandBuffers": {
		"prefix": "Light.RemoveCommandBuffers",
		"body": [
			"RemoveCommandBuffers($1)"
		],
		"description": "public void RemoveCommandBuffers(Rendering.LightEvent evt); des: Remove command buffers from execution at a specified place."
	}
,
	"Light.SetLightDirty": {
		"prefix": "Light.SetLightDirty",
		"body": [
			"SetLightDirty($1)"
		],
		"description": "public void SetLightDirty(); des: Sets a light dirty to notify the light baking backends to update their internal light representation."
	}
,
	"Light.enabled": {
		"prefix": "Light.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"Light.isActiveAndEnabled": {
		"prefix": "Light.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"Light.gameObject": {
		"prefix": "Light.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"Light.tag": {
		"prefix": "Light.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"Light.transform": {
		"prefix": "Light.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"Light.hideFlags": {
		"prefix": "Light.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Light.name": {
		"prefix": "Light.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Light.BroadcastMessage": {
		"prefix": "Light.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"Light.CompareTag": {
		"prefix": "Light.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"Light.GetComponent": {
		"prefix": "Light.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"Light.GetComponentInChildren": {
		"prefix": "Light.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"Light.GetComponentInParent": {
		"prefix": "Light.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"Light.GetComponents": {
		"prefix": "Light.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"Light.GetComponentsInChildren": {
		"prefix": "Light.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"Light.GetComponentsInParent": {
		"prefix": "Light.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"Light.SendMessage": {
		"prefix": "Light.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"Light.SendMessageUpwards": {
		"prefix": "Light.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"Light.GetInstanceID": {
		"prefix": "Light.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Light.ToString": {
		"prefix": "Light.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Light.Destroy": {
		"prefix": "Light.Destroy",
		"body": [
			"Light.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Light.DestroyImmediate": {
		"prefix": "Light.DestroyImmediate",
		"body": [
			"Light.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Light.DontDestroyOnLoad": {
		"prefix": "Light.DontDestroyOnLoad",
		"body": [
			"Light.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Light.FindObjectOfType": {
		"prefix": "Light.FindObjectOfType",
		"body": [
			"Light.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Light.FindObjectsOfType": {
		"prefix": "Light.FindObjectsOfType",
		"body": [
			"Light.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Light.Instantiate": {
		"prefix": "Light.Instantiate",
		"body": [
			"Light.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"LightBakingOutput.isBaked": {
		"prefix": "LightBakingOutput.isBaked",
		"body": [
			"isBaked"
		],
		"description": "return:bool des: Is the light contribution already stored in lightmaps and/or lightprobes?"
	}
,
	"LightBakingOutput.lightmapBakeType": {
		"prefix": "LightBakingOutput.lightmapBakeType",
		"body": [
			"lightmapBakeType"
		],
		"description": "return:LightmapBakeType des: This property describes what part of a light's contribution was baked."
	}
,
	"LightBakingOutput.mixedLightingMode": {
		"prefix": "LightBakingOutput.mixedLightingMode",
		"body": [
			"mixedLightingMode"
		],
		"description": "return:MixedLightingMode des: In case of a LightmapBakeType.Mixed light, describes what Mixed mode was used to bake the light, irrelevant otherwise."
	}
,
	"LightBakingOutput.occlusionMaskChannel": {
		"prefix": "LightBakingOutput.occlusionMaskChannel",
		"body": [
			"occlusionMaskChannel"
		],
		"description": "return:int des: In case of a LightmapBakeType.Mixed light, contains the index of the occlusion mask channel to use if any, otherwise -1."
	}
,
	"LightBakingOutput.probeOcclusionLightIndex": {
		"prefix": "LightBakingOutput.probeOcclusionLightIndex",
		"body": [
			"probeOcclusionLightIndex"
		],
		"description": "return:int des: In case of a LightmapBakeType.Mixed light, contains the index of the light as seen from the occlusion probes point of view if any, otherwise -1."
	}
,
	"LightmapData.lightmapColor": {
		"prefix": "LightmapData.lightmapColor",
		"body": [
			"lightmapColor"
		],
		"description": "return:Texture2D des: Lightmap storing color of incoming light."
	}
,
	"LightmapData.lightmapDir": {
		"prefix": "LightmapData.lightmapDir",
		"body": [
			"lightmapDir"
		],
		"description": "return:Texture2D des: Lightmap storing dominant direction of incoming light."
	}
,
	"LightmapData.shadowMask": {
		"prefix": "LightmapData.shadowMask",
		"body": [
			"shadowMask"
		],
		"description": "return:Texture2D des: Texture storing occlusion mask per light (ShadowMask, up to four lights)."
	}
,
	"LightmapSettings.hideFlags": {
		"prefix": "LightmapSettings.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"LightmapSettings.name": {
		"prefix": "LightmapSettings.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"LightmapSettings.GetInstanceID": {
		"prefix": "LightmapSettings.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"LightmapSettings.ToString": {
		"prefix": "LightmapSettings.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"LightmapSettings.Destroy": {
		"prefix": "LightmapSettings.Destroy",
		"body": [
			"LightmapSettings.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"LightmapSettings.DestroyImmediate": {
		"prefix": "LightmapSettings.DestroyImmediate",
		"body": [
			"LightmapSettings.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"LightmapSettings.DontDestroyOnLoad": {
		"prefix": "LightmapSettings.DontDestroyOnLoad",
		"body": [
			"LightmapSettings.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"LightmapSettings.FindObjectOfType": {
		"prefix": "LightmapSettings.FindObjectOfType",
		"body": [
			"LightmapSettings.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"LightmapSettings.FindObjectsOfType": {
		"prefix": "LightmapSettings.FindObjectsOfType",
		"body": [
			"LightmapSettings.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"LightmapSettings.Instantiate": {
		"prefix": "LightmapSettings.Instantiate",
		"body": [
			"LightmapSettings.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"LightProbeGroup.probePositions": {
		"prefix": "LightProbeGroup.probePositions",
		"body": [
			"probePositions"
		],
		"description": "return:Vector3[] des: Editor only function to access and modify probe positions."
	}
,
	"LightProbeGroup.enabled": {
		"prefix": "LightProbeGroup.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"LightProbeGroup.isActiveAndEnabled": {
		"prefix": "LightProbeGroup.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"LightProbeGroup.gameObject": {
		"prefix": "LightProbeGroup.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"LightProbeGroup.tag": {
		"prefix": "LightProbeGroup.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"LightProbeGroup.transform": {
		"prefix": "LightProbeGroup.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"LightProbeGroup.hideFlags": {
		"prefix": "LightProbeGroup.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"LightProbeGroup.name": {
		"prefix": "LightProbeGroup.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"LightProbeGroup.BroadcastMessage": {
		"prefix": "LightProbeGroup.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"LightProbeGroup.CompareTag": {
		"prefix": "LightProbeGroup.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"LightProbeGroup.GetComponent": {
		"prefix": "LightProbeGroup.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"LightProbeGroup.GetComponentInChildren": {
		"prefix": "LightProbeGroup.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"LightProbeGroup.GetComponentInParent": {
		"prefix": "LightProbeGroup.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"LightProbeGroup.GetComponents": {
		"prefix": "LightProbeGroup.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"LightProbeGroup.GetComponentsInChildren": {
		"prefix": "LightProbeGroup.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"LightProbeGroup.GetComponentsInParent": {
		"prefix": "LightProbeGroup.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"LightProbeGroup.SendMessage": {
		"prefix": "LightProbeGroup.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"LightProbeGroup.SendMessageUpwards": {
		"prefix": "LightProbeGroup.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"LightProbeGroup.GetInstanceID": {
		"prefix": "LightProbeGroup.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"LightProbeGroup.ToString": {
		"prefix": "LightProbeGroup.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"LightProbeGroup.Destroy": {
		"prefix": "LightProbeGroup.Destroy",
		"body": [
			"LightProbeGroup.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"LightProbeGroup.DestroyImmediate": {
		"prefix": "LightProbeGroup.DestroyImmediate",
		"body": [
			"LightProbeGroup.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"LightProbeGroup.DontDestroyOnLoad": {
		"prefix": "LightProbeGroup.DontDestroyOnLoad",
		"body": [
			"LightProbeGroup.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"LightProbeGroup.FindObjectOfType": {
		"prefix": "LightProbeGroup.FindObjectOfType",
		"body": [
			"LightProbeGroup.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"LightProbeGroup.FindObjectsOfType": {
		"prefix": "LightProbeGroup.FindObjectsOfType",
		"body": [
			"LightProbeGroup.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"LightProbeGroup.Instantiate": {
		"prefix": "LightProbeGroup.Instantiate",
		"body": [
			"LightProbeGroup.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"LightProbeProxyVolume.boundingBoxMode": {
		"prefix": "LightProbeProxyVolume.boundingBoxMode",
		"body": [
			"boundingBoxMode"
		],
		"description": "return:LightProbeProxyVolume.BoundingBoxMode des: The bounding box mode for generating the 3D grid of interpolated Light Probes."
	}
,
	"LightProbeProxyVolume.boundsGlobal": {
		"prefix": "LightProbeProxyVolume.boundsGlobal",
		"body": [
			"boundsGlobal"
		],
		"description": "return:Bounds des: The world-space bounding box in which the 3D grid of interpolated Light Probes is generated."
	}
,
	"LightProbeProxyVolume.gridResolutionX": {
		"prefix": "LightProbeProxyVolume.gridResolutionX",
		"body": [
			"gridResolutionX"
		],
		"description": "return:int des: The 3D grid resolution on the z-axis."
	}
,
	"LightProbeProxyVolume.gridResolutionY": {
		"prefix": "LightProbeProxyVolume.gridResolutionY",
		"body": [
			"gridResolutionY"
		],
		"description": "return:int des: The 3D grid resolution on the y-axis."
	}
,
	"LightProbeProxyVolume.gridResolutionZ": {
		"prefix": "LightProbeProxyVolume.gridResolutionZ",
		"body": [
			"gridResolutionZ"
		],
		"description": "return:int des: The 3D grid resolution on the z-axis."
	}
,
	"LightProbeProxyVolume.originCustom": {
		"prefix": "LightProbeProxyVolume.originCustom",
		"body": [
			"originCustom"
		],
		"description": "return:Vector3 des: The local-space origin of the bounding box in which the 3D grid of interpolated Light Probes is generated."
	}
,
	"LightProbeProxyVolume.probeDensity": {
		"prefix": "LightProbeProxyVolume.probeDensity",
		"body": [
			"probeDensity"
		],
		"description": "return:float des: Interpolated Light Probe density."
	}
,
	"LightProbeProxyVolume.probePositionMode": {
		"prefix": "LightProbeProxyVolume.probePositionMode",
		"body": [
			"probePositionMode"
		],
		"description": "return:LightProbeProxyVolume.ProbePositionMode des: The mode in which the interpolated Light Probe positions are generated."
	}
,
	"LightProbeProxyVolume.qualityMode": {
		"prefix": "LightProbeProxyVolume.qualityMode",
		"body": [
			"qualityMode"
		],
		"description": "return:LightProbeProxyVolume.QualityMode des: Determines how many Spherical Harmonics bands will be evaluated to compute the ambient color."
	}
,
	"LightProbeProxyVolume.refreshMode": {
		"prefix": "LightProbeProxyVolume.refreshMode",
		"body": [
			"refreshMode"
		],
		"description": "return:LightProbeProxyVolume.RefreshMode des: Sets the way the Light Probe Proxy Volume refreshes."
	}
,
	"LightProbeProxyVolume.resolutionMode": {
		"prefix": "LightProbeProxyVolume.resolutionMode",
		"body": [
			"resolutionMode"
		],
		"description": "return:LightProbeProxyVolume.ResolutionMode des: The resolution mode for generating the grid of interpolated Light Probes."
	}
,
	"LightProbeProxyVolume.sizeCustom": {
		"prefix": "LightProbeProxyVolume.sizeCustom",
		"body": [
			"sizeCustom"
		],
		"description": "return:Vector3 des: The size of the bounding box in which the 3D grid of interpolated Light Probes is generated."
	}
,
	"LightProbeProxyVolume.Update": {
		"prefix": "LightProbeProxyVolume.Update",
		"body": [
			"Update($1)"
		],
		"description": "public void Update(); des: Triggers an update of the Light Probe Proxy Volume."
	}
,
	"LightProbeProxyVolume.enabled": {
		"prefix": "LightProbeProxyVolume.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"LightProbeProxyVolume.isActiveAndEnabled": {
		"prefix": "LightProbeProxyVolume.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"LightProbeProxyVolume.gameObject": {
		"prefix": "LightProbeProxyVolume.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"LightProbeProxyVolume.tag": {
		"prefix": "LightProbeProxyVolume.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"LightProbeProxyVolume.transform": {
		"prefix": "LightProbeProxyVolume.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"LightProbeProxyVolume.hideFlags": {
		"prefix": "LightProbeProxyVolume.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"LightProbeProxyVolume.name": {
		"prefix": "LightProbeProxyVolume.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"LightProbeProxyVolume.BroadcastMessage": {
		"prefix": "LightProbeProxyVolume.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"LightProbeProxyVolume.CompareTag": {
		"prefix": "LightProbeProxyVolume.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"LightProbeProxyVolume.GetComponent": {
		"prefix": "LightProbeProxyVolume.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"LightProbeProxyVolume.GetComponentInChildren": {
		"prefix": "LightProbeProxyVolume.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"LightProbeProxyVolume.GetComponentInParent": {
		"prefix": "LightProbeProxyVolume.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"LightProbeProxyVolume.GetComponents": {
		"prefix": "LightProbeProxyVolume.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"LightProbeProxyVolume.GetComponentsInChildren": {
		"prefix": "LightProbeProxyVolume.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"LightProbeProxyVolume.GetComponentsInParent": {
		"prefix": "LightProbeProxyVolume.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"LightProbeProxyVolume.SendMessage": {
		"prefix": "LightProbeProxyVolume.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"LightProbeProxyVolume.SendMessageUpwards": {
		"prefix": "LightProbeProxyVolume.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"LightProbeProxyVolume.GetInstanceID": {
		"prefix": "LightProbeProxyVolume.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"LightProbeProxyVolume.ToString": {
		"prefix": "LightProbeProxyVolume.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"LightProbeProxyVolume.Destroy": {
		"prefix": "LightProbeProxyVolume.Destroy",
		"body": [
			"LightProbeProxyVolume.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"LightProbeProxyVolume.DestroyImmediate": {
		"prefix": "LightProbeProxyVolume.DestroyImmediate",
		"body": [
			"LightProbeProxyVolume.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"LightProbeProxyVolume.DontDestroyOnLoad": {
		"prefix": "LightProbeProxyVolume.DontDestroyOnLoad",
		"body": [
			"LightProbeProxyVolume.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"LightProbeProxyVolume.FindObjectOfType": {
		"prefix": "LightProbeProxyVolume.FindObjectOfType",
		"body": [
			"LightProbeProxyVolume.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"LightProbeProxyVolume.FindObjectsOfType": {
		"prefix": "LightProbeProxyVolume.FindObjectsOfType",
		"body": [
			"LightProbeProxyVolume.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"LightProbeProxyVolume.Instantiate": {
		"prefix": "LightProbeProxyVolume.Instantiate",
		"body": [
			"LightProbeProxyVolume.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"LightProbeProxyVolume.BoundingBoxMode.AutomaticLocal": {
		"prefix": "LightProbeProxyVolume.BoundingBoxMode.AutomaticLocal",
		"body": [
			"AutomaticLocal"
		],
		"description": "return: des: The bounding box encloses the current Renderer and all the relevant Renderers down the hierarchy, in local space."
	}
,
	"LightProbeProxyVolume.BoundingBoxMode.AutomaticWorld": {
		"prefix": "LightProbeProxyVolume.BoundingBoxMode.AutomaticWorld",
		"body": [
			"AutomaticWorld"
		],
		"description": "return: des: The bounding box encloses the current Renderer and all the relevant Renderers down the hierarchy, in world space."
	}
,
	"LightProbeProxyVolume.BoundingBoxMode.Custom": {
		"prefix": "LightProbeProxyVolume.BoundingBoxMode.Custom",
		"body": [
			"Custom"
		],
		"description": "return: des: A custom local-space bounding box is used. The user is able to edit the bounding box."
	}
,
	"LightProbeProxyVolume.ProbePositionMode.CellCorner": {
		"prefix": "LightProbeProxyVolume.ProbePositionMode.CellCorner",
		"body": [
			"CellCorner"
		],
		"description": "return: des: Divide the volume in cells based on resolution, and generate interpolated Light Probes positions in the corner/edge of the cells."
	}
,
	"LightProbeProxyVolume.ProbePositionMode.CellCenter": {
		"prefix": "LightProbeProxyVolume.ProbePositionMode.CellCenter",
		"body": [
			"CellCenter"
		],
		"description": "return: des: Divide the volume in cells based on resolution, and generate interpolated Light Probe positions in the center of the cells."
	}
,
	"LightProbeProxyVolume.QualityMode.Low": {
		"prefix": "LightProbeProxyVolume.QualityMode.Low",
		"body": [
			"Low"
		],
		"description": "return: des: This option will use only two SH coefficients bands: L0 and L1. The coefficients are sampled from the Light Probe Proxy Volume 3D Texture. Using this option might increase the draw call batch sizes by not having to change the L2 coefficients per Renderer."
	}
,
	"LightProbeProxyVolume.QualityMode.Normal": {
		"prefix": "LightProbeProxyVolume.QualityMode.Normal",
		"body": [
			"Normal"
		],
		"description": "return: des: This option will use L0 and L1 SH coefficients from the Light Probe Proxy Volume 3D Texture. The L2 coefficients are constant per Renderer. By having to provide the L2 coefficients, draw call batches might be broken."
	}
,
	"LightProbeProxyVolume.RefreshMode.Automatic": {
		"prefix": "LightProbeProxyVolume.RefreshMode.Automatic",
		"body": [
			"Automatic"
		],
		"description": "return: des: Automatically detects updates in Light Probes and triggers an update of the Light Probe volume."
	}
,
	"LightProbeProxyVolume.RefreshMode.EveryFrame": {
		"prefix": "LightProbeProxyVolume.RefreshMode.EveryFrame",
		"body": [
			"EveryFrame"
		],
		"description": "return: des: Causes Unity to update the Light Probe Proxy Volume every frame."
	}
,
	"LightProbeProxyVolume.RefreshMode.ViaScripting": {
		"prefix": "LightProbeProxyVolume.RefreshMode.ViaScripting",
		"body": [
			"ViaScripting"
		],
		"description": "return: des: Use this option to indicate that the Light Probe Proxy Volume is never to be automatically updated by Unity."
	}
,
	"LightProbeProxyVolume.ResolutionMode.Automatic": {
		"prefix": "LightProbeProxyVolume.ResolutionMode.Automatic",
		"body": [
			"Automatic"
		],
		"description": "return: des: The automatic mode uses a number of interpolated Light Probes per unit area, and uses the bounding volume size to compute the resolution. The final resolution value is a power of 2."
	}
,
	"LightProbeProxyVolume.ResolutionMode.Custom": {
		"prefix": "LightProbeProxyVolume.ResolutionMode.Custom",
		"body": [
			"Custom"
		],
		"description": "return: des: The custom mode allows you to specify the 3D grid resolution."
	}
,
	"LightProbes.bakedProbes": {
		"prefix": "LightProbes.bakedProbes",
		"body": [
			"bakedProbes"
		],
		"description": "return:SphericalHarmonicsL2[] des: Coefficients of baked light probes."
	}
,
	"LightProbes.cellCount": {
		"prefix": "LightProbes.cellCount",
		"body": [
			"cellCount"
		],
		"description": "return:int des: The number of cells space is divided into (Read Only)."
	}
,
	"LightProbes.count": {
		"prefix": "LightProbes.count",
		"body": [
			"count"
		],
		"description": "return:int des: The number of light probes (Read Only)."
	}
,
	"LightProbes.positions": {
		"prefix": "LightProbes.positions",
		"body": [
			"positions"
		],
		"description": "return:Vector3[] des: Positions of the baked light probes (Read Only)."
	}
,
	"LightProbes.CalculateInterpolatedLightAndOcclusionProbes": {
		"prefix": "LightProbes.CalculateInterpolatedLightAndOcclusionProbes",
		"body": [
			"LightProbes.CalculateInterpolatedLightAndOcclusionProbes"
		],
		"description": "public static void CalculateInterpolatedLightAndOcclusionProbes(Vector3[] positions, SphericalHarmonicsL2[] lightProbes, Vector4[] occlusionProbes); public static void CalculateInterpolatedLightAndOcclusionProbes(List<Vector3> positions, List<SphericalHarmonicsL2> lightProbes, List<Vector4> occlusionProbes); des: Calculate light probes and occlusion probes at the given world space positions."
	}
,
	"LightProbes.GetInterpolatedProbe": {
		"prefix": "LightProbes.GetInterpolatedProbe",
		"body": [
			"LightProbes.GetInterpolatedProbe"
		],
		"description": "public static void GetInterpolatedProbe(Vector3 position, Renderer renderer, out Rendering.SphericalHarmonicsL2 probe); des: Returns an interpolated probe for the given position for both realtime and baked light probes combined."
	}
,
	"LightProbes.hideFlags": {
		"prefix": "LightProbes.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"LightProbes.name": {
		"prefix": "LightProbes.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"LightProbes.GetInstanceID": {
		"prefix": "LightProbes.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"LightProbes.ToString": {
		"prefix": "LightProbes.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"LightProbes.Destroy": {
		"prefix": "LightProbes.Destroy",
		"body": [
			"LightProbes.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"LightProbes.DestroyImmediate": {
		"prefix": "LightProbes.DestroyImmediate",
		"body": [
			"LightProbes.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"LightProbes.DontDestroyOnLoad": {
		"prefix": "LightProbes.DontDestroyOnLoad",
		"body": [
			"LightProbes.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"LightProbes.FindObjectOfType": {
		"prefix": "LightProbes.FindObjectOfType",
		"body": [
			"LightProbes.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"LightProbes.FindObjectsOfType": {
		"prefix": "LightProbes.FindObjectsOfType",
		"body": [
			"LightProbes.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"LightProbes.Instantiate": {
		"prefix": "LightProbes.Instantiate",
		"body": [
			"LightProbes.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"LineRenderer.alignment": {
		"prefix": "LineRenderer.alignment",
		"body": [
			"alignment"
		],
		"description": "return:LineAlignment des: Select whether the line will face the camera, or the orientation of the Transform Component."
	}
,
	"LineRenderer.colorGradient": {
		"prefix": "LineRenderer.colorGradient",
		"body": [
			"colorGradient"
		],
		"description": "return:Gradient des: Set the color gradient describing the color of the line at various points along its length."
	}
,
	"LineRenderer.endColor": {
		"prefix": "LineRenderer.endColor",
		"body": [
			"endColor"
		],
		"description": "return:Color des: Set the color at the end of the line."
	}
,
	"LineRenderer.endWidth": {
		"prefix": "LineRenderer.endWidth",
		"body": [
			"endWidth"
		],
		"description": "return:float des: Set the width at the end of the line."
	}
,
	"LineRenderer.generateLightingData": {
		"prefix": "LineRenderer.generateLightingData",
		"body": [
			"generateLightingData"
		],
		"description": "return:bool des: Configures a line to generate Normals and Tangents. With this data, Scene lighting can affect the line via Normal Maps and the Unity Standard Shader, or your own custom-built Shaders."
	}
,
	"LineRenderer.loop": {
		"prefix": "LineRenderer.loop",
		"body": [
			"loop"
		],
		"description": "return:bool des: Connect the start and end positions of the line together to form a continuous loop."
	}
,
	"LineRenderer.numCapVertices": {
		"prefix": "LineRenderer.numCapVertices",
		"body": [
			"numCapVertices"
		],
		"description": "return:int des: Set this to a value greater than 0, to get rounded corners on each end of the line."
	}
,
	"LineRenderer.numCornerVertices": {
		"prefix": "LineRenderer.numCornerVertices",
		"body": [
			"numCornerVertices"
		],
		"description": "return:int des: Set this to a value greater than 0, to get rounded corners between each segment of the line."
	}
,
	"LineRenderer.positionCount": {
		"prefix": "LineRenderer.positionCount",
		"body": [
			"positionCount"
		],
		"description": "return:int des: Set/get the number of vertices."
	}
,
	"LineRenderer.startColor": {
		"prefix": "LineRenderer.startColor",
		"body": [
			"startColor"
		],
		"description": "return:Color des: Set the color at the start of the line."
	}
,
	"LineRenderer.startWidth": {
		"prefix": "LineRenderer.startWidth",
		"body": [
			"startWidth"
		],
		"description": "return:float des: Set the width at the start of the line."
	}
,
	"LineRenderer.textureMode": {
		"prefix": "LineRenderer.textureMode",
		"body": [
			"textureMode"
		],
		"description": "return:LineTextureMode des: Choose whether the U coordinate of the line texture is tiled or stretched."
	}
,
	"LineRenderer.useWorldSpace": {
		"prefix": "LineRenderer.useWorldSpace",
		"body": [
			"useWorldSpace"
		],
		"description": "return:bool des: If enabled, the lines are defined in world space."
	}
,
	"LineRenderer.widthCurve": {
		"prefix": "LineRenderer.widthCurve",
		"body": [
			"widthCurve"
		],
		"description": "return:AnimationCurve des: Set the curve describing the width of the line at various points along its length."
	}
,
	"LineRenderer.widthMultiplier": {
		"prefix": "LineRenderer.widthMultiplier",
		"body": [
			"widthMultiplier"
		],
		"description": "return:float des: Set an overall multiplier that is applied to the LineRenderer.widthCurve to get the final width of the line."
	}
,
	"LineRenderer.BakeMesh": {
		"prefix": "LineRenderer.BakeMesh",
		"body": [
			"BakeMesh($1)"
		],
		"description": "public void BakeMesh(Mesh mesh, bool useTransform); public void BakeMesh(Mesh mesh, Camera camera, bool useTransform); des: Creates a snapshot of LineRenderer and stores it in mesh."
	}
,
	"LineRenderer.GetPosition": {
		"prefix": "LineRenderer.GetPosition",
		"body": [
			"GetPosition($1)"
		],
		"description": "public Vector3 GetPosition(int index); des: Get the position of a vertex in the line."
	}
,
	"LineRenderer.GetPositions": {
		"prefix": "LineRenderer.GetPositions",
		"body": [
			"GetPositions($1)"
		],
		"description": "public int GetPositions(out Vector3[] positions); des: Get the positions of all vertices in the line."
	}
,
	"LineRenderer.SetPosition": {
		"prefix": "LineRenderer.SetPosition",
		"body": [
			"SetPosition($1)"
		],
		"description": "public void SetPosition(int index, Vector3 position); des: Set the position of a vertex in the line."
	}
,
	"LineRenderer.SetPositions": {
		"prefix": "LineRenderer.SetPositions",
		"body": [
			"SetPositions($1)"
		],
		"description": "public void SetPositions(Vector3[] positions); des: Set the positions of all vertices in the line."
	}
,
	"LineRenderer.Simplify": {
		"prefix": "LineRenderer.Simplify",
		"body": [
			"Simplify($1)"
		],
		"description": "public void Simplify(float tolerance); des: Generates a simplified version of the original line by removing points that fall within the specified tolerance."
	}
,
	"LineRenderer.gameObject": {
		"prefix": "LineRenderer.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"LineRenderer.tag": {
		"prefix": "LineRenderer.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"LineRenderer.transform": {
		"prefix": "LineRenderer.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"LineRenderer.hideFlags": {
		"prefix": "LineRenderer.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"LineRenderer.name": {
		"prefix": "LineRenderer.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"LineRenderer.allowOcclusionWhenDynamic": {
		"prefix": "LineRenderer.allowOcclusionWhenDynamic",
		"body": [
			"allowOcclusionWhenDynamic"
		],
		"description": "return:bool des: Controls if dynamic occlusion culling should be performed for this renderer."
	}
,
	"LineRenderer.bounds": {
		"prefix": "LineRenderer.bounds",
		"body": [
			"bounds"
		],
		"description": "return:Bounds des: The bounding volume of the renderer (Read Only)."
	}
,
	"LineRenderer.enabled": {
		"prefix": "LineRenderer.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Makes the rendered 3D object visible if enabled."
	}
,
	"LineRenderer.isPartOfStaticBatch": {
		"prefix": "LineRenderer.isPartOfStaticBatch",
		"body": [
			"isPartOfStaticBatch"
		],
		"description": "return:bool des: Has this renderer been statically batched with any other renderers?"
	}
,
	"LineRenderer.isVisible": {
		"prefix": "LineRenderer.isVisible",
		"body": [
			"isVisible"
		],
		"description": "return:bool des: Is this renderer visible in any camera? (Read Only)"
	}
,
	"LineRenderer.lightmapIndex": {
		"prefix": "LineRenderer.lightmapIndex",
		"body": [
			"lightmapIndex"
		],
		"description": "return:int des: The index of the baked lightmap applied to this renderer."
	}
,
	"LineRenderer.lightmapScaleOffset": {
		"prefix": "LineRenderer.lightmapScaleOffset",
		"body": [
			"lightmapScaleOffset"
		],
		"description": "return:Vector4 des: The UV scale & offset used for a lightmap."
	}
,
	"LineRenderer.lightProbeProxyVolumeOverride": {
		"prefix": "LineRenderer.lightProbeProxyVolumeOverride",
		"body": [
			"lightProbeProxyVolumeOverride"
		],
		"description": "return:GameObject des: If set, the Renderer will use the Light Probe Proxy Volume component attached to the source GameObject."
	}
,
	"LineRenderer.lightProbeUsage": {
		"prefix": "LineRenderer.lightProbeUsage",
		"body": [
			"lightProbeUsage"
		],
		"description": "return:Rendering.LightProbeUsage des: The light probe interpolation type."
	}
,
	"LineRenderer.localToWorldMatrix": {
		"prefix": "LineRenderer.localToWorldMatrix",
		"body": [
			"localToWorldMatrix"
		],
		"description": "return:Matrix4x4 des: Matrix that transforms a point from local space into world space (Read Only)."
	}
,
	"LineRenderer.material": {
		"prefix": "LineRenderer.material",
		"body": [
			"material"
		],
		"description": "return:Material des: Returns the first instantiated Material assigned to the renderer."
	}
,
	"LineRenderer.materials": {
		"prefix": "LineRenderer.materials",
		"body": [
			"materials"
		],
		"description": "return:Material[] des: Returns all the instantiated materials of this object."
	}
,
	"LineRenderer.motionVectorGenerationMode": {
		"prefix": "LineRenderer.motionVectorGenerationMode",
		"body": [
			"motionVectorGenerationMode"
		],
		"description": "return:MotionVectorGenerationMode des: Specifies the mode for motion vector rendering."
	}
,
	"LineRenderer.probeAnchor": {
		"prefix": "LineRenderer.probeAnchor",
		"body": [
			"probeAnchor"
		],
		"description": "return:Transform des: If set, Renderer will use this Transform's position to find the light or reflection probe."
	}
,
	"LineRenderer.realtimeLightmapIndex": {
		"prefix": "LineRenderer.realtimeLightmapIndex",
		"body": [
			"realtimeLightmapIndex"
		],
		"description": "return:int des: The index of the realtime lightmap applied to this renderer."
	}
,
	"LineRenderer.realtimeLightmapScaleOffset": {
		"prefix": "LineRenderer.realtimeLightmapScaleOffset",
		"body": [
			"realtimeLightmapScaleOffset"
		],
		"description": "return:Vector4 des: The UV scale & offset used for a realtime lightmap."
	}
,
	"LineRenderer.receiveShadows": {
		"prefix": "LineRenderer.receiveShadows",
		"body": [
			"receiveShadows"
		],
		"description": "return:bool des: Does this object receive shadows?"
	}
,
	"LineRenderer.reflectionProbeUsage": {
		"prefix": "LineRenderer.reflectionProbeUsage",
		"body": [
			"reflectionProbeUsage"
		],
		"description": "return:Rendering.ReflectionProbeUsage des: Should reflection probes be used for this Renderer?"
	}
,
	"LineRenderer.renderingLayerMask": {
		"prefix": "LineRenderer.renderingLayerMask",
		"body": [
			"renderingLayerMask"
		],
		"description": "return:uint des: Determines which rendering layer this renderer lives on."
	}
,
	"LineRenderer.shadowCastingMode": {
		"prefix": "LineRenderer.shadowCastingMode",
		"body": [
			"shadowCastingMode"
		],
		"description": "return:Rendering.ShadowCastingMode des: Does this object cast shadows?"
	}
,
	"LineRenderer.sharedMaterial": {
		"prefix": "LineRenderer.sharedMaterial",
		"body": [
			"sharedMaterial"
		],
		"description": "return:Material des: The shared material of this object."
	}
,
	"LineRenderer.sharedMaterials": {
		"prefix": "LineRenderer.sharedMaterials",
		"body": [
			"sharedMaterials"
		],
		"description": "return:Material[] des: All the shared materials of this object."
	}
,
	"LineRenderer.sortingLayerID": {
		"prefix": "LineRenderer.sortingLayerID",
		"body": [
			"sortingLayerID"
		],
		"description": "return:int des: Unique ID of the Renderer's sorting layer."
	}
,
	"LineRenderer.sortingLayerName": {
		"prefix": "LineRenderer.sortingLayerName",
		"body": [
			"sortingLayerName"
		],
		"description": "return:string des: Name of the Renderer's sorting layer."
	}
,
	"LineRenderer.sortingOrder": {
		"prefix": "LineRenderer.sortingOrder",
		"body": [
			"sortingOrder"
		],
		"description": "return:int des: Renderer's order within a sorting layer."
	}
,
	"LineRenderer.worldToLocalMatrix": {
		"prefix": "LineRenderer.worldToLocalMatrix",
		"body": [
			"worldToLocalMatrix"
		],
		"description": "return:Matrix4x4 des: Matrix that transforms a point from world space into local space (Read Only)."
	}
,
	"LineRenderer.BroadcastMessage": {
		"prefix": "LineRenderer.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"LineRenderer.CompareTag": {
		"prefix": "LineRenderer.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"LineRenderer.GetComponent": {
		"prefix": "LineRenderer.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"LineRenderer.GetComponentInChildren": {
		"prefix": "LineRenderer.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"LineRenderer.GetComponentInParent": {
		"prefix": "LineRenderer.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"LineRenderer.GetComponents": {
		"prefix": "LineRenderer.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"LineRenderer.GetComponentsInChildren": {
		"prefix": "LineRenderer.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"LineRenderer.GetComponentsInParent": {
		"prefix": "LineRenderer.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"LineRenderer.SendMessage": {
		"prefix": "LineRenderer.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"LineRenderer.SendMessageUpwards": {
		"prefix": "LineRenderer.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"LineRenderer.GetInstanceID": {
		"prefix": "LineRenderer.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"LineRenderer.ToString": {
		"prefix": "LineRenderer.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"LineRenderer.GetClosestReflectionProbes": {
		"prefix": "LineRenderer.GetClosestReflectionProbes",
		"body": [
			"GetClosestReflectionProbes($1)"
		],
		"description": "public void GetClosestReflectionProbes(List<ReflectionProbeBlendInfo> result); des: Returns an array of closest reflection probes with weights, weight shows how much influence the probe has on the renderer, this value is also used when blending between reflection probes occur."
	}
,
	"LineRenderer.GetMaterials": {
		"prefix": "LineRenderer.GetMaterials",
		"body": [
			"GetMaterials($1)"
		],
		"description": "public void GetMaterials(List<Material> m); des: Returns all the instantiated materials of this object."
	}
,
	"LineRenderer.GetPropertyBlock": {
		"prefix": "LineRenderer.GetPropertyBlock",
		"body": [
			"GetPropertyBlock($1)"
		],
		"description": "public void GetPropertyBlock(MaterialPropertyBlock properties); public void GetPropertyBlock(MaterialPropertyBlock properties, int materialIndex); des: Get per-Renderer or per-Material property block."
	}
,
	"LineRenderer.GetSharedMaterials": {
		"prefix": "LineRenderer.GetSharedMaterials",
		"body": [
			"GetSharedMaterials($1)"
		],
		"description": "public void GetSharedMaterials(List<Material> m); des: Returns all the shared materials of this object."
	}
,
	"LineRenderer.HasPropertyBlock": {
		"prefix": "LineRenderer.HasPropertyBlock",
		"body": [
			"HasPropertyBlock($1)"
		],
		"description": "public bool HasPropertyBlock(); des: Returns true if the Renderer has a material property block attached via SetPropertyBlock."
	}
,
	"LineRenderer.SetPropertyBlock": {
		"prefix": "LineRenderer.SetPropertyBlock",
		"body": [
			"SetPropertyBlock($1)"
		],
		"description": "public void SetPropertyBlock(MaterialPropertyBlock properties); public void SetPropertyBlock(MaterialPropertyBlock properties, int materialIndex); des: Lets you set or clear per-renderer or per-material parameter overrides."
	}
,
	"LineRenderer.Destroy": {
		"prefix": "LineRenderer.Destroy",
		"body": [
			"LineRenderer.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"LineRenderer.DestroyImmediate": {
		"prefix": "LineRenderer.DestroyImmediate",
		"body": [
			"LineRenderer.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"LineRenderer.DontDestroyOnLoad": {
		"prefix": "LineRenderer.DontDestroyOnLoad",
		"body": [
			"LineRenderer.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"LineRenderer.FindObjectOfType": {
		"prefix": "LineRenderer.FindObjectOfType",
		"body": [
			"LineRenderer.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"LineRenderer.FindObjectsOfType": {
		"prefix": "LineRenderer.FindObjectsOfType",
		"body": [
			"LineRenderer.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"LineRenderer.Instantiate": {
		"prefix": "LineRenderer.Instantiate",
		"body": [
			"LineRenderer.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"LineRenderer.OnBecameInvisible": {
		"prefix": "LineRenderer.OnBecameInvisible",
		"body": [
			"OnBecameInvisible"
		],
		"description": "OnBecameInvisible is called when the object is no longer visible by any camera."
	}
,
	"LineRenderer.OnBecameVisible": {
		"prefix": "LineRenderer.OnBecameVisible",
		"body": [
			"OnBecameVisible"
		],
		"description": "OnBecameVisible is called when the object became visible by any camera."
	}
,
	"LineUtility.Simplify": {
		"prefix": "LineUtility.Simplify",
		"body": [
			"LineUtility.Simplify"
		],
		"description": "public static void Simplify(List<Vector3> points, float tolerance, List<int> pointsToKeep); public static void Simplify(List<Vector3> points, float tolerance, List<Vector3> simplifiedPoints); public static void Simplify(List<Vector2> points, float tolerance, List<int> pointsToKeep); public static void Simplify(List<Vector2> points, float tolerance, List<Vector2> simplifiedPoints); des: Generates a simplified version of the original line by removing points that fall within the specified tolerance."
	}
,
	"LocationInfo.altitude": {
		"prefix": "LocationInfo.altitude",
		"body": [
			"altitude"
		],
		"description": "return:float des: Geographical device location altitude."
	}
,
	"LocationInfo.horizontalAccuracy": {
		"prefix": "LocationInfo.horizontalAccuracy",
		"body": [
			"horizontalAccuracy"
		],
		"description": "return:float des: Horizontal accuracy of the location."
	}
,
	"LocationInfo.latitude": {
		"prefix": "LocationInfo.latitude",
		"body": [
			"latitude"
		],
		"description": "return:float des: Geographical device location latitude."
	}
,
	"LocationInfo.longitude": {
		"prefix": "LocationInfo.longitude",
		"body": [
			"longitude"
		],
		"description": "return:float des: Geographical device location latitude."
	}
,
	"LocationInfo.timestamp": {
		"prefix": "LocationInfo.timestamp",
		"body": [
			"timestamp"
		],
		"description": "return:double des: Timestamp (in seconds since 1970) when location was last time updated."
	}
,
	"LocationInfo.verticalAccuracy": {
		"prefix": "LocationInfo.verticalAccuracy",
		"body": [
			"verticalAccuracy"
		],
		"description": "return:float des: Vertical accuracy of the location."
	}
,
	"LocationService.isEnabledByUser": {
		"prefix": "LocationService.isEnabledByUser",
		"body": [
			"isEnabledByUser"
		],
		"description": "return:bool des: Specifies whether location service is enabled in user settings."
	}
,
	"LocationService.lastData": {
		"prefix": "LocationService.lastData",
		"body": [
			"lastData"
		],
		"description": "return:LocationInfo des: Last measured device geographical location."
	}
,
	"LocationService.status": {
		"prefix": "LocationService.status",
		"body": [
			"status"
		],
		"description": "return:LocationServiceStatus des: Returns location service status."
	}
,
	"LocationService.Start": {
		"prefix": "LocationService.Start",
		"body": [
			"Start($1)"
		],
		"description": "public void Start(float desiredAccuracyInMeters = 10f, float updateDistanceInMeters = 10f); des: Starts location service updates. Last location coordinates could be."
	}
,
	"LocationService.Stop": {
		"prefix": "LocationService.Stop",
		"body": [
			"Stop($1)"
		],
		"description": "public void Stop(); des: Stops location service updates. This could be useful for saving battery life."
	}
,
	"LOD.fadeTransitionWidth": {
		"prefix": "LOD.fadeTransitionWidth",
		"body": [
			"fadeTransitionWidth"
		],
		"description": "return:float des: Width of the cross-fade transition zone (proportion to the current LOD's whole length) [0-1]. Only used if it's not animated."
	}
,
	"LOD.renderers": {
		"prefix": "LOD.renderers",
		"body": [
			"renderers"
		],
		"description": "return:Renderer[] des: List of renderers for this LOD level."
	}
,
	"LOD.screenRelativeTransitionHeight": {
		"prefix": "LOD.screenRelativeTransitionHeight",
		"body": [
			"screenRelativeTransitionHeight"
		],
		"description": "return:float des: The screen relative height to use for the transition [0-1]."
	}
,
	"LODGroup.animateCrossFading": {
		"prefix": "LODGroup.animateCrossFading",
		"body": [
			"animateCrossFading"
		],
		"description": "return:bool des: Specify if the cross-fading should be animated by time. The animation duration is specified globally as crossFadeAnimationDuration."
	}
,
	"LODGroup.enabled": {
		"prefix": "LODGroup.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enable / Disable the LODGroup - Disabling will turn off all renderers."
	}
,
	"LODGroup.fadeMode": {
		"prefix": "LODGroup.fadeMode",
		"body": [
			"fadeMode"
		],
		"description": "return:LODFadeMode des: The LOD fade mode used."
	}
,
	"LODGroup.localReferencePoint": {
		"prefix": "LODGroup.localReferencePoint",
		"body": [
			"localReferencePoint"
		],
		"description": "return:Vector3 des: The local reference point against which the LOD distance is calculated."
	}
,
	"LODGroup.lodCount": {
		"prefix": "LODGroup.lodCount",
		"body": [
			"lodCount"
		],
		"description": "return:int des: The number of LOD levels."
	}
,
	"LODGroup.size": {
		"prefix": "LODGroup.size",
		"body": [
			"size"
		],
		"description": "return:float des: The size of the LOD object in local space."
	}
,
	"LODGroup.ForceLOD": {
		"prefix": "LODGroup.ForceLOD",
		"body": [
			"ForceLOD($1)"
		],
		"description": "public void ForceLOD(int index); des: "
	}
,
	"LODGroup.GetLODs": {
		"prefix": "LODGroup.GetLODs",
		"body": [
			"GetLODs($1)"
		],
		"description": "public LOD[] GetLODs(); des: Returns the array of LODs."
	}
,
	"LODGroup.RecalculateBounds": {
		"prefix": "LODGroup.RecalculateBounds",
		"body": [
			"RecalculateBounds($1)"
		],
		"description": "public void RecalculateBounds(); des: Recalculate the bounding region for the LODGroup (Relatively slow, do not call often)."
	}
,
	"LODGroup.SetLODs": {
		"prefix": "LODGroup.SetLODs",
		"body": [
			"SetLODs($1)"
		],
		"description": "public void SetLODs(LOD[] lods); des: Set the LODs for the LOD group. This will remove any existing LODs configured on the LODGroup."
	}
,
	"LODGroup.gameObject": {
		"prefix": "LODGroup.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"LODGroup.tag": {
		"prefix": "LODGroup.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"LODGroup.transform": {
		"prefix": "LODGroup.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"LODGroup.hideFlags": {
		"prefix": "LODGroup.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"LODGroup.name": {
		"prefix": "LODGroup.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"LODGroup.BroadcastMessage": {
		"prefix": "LODGroup.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"LODGroup.CompareTag": {
		"prefix": "LODGroup.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"LODGroup.GetComponent": {
		"prefix": "LODGroup.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"LODGroup.GetComponentInChildren": {
		"prefix": "LODGroup.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"LODGroup.GetComponentInParent": {
		"prefix": "LODGroup.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"LODGroup.GetComponents": {
		"prefix": "LODGroup.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"LODGroup.GetComponentsInChildren": {
		"prefix": "LODGroup.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"LODGroup.GetComponentsInParent": {
		"prefix": "LODGroup.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"LODGroup.SendMessage": {
		"prefix": "LODGroup.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"LODGroup.SendMessageUpwards": {
		"prefix": "LODGroup.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"LODGroup.GetInstanceID": {
		"prefix": "LODGroup.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"LODGroup.ToString": {
		"prefix": "LODGroup.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"LODGroup.Destroy": {
		"prefix": "LODGroup.Destroy",
		"body": [
			"LODGroup.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"LODGroup.DestroyImmediate": {
		"prefix": "LODGroup.DestroyImmediate",
		"body": [
			"LODGroup.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"LODGroup.DontDestroyOnLoad": {
		"prefix": "LODGroup.DontDestroyOnLoad",
		"body": [
			"LODGroup.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"LODGroup.FindObjectOfType": {
		"prefix": "LODGroup.FindObjectOfType",
		"body": [
			"LODGroup.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"LODGroup.FindObjectsOfType": {
		"prefix": "LODGroup.FindObjectsOfType",
		"body": [
			"LODGroup.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"LODGroup.Instantiate": {
		"prefix": "LODGroup.Instantiate",
		"body": [
			"LODGroup.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"Logger.filterLogType": {
		"prefix": "Logger.filterLogType",
		"body": [
			"filterLogType"
		],
		"description": "return:LogType des: To selective enable debug log message."
	}
,
	"Logger.logEnabled": {
		"prefix": "Logger.logEnabled",
		"body": [
			"logEnabled"
		],
		"description": "return:bool des: To runtime toggle debug logging [ON/OFF]."
	}
,
	"Logger.logHandler": {
		"prefix": "Logger.logHandler",
		"body": [
			"logHandler"
		],
		"description": "return:ILogHandler des: Set Logger.ILogHandler."
	}
,
	"Logger.IsLogTypeAllowed": {
		"prefix": "Logger.IsLogTypeAllowed",
		"body": [
			"IsLogTypeAllowed($1)"
		],
		"description": "public bool IsLogTypeAllowed(LogType logType); des: Check logging is enabled based on the LogType."
	}
,
	"Logger.Log": {
		"prefix": "Logger.Log",
		"body": [
			"Log($1)"
		],
		"description": "public void Log(LogType logType, object message); public void Log(LogType logType, object message, Object context); public void Log(LogType logType, string tag, object message); public void Log(LogType logType, string tag, object message, Object context); public void Log(object message); public void Log(string tag, object message); public void Log(string tag, object message, Object context); des: Logs message to the Unity Console using default logger."
	}
,
	"Logger.LogError": {
		"prefix": "Logger.LogError",
		"body": [
			"LogError($1)"
		],
		"description": "public void LogError(string tag, object message); public void LogError(string tag, object message, Object context); des: A variant of Logger.Log that logs an error message."
	}
,
	"Logger.LogException": {
		"prefix": "Logger.LogException",
		"body": [
			"LogException($1)"
		],
		"description": "public void LogException(Exception exception); public void LogException(Exception exception, Object context); des: A variant of Logger.Log that logs an exception message."
	}
,
	"Logger.LogFormat": {
		"prefix": "Logger.LogFormat",
		"body": [
			"LogFormat($1)"
		],
		"description": "public void LogFormat(LogType logType, string format, params object[] args); public void LogFormat(LogType logType, Object context, string format, params object[] args); des: Logs a formatted message."
	}
,
	"Logger.LogWarning": {
		"prefix": "Logger.LogWarning",
		"body": [
			"LogWarning($1)"
		],
		"description": "public void LogWarning(string tag, object message); public void LogWarning(string tag, object message, Object context); des: A variant of Logger.Log that logs an warning message."
	}
,
	"MasterServer.OnFailedToConnectToMasterServer": {
		"prefix": "MasterServer.OnFailedToConnectToMasterServer",
		"body": [
			"OnFailedToConnectToMasterServer"
		],
		"description": "Called on clients or servers when there is a problem connecting to the master server."
	}
,
	"MasterServer.OnMasterServerEvent": {
		"prefix": "MasterServer.OnMasterServerEvent",
		"body": [
			"OnMasterServerEvent"
		],
		"description": "Called on clients or servers when reporting events from the MasterServer."
	}
,
	"MatchTargetWeightMask.positionXYZWeight": {
		"prefix": "MatchTargetWeightMask.positionXYZWeight",
		"body": [
			"positionXYZWeight"
		],
		"description": "return:Vector3 des: Position XYZ weight."
	}
,
	"MatchTargetWeightMask.rotationWeight": {
		"prefix": "MatchTargetWeightMask.rotationWeight",
		"body": [
			"rotationWeight"
		],
		"description": "return:float des: Rotation weight."
	}
,
	"Material.color": {
		"prefix": "Material.color",
		"body": [
			"color"
		],
		"description": "return:Color des: The main material's color."
	}
,
	"Material.doubleSidedGI": {
		"prefix": "Material.doubleSidedGI",
		"body": [
			"doubleSidedGI"
		],
		"description": "return:bool des: Gets and sets whether the Double Sided Global Illumination setting is enabled for this material."
	}
,
	"Material.enableInstancing": {
		"prefix": "Material.enableInstancing",
		"body": [
			"enableInstancing"
		],
		"description": "return:bool des: Gets and sets whether GPU instancing is enabled for this material."
	}
,
	"Material.globalIlluminationFlags": {
		"prefix": "Material.globalIlluminationFlags",
		"body": [
			"globalIlluminationFlags"
		],
		"description": "return:MaterialGlobalIlluminationFlags des: Defines how the material should interact with lightmaps and lightprobes."
	}
,
	"Material.mainTexture": {
		"prefix": "Material.mainTexture",
		"body": [
			"mainTexture"
		],
		"description": "return:Texture des: The material's texture."
	}
,
	"Material.mainTextureOffset": {
		"prefix": "Material.mainTextureOffset",
		"body": [
			"mainTextureOffset"
		],
		"description": "return:Vector2 des: The texture offset of the main texture."
	}
,
	"Material.mainTextureScale": {
		"prefix": "Material.mainTextureScale",
		"body": [
			"mainTextureScale"
		],
		"description": "return:Vector2 des: The texture scale of the main texture."
	}
,
	"Material.passCount": {
		"prefix": "Material.passCount",
		"body": [
			"passCount"
		],
		"description": "return:int des: How many passes are in this material (Read Only)."
	}
,
	"Material.renderQueue": {
		"prefix": "Material.renderQueue",
		"body": [
			"renderQueue"
		],
		"description": "return:int des: Render queue of this material."
	}
,
	"Material.shader": {
		"prefix": "Material.shader",
		"body": [
			"shader"
		],
		"description": "return:Shader des: The shader used by the material."
	}
,
	"Material.shaderKeywords": {
		"prefix": "Material.shaderKeywords",
		"body": [
			"shaderKeywords"
		],
		"description": "return:string[] des: Additional shader keywords set by this material."
	}
,
	"Material.CopyPropertiesFromMaterial": {
		"prefix": "Material.CopyPropertiesFromMaterial",
		"body": [
			"CopyPropertiesFromMaterial($1)"
		],
		"description": "public void CopyPropertiesFromMaterial(Material mat); des: Copy properties from other material into this material."
	}
,
	"Material.DisableKeyword": {
		"prefix": "Material.DisableKeyword",
		"body": [
			"DisableKeyword($1)"
		],
		"description": "public void DisableKeyword(string keyword); des: Unset a shader keyword."
	}
,
	"Material.EnableKeyword": {
		"prefix": "Material.EnableKeyword",
		"body": [
			"EnableKeyword($1)"
		],
		"description": "public void EnableKeyword(string keyword); des: Sets a shader keyword that is enabled by this material."
	}
,
	"Material.FindPass": {
		"prefix": "Material.FindPass",
		"body": [
			"FindPass($1)"
		],
		"description": "public int FindPass(string passName); des: Returns the index of the pass passName."
	}
,
	"Material.GetColor": {
		"prefix": "Material.GetColor",
		"body": [
			"GetColor($1)"
		],
		"description": "public Color GetColor(string name); public Color GetColor(int nameID); des: Get a named color value."
	}
,
	"Material.GetColorArray": {
		"prefix": "Material.GetColorArray",
		"body": [
			"GetColorArray($1)"
		],
		"description": "public Color[] GetColorArray(string name); public Color[] GetColorArray(int nameID); public void GetColorArray(string name, List<Color> values); public void GetColorArray(int nameID, List<Color> values); des: Get a named color array."
	}
,
	"Material.GetFloat": {
		"prefix": "Material.GetFloat",
		"body": [
			"GetFloat($1)"
		],
		"description": "public float GetFloat(string name); public float GetFloat(int nameID); des: Get a named float value."
	}
,
	"Material.GetFloatArray": {
		"prefix": "Material.GetFloatArray",
		"body": [
			"GetFloatArray($1)"
		],
		"description": "public float[] GetFloatArray(string name); public float[] GetFloatArray(int nameID); public void GetFloatArray(string name, List<float> values); public void GetFloatArray(int nameID, List<float> values); des: Get a named float array."
	}
,
	"Material.GetInt": {
		"prefix": "Material.GetInt",
		"body": [
			"GetInt($1)"
		],
		"description": "public int GetInt(string name); public int GetInt(int nameID); des: Get a named integer value."
	}
,
	"Material.GetMatrix": {
		"prefix": "Material.GetMatrix",
		"body": [
			"GetMatrix($1)"
		],
		"description": "public Matrix4x4 GetMatrix(string name); public Matrix4x4 GetMatrix(int nameID); des: Get a named matrix value from the shader."
	}
,
	"Material.GetMatrixArray": {
		"prefix": "Material.GetMatrixArray",
		"body": [
			"GetMatrixArray($1)"
		],
		"description": "public Matrix4x4[] GetMatrixArray(string name); public Matrix4x4[] GetMatrixArray(int nameID); public void GetMatrixArray(string name, List<Matrix4x4> values); public void GetMatrixArray(int nameID, List<Matrix4x4> values); des: Get a named matrix array."
	}
,
	"Material.GetPassName": {
		"prefix": "Material.GetPassName",
		"body": [
			"GetPassName($1)"
		],
		"description": "public string GetPassName(int pass); des: Returns the name of the shader pass at index pass."
	}
,
	"Material.GetShaderPassEnabled": {
		"prefix": "Material.GetShaderPassEnabled",
		"body": [
			"GetShaderPassEnabled($1)"
		],
		"description": "public bool GetShaderPassEnabled(string passName); des: Checks whether a given Shader pass is enabled on this Material."
	}
,
	"Material.GetTag": {
		"prefix": "Material.GetTag",
		"body": [
			"GetTag($1)"
		],
		"description": "public string GetTag(string tag, bool searchFallbacks); public string GetTag(string tag, bool searchFallbacks, string defaultValue); des: Get the value of material's shader tag."
	}
,
	"Material.GetTexture": {
		"prefix": "Material.GetTexture",
		"body": [
			"GetTexture($1)"
		],
		"description": "public Texture GetTexture(string name); public Texture GetTexture(int nameID); des: Get a named texture."
	}
,
	"Material.GetTextureOffset": {
		"prefix": "Material.GetTextureOffset",
		"body": [
			"GetTextureOffset($1)"
		],
		"description": "public Vector2 GetTextureOffset(string name); public Vector2 GetTextureOffset(int nameID); des: Gets the placement offset of texture propertyName."
	}
,
	"Material.GetTexturePropertyNameIDs": {
		"prefix": "Material.GetTexturePropertyNameIDs",
		"body": [
			"GetTexturePropertyNameIDs($1)"
		],
		"description": "public int[] GetTexturePropertyNameIDs(); public void GetTexturePropertyNameIDs(List<int> outNames); des: Return the name IDs of all texture properties exposed on this material."
	}
,
	"Material.GetTexturePropertyNames": {
		"prefix": "Material.GetTexturePropertyNames",
		"body": [
			"GetTexturePropertyNames($1)"
		],
		"description": "public string[] GetTexturePropertyNames(); public void GetTexturePropertyNames(List<string> outNames); des: Returns the names of all texture properties exposed on this material."
	}
,
	"Material.GetTextureScale": {
		"prefix": "Material.GetTextureScale",
		"body": [
			"GetTextureScale($1)"
		],
		"description": "public Vector2 GetTextureScale(string name); public Vector2 GetTextureScale(int nameID); des: Gets the placement scale of texture propertyName."
	}
,
	"Material.GetVector": {
		"prefix": "Material.GetVector",
		"body": [
			"GetVector($1)"
		],
		"description": "public Vector4 GetVector(string name); public Vector4 GetVector(int nameID); des: Get a named vector value."
	}
,
	"Material.GetVectorArray": {
		"prefix": "Material.GetVectorArray",
		"body": [
			"GetVectorArray($1)"
		],
		"description": "public Vector4[] GetVectorArray(string name); public Vector4[] GetVectorArray(int nameID); public void GetVectorArray(string name, List<Vector4> values); public void GetVectorArray(int nameID, List<Vector4> values); des: Get a named vector array."
	}
,
	"Material.HasProperty": {
		"prefix": "Material.HasProperty",
		"body": [
			"HasProperty($1)"
		],
		"description": "public bool HasProperty(string name); public bool HasProperty(int nameID); des: Checks if material's shader has a property of a given name."
	}
,
	"Material.IsKeywordEnabled": {
		"prefix": "Material.IsKeywordEnabled",
		"body": [
			"IsKeywordEnabled($1)"
		],
		"description": "public bool IsKeywordEnabled(string keyword); des: Is the shader keyword enabled on this material?"
	}
,
	"Material.Lerp": {
		"prefix": "Material.Lerp",
		"body": [
			"Lerp($1)"
		],
		"description": "public void Lerp(Material start, Material end, float t); des: Interpolate properties between two materials."
	}
,
	"Material.SetBuffer": {
		"prefix": "Material.SetBuffer",
		"body": [
			"SetBuffer($1)"
		],
		"description": "public void SetBuffer(string name, ComputeBuffer value); public void SetBuffer(int nameID, ComputeBuffer value); des: Sets a named ComputeBuffer value."
	}
,
	"Material.SetColor": {
		"prefix": "Material.SetColor",
		"body": [
			"SetColor($1)"
		],
		"description": "public void SetColor(string name, Color value); public void SetColor(int nameID, Color value); des: Sets a named color value."
	}
,
	"Material.SetColorArray": {
		"prefix": "Material.SetColorArray",
		"body": [
			"SetColorArray($1)"
		],
		"description": "public void SetColorArray(string name, Color[] values); public void SetColorArray(int nameID, Color[] values); public void SetColorArray(string name, List<Color> values); public void SetColorArray(int nameID, List<Color> values); des: Sets a color array property."
	}
,
	"Material.SetFloat": {
		"prefix": "Material.SetFloat",
		"body": [
			"SetFloat($1)"
		],
		"description": "public void SetFloat(string name, float value); public void SetFloat(int nameID, float value); des: Sets a named float value."
	}
,
	"Material.SetFloatArray": {
		"prefix": "Material.SetFloatArray",
		"body": [
			"SetFloatArray($1)"
		],
		"description": "public void SetFloatArray(string name, float[] values); public void SetFloatArray(int nameID, float[] values); public void SetFloatArray(string name, List<float> values); public void SetFloatArray(int nameID, List<float> values); des: Sets a float array property."
	}
,
	"Material.SetInt": {
		"prefix": "Material.SetInt",
		"body": [
			"SetInt($1)"
		],
		"description": "public void SetInt(string name, int value); public void SetInt(int nameID, int value); des: Sets a named integer value."
	}
,
	"Material.SetMatrix": {
		"prefix": "Material.SetMatrix",
		"body": [
			"SetMatrix($1)"
		],
		"description": "public void SetMatrix(string name, Matrix4x4 value); public void SetMatrix(int nameID, Matrix4x4 value); des: Sets a named matrix for the shader."
	}
,
	"Material.SetMatrixArray": {
		"prefix": "Material.SetMatrixArray",
		"body": [
			"SetMatrixArray($1)"
		],
		"description": "public void SetMatrixArray(string name, Matrix4x4[] values); public void SetMatrixArray(int nameID, Matrix4x4[] values); public void SetMatrixArray(string name, List<Matrix4x4> values); public void SetMatrixArray(int nameID, List<Matrix4x4> values); des: Sets a matrix array property."
	}
,
	"Material.SetOverrideTag": {
		"prefix": "Material.SetOverrideTag",
		"body": [
			"SetOverrideTag($1)"
		],
		"description": "public void SetOverrideTag(string tag, string val); des: Sets an override tag/value on the material."
	}
,
	"Material.SetPass": {
		"prefix": "Material.SetPass",
		"body": [
			"SetPass($1)"
		],
		"description": "public bool SetPass(int pass); des: Activate the given pass for rendering."
	}
,
	"Material.SetShaderPassEnabled": {
		"prefix": "Material.SetShaderPassEnabled",
		"body": [
			"SetShaderPassEnabled($1)"
		],
		"description": "public void SetShaderPassEnabled(string passName, bool enabled); des: Enables or disables a Shader pass on a per-Material level."
	}
,
	"Material.SetTexture": {
		"prefix": "Material.SetTexture",
		"body": [
			"SetTexture($1)"
		],
		"description": "public void SetTexture(string name, Texture value); public void SetTexture(int nameID, Texture value); des: Sets a named texture."
	}
,
	"Material.SetTextureOffset": {
		"prefix": "Material.SetTextureOffset",
		"body": [
			"SetTextureOffset($1)"
		],
		"description": "public void SetTextureOffset(string name, Vector2 value); public void SetTextureOffset(int nameID, Vector2 value); des: Sets the placement offset of texture propertyName."
	}
,
	"Material.SetTextureScale": {
		"prefix": "Material.SetTextureScale",
		"body": [
			"SetTextureScale($1)"
		],
		"description": "public void SetTextureScale(string name, Vector2 value); public void SetTextureScale(int nameID, Vector2 value); des: Sets the placement scale of texture propertyName."
	}
,
	"Material.SetVector": {
		"prefix": "Material.SetVector",
		"body": [
			"SetVector($1)"
		],
		"description": "public void SetVector(string name, Vector4 value); public void SetVector(int nameID, Vector4 value); des: Sets a named vector value."
	}
,
	"Material.SetVectorArray": {
		"prefix": "Material.SetVectorArray",
		"body": [
			"SetVectorArray($1)"
		],
		"description": "public void SetVectorArray(string name, Vector4[] values); public void SetVectorArray(int nameID, Vector4[] values); public void SetVectorArray(string name, List<Vector4> values); public void SetVectorArray(int nameID, List<Vector4> values); des: Sets a vector array property."
	}
,
	"Material.hideFlags": {
		"prefix": "Material.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Material.name": {
		"prefix": "Material.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Material.GetInstanceID": {
		"prefix": "Material.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Material.ToString": {
		"prefix": "Material.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Material.Destroy": {
		"prefix": "Material.Destroy",
		"body": [
			"Material.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Material.DestroyImmediate": {
		"prefix": "Material.DestroyImmediate",
		"body": [
			"Material.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Material.DontDestroyOnLoad": {
		"prefix": "Material.DontDestroyOnLoad",
		"body": [
			"Material.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Material.FindObjectOfType": {
		"prefix": "Material.FindObjectOfType",
		"body": [
			"Material.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Material.FindObjectsOfType": {
		"prefix": "Material.FindObjectsOfType",
		"body": [
			"Material.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Material.Instantiate": {
		"prefix": "Material.Instantiate",
		"body": [
			"Material.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"MaterialPropertyBlock.isEmpty": {
		"prefix": "MaterialPropertyBlock.isEmpty",
		"body": [
			"isEmpty"
		],
		"description": "return:bool des: Is the material property block empty? (Read Only)"
	}
,
	"MaterialPropertyBlock.Clear": {
		"prefix": "MaterialPropertyBlock.Clear",
		"body": [
			"Clear($1)"
		],
		"description": "public void Clear(); des: Clear material property values."
	}
,
	"MaterialPropertyBlock.CopyProbeOcclusionArrayFrom": {
		"prefix": "MaterialPropertyBlock.CopyProbeOcclusionArrayFrom",
		"body": [
			"CopyProbeOcclusionArrayFrom($1)"
		],
		"description": "public void CopyProbeOcclusionArrayFrom(Vector4[] occlusionProbes); public void CopyProbeOcclusionArrayFrom(List<Vector4> occlusionProbes); public void CopyProbeOcclusionArrayFrom(Vector4[] occlusionProbes, int sourceStart, int destStart, int count); public void CopyProbeOcclusionArrayFrom(List<Vector4> occlusionProbes, int sourceStart, int destStart, int count); des: This function copies the entire source array into a Vector4 property array named unity_ProbesOcclusion for use with instanced Shadowmask rendering."
	}
,
	"MaterialPropertyBlock.CopySHCoefficientArraysFrom": {
		"prefix": "MaterialPropertyBlock.CopySHCoefficientArraysFrom",
		"body": [
			"CopySHCoefficientArraysFrom($1)"
		],
		"description": "public void CopySHCoefficientArraysFrom(List<SphericalHarmonicsL2> lightProbes); public void CopySHCoefficientArraysFrom(SphericalHarmonicsL2[] lightProbes); public void CopySHCoefficientArraysFrom(SphericalHarmonicsL2[] lightProbes, int sourceStart, int destStart, int count); public void CopySHCoefficientArraysFrom(List<SphericalHarmonicsL2> lightProbes, int sourceStart, int destStart, int count); des: This function converts and copies the entire source array into 7 Vector4 property arrays named unity_SHAr, unity_SHAg, unity_SHAb, unity_SHBr, unity_SHBg, unity_SHBb and unity_SHC for use with instanced light probe rendering."
	}
,
	"MaterialPropertyBlock.GetColor": {
		"prefix": "MaterialPropertyBlock.GetColor",
		"body": [
			"GetColor($1)"
		],
		"description": "public Color GetColor(string name); public Color GetColor(int nameID); des: Get a color from the property block."
	}
,
	"MaterialPropertyBlock.GetFloat": {
		"prefix": "MaterialPropertyBlock.GetFloat",
		"body": [
			"GetFloat($1)"
		],
		"description": "public float GetFloat(string name); public float GetFloat(int nameID); des: Get a float from the property block."
	}
,
	"MaterialPropertyBlock.GetFloatArray": {
		"prefix": "MaterialPropertyBlock.GetFloatArray",
		"body": [
			"GetFloatArray($1)"
		],
		"description": "public float[] GetFloatArray(string name); public float[] GetFloatArray(int nameID); public void GetFloatArray(string name, List<float> values); public void GetFloatArray(int nameID, List<float> values); des: Get a float array from the property block."
	}
,
	"MaterialPropertyBlock.GetInt": {
		"prefix": "MaterialPropertyBlock.GetInt",
		"body": [
			"GetInt($1)"
		],
		"description": "public int GetInt(string name); public int GetInt(int nameID); des: Get an int from the property block."
	}
,
	"MaterialPropertyBlock.GetMatrix": {
		"prefix": "MaterialPropertyBlock.GetMatrix",
		"body": [
			"GetMatrix($1)"
		],
		"description": "public Matrix4x4 GetMatrix(string name); public Matrix4x4 GetMatrix(int nameID); des: Get a matrix from the property block."
	}
,
	"MaterialPropertyBlock.GetMatrixArray": {
		"prefix": "MaterialPropertyBlock.GetMatrixArray",
		"body": [
			"GetMatrixArray($1)"
		],
		"description": "public Matrix4x4[] GetMatrixArray(string name); public Matrix4x4[] GetMatrixArray(int nameID); public void GetMatrixArray(string name, List<Matrix4x4> values); public void GetMatrixArray(int nameID, List<Matrix4x4> values); des: Get a matrix array from the property block."
	}
,
	"MaterialPropertyBlock.GetTexture": {
		"prefix": "MaterialPropertyBlock.GetTexture",
		"body": [
			"GetTexture($1)"
		],
		"description": "public Texture GetTexture(string name); public Texture GetTexture(int nameID); des: Get a texture from the property block."
	}
,
	"MaterialPropertyBlock.GetVector": {
		"prefix": "MaterialPropertyBlock.GetVector",
		"body": [
			"GetVector($1)"
		],
		"description": "public Vector4 GetVector(string name); public Vector4 GetVector(int nameID); des: Get a vector from the property block."
	}
,
	"MaterialPropertyBlock.GetVectorArray": {
		"prefix": "MaterialPropertyBlock.GetVectorArray",
		"body": [
			"GetVectorArray($1)"
		],
		"description": "public Vector4[] GetVectorArray(string name); public Vector4[] GetVectorArray(int nameID); public void GetVectorArray(string name, List<Vector4> values); public void GetVectorArray(int nameID, List<Vector4> values); des: Get a vector array from the property block."
	}
,
	"MaterialPropertyBlock.SetBuffer": {
		"prefix": "MaterialPropertyBlock.SetBuffer",
		"body": [
			"SetBuffer($1)"
		],
		"description": "public void SetBuffer(string name, ComputeBuffer value); public void SetBuffer(int nameID, ComputeBuffer value); des: Set a ComputeBuffer property."
	}
,
	"MaterialPropertyBlock.SetColor": {
		"prefix": "MaterialPropertyBlock.SetColor",
		"body": [
			"SetColor($1)"
		],
		"description": "public void SetColor(string name, Color value); public void SetColor(int nameID, Color value); des: Set a color property."
	}
,
	"MaterialPropertyBlock.SetFloat": {
		"prefix": "MaterialPropertyBlock.SetFloat",
		"body": [
			"SetFloat($1)"
		],
		"description": "public void SetFloat(string name, float value); public void SetFloat(int nameID, float value); des: Set a float property."
	}
,
	"MaterialPropertyBlock.SetFloatArray": {
		"prefix": "MaterialPropertyBlock.SetFloatArray",
		"body": [
			"SetFloatArray($1)"
		],
		"description": "public void SetFloatArray(string name, float[] values); public void SetFloatArray(int nameID, float[] values); public void SetFloatArray(string name, List<float> values); public void SetFloatArray(int nameID, List<float> values); des: Set a float array property."
	}
,
	"MaterialPropertyBlock.SetInt": {
		"prefix": "MaterialPropertyBlock.SetInt",
		"body": [
			"SetInt($1)"
		],
		"description": "public void SetInt(int nameID, int value); public void SetInt(string name, int value); des: Adds a property to the block. If an int property with the given name already exists, the old value is replaced."
	}
,
	"MaterialPropertyBlock.SetMatrix": {
		"prefix": "MaterialPropertyBlock.SetMatrix",
		"body": [
			"SetMatrix($1)"
		],
		"description": "public void SetMatrix(string name, Matrix4x4 value); public void SetMatrix(int nameID, Matrix4x4 value); des: Set a matrix property."
	}
,
	"MaterialPropertyBlock.SetMatrixArray": {
		"prefix": "MaterialPropertyBlock.SetMatrixArray",
		"body": [
			"SetMatrixArray($1)"
		],
		"description": "public void SetMatrixArray(string name, Matrix4x4[] values); public void SetMatrixArray(int nameID, Matrix4x4[] values); public void SetMatrixArray(string name, List<Matrix4x4> values); public void SetMatrixArray(int nameID, List<Matrix4x4> values); des: Set a matrix array property."
	}
,
	"MaterialPropertyBlock.SetTexture": {
		"prefix": "MaterialPropertyBlock.SetTexture",
		"body": [
			"SetTexture($1)"
		],
		"description": "public void SetTexture(string name, Texture value); public void SetTexture(int nameID, Texture value); des: Set a texture property."
	}
,
	"MaterialPropertyBlock.SetVector": {
		"prefix": "MaterialPropertyBlock.SetVector",
		"body": [
			"SetVector($1)"
		],
		"description": "public void SetVector(string name, Vector4 value); public void SetVector(int nameID, Vector4 value); des: Set a vector property."
	}
,
	"MaterialPropertyBlock.SetVectorArray": {
		"prefix": "MaterialPropertyBlock.SetVectorArray",
		"body": [
			"SetVectorArray($1)"
		],
		"description": "public void SetVectorArray(string name, Vector4[] values); public void SetVectorArray(int nameID, Vector4[] values); public void SetVectorArray(string name, List<Vector4> values); public void SetVectorArray(int nameID, List<Vector4> values); des: Set a vector array property."
	}
,
	"Mathf.Abs": {
		"prefix": "Mathf.Abs",
		"body": [
			"Mathf.Abs"
		],
		"description": "public static float Abs(float f); public static int Abs(int value); des: Returns the absolute value of f."
	}
,
	"Mathf.Acos": {
		"prefix": "Mathf.Acos",
		"body": [
			"Mathf.Acos"
		],
		"description": "public static float Acos(float f); des: Returns the arc-cosine of f - the angle in radians whose cosine is f."
	}
,
	"Mathf.Approximately": {
		"prefix": "Mathf.Approximately",
		"body": [
			"Mathf.Approximately"
		],
		"description": "public static bool Approximately(float a, float b); des: Compares two floating point values and returns true if they are similar."
	}
,
	"Mathf.Asin": {
		"prefix": "Mathf.Asin",
		"body": [
			"Mathf.Asin"
		],
		"description": "public static float Asin(float f); des: Returns the arc-sine of f - the angle in radians whose sine is f."
	}
,
	"Mathf.Atan": {
		"prefix": "Mathf.Atan",
		"body": [
			"Mathf.Atan"
		],
		"description": "public static float Atan(float f); des: Returns the arc-tangent of f - the angle in radians whose tangent is f."
	}
,
	"Mathf.Atan2": {
		"prefix": "Mathf.Atan2",
		"body": [
			"Mathf.Atan2"
		],
		"description": "public static float Atan2(float y, float x); des: Returns the angle in radians whose Tan is y/x."
	}
,
	"Mathf.Ceil": {
		"prefix": "Mathf.Ceil",
		"body": [
			"Mathf.Ceil"
		],
		"description": "public static float Ceil(float f); des: Returns the smallest integer greater to or equal to f."
	}
,
	"Mathf.CeilToInt": {
		"prefix": "Mathf.CeilToInt",
		"body": [
			"Mathf.CeilToInt"
		],
		"description": "public static int CeilToInt(float f); des: Returns the smallest integer greater to or equal to f."
	}
,
	"Mathf.Clamp": {
		"prefix": "Mathf.Clamp",
		"body": [
			"Mathf.Clamp"
		],
		"description": "public static float Clamp(float value, float min, float max); public static int Clamp(int value, int min, int max); des: Clamps a value between a minimum float and maximum float value."
	}
,
	"Mathf.Clamp01": {
		"prefix": "Mathf.Clamp01",
		"body": [
			"Mathf.Clamp01"
		],
		"description": "public static float Clamp01(float value); des: Clamps value between 0 and 1 and returns value."
	}
,
	"Mathf.ClosestPowerOfTwo": {
		"prefix": "Mathf.ClosestPowerOfTwo",
		"body": [
			"Mathf.ClosestPowerOfTwo"
		],
		"description": "public static int ClosestPowerOfTwo(int value); des: Returns the closest power of two value."
	}
,
	"Mathf.CorrelatedColorTemperatureToRGB": {
		"prefix": "Mathf.CorrelatedColorTemperatureToRGB",
		"body": [
			"Mathf.CorrelatedColorTemperatureToRGB"
		],
		"description": "public static Color CorrelatedColorTemperatureToRGB(float kelvin); des: Convert a color temperature in Kelvin to RGB color."
	}
,
	"Mathf.Cos": {
		"prefix": "Mathf.Cos",
		"body": [
			"Mathf.Cos"
		],
		"description": "public static float Cos(float f); des: Returns the cosine of angle f."
	}
,
	"Mathf.DeltaAngle": {
		"prefix": "Mathf.DeltaAngle",
		"body": [
			"Mathf.DeltaAngle"
		],
		"description": "public static float DeltaAngle(float current, float target); des: Calculates the shortest difference between two given angles given in degrees."
	}
,
	"Mathf.Exp": {
		"prefix": "Mathf.Exp",
		"body": [
			"Mathf.Exp"
		],
		"description": "public static float Exp(float power); des: Returns e raised to the specified power."
	}
,
	"Mathf.Floor": {
		"prefix": "Mathf.Floor",
		"body": [
			"Mathf.Floor"
		],
		"description": "public static float Floor(float f); des: Returns the largest integer smaller than or equal to f."
	}
,
	"Mathf.FloorToInt": {
		"prefix": "Mathf.FloorToInt",
		"body": [
			"Mathf.FloorToInt"
		],
		"description": "public static int FloorToInt(float f); des: Returns the largest integer smaller to or equal to f."
	}
,
	"Mathf.GammaToLinearSpace": {
		"prefix": "Mathf.GammaToLinearSpace",
		"body": [
			"Mathf.GammaToLinearSpace"
		],
		"description": "public static float GammaToLinearSpace(float value); des: Converts the given value from gamma (sRGB) to linear color space."
	}
,
	"Mathf.InverseLerp": {
		"prefix": "Mathf.InverseLerp",
		"body": [
			"Mathf.InverseLerp"
		],
		"description": "public static float InverseLerp(float a, float b, float value); des: Calculates the linear parameter t that produces the interpolant value within the range [a, b]."
	}
,
	"Mathf.IsPowerOfTwo": {
		"prefix": "Mathf.IsPowerOfTwo",
		"body": [
			"Mathf.IsPowerOfTwo"
		],
		"description": "public static bool IsPowerOfTwo(int value); des: Returns true if the value is power of two."
	}
,
	"Mathf.Lerp": {
		"prefix": "Mathf.Lerp",
		"body": [
			"Mathf.Lerp"
		],
		"description": "public static float Lerp(float a, float b, float t); des: Linearly interpolates between a and b by t."
	}
,
	"Mathf.LerpAngle": {
		"prefix": "Mathf.LerpAngle",
		"body": [
			"Mathf.LerpAngle"
		],
		"description": "public static float LerpAngle(float a, float b, float t); des: Same as Lerp but makes sure the values interpolate correctly when they wrap around 360 degrees."
	}
,
	"Mathf.LerpUnclamped": {
		"prefix": "Mathf.LerpUnclamped",
		"body": [
			"Mathf.LerpUnclamped"
		],
		"description": "public static float LerpUnclamped(float a, float b, float t); des: Linearly interpolates between a and b by t with no limit to t."
	}
,
	"Mathf.LinearToGammaSpace": {
		"prefix": "Mathf.LinearToGammaSpace",
		"body": [
			"Mathf.LinearToGammaSpace"
		],
		"description": "public static float LinearToGammaSpace(float value); des: Converts the given value from linear to gamma (sRGB) color space."
	}
,
	"Mathf.Log": {
		"prefix": "Mathf.Log",
		"body": [
			"Mathf.Log"
		],
		"description": "public static float Log(float f, float p); public static float Log(float f); des: Returns the logarithm of a specified number in a specified base."
	}
,
	"Mathf.Log10": {
		"prefix": "Mathf.Log10",
		"body": [
			"Mathf.Log10"
		],
		"description": "public static float Log10(float f); des: Returns the base 10 logarithm of a specified number."
	}
,
	"Mathf.Max": {
		"prefix": "Mathf.Max",
		"body": [
			"Mathf.Max"
		],
		"description": "public static float Max(float a, float b); public static float Max(params float[] values); public static int Max(int a, int b); public static int Max(params int[] values); des: Returns largest of two or more values."
	}
,
	"Mathf.Min": {
		"prefix": "Mathf.Min",
		"body": [
			"Mathf.Min"
		],
		"description": "public static float Min(float a, float b); public static float Min(params float[] values); public static int Min(int a, int b); public static int Min(params int[] values); des: Returns the smallest of two or more values."
	}
,
	"Mathf.MoveTowards": {
		"prefix": "Mathf.MoveTowards",
		"body": [
			"Mathf.MoveTowards"
		],
		"description": "public static float MoveTowards(float current, float target, float maxDelta); des: Moves a value current towards target."
	}
,
	"Mathf.MoveTowardsAngle": {
		"prefix": "Mathf.MoveTowardsAngle",
		"body": [
			"Mathf.MoveTowardsAngle"
		],
		"description": "public static float MoveTowardsAngle(float current, float target, float maxDelta); des: Same as MoveTowards but makes sure the values interpolate correctly when they wrap around 360 degrees."
	}
,
	"Mathf.NextPowerOfTwo": {
		"prefix": "Mathf.NextPowerOfTwo",
		"body": [
			"Mathf.NextPowerOfTwo"
		],
		"description": "public static int NextPowerOfTwo(int value); des: Returns the next power of two value."
	}
,
	"Mathf.PerlinNoise": {
		"prefix": "Mathf.PerlinNoise",
		"body": [
			"Mathf.PerlinNoise"
		],
		"description": "public static float PerlinNoise(float x, float y); des: Generate 2D Perlin noise."
	}
,
	"Mathf.PingPong": {
		"prefix": "Mathf.PingPong",
		"body": [
			"Mathf.PingPong"
		],
		"description": "public static float PingPong(float t, float length); des: PingPongs the value t, so that it is never larger than length and never smaller than 0."
	}
,
	"Mathf.Pow": {
		"prefix": "Mathf.Pow",
		"body": [
			"Mathf.Pow"
		],
		"description": "public static float Pow(float f, float p); des: Returns f raised to power p."
	}
,
	"Mathf.Repeat": {
		"prefix": "Mathf.Repeat",
		"body": [
			"Mathf.Repeat"
		],
		"description": "public static float Repeat(float t, float length); des: Loops the value t, so that it is never larger than length and never smaller than 0."
	}
,
	"Mathf.Round": {
		"prefix": "Mathf.Round",
		"body": [
			"Mathf.Round"
		],
		"description": "public static float Round(float f); des: Returns f rounded to the nearest integer."
	}
,
	"Mathf.RoundToInt": {
		"prefix": "Mathf.RoundToInt",
		"body": [
			"Mathf.RoundToInt"
		],
		"description": "public static int RoundToInt(float f); des: Returns f rounded to the nearest integer."
	}
,
	"Mathf.Sign": {
		"prefix": "Mathf.Sign",
		"body": [
			"Mathf.Sign"
		],
		"description": "public static float Sign(float f); des: Returns the sign of f."
	}
,
	"Mathf.Sin": {
		"prefix": "Mathf.Sin",
		"body": [
			"Mathf.Sin"
		],
		"description": "public static float Sin(float f); des: Returns the sine of angle f."
	}
,
	"Mathf.SmoothDamp": {
		"prefix": "Mathf.SmoothDamp",
		"body": [
			"Mathf.SmoothDamp"
		],
		"description": "public static float SmoothDamp(float current, float target, ref float currentVelocity, float smoothTime, float maxSpeed = Mathf.Infinity, float deltaTime = Time.deltaTime); des: Gradually changes a value towards a desired goal over time."
	}
,
	"Mathf.SmoothDampAngle": {
		"prefix": "Mathf.SmoothDampAngle",
		"body": [
			"Mathf.SmoothDampAngle"
		],
		"description": "public static float SmoothDampAngle(float current, float target, ref float currentVelocity, float smoothTime, float maxSpeed = Mathf.Infinity, float deltaTime = Time.deltaTime); des: Gradually changes an angle given in degrees towards a desired goal angle over time."
	}
,
	"Mathf.SmoothStep": {
		"prefix": "Mathf.SmoothStep",
		"body": [
			"Mathf.SmoothStep"
		],
		"description": "public static float SmoothStep(float from, float to, float t); des: Interpolates between min and max with smoothing at the limits."
	}
,
	"Mathf.Sqrt": {
		"prefix": "Mathf.Sqrt",
		"body": [
			"Mathf.Sqrt"
		],
		"description": "public static float Sqrt(float f); des: Returns square root of f."
	}
,
	"Mathf.Tan": {
		"prefix": "Mathf.Tan",
		"body": [
			"Mathf.Tan"
		],
		"description": "public static float Tan(float f); des: Returns the tangent of angle f in radians."
	}
,
	"Matrix4x4.decomposeProjection": {
		"prefix": "Matrix4x4.decomposeProjection",
		"body": [
			"decomposeProjection"
		],
		"description": "return:FrustumPlanes des: This property takes a projection matrix and returns the six plane coordinates that define a projection frustum."
	}
,
	"Matrix4x4.determinant": {
		"prefix": "Matrix4x4.determinant",
		"body": [
			"determinant"
		],
		"description": "return:float des: The determinant of the matrix."
	}
,
	"Matrix4x4.inverse": {
		"prefix": "Matrix4x4.inverse",
		"body": [
			"inverse"
		],
		"description": "return:Matrix4x4 des: The inverse of this matrix (Read Only)."
	}
,
	"Matrix4x4.isIdentity": {
		"prefix": "Matrix4x4.isIdentity",
		"body": [
			"isIdentity"
		],
		"description": "return:bool des: Is this the identity matrix?"
	}
,
	"Matrix4x4.lossyScale": {
		"prefix": "Matrix4x4.lossyScale",
		"body": [
			"lossyScale"
		],
		"description": "return:Vector3 des: Attempts to get a scale value from the matrix."
	}
,
	"Matrix4x4.rotation": {
		"prefix": "Matrix4x4.rotation",
		"body": [
			"rotation"
		],
		"description": "return:Quaternion des: Attempts to get a rotation quaternion from this matrix."
	}
,
	"Matrix4x4.this[int,int]": {
		"prefix": "Matrix4x4.this[int,int]",
		"body": [
			"this[int,int]"
		],
		"description": "return:float   float this[int] des: Access element at [row, column]."
	}
,
	"Matrix4x4.transpose": {
		"prefix": "Matrix4x4.transpose",
		"body": [
			"transpose"
		],
		"description": "return:Matrix4x4 des: Returns the transpose of this matrix (Read Only)."
	}
,
	"Matrix4x4.GetColumn": {
		"prefix": "Matrix4x4.GetColumn",
		"body": [
			"GetColumn($1)"
		],
		"description": "public Vector4 GetColumn(int index); des: Get a column of the matrix."
	}
,
	"Matrix4x4.GetRow": {
		"prefix": "Matrix4x4.GetRow",
		"body": [
			"GetRow($1)"
		],
		"description": "public Vector4 GetRow(int index); des: Returns a row of the matrix."
	}
,
	"Matrix4x4.MultiplyPoint": {
		"prefix": "Matrix4x4.MultiplyPoint",
		"body": [
			"MultiplyPoint($1)"
		],
		"description": "public Vector3 MultiplyPoint(Vector3 point); des: Transforms a position by this matrix (generic)."
	}
,
	"Matrix4x4.MultiplyPoint3x4": {
		"prefix": "Matrix4x4.MultiplyPoint3x4",
		"body": [
			"MultiplyPoint3x4($1)"
		],
		"description": "public Vector3 MultiplyPoint3x4(Vector3 point); des: Transforms a position by this matrix (fast)."
	}
,
	"Matrix4x4.MultiplyVector": {
		"prefix": "Matrix4x4.MultiplyVector",
		"body": [
			"MultiplyVector($1)"
		],
		"description": "public Vector3 MultiplyVector(Vector3 vector); des: Transforms a direction by this matrix."
	}
,
	"Matrix4x4.SetColumn": {
		"prefix": "Matrix4x4.SetColumn",
		"body": [
			"SetColumn($1)"
		],
		"description": "public void SetColumn(int index, Vector4 column); des: Sets a column of the matrix."
	}
,
	"Matrix4x4.SetRow": {
		"prefix": "Matrix4x4.SetRow",
		"body": [
			"SetRow($1)"
		],
		"description": "public void SetRow(int index, Vector4 row); des: Sets a row of the matrix."
	}
,
	"Matrix4x4.SetTRS": {
		"prefix": "Matrix4x4.SetTRS",
		"body": [
			"SetTRS($1)"
		],
		"description": "public void SetTRS(Vector3 pos, Quaternion q, Vector3 s); des: Sets this matrix to a translation, rotation and scaling matrix."
	}
,
	"Matrix4x4.ToString": {
		"prefix": "Matrix4x4.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); public string ToString(string format); des: Returns a nicely formatted string for this matrix."
	}
,
	"Matrix4x4.TransformPlane": {
		"prefix": "Matrix4x4.TransformPlane",
		"body": [
			"TransformPlane($1)"
		],
		"description": "public Plane TransformPlane(Plane plane); des: Returns a plane that is transformed in space."
	}
,
	"Matrix4x4.ValidTRS": {
		"prefix": "Matrix4x4.ValidTRS",
		"body": [
			"ValidTRS($1)"
		],
		"description": "public bool ValidTRS(); des: Checks if this matrix is a valid transform matrix."
	}
,
	"Matrix4x4.Frustum": {
		"prefix": "Matrix4x4.Frustum",
		"body": [
			"Matrix4x4.Frustum"
		],
		"description": "public static Matrix4x4 Frustum(float left, float right, float bottom, float top, float zNear, float zFar); public static Matrix4x4 Frustum(FrustumPlanes fp); des: This function returns a projection matrix with viewing frustum that has a near plane defined by the coordinates that were passed in."
	}
,
	"Matrix4x4.LookAt": {
		"prefix": "Matrix4x4.LookAt",
		"body": [
			"Matrix4x4.LookAt"
		],
		"description": "public static Matrix4x4 LookAt(Vector3 from, Vector3 to, Vector3 up); des: Given a source point, a target point, and an up vector, computes a transformation matrix that corresponds to a camera viewing the target from the source, such that the right-hand vector is perpendicular to the up vector."
	}
,
	"Matrix4x4.Ortho": {
		"prefix": "Matrix4x4.Ortho",
		"body": [
			"Matrix4x4.Ortho"
		],
		"description": "public static Matrix4x4 Ortho(float left, float right, float bottom, float top, float zNear, float zFar); des: Creates an orthogonal projection matrix."
	}
,
	"Matrix4x4.Perspective": {
		"prefix": "Matrix4x4.Perspective",
		"body": [
			"Matrix4x4.Perspective"
		],
		"description": "public static Matrix4x4 Perspective(float fov, float aspect, float zNear, float zFar); des: Creates a perspective projection matrix."
	}
,
	"Matrix4x4.Rotate": {
		"prefix": "Matrix4x4.Rotate",
		"body": [
			"Matrix4x4.Rotate"
		],
		"description": "public static Matrix4x4 Rotate(Quaternion q); des: Creates a rotation matrix."
	}
,
	"Matrix4x4.Scale": {
		"prefix": "Matrix4x4.Scale",
		"body": [
			"Matrix4x4.Scale"
		],
		"description": "public static Matrix4x4 Scale(Vector3 vector); des: Creates a scaling matrix."
	}
,
	"Matrix4x4.Translate": {
		"prefix": "Matrix4x4.Translate",
		"body": [
			"Matrix4x4.Translate"
		],
		"description": "public static Matrix4x4 Translate(Vector3 vector); des: Creates a translation matrix."
	}
,
	"Matrix4x4.TRS": {
		"prefix": "Matrix4x4.TRS",
		"body": [
			"Matrix4x4.TRS"
		],
		"description": "public static Matrix4x4 TRS(Vector3 pos, Quaternion q, Vector3 s); des: Creates a translation, rotation and scaling matrix."
	}
,
	"Mesh.bindposes": {
		"prefix": "Mesh.bindposes",
		"body": [
			"bindposes"
		],
		"description": "return:Matrix4x4[] des: The bind poses. The bind pose at each index refers to the bone with the same index."
	}
,
	"Mesh.blendShapeCount": {
		"prefix": "Mesh.blendShapeCount",
		"body": [
			"blendShapeCount"
		],
		"description": "return:int des: Returns BlendShape count on this mesh."
	}
,
	"Mesh.boneWeights": {
		"prefix": "Mesh.boneWeights",
		"body": [
			"boneWeights"
		],
		"description": "return:BoneWeight[] des: The bone weights of each vertex."
	}
,
	"Mesh.bounds": {
		"prefix": "Mesh.bounds",
		"body": [
			"bounds"
		],
		"description": "return:Bounds des: The bounding volume of the mesh."
	}
,
	"Mesh.colors": {
		"prefix": "Mesh.colors",
		"body": [
			"colors"
		],
		"description": "return:Color[] des: Vertex colors of the Mesh."
	}
,
	"Mesh.colors32": {
		"prefix": "Mesh.colors32",
		"body": [
			"colors32"
		],
		"description": "return:Color32[] des: Vertex colors of the Mesh."
	}
,
	"Mesh.indexFormat": {
		"prefix": "Mesh.indexFormat",
		"body": [
			"indexFormat"
		],
		"description": "return:Rendering.IndexFormat des: Format of the mesh index buffer data."
	}
,
	"Mesh.isReadable": {
		"prefix": "Mesh.isReadable",
		"body": [
			"isReadable"
		],
		"description": "return:bool des: Returns a bool indicated whether the mesh is read/write enabled."
	}
,
	"Mesh.normals": {
		"prefix": "Mesh.normals",
		"body": [
			"normals"
		],
		"description": "return:Vector3[] des: The normals of the Mesh."
	}
,
	"Mesh.subMeshCount": {
		"prefix": "Mesh.subMeshCount",
		"body": [
			"subMeshCount"
		],
		"description": "return:int des: The number of sub-meshes inside the Mesh object."
	}
,
	"Mesh.tangents": {
		"prefix": "Mesh.tangents",
		"body": [
			"tangents"
		],
		"description": "return:Vector4[] des: The tangents of the Mesh."
	}
,
	"Mesh.triangles": {
		"prefix": "Mesh.triangles",
		"body": [
			"triangles"
		],
		"description": "return:int[] des: An array containing all triangles in the Mesh."
	}
,
	"Mesh.uv": {
		"prefix": "Mesh.uv",
		"body": [
			"uv"
		],
		"description": "return:Vector2[] des: The base texture coordinates of the Mesh."
	}
,
	"Mesh.uv2": {
		"prefix": "Mesh.uv2",
		"body": [
			"uv2"
		],
		"description": "return:Vector2[] des: The second texture coordinate set of the mesh, if present."
	}
,
	"Mesh.uv3": {
		"prefix": "Mesh.uv3",
		"body": [
			"uv3"
		],
		"description": "return:Vector2[] des: The third texture coordinate set of the mesh, if present."
	}
,
	"Mesh.uv4": {
		"prefix": "Mesh.uv4",
		"body": [
			"uv4"
		],
		"description": "return:Vector2[] des: The fourth texture coordinate set of the mesh, if present."
	}
,
	"Mesh.uv5": {
		"prefix": "Mesh.uv5",
		"body": [
			"uv5"
		],
		"description": "return:Vector2[] des: The fifth texture coordinate set of the mesh, if present."
	}
,
	"Mesh.uv6": {
		"prefix": "Mesh.uv6",
		"body": [
			"uv6"
		],
		"description": "return:Vector2[] des: The sixth texture coordinate set of the mesh, if present."
	}
,
	"Mesh.uv7": {
		"prefix": "Mesh.uv7",
		"body": [
			"uv7"
		],
		"description": "return:Vector2[] des: The seventh texture coordinate set of the mesh, if present."
	}
,
	"Mesh.uv8": {
		"prefix": "Mesh.uv8",
		"body": [
			"uv8"
		],
		"description": "return:Vector2[] des: The eighth texture coordinate set of the mesh, if present."
	}
,
	"Mesh.vertexBufferCount": {
		"prefix": "Mesh.vertexBufferCount",
		"body": [
			"vertexBufferCount"
		],
		"description": "return:int des: Gets the number of vertex buffers present in the Mesh. (Read Only)"
	}
,
	"Mesh.vertexCount": {
		"prefix": "Mesh.vertexCount",
		"body": [
			"vertexCount"
		],
		"description": "return:int des: Returns the number of vertices in the Mesh (Read Only)."
	}
,
	"Mesh.vertices": {
		"prefix": "Mesh.vertices",
		"body": [
			"vertices"
		],
		"description": "return:Vector3[] des: Returns a copy of the vertex positions or assigns a new vertex positions array."
	}
,
	"Mesh.AddBlendShapeFrame": {
		"prefix": "Mesh.AddBlendShapeFrame",
		"body": [
			"AddBlendShapeFrame($1)"
		],
		"description": "public void AddBlendShapeFrame(string shapeName, float frameWeight, Vector3[] deltaVertices, Vector3[] deltaNormals, Vector3[] deltaTangents); des: Adds a new blend shape frame."
	}
,
	"Mesh.Clear": {
		"prefix": "Mesh.Clear",
		"body": [
			"Clear($1)"
		],
		"description": "public void Clear(bool keepVertexLayout); des: Clears all vertex data and all triangle indices."
	}
,
	"Mesh.ClearBlendShapes": {
		"prefix": "Mesh.ClearBlendShapes",
		"body": [
			"ClearBlendShapes($1)"
		],
		"description": "public void ClearBlendShapes(); des: Clears all blend shapes from Mesh."
	}
,
	"Mesh.CombineMeshes": {
		"prefix": "Mesh.CombineMeshes",
		"body": [
			"CombineMeshes($1)"
		],
		"description": "public void CombineMeshes(CombineInstance[] combine, bool mergeSubMeshes = true, bool useMatrices = true, bool hasLightmapData = false); des: Combines several Meshes into this Mesh."
	}
,
	"Mesh.GetBaseVertex": {
		"prefix": "Mesh.GetBaseVertex",
		"body": [
			"GetBaseVertex($1)"
		],
		"description": "public uint GetBaseVertex(int submesh); des: Gets the base vertex index of the given sub-mesh."
	}
,
	"Mesh.GetBindposes": {
		"prefix": "Mesh.GetBindposes",
		"body": [
			"GetBindposes($1)"
		],
		"description": "public void GetBindposes(List<Matrix4x4> bindposes); des: Gets the bind poses for this instance."
	}
,
	"Mesh.GetBlendShapeFrameCount": {
		"prefix": "Mesh.GetBlendShapeFrameCount",
		"body": [
			"GetBlendShapeFrameCount($1)"
		],
		"description": "public int GetBlendShapeFrameCount(int shapeIndex); des: Returns the frame count for a blend shape."
	}
,
	"Mesh.GetBlendShapeFrameVertices": {
		"prefix": "Mesh.GetBlendShapeFrameVertices",
		"body": [
			"GetBlendShapeFrameVertices($1)"
		],
		"description": "public void GetBlendShapeFrameVertices(int shapeIndex, int frameIndex, Vector3[] deltaVertices, Vector3[] deltaNormals, Vector3[] deltaTangents); des: Retreives deltaVertices, deltaNormals and deltaTangents of a blend shape frame."
	}
,
	"Mesh.GetBlendShapeFrameWeight": {
		"prefix": "Mesh.GetBlendShapeFrameWeight",
		"body": [
			"GetBlendShapeFrameWeight($1)"
		],
		"description": "public float GetBlendShapeFrameWeight(int shapeIndex, int frameIndex); des: Returns the weight of a blend shape frame."
	}
,
	"Mesh.GetBlendShapeIndex": {
		"prefix": "Mesh.GetBlendShapeIndex",
		"body": [
			"GetBlendShapeIndex($1)"
		],
		"description": "public int GetBlendShapeIndex(string blendShapeName); des: Returns index of BlendShape by given name."
	}
,
	"Mesh.GetBlendShapeName": {
		"prefix": "Mesh.GetBlendShapeName",
		"body": [
			"GetBlendShapeName($1)"
		],
		"description": "public string GetBlendShapeName(int shapeIndex); des: Returns name of BlendShape by given index."
	}
,
	"Mesh.GetBoneWeights": {
		"prefix": "Mesh.GetBoneWeights",
		"body": [
			"GetBoneWeights($1)"
		],
		"description": "public void GetBoneWeights(List<BoneWeight> boneWeights); des: Gets the bone weights for this instance."
	}
,
	"Mesh.GetColors": {
		"prefix": "Mesh.GetColors",
		"body": [
			"GetColors($1)"
		],
		"description": "public void GetColors(List<Color> colors); public void GetColors(List<Color32> colors); des: Gets the vertex colors for this instance."
	}
,
	"Mesh.GetIndexCount": {
		"prefix": "Mesh.GetIndexCount",
		"body": [
			"GetIndexCount($1)"
		],
		"description": "public uint GetIndexCount(int submesh); des: Gets the index count of the given sub-mesh."
	}
,
	"Mesh.GetIndexStart": {
		"prefix": "Mesh.GetIndexStart",
		"body": [
			"GetIndexStart($1)"
		],
		"description": "public uint GetIndexStart(int submesh); des: Gets the starting index location within the Mesh's index buffer, for the given sub-mesh."
	}
,
	"Mesh.GetIndices": {
		"prefix": "Mesh.GetIndices",
		"body": [
			"GetIndices($1)"
		],
		"description": "public void GetIndices(List<int> indices, int submesh); public int[] GetIndices(int submesh); des: Fetches the index list for the specified sub-mesh."
	}
,
	"Mesh.GetNativeIndexBufferPtr": {
		"prefix": "Mesh.GetNativeIndexBufferPtr",
		"body": [
			"GetNativeIndexBufferPtr($1)"
		],
		"description": "public IntPtr GetNativeIndexBufferPtr(); des: Retrieves a native (underlying graphics API) pointer to the index buffer."
	}
,
	"Mesh.GetNativeVertexBufferPtr": {
		"prefix": "Mesh.GetNativeVertexBufferPtr",
		"body": [
			"GetNativeVertexBufferPtr($1)"
		],
		"description": "public IntPtr GetNativeVertexBufferPtr(int index); des: Retrieves a native (underlying graphics API) pointer to the vertex buffer."
	}
,
	"Mesh.GetNormals": {
		"prefix": "Mesh.GetNormals",
		"body": [
			"GetNormals($1)"
		],
		"description": "public void GetNormals(List<Vector3> normals); des: Gets the vertex normals for this instance."
	}
,
	"Mesh.GetTangents": {
		"prefix": "Mesh.GetTangents",
		"body": [
			"GetTangents($1)"
		],
		"description": "public void GetTangents(List<Vector4> tangents); des: Gets the tangents for this instance."
	}
,
	"Mesh.GetTopology": {
		"prefix": "Mesh.GetTopology",
		"body": [
			"GetTopology($1)"
		],
		"description": "public MeshTopology GetTopology(int submesh); des: Gets the topology of a sub-mesh."
	}
,
	"Mesh.GetTriangles": {
		"prefix": "Mesh.GetTriangles",
		"body": [
			"GetTriangles($1)"
		],
		"description": "public int[] GetTriangles(int submesh); public int[] GetTriangles(int submesh, bool applyBaseVertex = true); public void GetTriangles(List<int> triangles, int submesh, bool applyBaseVertex = true); public void GetTriangles(List<int> triangles, int submesh); des: Fetches the triangle list for the specified sub-mesh on this object."
	}
,
	"Mesh.GetUVDistributionMetric": {
		"prefix": "Mesh.GetUVDistributionMetric",
		"body": [
			"GetUVDistributionMetric($1)"
		],
		"description": "public float GetUVDistributionMetric(int uvSetIndex); des: The UV distribution metric can be used to calculate the desired mipmap level based on the position of the camera."
	}
,
	"Mesh.GetUVs": {
		"prefix": "Mesh.GetUVs",
		"body": [
			"GetUVs($1)"
		],
		"description": "public void GetUVs(int channel, List<Vector2> uvs); public void GetUVs(int channel, List<Vector3> uvs); public void GetUVs(int channel, List<Vector4> uvs); des: Gets the UVs of the Mesh."
	}
,
	"Mesh.GetVertices": {
		"prefix": "Mesh.GetVertices",
		"body": [
			"GetVertices($1)"
		],
		"description": "public void GetVertices(List<Vector3> vertices); des: Gets the vertex positions for this instance."
	}
,
	"Mesh.MarkDynamic": {
		"prefix": "Mesh.MarkDynamic",
		"body": [
			"MarkDynamic($1)"
		],
		"description": "public void MarkDynamic(); des: Optimize mesh for frequent updates."
	}
,
	"Mesh.RecalculateBounds": {
		"prefix": "Mesh.RecalculateBounds",
		"body": [
			"RecalculateBounds($1)"
		],
		"description": "public void RecalculateBounds(); des: Recalculate the bounding volume of the Mesh from the vertices."
	}
,
	"Mesh.RecalculateNormals": {
		"prefix": "Mesh.RecalculateNormals",
		"body": [
			"RecalculateNormals($1)"
		],
		"description": "public void RecalculateNormals(); des: Recalculates the normals of the Mesh from the triangles and vertices."
	}
,
	"Mesh.RecalculateTangents": {
		"prefix": "Mesh.RecalculateTangents",
		"body": [
			"RecalculateTangents($1)"
		],
		"description": "public void RecalculateTangents(); des: Recalculates the tangents of the Mesh from the normals and texture coordinates."
	}
,
	"Mesh.SetColors": {
		"prefix": "Mesh.SetColors",
		"body": [
			"SetColors($1)"
		],
		"description": "public void SetColors(List<Color> inColors); public void SetColors(List<Color32> inColors); des: Vertex colors of the Mesh."
	}
,
	"Mesh.SetIndices": {
		"prefix": "Mesh.SetIndices",
		"body": [
			"SetIndices($1)"
		],
		"description": "public void SetIndices(int[] indices, MeshTopology topology, int submesh, bool calculateBounds); public void SetIndices(int[] indices, MeshTopology topology, int submesh); public void SetIndices(int[] indices, MeshTopology topology, int submesh, bool calculateBounds = true, int baseVertex = 0); des: Sets the index buffer for the sub-mesh."
	}
,
	"Mesh.SetNormals": {
		"prefix": "Mesh.SetNormals",
		"body": [
			"SetNormals($1)"
		],
		"description": "public void SetNormals(List<Vector3> inNormals); des: Set the normals of the Mesh."
	}
,
	"Mesh.SetTangents": {
		"prefix": "Mesh.SetTangents",
		"body": [
			"SetTangents($1)"
		],
		"description": "public void SetTangents(List<Vector4> inTangents); des: Set the tangents of the Mesh."
	}
,
	"Mesh.SetTriangles": {
		"prefix": "Mesh.SetTriangles",
		"body": [
			"SetTriangles($1)"
		],
		"description": "public void SetTriangles(int[] triangles, int submesh, bool calculateBounds = true, int baseVertex = 0); public void SetTriangles(int[] triangles, int submesh); public void SetTriangles(List<int> triangles, int submesh, bool calculateBounds = true, int baseVertex = 0); public void SetTriangles(List<int> triangles, int submesh); des: Sets the triangle list for the sub-mesh."
	}
,
	"Mesh.SetUVs": {
		"prefix": "Mesh.SetUVs",
		"body": [
			"SetUVs($1)"
		],
		"description": "public void SetUVs(int channel, List<Vector2> uvs); public void SetUVs(int channel, List<Vector3> uvs); public void SetUVs(int channel, List<Vector4> uvs); des: Sets the UVs of the Mesh."
	}
,
	"Mesh.SetVertices": {
		"prefix": "Mesh.SetVertices",
		"body": [
			"SetVertices($1)"
		],
		"description": "public void SetVertices(List<Vector3> inVertices); des: Assigns a new vertex positions array."
	}
,
	"Mesh.UploadMeshData": {
		"prefix": "Mesh.UploadMeshData",
		"body": [
			"UploadMeshData($1)"
		],
		"description": "public void UploadMeshData(bool markNoLongerReadable); des: Upload previously done Mesh modifications to the graphics API."
	}
,
	"Mesh.hideFlags": {
		"prefix": "Mesh.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Mesh.name": {
		"prefix": "Mesh.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Mesh.GetInstanceID": {
		"prefix": "Mesh.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Mesh.ToString": {
		"prefix": "Mesh.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Mesh.Destroy": {
		"prefix": "Mesh.Destroy",
		"body": [
			"Mesh.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Mesh.DestroyImmediate": {
		"prefix": "Mesh.DestroyImmediate",
		"body": [
			"Mesh.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Mesh.DontDestroyOnLoad": {
		"prefix": "Mesh.DontDestroyOnLoad",
		"body": [
			"Mesh.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Mesh.FindObjectOfType": {
		"prefix": "Mesh.FindObjectOfType",
		"body": [
			"Mesh.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Mesh.FindObjectsOfType": {
		"prefix": "Mesh.FindObjectsOfType",
		"body": [
			"Mesh.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Mesh.Instantiate": {
		"prefix": "Mesh.Instantiate",
		"body": [
			"Mesh.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"MeshCollider.convex": {
		"prefix": "MeshCollider.convex",
		"body": [
			"convex"
		],
		"description": "return:bool des: Use a convex collider from the mesh."
	}
,
	"MeshCollider.cookingOptions": {
		"prefix": "MeshCollider.cookingOptions",
		"body": [
			"cookingOptions"
		],
		"description": "return:MeshColliderCookingOptions des: Options used to enable or disable certain features in mesh cooking."
	}
,
	"MeshCollider.inflateMesh": {
		"prefix": "MeshCollider.inflateMesh",
		"body": [
			"inflateMesh"
		],
		"description": "return:bool des: Allow the physics engine to increase the volume of the input mesh in attempt to generate a valid convex mesh."
	}
,
	"MeshCollider.sharedMesh": {
		"prefix": "MeshCollider.sharedMesh",
		"body": [
			"sharedMesh"
		],
		"description": "return:Mesh des: The mesh object used for collision detection."
	}
,
	"MeshCollider.skinWidth": {
		"prefix": "MeshCollider.skinWidth",
		"body": [
			"skinWidth"
		],
		"description": "return:float des: Used when set to inflateMesh to determine how much inflation is acceptable."
	}
,
	"MeshCollider.attachedRigidbody": {
		"prefix": "MeshCollider.attachedRigidbody",
		"body": [
			"attachedRigidbody"
		],
		"description": "return:Rigidbody des: The rigidbody the collider is attached to."
	}
,
	"MeshCollider.bounds": {
		"prefix": "MeshCollider.bounds",
		"body": [
			"bounds"
		],
		"description": "return:Bounds des: The world space bounding volume of the collider (Read Only)."
	}
,
	"MeshCollider.contactOffset": {
		"prefix": "MeshCollider.contactOffset",
		"body": [
			"contactOffset"
		],
		"description": "return:float des: Contact offset value of this collider."
	}
,
	"MeshCollider.enabled": {
		"prefix": "MeshCollider.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Colliders will collide with other Colliders, disabled Colliders won't."
	}
,
	"MeshCollider.isTrigger": {
		"prefix": "MeshCollider.isTrigger",
		"body": [
			"isTrigger"
		],
		"description": "return:bool des: Is the collider a trigger?"
	}
,
	"MeshCollider.material": {
		"prefix": "MeshCollider.material",
		"body": [
			"material"
		],
		"description": "return:PhysicMaterial des: The material used by the collider."
	}
,
	"MeshCollider.sharedMaterial": {
		"prefix": "MeshCollider.sharedMaterial",
		"body": [
			"sharedMaterial"
		],
		"description": "return:PhysicMaterial des: The shared physic material of this collider."
	}
,
	"MeshCollider.gameObject": {
		"prefix": "MeshCollider.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"MeshCollider.tag": {
		"prefix": "MeshCollider.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"MeshCollider.transform": {
		"prefix": "MeshCollider.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"MeshCollider.hideFlags": {
		"prefix": "MeshCollider.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"MeshCollider.name": {
		"prefix": "MeshCollider.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"MeshCollider.ClosestPoint": {
		"prefix": "MeshCollider.ClosestPoint",
		"body": [
			"ClosestPoint($1)"
		],
		"description": "public Vector3 ClosestPoint(Vector3 position); des: Returns a point on the collider that is closest to a given location."
	}
,
	"MeshCollider.ClosestPointOnBounds": {
		"prefix": "MeshCollider.ClosestPointOnBounds",
		"body": [
			"ClosestPointOnBounds($1)"
		],
		"description": "public Vector3 ClosestPointOnBounds(Vector3 position); des: The closest point to the bounding box of the attached collider."
	}
,
	"MeshCollider.Raycast": {
		"prefix": "MeshCollider.Raycast",
		"body": [
			"Raycast($1)"
		],
		"description": "public bool Raycast(Ray ray, out RaycastHit hitInfo, float maxDistance); des: Casts a Ray that ignores all Colliders except this one."
	}
,
	"MeshCollider.BroadcastMessage": {
		"prefix": "MeshCollider.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"MeshCollider.CompareTag": {
		"prefix": "MeshCollider.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"MeshCollider.GetComponent": {
		"prefix": "MeshCollider.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"MeshCollider.GetComponentInChildren": {
		"prefix": "MeshCollider.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"MeshCollider.GetComponentInParent": {
		"prefix": "MeshCollider.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"MeshCollider.GetComponents": {
		"prefix": "MeshCollider.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"MeshCollider.GetComponentsInChildren": {
		"prefix": "MeshCollider.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"MeshCollider.GetComponentsInParent": {
		"prefix": "MeshCollider.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"MeshCollider.SendMessage": {
		"prefix": "MeshCollider.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"MeshCollider.SendMessageUpwards": {
		"prefix": "MeshCollider.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"MeshCollider.GetInstanceID": {
		"prefix": "MeshCollider.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"MeshCollider.ToString": {
		"prefix": "MeshCollider.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"MeshCollider.Destroy": {
		"prefix": "MeshCollider.Destroy",
		"body": [
			"MeshCollider.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"MeshCollider.DestroyImmediate": {
		"prefix": "MeshCollider.DestroyImmediate",
		"body": [
			"MeshCollider.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"MeshCollider.DontDestroyOnLoad": {
		"prefix": "MeshCollider.DontDestroyOnLoad",
		"body": [
			"MeshCollider.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"MeshCollider.FindObjectOfType": {
		"prefix": "MeshCollider.FindObjectOfType",
		"body": [
			"MeshCollider.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"MeshCollider.FindObjectsOfType": {
		"prefix": "MeshCollider.FindObjectsOfType",
		"body": [
			"MeshCollider.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"MeshCollider.Instantiate": {
		"prefix": "MeshCollider.Instantiate",
		"body": [
			"MeshCollider.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"MeshCollider.OnCollisionEnter": {
		"prefix": "MeshCollider.OnCollisionEnter",
		"body": [
			"OnCollisionEnter"
		],
		"description": "OnCollisionEnter is called when this collider/rigidbody has begun touching another rigidbody/collider."
	}
,
	"MeshCollider.OnCollisionExit": {
		"prefix": "MeshCollider.OnCollisionExit",
		"body": [
			"OnCollisionExit"
		],
		"description": "OnCollisionExit is called when this collider/rigidbody has stopped touching another rigidbody/collider."
	}
,
	"MeshCollider.OnCollisionStay": {
		"prefix": "MeshCollider.OnCollisionStay",
		"body": [
			"OnCollisionStay"
		],
		"description": "OnCollisionStay is called once per frame for every collider/rigidbody that is touching rigidbody/collider."
	}
,
	"MeshCollider.OnTriggerEnter": {
		"prefix": "MeshCollider.OnTriggerEnter",
		"body": [
			"OnTriggerEnter"
		],
		"description": "OnTriggerEnter is called when the Collider other enters the trigger."
	}
,
	"MeshCollider.OnTriggerExit": {
		"prefix": "MeshCollider.OnTriggerExit",
		"body": [
			"OnTriggerExit"
		],
		"description": "OnTriggerExit is called when the Collider other has stopped touching the trigger."
	}
,
	"MeshCollider.OnTriggerStay": {
		"prefix": "MeshCollider.OnTriggerStay",
		"body": [
			"OnTriggerStay"
		],
		"description": "OnTriggerStay is called almost all the frames for every Collider other that is touching the trigger. The function is on the physics timer so it won't necessarily run every frame."
	}
,
	"MeshFilter.mesh": {
		"prefix": "MeshFilter.mesh",
		"body": [
			"mesh"
		],
		"description": "return:Mesh des: Returns the instantiated Mesh assigned to the mesh filter."
	}
,
	"MeshFilter.sharedMesh": {
		"prefix": "MeshFilter.sharedMesh",
		"body": [
			"sharedMesh"
		],
		"description": "return:Mesh des: Returns the shared mesh of the mesh filter."
	}
,
	"MeshFilter.gameObject": {
		"prefix": "MeshFilter.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"MeshFilter.tag": {
		"prefix": "MeshFilter.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"MeshFilter.transform": {
		"prefix": "MeshFilter.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"MeshFilter.hideFlags": {
		"prefix": "MeshFilter.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"MeshFilter.name": {
		"prefix": "MeshFilter.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"MeshFilter.BroadcastMessage": {
		"prefix": "MeshFilter.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"MeshFilter.CompareTag": {
		"prefix": "MeshFilter.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"MeshFilter.GetComponent": {
		"prefix": "MeshFilter.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"MeshFilter.GetComponentInChildren": {
		"prefix": "MeshFilter.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"MeshFilter.GetComponentInParent": {
		"prefix": "MeshFilter.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"MeshFilter.GetComponents": {
		"prefix": "MeshFilter.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"MeshFilter.GetComponentsInChildren": {
		"prefix": "MeshFilter.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"MeshFilter.GetComponentsInParent": {
		"prefix": "MeshFilter.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"MeshFilter.SendMessage": {
		"prefix": "MeshFilter.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"MeshFilter.SendMessageUpwards": {
		"prefix": "MeshFilter.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"MeshFilter.GetInstanceID": {
		"prefix": "MeshFilter.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"MeshFilter.ToString": {
		"prefix": "MeshFilter.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"MeshFilter.Destroy": {
		"prefix": "MeshFilter.Destroy",
		"body": [
			"MeshFilter.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"MeshFilter.DestroyImmediate": {
		"prefix": "MeshFilter.DestroyImmediate",
		"body": [
			"MeshFilter.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"MeshFilter.DontDestroyOnLoad": {
		"prefix": "MeshFilter.DontDestroyOnLoad",
		"body": [
			"MeshFilter.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"MeshFilter.FindObjectOfType": {
		"prefix": "MeshFilter.FindObjectOfType",
		"body": [
			"MeshFilter.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"MeshFilter.FindObjectsOfType": {
		"prefix": "MeshFilter.FindObjectsOfType",
		"body": [
			"MeshFilter.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"MeshFilter.Instantiate": {
		"prefix": "MeshFilter.Instantiate",
		"body": [
			"MeshFilter.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"MeshParticleEmitter.gameObject": {
		"prefix": "MeshParticleEmitter.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"MeshParticleEmitter.tag": {
		"prefix": "MeshParticleEmitter.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"MeshParticleEmitter.transform": {
		"prefix": "MeshParticleEmitter.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"MeshParticleEmitter.hideFlags": {
		"prefix": "MeshParticleEmitter.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"MeshParticleEmitter.name": {
		"prefix": "MeshParticleEmitter.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"MeshParticleEmitter.BroadcastMessage": {
		"prefix": "MeshParticleEmitter.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"MeshParticleEmitter.CompareTag": {
		"prefix": "MeshParticleEmitter.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"MeshParticleEmitter.GetComponent": {
		"prefix": "MeshParticleEmitter.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"MeshParticleEmitter.GetComponentInChildren": {
		"prefix": "MeshParticleEmitter.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"MeshParticleEmitter.GetComponentInParent": {
		"prefix": "MeshParticleEmitter.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"MeshParticleEmitter.GetComponents": {
		"prefix": "MeshParticleEmitter.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"MeshParticleEmitter.GetComponentsInChildren": {
		"prefix": "MeshParticleEmitter.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"MeshParticleEmitter.GetComponentsInParent": {
		"prefix": "MeshParticleEmitter.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"MeshParticleEmitter.SendMessage": {
		"prefix": "MeshParticleEmitter.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"MeshParticleEmitter.SendMessageUpwards": {
		"prefix": "MeshParticleEmitter.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"MeshParticleEmitter.GetInstanceID": {
		"prefix": "MeshParticleEmitter.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"MeshParticleEmitter.ToString": {
		"prefix": "MeshParticleEmitter.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"MeshParticleEmitter.Destroy": {
		"prefix": "MeshParticleEmitter.Destroy",
		"body": [
			"MeshParticleEmitter.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"MeshParticleEmitter.DestroyImmediate": {
		"prefix": "MeshParticleEmitter.DestroyImmediate",
		"body": [
			"MeshParticleEmitter.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"MeshParticleEmitter.DontDestroyOnLoad": {
		"prefix": "MeshParticleEmitter.DontDestroyOnLoad",
		"body": [
			"MeshParticleEmitter.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"MeshParticleEmitter.FindObjectOfType": {
		"prefix": "MeshParticleEmitter.FindObjectOfType",
		"body": [
			"MeshParticleEmitter.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"MeshParticleEmitter.FindObjectsOfType": {
		"prefix": "MeshParticleEmitter.FindObjectsOfType",
		"body": [
			"MeshParticleEmitter.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"MeshParticleEmitter.Instantiate": {
		"prefix": "MeshParticleEmitter.Instantiate",
		"body": [
			"MeshParticleEmitter.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"MeshRenderer.additionalVertexStreams": {
		"prefix": "MeshRenderer.additionalVertexStreams",
		"body": [
			"additionalVertexStreams"
		],
		"description": "return:Mesh des: Vertex attributes in this mesh will override or add attributes of the primary mesh in the MeshRenderer."
	}
,
	"MeshRenderer.subMeshStartIndex": {
		"prefix": "MeshRenderer.subMeshStartIndex",
		"body": [
			"subMeshStartIndex"
		],
		"description": "return:int des: Index of the first sub-mesh to use from the Mesh associated with this MeshRenderer (Read Only)."
	}
,
	"MeshRenderer.gameObject": {
		"prefix": "MeshRenderer.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"MeshRenderer.tag": {
		"prefix": "MeshRenderer.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"MeshRenderer.transform": {
		"prefix": "MeshRenderer.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"MeshRenderer.hideFlags": {
		"prefix": "MeshRenderer.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"MeshRenderer.name": {
		"prefix": "MeshRenderer.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"MeshRenderer.allowOcclusionWhenDynamic": {
		"prefix": "MeshRenderer.allowOcclusionWhenDynamic",
		"body": [
			"allowOcclusionWhenDynamic"
		],
		"description": "return:bool des: Controls if dynamic occlusion culling should be performed for this renderer."
	}
,
	"MeshRenderer.bounds": {
		"prefix": "MeshRenderer.bounds",
		"body": [
			"bounds"
		],
		"description": "return:Bounds des: The bounding volume of the renderer (Read Only)."
	}
,
	"MeshRenderer.enabled": {
		"prefix": "MeshRenderer.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Makes the rendered 3D object visible if enabled."
	}
,
	"MeshRenderer.isPartOfStaticBatch": {
		"prefix": "MeshRenderer.isPartOfStaticBatch",
		"body": [
			"isPartOfStaticBatch"
		],
		"description": "return:bool des: Has this renderer been statically batched with any other renderers?"
	}
,
	"MeshRenderer.isVisible": {
		"prefix": "MeshRenderer.isVisible",
		"body": [
			"isVisible"
		],
		"description": "return:bool des: Is this renderer visible in any camera? (Read Only)"
	}
,
	"MeshRenderer.lightmapIndex": {
		"prefix": "MeshRenderer.lightmapIndex",
		"body": [
			"lightmapIndex"
		],
		"description": "return:int des: The index of the baked lightmap applied to this renderer."
	}
,
	"MeshRenderer.lightmapScaleOffset": {
		"prefix": "MeshRenderer.lightmapScaleOffset",
		"body": [
			"lightmapScaleOffset"
		],
		"description": "return:Vector4 des: The UV scale & offset used for a lightmap."
	}
,
	"MeshRenderer.lightProbeProxyVolumeOverride": {
		"prefix": "MeshRenderer.lightProbeProxyVolumeOverride",
		"body": [
			"lightProbeProxyVolumeOverride"
		],
		"description": "return:GameObject des: If set, the Renderer will use the Light Probe Proxy Volume component attached to the source GameObject."
	}
,
	"MeshRenderer.lightProbeUsage": {
		"prefix": "MeshRenderer.lightProbeUsage",
		"body": [
			"lightProbeUsage"
		],
		"description": "return:Rendering.LightProbeUsage des: The light probe interpolation type."
	}
,
	"MeshRenderer.localToWorldMatrix": {
		"prefix": "MeshRenderer.localToWorldMatrix",
		"body": [
			"localToWorldMatrix"
		],
		"description": "return:Matrix4x4 des: Matrix that transforms a point from local space into world space (Read Only)."
	}
,
	"MeshRenderer.material": {
		"prefix": "MeshRenderer.material",
		"body": [
			"material"
		],
		"description": "return:Material des: Returns the first instantiated Material assigned to the renderer."
	}
,
	"MeshRenderer.materials": {
		"prefix": "MeshRenderer.materials",
		"body": [
			"materials"
		],
		"description": "return:Material[] des: Returns all the instantiated materials of this object."
	}
,
	"MeshRenderer.motionVectorGenerationMode": {
		"prefix": "MeshRenderer.motionVectorGenerationMode",
		"body": [
			"motionVectorGenerationMode"
		],
		"description": "return:MotionVectorGenerationMode des: Specifies the mode for motion vector rendering."
	}
,
	"MeshRenderer.probeAnchor": {
		"prefix": "MeshRenderer.probeAnchor",
		"body": [
			"probeAnchor"
		],
		"description": "return:Transform des: If set, Renderer will use this Transform's position to find the light or reflection probe."
	}
,
	"MeshRenderer.realtimeLightmapIndex": {
		"prefix": "MeshRenderer.realtimeLightmapIndex",
		"body": [
			"realtimeLightmapIndex"
		],
		"description": "return:int des: The index of the realtime lightmap applied to this renderer."
	}
,
	"MeshRenderer.realtimeLightmapScaleOffset": {
		"prefix": "MeshRenderer.realtimeLightmapScaleOffset",
		"body": [
			"realtimeLightmapScaleOffset"
		],
		"description": "return:Vector4 des: The UV scale & offset used for a realtime lightmap."
	}
,
	"MeshRenderer.receiveShadows": {
		"prefix": "MeshRenderer.receiveShadows",
		"body": [
			"receiveShadows"
		],
		"description": "return:bool des: Does this object receive shadows?"
	}
,
	"MeshRenderer.reflectionProbeUsage": {
		"prefix": "MeshRenderer.reflectionProbeUsage",
		"body": [
			"reflectionProbeUsage"
		],
		"description": "return:Rendering.ReflectionProbeUsage des: Should reflection probes be used for this Renderer?"
	}
,
	"MeshRenderer.renderingLayerMask": {
		"prefix": "MeshRenderer.renderingLayerMask",
		"body": [
			"renderingLayerMask"
		],
		"description": "return:uint des: Determines which rendering layer this renderer lives on."
	}
,
	"MeshRenderer.shadowCastingMode": {
		"prefix": "MeshRenderer.shadowCastingMode",
		"body": [
			"shadowCastingMode"
		],
		"description": "return:Rendering.ShadowCastingMode des: Does this object cast shadows?"
	}
,
	"MeshRenderer.sharedMaterial": {
		"prefix": "MeshRenderer.sharedMaterial",
		"body": [
			"sharedMaterial"
		],
		"description": "return:Material des: The shared material of this object."
	}
,
	"MeshRenderer.sharedMaterials": {
		"prefix": "MeshRenderer.sharedMaterials",
		"body": [
			"sharedMaterials"
		],
		"description": "return:Material[] des: All the shared materials of this object."
	}
,
	"MeshRenderer.sortingLayerID": {
		"prefix": "MeshRenderer.sortingLayerID",
		"body": [
			"sortingLayerID"
		],
		"description": "return:int des: Unique ID of the Renderer's sorting layer."
	}
,
	"MeshRenderer.sortingLayerName": {
		"prefix": "MeshRenderer.sortingLayerName",
		"body": [
			"sortingLayerName"
		],
		"description": "return:string des: Name of the Renderer's sorting layer."
	}
,
	"MeshRenderer.sortingOrder": {
		"prefix": "MeshRenderer.sortingOrder",
		"body": [
			"sortingOrder"
		],
		"description": "return:int des: Renderer's order within a sorting layer."
	}
,
	"MeshRenderer.worldToLocalMatrix": {
		"prefix": "MeshRenderer.worldToLocalMatrix",
		"body": [
			"worldToLocalMatrix"
		],
		"description": "return:Matrix4x4 des: Matrix that transforms a point from world space into local space (Read Only)."
	}
,
	"MeshRenderer.BroadcastMessage": {
		"prefix": "MeshRenderer.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"MeshRenderer.CompareTag": {
		"prefix": "MeshRenderer.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"MeshRenderer.GetComponent": {
		"prefix": "MeshRenderer.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"MeshRenderer.GetComponentInChildren": {
		"prefix": "MeshRenderer.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"MeshRenderer.GetComponentInParent": {
		"prefix": "MeshRenderer.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"MeshRenderer.GetComponents": {
		"prefix": "MeshRenderer.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"MeshRenderer.GetComponentsInChildren": {
		"prefix": "MeshRenderer.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"MeshRenderer.GetComponentsInParent": {
		"prefix": "MeshRenderer.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"MeshRenderer.SendMessage": {
		"prefix": "MeshRenderer.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"MeshRenderer.SendMessageUpwards": {
		"prefix": "MeshRenderer.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"MeshRenderer.GetInstanceID": {
		"prefix": "MeshRenderer.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"MeshRenderer.ToString": {
		"prefix": "MeshRenderer.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"MeshRenderer.GetClosestReflectionProbes": {
		"prefix": "MeshRenderer.GetClosestReflectionProbes",
		"body": [
			"GetClosestReflectionProbes($1)"
		],
		"description": "public void GetClosestReflectionProbes(List<ReflectionProbeBlendInfo> result); des: Returns an array of closest reflection probes with weights, weight shows how much influence the probe has on the renderer, this value is also used when blending between reflection probes occur."
	}
,
	"MeshRenderer.GetMaterials": {
		"prefix": "MeshRenderer.GetMaterials",
		"body": [
			"GetMaterials($1)"
		],
		"description": "public void GetMaterials(List<Material> m); des: Returns all the instantiated materials of this object."
	}
,
	"MeshRenderer.GetPropertyBlock": {
		"prefix": "MeshRenderer.GetPropertyBlock",
		"body": [
			"GetPropertyBlock($1)"
		],
		"description": "public void GetPropertyBlock(MaterialPropertyBlock properties); public void GetPropertyBlock(MaterialPropertyBlock properties, int materialIndex); des: Get per-Renderer or per-Material property block."
	}
,
	"MeshRenderer.GetSharedMaterials": {
		"prefix": "MeshRenderer.GetSharedMaterials",
		"body": [
			"GetSharedMaterials($1)"
		],
		"description": "public void GetSharedMaterials(List<Material> m); des: Returns all the shared materials of this object."
	}
,
	"MeshRenderer.HasPropertyBlock": {
		"prefix": "MeshRenderer.HasPropertyBlock",
		"body": [
			"HasPropertyBlock($1)"
		],
		"description": "public bool HasPropertyBlock(); des: Returns true if the Renderer has a material property block attached via SetPropertyBlock."
	}
,
	"MeshRenderer.SetPropertyBlock": {
		"prefix": "MeshRenderer.SetPropertyBlock",
		"body": [
			"SetPropertyBlock($1)"
		],
		"description": "public void SetPropertyBlock(MaterialPropertyBlock properties); public void SetPropertyBlock(MaterialPropertyBlock properties, int materialIndex); des: Lets you set or clear per-renderer or per-material parameter overrides."
	}
,
	"MeshRenderer.Destroy": {
		"prefix": "MeshRenderer.Destroy",
		"body": [
			"MeshRenderer.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"MeshRenderer.DestroyImmediate": {
		"prefix": "MeshRenderer.DestroyImmediate",
		"body": [
			"MeshRenderer.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"MeshRenderer.DontDestroyOnLoad": {
		"prefix": "MeshRenderer.DontDestroyOnLoad",
		"body": [
			"MeshRenderer.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"MeshRenderer.FindObjectOfType": {
		"prefix": "MeshRenderer.FindObjectOfType",
		"body": [
			"MeshRenderer.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"MeshRenderer.FindObjectsOfType": {
		"prefix": "MeshRenderer.FindObjectsOfType",
		"body": [
			"MeshRenderer.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"MeshRenderer.Instantiate": {
		"prefix": "MeshRenderer.Instantiate",
		"body": [
			"MeshRenderer.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"MeshRenderer.OnBecameInvisible": {
		"prefix": "MeshRenderer.OnBecameInvisible",
		"body": [
			"OnBecameInvisible"
		],
		"description": "OnBecameInvisible is called when the object is no longer visible by any camera."
	}
,
	"MeshRenderer.OnBecameVisible": {
		"prefix": "MeshRenderer.OnBecameVisible",
		"body": [
			"OnBecameVisible"
		],
		"description": "OnBecameVisible is called when the object became visible by any camera."
	}
,
	"Microphone.End": {
		"prefix": "Microphone.End",
		"body": [
			"Microphone.End"
		],
		"description": "public static void End(string deviceName); des: Stops recording."
	}
,
	"Microphone.GetDeviceCaps": {
		"prefix": "Microphone.GetDeviceCaps",
		"body": [
			"Microphone.GetDeviceCaps"
		],
		"description": "public static void GetDeviceCaps(string deviceName, out int minFreq, out int maxFreq); des: Get the frequency capabilities of a device."
	}
,
	"Microphone.GetPosition": {
		"prefix": "Microphone.GetPosition",
		"body": [
			"Microphone.GetPosition"
		],
		"description": "public static int GetPosition(string deviceName); des: Get the position in samples of the recording."
	}
,
	"Microphone.IsRecording": {
		"prefix": "Microphone.IsRecording",
		"body": [
			"Microphone.IsRecording"
		],
		"description": "public static bool IsRecording(string deviceName); des: Query if a device is currently recording."
	}
,
	"Microphone.Start": {
		"prefix": "Microphone.Start",
		"body": [
			"Microphone.Start"
		],
		"description": "public static AudioClip Start(string deviceName, bool loop, int lengthSec, int frequency); des: Start Recording with device."
	}
,
	"MonoBehaviour.runInEditMode": {
		"prefix": "MonoBehaviour.runInEditMode",
		"body": [
			"runInEditMode"
		],
		"description": "return:bool des: Allow a specific instance of a MonoBehaviour to run in edit mode (only available in the editor)."
	}
,
	"MonoBehaviour.useGUILayout": {
		"prefix": "MonoBehaviour.useGUILayout",
		"body": [
			"useGUILayout"
		],
		"description": "return:bool des: Disabling this lets you skip the GUI layout phase."
	}
,
	"MonoBehaviour.CancelInvoke": {
		"prefix": "MonoBehaviour.CancelInvoke",
		"body": [
			"CancelInvoke($1)"
		],
		"description": "public void CancelInvoke(); public void CancelInvoke(string methodName); des: Cancels all Invoke calls on this MonoBehaviour."
	}
,
	"MonoBehaviour.Invoke": {
		"prefix": "MonoBehaviour.Invoke",
		"body": [
			"Invoke($1)"
		],
		"description": "public void Invoke(string methodName, float time); des: Invokes the method methodName in time seconds."
	}
,
	"MonoBehaviour.InvokeRepeating": {
		"prefix": "MonoBehaviour.InvokeRepeating",
		"body": [
			"InvokeRepeating($1)"
		],
		"description": "public void InvokeRepeating(string methodName, float time, float repeatRate); des: Invokes the method methodName in time seconds, then repeatedly every repeatRate seconds."
	}
,
	"MonoBehaviour.IsInvoking": {
		"prefix": "MonoBehaviour.IsInvoking",
		"body": [
			"IsInvoking($1)"
		],
		"description": "public bool IsInvoking(string methodName); public bool IsInvoking(); des: Is any invoke on methodName pending?"
	}
,
	"MonoBehaviour.StartCoroutine": {
		"prefix": "MonoBehaviour.StartCoroutine",
		"body": [
			"StartCoroutine($1)"
		],
		"description": "public Coroutine StartCoroutine(IEnumerator routine); public Coroutine StartCoroutine(string methodName, object value = null);  des: Starts a coroutine."
	}
,
	"MonoBehaviour.StopAllCoroutines": {
		"prefix": "MonoBehaviour.StopAllCoroutines",
		"body": [
			"StopAllCoroutines($1)"
		],
		"description": "public void StopAllCoroutines(); des: Stops all coroutines running on this behaviour."
	}
,
	"MonoBehaviour.StopCoroutine": {
		"prefix": "MonoBehaviour.StopCoroutine",
		"body": [
			"StopCoroutine($1)"
		],
		"description": "public void StopCoroutine(string methodName); public void StopCoroutine(IEnumerator routine); public void StopCoroutine(Coroutine routine); des: Stops the first coroutine named methodName, or the coroutine stored in routine running on this behaviour."
	}
,
	"MonoBehaviour.print": {
		"prefix": "MonoBehaviour.print",
		"body": [
			"MonoBehaviour.print"
		],
		"description": "public static void print(object message); des: Logs message to the Unity Console (identical to Debug.Log)."
	}
,
	"MonoBehaviour.Awake": {
		"prefix": "MonoBehaviour.Awake",
		"body": [
			"Awake"
		],
		"description": "Awake is called when the script instance is being loaded."
	}
,
	"MonoBehaviour.FixedUpdate": {
		"prefix": "MonoBehaviour.FixedUpdate",
		"body": [
			"FixedUpdate"
		],
		"description": "This function is called every fixed framerate frame, if the MonoBehaviour is enabled."
	}
,
	"MonoBehaviour.LateUpdate": {
		"prefix": "MonoBehaviour.LateUpdate",
		"body": [
			"LateUpdate"
		],
		"description": "LateUpdate is called every frame, if the Behaviour is enabled."
	}
,
	"MonoBehaviour.OnAnimatorIK": {
		"prefix": "MonoBehaviour.OnAnimatorIK",
		"body": [
			"OnAnimatorIK"
		],
		"description": "Callback for setting up animation IK (inverse kinematics)."
	}
,
	"MonoBehaviour.OnAnimatorMove": {
		"prefix": "MonoBehaviour.OnAnimatorMove",
		"body": [
			"OnAnimatorMove"
		],
		"description": "Callback for processing animation movements for modifying root motion."
	}
,
	"MonoBehaviour.OnApplicationFocus": {
		"prefix": "MonoBehaviour.OnApplicationFocus",
		"body": [
			"OnApplicationFocus"
		],
		"description": "Sent to all GameObjects when the player gets or loses focus."
	}
,
	"MonoBehaviour.OnApplicationPause": {
		"prefix": "MonoBehaviour.OnApplicationPause",
		"body": [
			"OnApplicationPause"
		],
		"description": "Sent to all GameObjects when the application pauses."
	}
,
	"MonoBehaviour.OnApplicationQuit": {
		"prefix": "MonoBehaviour.OnApplicationQuit",
		"body": [
			"OnApplicationQuit"
		],
		"description": "Sent to all game objects before the application quits."
	}
,
	"MonoBehaviour.OnAudioFilterRead": {
		"prefix": "MonoBehaviour.OnAudioFilterRead",
		"body": [
			"OnAudioFilterRead"
		],
		"description": "If OnAudioFilterRead is implemented, Unity will insert a custom filter into the audio DSP chain."
	}
,
	"MonoBehaviour.OnBecameInvisible": {
		"prefix": "MonoBehaviour.OnBecameInvisible",
		"body": [
			"OnBecameInvisible"
		],
		"description": "OnBecameInvisible is called when the renderer is no longer visible by any camera."
	}
,
	"MonoBehaviour.OnBecameVisible": {
		"prefix": "MonoBehaviour.OnBecameVisible",
		"body": [
			"OnBecameVisible"
		],
		"description": "OnBecameVisible is called when the renderer became visible by any camera."
	}
,
	"MonoBehaviour.OnCollisionEnter": {
		"prefix": "MonoBehaviour.OnCollisionEnter",
		"body": [
			"OnCollisionEnter"
		],
		"description": "OnCollisionEnter is called when this collider/rigidbody has begun touching another rigidbody/collider."
	}
,
	"MonoBehaviour.OnCollisionEnter2D": {
		"prefix": "MonoBehaviour.OnCollisionEnter2D",
		"body": [
			"OnCollisionEnter2D"
		],
		"description": "Sent when an incoming collider makes contact with this object's collider (2D physics only)."
	}
,
	"MonoBehaviour.OnCollisionExit": {
		"prefix": "MonoBehaviour.OnCollisionExit",
		"body": [
			"OnCollisionExit"
		],
		"description": "OnCollisionExit is called when this collider/rigidbody has stopped touching another rigidbody/collider."
	}
,
	"MonoBehaviour.OnCollisionExit2D": {
		"prefix": "MonoBehaviour.OnCollisionExit2D",
		"body": [
			"OnCollisionExit2D"
		],
		"description": "Sent when a collider on another object stops touching this object's collider (2D physics only)."
	}
,
	"MonoBehaviour.OnCollisionStay": {
		"prefix": "MonoBehaviour.OnCollisionStay",
		"body": [
			"OnCollisionStay"
		],
		"description": ":ref::OnCollisionStay is called once per frame for every collider/rigidbody that is touching rigidbody/collider."
	}
,
	"MonoBehaviour.OnCollisionStay2D": {
		"prefix": "MonoBehaviour.OnCollisionStay2D",
		"body": [
			"OnCollisionStay2D"
		],
		"description": "Sent each frame where a collider on another object is touching this object's collider (2D physics only)."
	}
,
	"MonoBehaviour.OnConnectedToServer": {
		"prefix": "MonoBehaviour.OnConnectedToServer",
		"body": [
			"OnConnectedToServer"
		],
		"description": "Called on the client when you have successfully connected to a server."
	}
,
	"MonoBehaviour.OnControllerColliderHit": {
		"prefix": "MonoBehaviour.OnControllerColliderHit",
		"body": [
			"OnControllerColliderHit"
		],
		"description": "OnControllerColliderHit is called when the controller hits a collider while performing a Move."
	}
,
	"MonoBehaviour.OnDestroy": {
		"prefix": "MonoBehaviour.OnDestroy",
		"body": [
			"OnDestroy"
		],
		"description": "Destroying the attached Behaviour will result in the game or Scene receiving OnDestroy."
	}
,
	"MonoBehaviour.OnDisable": {
		"prefix": "MonoBehaviour.OnDisable",
		"body": [
			"OnDisable"
		],
		"description": "This function is called when the behaviour becomes disabled."
	}
,
	"MonoBehaviour.OnDisconnectedFromServer": {
		"prefix": "MonoBehaviour.OnDisconnectedFromServer",
		"body": [
			"OnDisconnectedFromServer"
		],
		"description": "Called on the client when the connection was lost or you disconnected from the server."
	}
,
	"MonoBehaviour.OnDrawGizmos": {
		"prefix": "MonoBehaviour.OnDrawGizmos",
		"body": [
			"OnDrawGizmos"
		],
		"description": "Implement OnDrawGizmos if you want to draw gizmos that are also pickable and always drawn."
	}
,
	"MonoBehaviour.OnDrawGizmosSelected": {
		"prefix": "MonoBehaviour.OnDrawGizmosSelected",
		"body": [
			"OnDrawGizmosSelected"
		],
		"description": "Implement OnDrawGizmosSelected to draw a gizmo if the object is selected."
	}
,
	"MonoBehaviour.OnEnable": {
		"prefix": "MonoBehaviour.OnEnable",
		"body": [
			"OnEnable"
		],
		"description": "This function is called when the object becomes enabled and active."
	}
,
	"MonoBehaviour.OnFailedToConnect": {
		"prefix": "MonoBehaviour.OnFailedToConnect",
		"body": [
			"OnFailedToConnect"
		],
		"description": "Called on the client when a connection attempt fails for some reason."
	}
,
	"MonoBehaviour.OnFailedToConnectToMasterServer": {
		"prefix": "MonoBehaviour.OnFailedToConnectToMasterServer",
		"body": [
			"OnFailedToConnectToMasterServer"
		],
		"description": "Called on clients or servers when there is a problem connecting to the MasterServer."
	}
,
	"MonoBehaviour.OnGUI": {
		"prefix": "MonoBehaviour.OnGUI",
		"body": [
			"OnGUI"
		],
		"description": "OnGUI is called for rendering and handling GUI events."
	}
,
	"MonoBehaviour.OnJointBreak": {
		"prefix": "MonoBehaviour.OnJointBreak",
		"body": [
			"OnJointBreak"
		],
		"description": "Called when a joint attached to the same game object broke."
	}
,
	"MonoBehaviour.OnJointBreak2D": {
		"prefix": "MonoBehaviour.OnJointBreak2D",
		"body": [
			"OnJointBreak2D"
		],
		"description": "Called when a Joint2D attached to the same game object breaks."
	}
,
	"MonoBehaviour.OnMasterServerEvent": {
		"prefix": "MonoBehaviour.OnMasterServerEvent",
		"body": [
			"OnMasterServerEvent"
		],
		"description": "Called on clients or servers when reporting events from the MasterServer."
	}
,
	"MonoBehaviour.OnMouseDown": {
		"prefix": "MonoBehaviour.OnMouseDown",
		"body": [
			"OnMouseDown"
		],
		"description": "OnMouseDown is called when the user has pressed the mouse button while over the GUIElement or Collider."
	}
,
	"MonoBehaviour.OnMouseDrag": {
		"prefix": "MonoBehaviour.OnMouseDrag",
		"body": [
			"OnMouseDrag"
		],
		"description": "OnMouseDrag is called when the user has clicked on a GUIElement or Collider and is still holding down the mouse."
	}
,
	"MonoBehaviour.OnMouseEnter": {
		"prefix": "MonoBehaviour.OnMouseEnter",
		"body": [
			"OnMouseEnter"
		],
		"description": "Called when the mouse enters the GUIElement or Collider."
	}
,
	"MonoBehaviour.OnMouseExit": {
		"prefix": "MonoBehaviour.OnMouseExit",
		"body": [
			"OnMouseExit"
		],
		"description": "Called when the mouse is not any longer over the GUIElement or Collider."
	}
,
	"MonoBehaviour.OnMouseOver": {
		"prefix": "MonoBehaviour.OnMouseOver",
		"body": [
			"OnMouseOver"
		],
		"description": "Called every frame while the mouse is over the GUIElement or Collider."
	}
,
	"MonoBehaviour.OnMouseUp": {
		"prefix": "MonoBehaviour.OnMouseUp",
		"body": [
			"OnMouseUp"
		],
		"description": "OnMouseUp is called when the user has released the mouse button."
	}
,
	"MonoBehaviour.OnMouseUpAsButton": {
		"prefix": "MonoBehaviour.OnMouseUpAsButton",
		"body": [
			"OnMouseUpAsButton"
		],
		"description": "OnMouseUpAsButton is only called when the mouse is released over the same GUIElement or Collider as it was pressed."
	}
,
	"MonoBehaviour.OnNetworkInstantiate": {
		"prefix": "MonoBehaviour.OnNetworkInstantiate",
		"body": [
			"OnNetworkInstantiate"
		],
		"description": "Called on objects which have been network instantiated with Network.Instantiate."
	}
,
	"MonoBehaviour.OnParticleCollision": {
		"prefix": "MonoBehaviour.OnParticleCollision",
		"body": [
			"OnParticleCollision"
		],
		"description": "OnParticleCollision is called when a particle hits a Collider."
	}
,
	"MonoBehaviour.OnParticleSystemStopped": {
		"prefix": "MonoBehaviour.OnParticleSystemStopped",
		"body": [
			"OnParticleSystemStopped"
		],
		"description": "OnParticleSystemStopped is called when all particles in the system have died, and no new particles will be born. New particles cease to be created either after Stop is called, or when the duration property of a non-looping system has been exceeded."
	}
,
	"MonoBehaviour.OnParticleTrigger": {
		"prefix": "MonoBehaviour.OnParticleTrigger",
		"body": [
			"OnParticleTrigger"
		],
		"description": "OnParticleTrigger is called when any particles in a particle system meet the conditions in the trigger module."
	}
,
	"MonoBehaviour.OnPlayerConnected": {
		"prefix": "MonoBehaviour.OnPlayerConnected",
		"body": [
			"OnPlayerConnected"
		],
		"description": "Called on the server whenever a new player has successfully connected."
	}
,
	"MonoBehaviour.OnPlayerDisconnected": {
		"prefix": "MonoBehaviour.OnPlayerDisconnected",
		"body": [
			"OnPlayerDisconnected"
		],
		"description": "Called on the server whenever a player disconnected from the server."
	}
,
	"MonoBehaviour.OnPostRender": {
		"prefix": "MonoBehaviour.OnPostRender",
		"body": [
			"OnPostRender"
		],
		"description": "OnPostRender is called after a camera finished rendering the Scene."
	}
,
	"MonoBehaviour.OnPreCull": {
		"prefix": "MonoBehaviour.OnPreCull",
		"body": [
			"OnPreCull"
		],
		"description": "OnPreCull is called before a camera culls the Scene."
	}
,
	"MonoBehaviour.OnPreRender": {
		"prefix": "MonoBehaviour.OnPreRender",
		"body": [
			"OnPreRender"
		],
		"description": "OnPreRender is called before a camera starts rendering the Scene."
	}
,
	"MonoBehaviour.OnRenderImage": {
		"prefix": "MonoBehaviour.OnRenderImage",
		"body": [
			"OnRenderImage"
		],
		"description": "OnRenderImage is called after all rendering is complete to render image."
	}
,
	"MonoBehaviour.OnRenderObject": {
		"prefix": "MonoBehaviour.OnRenderObject",
		"body": [
			"OnRenderObject"
		],
		"description": "OnRenderObject is called after camera has rendered the Scene."
	}
,
	"MonoBehaviour.OnSerializeNetworkView": {
		"prefix": "MonoBehaviour.OnSerializeNetworkView",
		"body": [
			"OnSerializeNetworkView"
		],
		"description": "Used to customize synchronization of variables in a script watched by a network view."
	}
,
	"MonoBehaviour.OnServerInitialized": {
		"prefix": "MonoBehaviour.OnServerInitialized",
		"body": [
			"OnServerInitialized"
		],
		"description": "Called on the server whenever a Network.InitializeServer was invoked and has completed."
	}
,
	"MonoBehaviour.OnTransformChildrenChanged": {
		"prefix": "MonoBehaviour.OnTransformChildrenChanged",
		"body": [
			"OnTransformChildrenChanged"
		],
		"description": "This function is called when the list of children of the transform of the GameObject has changed."
	}
,
	"MonoBehaviour.OnTransformParentChanged": {
		"prefix": "MonoBehaviour.OnTransformParentChanged",
		"body": [
			"OnTransformParentChanged"
		],
		"description": "This function is called when the parent property of the transform of the GameObject has changed."
	}
,
	"MonoBehaviour.OnTriggerEnter": {
		"prefix": "MonoBehaviour.OnTriggerEnter",
		"body": [
			"OnTriggerEnter"
		],
		"description": "OnTriggerEnter is called when the Collider other enters the trigger."
	}
,
	"MonoBehaviour.OnTriggerEnter2D": {
		"prefix": "MonoBehaviour.OnTriggerEnter2D",
		"body": [
			"OnTriggerEnter2D"
		],
		"description": "Sent when another object enters a trigger collider attached to this object (2D physics only)."
	}
,
	"MonoBehaviour.OnTriggerExit": {
		"prefix": "MonoBehaviour.OnTriggerExit",
		"body": [
			"OnTriggerExit"
		],
		"description": "OnTriggerExit is called when the Collider other has stopped touching the trigger."
	}
,
	"MonoBehaviour.OnTriggerExit2D": {
		"prefix": "MonoBehaviour.OnTriggerExit2D",
		"body": [
			"OnTriggerExit2D"
		],
		"description": "Sent when another object leaves a trigger collider attached to this object (2D physics only)."
	}
,
	"MonoBehaviour.OnTriggerStay": {
		"prefix": "MonoBehaviour.OnTriggerStay",
		"body": [
			"OnTriggerStay"
		],
		"description": "OnTriggerStay is called once per physics update for every Collider other that is touching the trigger."
	}
,
	"MonoBehaviour.OnTriggerStay2D": {
		"prefix": "MonoBehaviour.OnTriggerStay2D",
		"body": [
			"OnTriggerStay2D"
		],
		"description": "Sent each frame where another object is within a trigger collider attached to this object (2D physics only)."
	}
,
	"MonoBehaviour.OnValidate": {
		"prefix": "MonoBehaviour.OnValidate",
		"body": [
			"OnValidate"
		],
		"description": "This function is called when the script is loaded or a value is changed in the inspector (Called in the editor only)."
	}
,
	"MonoBehaviour.OnWillRenderObject": {
		"prefix": "MonoBehaviour.OnWillRenderObject",
		"body": [
			"OnWillRenderObject"
		],
		"description": "OnWillRenderObject is called for each camera if the object is visible and not a UI element."
	}
,
	"MonoBehaviour.Reset": {
		"prefix": "MonoBehaviour.Reset",
		"body": [
			"Reset"
		],
		"description": "Reset to default values."
	}
,
	"MonoBehaviour.Start": {
		"prefix": "MonoBehaviour.Start",
		"body": [
			"Start"
		],
		"description": "Start is called on the frame when a script is enabled just before any of the Update methods are called the first time."
	}
,
	"MonoBehaviour.Update": {
		"prefix": "MonoBehaviour.Update",
		"body": [
			"Update"
		],
		"description": "Update is called every frame, if the MonoBehaviour is enabled."
	}
,
	"MonoBehaviour.enabled": {
		"prefix": "MonoBehaviour.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"MonoBehaviour.isActiveAndEnabled": {
		"prefix": "MonoBehaviour.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"MonoBehaviour.gameObject": {
		"prefix": "MonoBehaviour.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"MonoBehaviour.tag": {
		"prefix": "MonoBehaviour.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"MonoBehaviour.transform": {
		"prefix": "MonoBehaviour.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"MonoBehaviour.hideFlags": {
		"prefix": "MonoBehaviour.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"MonoBehaviour.name": {
		"prefix": "MonoBehaviour.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"MonoBehaviour.BroadcastMessage": {
		"prefix": "MonoBehaviour.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"MonoBehaviour.CompareTag": {
		"prefix": "MonoBehaviour.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"MonoBehaviour.GetComponent": {
		"prefix": "MonoBehaviour.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"MonoBehaviour.GetComponentInChildren": {
		"prefix": "MonoBehaviour.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"MonoBehaviour.GetComponentInParent": {
		"prefix": "MonoBehaviour.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"MonoBehaviour.GetComponents": {
		"prefix": "MonoBehaviour.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"MonoBehaviour.GetComponentsInChildren": {
		"prefix": "MonoBehaviour.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"MonoBehaviour.GetComponentsInParent": {
		"prefix": "MonoBehaviour.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"MonoBehaviour.SendMessage": {
		"prefix": "MonoBehaviour.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"MonoBehaviour.SendMessageUpwards": {
		"prefix": "MonoBehaviour.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"MonoBehaviour.GetInstanceID": {
		"prefix": "MonoBehaviour.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"MonoBehaviour.ToString": {
		"prefix": "MonoBehaviour.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"MonoBehaviour.Destroy": {
		"prefix": "MonoBehaviour.Destroy",
		"body": [
			"MonoBehaviour.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"MonoBehaviour.DestroyImmediate": {
		"prefix": "MonoBehaviour.DestroyImmediate",
		"body": [
			"MonoBehaviour.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"MonoBehaviour.DontDestroyOnLoad": {
		"prefix": "MonoBehaviour.DontDestroyOnLoad",
		"body": [
			"MonoBehaviour.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"MonoBehaviour.FindObjectOfType": {
		"prefix": "MonoBehaviour.FindObjectOfType",
		"body": [
			"MonoBehaviour.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"MonoBehaviour.FindObjectsOfType": {
		"prefix": "MonoBehaviour.FindObjectsOfType",
		"body": [
			"MonoBehaviour.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"MonoBehaviour.Instantiate": {
		"prefix": "MonoBehaviour.Instantiate",
		"body": [
			"MonoBehaviour.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"Motion.hideFlags": {
		"prefix": "Motion.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Motion.name": {
		"prefix": "Motion.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Motion.GetInstanceID": {
		"prefix": "Motion.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Motion.ToString": {
		"prefix": "Motion.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Motion.Destroy": {
		"prefix": "Motion.Destroy",
		"body": [
			"Motion.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Motion.DestroyImmediate": {
		"prefix": "Motion.DestroyImmediate",
		"body": [
			"Motion.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Motion.DontDestroyOnLoad": {
		"prefix": "Motion.DontDestroyOnLoad",
		"body": [
			"Motion.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Motion.FindObjectOfType": {
		"prefix": "Motion.FindObjectOfType",
		"body": [
			"Motion.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Motion.FindObjectsOfType": {
		"prefix": "Motion.FindObjectsOfType",
		"body": [
			"Motion.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Motion.Instantiate": {
		"prefix": "Motion.Instantiate",
		"body": [
			"Motion.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"MovieTexture.hideFlags": {
		"prefix": "MovieTexture.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"MovieTexture.name": {
		"prefix": "MovieTexture.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"MovieTexture.anisoLevel": {
		"prefix": "MovieTexture.anisoLevel",
		"body": [
			"anisoLevel"
		],
		"description": "return:int des: Anisotropic filtering level of the texture."
	}
,
	"MovieTexture.dimension": {
		"prefix": "MovieTexture.dimension",
		"body": [
			"dimension"
		],
		"description": "return:Rendering.TextureDimension des: Dimensionality (type) of the texture (Read Only)."
	}
,
	"MovieTexture.filterMode": {
		"prefix": "MovieTexture.filterMode",
		"body": [
			"filterMode"
		],
		"description": "return:FilterMode des: Filtering mode of the texture."
	}
,
	"MovieTexture.height": {
		"prefix": "MovieTexture.height",
		"body": [
			"height"
		],
		"description": "return:int des: Height of the texture in pixels. (Read Only)"
	}
,
	"MovieTexture.imageContentsHash": {
		"prefix": "MovieTexture.imageContentsHash",
		"body": [
			"imageContentsHash"
		],
		"description": "return:Hash128 des: The hash value of the Texture."
	}
,
	"MovieTexture.mipMapBias": {
		"prefix": "MovieTexture.mipMapBias",
		"body": [
			"mipMapBias"
		],
		"description": "return:float des: Mip map bias of the texture."
	}
,
	"MovieTexture.updateCount": {
		"prefix": "MovieTexture.updateCount",
		"body": [
			"updateCount"
		],
		"description": "return:uint des: This counter is incremented when the texture is updated."
	}
,
	"MovieTexture.width": {
		"prefix": "MovieTexture.width",
		"body": [
			"width"
		],
		"description": "return:int des: Width of the texture in pixels. (Read Only)"
	}
,
	"MovieTexture.wrapMode": {
		"prefix": "MovieTexture.wrapMode",
		"body": [
			"wrapMode"
		],
		"description": "return:TextureWrapMode des: Texture coordinate wrapping mode."
	}
,
	"MovieTexture.wrapModeU": {
		"prefix": "MovieTexture.wrapModeU",
		"body": [
			"wrapModeU"
		],
		"description": "return:TextureWrapMode des: Texture U coordinate wrapping mode."
	}
,
	"MovieTexture.wrapModeV": {
		"prefix": "MovieTexture.wrapModeV",
		"body": [
			"wrapModeV"
		],
		"description": "return:TextureWrapMode des: Texture V coordinate wrapping mode."
	}
,
	"MovieTexture.wrapModeW": {
		"prefix": "MovieTexture.wrapModeW",
		"body": [
			"wrapModeW"
		],
		"description": "return:TextureWrapMode des: Texture W coordinate wrapping mode for Texture3D."
	}
,
	"MovieTexture.GetInstanceID": {
		"prefix": "MovieTexture.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"MovieTexture.ToString": {
		"prefix": "MovieTexture.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"MovieTexture.GetNativeTexturePtr": {
		"prefix": "MovieTexture.GetNativeTexturePtr",
		"body": [
			"GetNativeTexturePtr($1)"
		],
		"description": "public IntPtr GetNativeTexturePtr(); des: Retrieve a native (underlying graphics API) pointer to the texture resource."
	}
,
	"MovieTexture.IncrementUpdateCount": {
		"prefix": "MovieTexture.IncrementUpdateCount",
		"body": [
			"IncrementUpdateCount($1)"
		],
		"description": "public void IncrementUpdateCount(); des: Increment the update counter."
	}
,
	"MovieTexture.Destroy": {
		"prefix": "MovieTexture.Destroy",
		"body": [
			"MovieTexture.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"MovieTexture.DestroyImmediate": {
		"prefix": "MovieTexture.DestroyImmediate",
		"body": [
			"MovieTexture.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"MovieTexture.DontDestroyOnLoad": {
		"prefix": "MovieTexture.DontDestroyOnLoad",
		"body": [
			"MovieTexture.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"MovieTexture.FindObjectOfType": {
		"prefix": "MovieTexture.FindObjectOfType",
		"body": [
			"MovieTexture.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"MovieTexture.FindObjectsOfType": {
		"prefix": "MovieTexture.FindObjectsOfType",
		"body": [
			"MovieTexture.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"MovieTexture.Instantiate": {
		"prefix": "MovieTexture.Instantiate",
		"body": [
			"MovieTexture.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"MovieTexture.SetGlobalAnisotropicFilteringLimits": {
		"prefix": "MovieTexture.SetGlobalAnisotropicFilteringLimits",
		"body": [
			"MovieTexture.SetGlobalAnisotropicFilteringLimits"
		],
		"description": "public static void SetGlobalAnisotropicFilteringLimits(int forcedMin, int globalMax); des: Sets Anisotropic limits."
	}
,
	"MovieTexture.SetStreamingTextureMaterialDebugProperties": {
		"prefix": "MovieTexture.SetStreamingTextureMaterialDebugProperties",
		"body": [
			"MovieTexture.SetStreamingTextureMaterialDebugProperties"
		],
		"description": "public static void SetStreamingTextureMaterialDebugProperties(); des: Uploads additional debug information to materials using textures set to stream mip maps."
	}
,
	"Network.OnConnectedToServer": {
		"prefix": "Network.OnConnectedToServer",
		"body": [
			"OnConnectedToServer"
		],
		"description": "Called on the client when you have successfully connected to a server."
	}
,
	"Network.OnDisconnectedFromServer": {
		"prefix": "Network.OnDisconnectedFromServer",
		"body": [
			"OnDisconnectedFromServer"
		],
		"description": "Called on client during disconnection from server, but also on the server when the connection has disconnected."
	}
,
	"Network.OnFailedToConnect": {
		"prefix": "Network.OnFailedToConnect",
		"body": [
			"OnFailedToConnect"
		],
		"description": "Called on the client when a connection attempt fails for some reason."
	}
,
	"Network.OnNetworkInstantiate": {
		"prefix": "Network.OnNetworkInstantiate",
		"body": [
			"OnNetworkInstantiate"
		],
		"description": "Called on objects which have been network instantiated with Network.Instantiate."
	}
,
	"Network.OnPlayerConnected": {
		"prefix": "Network.OnPlayerConnected",
		"body": [
			"OnPlayerConnected"
		],
		"description": "Called on the server whenever a new player has successfully connected."
	}
,
	"Network.OnPlayerDisconnected": {
		"prefix": "Network.OnPlayerDisconnected",
		"body": [
			"OnPlayerDisconnected"
		],
		"description": "Called on the server whenever a player is disconnected from the server."
	}
,
	"Network.OnSerializeNetworkView": {
		"prefix": "Network.OnSerializeNetworkView",
		"body": [
			"OnSerializeNetworkView"
		],
		"description": "Used to customize synchronization of variables in a script watched by a network view."
	}
,
	"Network.OnServerInitialized": {
		"prefix": "Network.OnServerInitialized",
		"body": [
			"OnServerInitialized"
		],
		"description": "Called on the server whenever a Network.InitializeServer was invoked and has completed."
	}
,
	"NetworkView.enabled": {
		"prefix": "NetworkView.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"NetworkView.isActiveAndEnabled": {
		"prefix": "NetworkView.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"NetworkView.gameObject": {
		"prefix": "NetworkView.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"NetworkView.tag": {
		"prefix": "NetworkView.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"NetworkView.transform": {
		"prefix": "NetworkView.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"NetworkView.hideFlags": {
		"prefix": "NetworkView.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"NetworkView.name": {
		"prefix": "NetworkView.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"NetworkView.BroadcastMessage": {
		"prefix": "NetworkView.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"NetworkView.CompareTag": {
		"prefix": "NetworkView.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"NetworkView.GetComponent": {
		"prefix": "NetworkView.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"NetworkView.GetComponentInChildren": {
		"prefix": "NetworkView.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"NetworkView.GetComponentInParent": {
		"prefix": "NetworkView.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"NetworkView.GetComponents": {
		"prefix": "NetworkView.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"NetworkView.GetComponentsInChildren": {
		"prefix": "NetworkView.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"NetworkView.GetComponentsInParent": {
		"prefix": "NetworkView.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"NetworkView.SendMessage": {
		"prefix": "NetworkView.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"NetworkView.SendMessageUpwards": {
		"prefix": "NetworkView.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"NetworkView.GetInstanceID": {
		"prefix": "NetworkView.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"NetworkView.ToString": {
		"prefix": "NetworkView.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"NetworkView.Destroy": {
		"prefix": "NetworkView.Destroy",
		"body": [
			"NetworkView.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"NetworkView.DestroyImmediate": {
		"prefix": "NetworkView.DestroyImmediate",
		"body": [
			"NetworkView.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"NetworkView.DontDestroyOnLoad": {
		"prefix": "NetworkView.DontDestroyOnLoad",
		"body": [
			"NetworkView.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"NetworkView.FindObjectOfType": {
		"prefix": "NetworkView.FindObjectOfType",
		"body": [
			"NetworkView.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"NetworkView.FindObjectsOfType": {
		"prefix": "NetworkView.FindObjectsOfType",
		"body": [
			"NetworkView.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"NetworkView.Instantiate": {
		"prefix": "NetworkView.Instantiate",
		"body": [
			"NetworkView.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"Object.hideFlags": {
		"prefix": "Object.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Object.name": {
		"prefix": "Object.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Object.GetInstanceID": {
		"prefix": "Object.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Object.ToString": {
		"prefix": "Object.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Object.Destroy": {
		"prefix": "Object.Destroy",
		"body": [
			"Object.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Object.DestroyImmediate": {
		"prefix": "Object.DestroyImmediate",
		"body": [
			"Object.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Object.DontDestroyOnLoad": {
		"prefix": "Object.DontDestroyOnLoad",
		"body": [
			"Object.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Object.FindObjectOfType": {
		"prefix": "Object.FindObjectOfType",
		"body": [
			"Object.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Object.FindObjectsOfType": {
		"prefix": "Object.FindObjectsOfType",
		"body": [
			"Object.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Object.Instantiate": {
		"prefix": "Object.Instantiate",
		"body": [
			"Object.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"OcclusionArea.center": {
		"prefix": "OcclusionArea.center",
		"body": [
			"center"
		],
		"description": "return:Vector3 des: Center of the occlusion area relative to the transform."
	}
,
	"OcclusionArea.size": {
		"prefix": "OcclusionArea.size",
		"body": [
			"size"
		],
		"description": "return:Vector3 des: Size that the occlusion area will have."
	}
,
	"OcclusionArea.gameObject": {
		"prefix": "OcclusionArea.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"OcclusionArea.tag": {
		"prefix": "OcclusionArea.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"OcclusionArea.transform": {
		"prefix": "OcclusionArea.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"OcclusionArea.hideFlags": {
		"prefix": "OcclusionArea.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"OcclusionArea.name": {
		"prefix": "OcclusionArea.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"OcclusionArea.BroadcastMessage": {
		"prefix": "OcclusionArea.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"OcclusionArea.CompareTag": {
		"prefix": "OcclusionArea.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"OcclusionArea.GetComponent": {
		"prefix": "OcclusionArea.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"OcclusionArea.GetComponentInChildren": {
		"prefix": "OcclusionArea.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"OcclusionArea.GetComponentInParent": {
		"prefix": "OcclusionArea.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"OcclusionArea.GetComponents": {
		"prefix": "OcclusionArea.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"OcclusionArea.GetComponentsInChildren": {
		"prefix": "OcclusionArea.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"OcclusionArea.GetComponentsInParent": {
		"prefix": "OcclusionArea.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"OcclusionArea.SendMessage": {
		"prefix": "OcclusionArea.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"OcclusionArea.SendMessageUpwards": {
		"prefix": "OcclusionArea.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"OcclusionArea.GetInstanceID": {
		"prefix": "OcclusionArea.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"OcclusionArea.ToString": {
		"prefix": "OcclusionArea.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"OcclusionArea.Destroy": {
		"prefix": "OcclusionArea.Destroy",
		"body": [
			"OcclusionArea.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"OcclusionArea.DestroyImmediate": {
		"prefix": "OcclusionArea.DestroyImmediate",
		"body": [
			"OcclusionArea.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"OcclusionArea.DontDestroyOnLoad": {
		"prefix": "OcclusionArea.DontDestroyOnLoad",
		"body": [
			"OcclusionArea.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"OcclusionArea.FindObjectOfType": {
		"prefix": "OcclusionArea.FindObjectOfType",
		"body": [
			"OcclusionArea.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"OcclusionArea.FindObjectsOfType": {
		"prefix": "OcclusionArea.FindObjectsOfType",
		"body": [
			"OcclusionArea.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"OcclusionArea.Instantiate": {
		"prefix": "OcclusionArea.Instantiate",
		"body": [
			"OcclusionArea.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"OcclusionPortal.open": {
		"prefix": "OcclusionPortal.open",
		"body": [
			"open"
		],
		"description": "return:bool des: Gets / sets the portal's open state."
	}
,
	"OcclusionPortal.gameObject": {
		"prefix": "OcclusionPortal.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"OcclusionPortal.tag": {
		"prefix": "OcclusionPortal.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"OcclusionPortal.transform": {
		"prefix": "OcclusionPortal.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"OcclusionPortal.hideFlags": {
		"prefix": "OcclusionPortal.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"OcclusionPortal.name": {
		"prefix": "OcclusionPortal.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"OcclusionPortal.BroadcastMessage": {
		"prefix": "OcclusionPortal.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"OcclusionPortal.CompareTag": {
		"prefix": "OcclusionPortal.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"OcclusionPortal.GetComponent": {
		"prefix": "OcclusionPortal.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"OcclusionPortal.GetComponentInChildren": {
		"prefix": "OcclusionPortal.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"OcclusionPortal.GetComponentInParent": {
		"prefix": "OcclusionPortal.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"OcclusionPortal.GetComponents": {
		"prefix": "OcclusionPortal.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"OcclusionPortal.GetComponentsInChildren": {
		"prefix": "OcclusionPortal.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"OcclusionPortal.GetComponentsInParent": {
		"prefix": "OcclusionPortal.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"OcclusionPortal.SendMessage": {
		"prefix": "OcclusionPortal.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"OcclusionPortal.SendMessageUpwards": {
		"prefix": "OcclusionPortal.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"OcclusionPortal.GetInstanceID": {
		"prefix": "OcclusionPortal.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"OcclusionPortal.ToString": {
		"prefix": "OcclusionPortal.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"OcclusionPortal.Destroy": {
		"prefix": "OcclusionPortal.Destroy",
		"body": [
			"OcclusionPortal.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"OcclusionPortal.DestroyImmediate": {
		"prefix": "OcclusionPortal.DestroyImmediate",
		"body": [
			"OcclusionPortal.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"OcclusionPortal.DontDestroyOnLoad": {
		"prefix": "OcclusionPortal.DontDestroyOnLoad",
		"body": [
			"OcclusionPortal.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"OcclusionPortal.FindObjectOfType": {
		"prefix": "OcclusionPortal.FindObjectOfType",
		"body": [
			"OcclusionPortal.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"OcclusionPortal.FindObjectsOfType": {
		"prefix": "OcclusionPortal.FindObjectsOfType",
		"body": [
			"OcclusionPortal.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"OcclusionPortal.Instantiate": {
		"prefix": "OcclusionPortal.Instantiate",
		"body": [
			"OcclusionPortal.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"ParticleAnimator.gameObject": {
		"prefix": "ParticleAnimator.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"ParticleAnimator.tag": {
		"prefix": "ParticleAnimator.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"ParticleAnimator.transform": {
		"prefix": "ParticleAnimator.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"ParticleAnimator.hideFlags": {
		"prefix": "ParticleAnimator.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"ParticleAnimator.name": {
		"prefix": "ParticleAnimator.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"ParticleAnimator.BroadcastMessage": {
		"prefix": "ParticleAnimator.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"ParticleAnimator.CompareTag": {
		"prefix": "ParticleAnimator.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"ParticleAnimator.GetComponent": {
		"prefix": "ParticleAnimator.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"ParticleAnimator.GetComponentInChildren": {
		"prefix": "ParticleAnimator.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"ParticleAnimator.GetComponentInParent": {
		"prefix": "ParticleAnimator.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"ParticleAnimator.GetComponents": {
		"prefix": "ParticleAnimator.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"ParticleAnimator.GetComponentsInChildren": {
		"prefix": "ParticleAnimator.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"ParticleAnimator.GetComponentsInParent": {
		"prefix": "ParticleAnimator.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"ParticleAnimator.SendMessage": {
		"prefix": "ParticleAnimator.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"ParticleAnimator.SendMessageUpwards": {
		"prefix": "ParticleAnimator.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"ParticleAnimator.GetInstanceID": {
		"prefix": "ParticleAnimator.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"ParticleAnimator.ToString": {
		"prefix": "ParticleAnimator.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"ParticleAnimator.Destroy": {
		"prefix": "ParticleAnimator.Destroy",
		"body": [
			"ParticleAnimator.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"ParticleAnimator.DestroyImmediate": {
		"prefix": "ParticleAnimator.DestroyImmediate",
		"body": [
			"ParticleAnimator.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"ParticleAnimator.DontDestroyOnLoad": {
		"prefix": "ParticleAnimator.DontDestroyOnLoad",
		"body": [
			"ParticleAnimator.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"ParticleAnimator.FindObjectOfType": {
		"prefix": "ParticleAnimator.FindObjectOfType",
		"body": [
			"ParticleAnimator.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"ParticleAnimator.FindObjectsOfType": {
		"prefix": "ParticleAnimator.FindObjectsOfType",
		"body": [
			"ParticleAnimator.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"ParticleAnimator.Instantiate": {
		"prefix": "ParticleAnimator.Instantiate",
		"body": [
			"ParticleAnimator.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"ParticleCollisionEvent.colliderComponent": {
		"prefix": "ParticleCollisionEvent.colliderComponent",
		"body": [
			"colliderComponent"
		],
		"description": "return:Component des: The Collider or Collider2D for the GameObject struck by the particles."
	}
,
	"ParticleCollisionEvent.intersection": {
		"prefix": "ParticleCollisionEvent.intersection",
		"body": [
			"intersection"
		],
		"description": "return:Vector3 des: Intersection point of the collision in world coordinates."
	}
,
	"ParticleCollisionEvent.normal": {
		"prefix": "ParticleCollisionEvent.normal",
		"body": [
			"normal"
		],
		"description": "return:Vector3 des: Geometry normal at the intersection point of the collision."
	}
,
	"ParticleCollisionEvent.velocity": {
		"prefix": "ParticleCollisionEvent.velocity",
		"body": [
			"velocity"
		],
		"description": "return:Vector3 des: Incident velocity at the intersection point of the collision."
	}
,
	"ParticleEmitter.gameObject": {
		"prefix": "ParticleEmitter.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"ParticleEmitter.tag": {
		"prefix": "ParticleEmitter.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"ParticleEmitter.transform": {
		"prefix": "ParticleEmitter.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"ParticleEmitter.hideFlags": {
		"prefix": "ParticleEmitter.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"ParticleEmitter.name": {
		"prefix": "ParticleEmitter.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"ParticleEmitter.BroadcastMessage": {
		"prefix": "ParticleEmitter.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"ParticleEmitter.CompareTag": {
		"prefix": "ParticleEmitter.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"ParticleEmitter.GetComponent": {
		"prefix": "ParticleEmitter.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"ParticleEmitter.GetComponentInChildren": {
		"prefix": "ParticleEmitter.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"ParticleEmitter.GetComponentInParent": {
		"prefix": "ParticleEmitter.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"ParticleEmitter.GetComponents": {
		"prefix": "ParticleEmitter.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"ParticleEmitter.GetComponentsInChildren": {
		"prefix": "ParticleEmitter.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"ParticleEmitter.GetComponentsInParent": {
		"prefix": "ParticleEmitter.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"ParticleEmitter.SendMessage": {
		"prefix": "ParticleEmitter.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"ParticleEmitter.SendMessageUpwards": {
		"prefix": "ParticleEmitter.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"ParticleEmitter.GetInstanceID": {
		"prefix": "ParticleEmitter.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"ParticleEmitter.ToString": {
		"prefix": "ParticleEmitter.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"ParticleEmitter.Destroy": {
		"prefix": "ParticleEmitter.Destroy",
		"body": [
			"ParticleEmitter.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"ParticleEmitter.DestroyImmediate": {
		"prefix": "ParticleEmitter.DestroyImmediate",
		"body": [
			"ParticleEmitter.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"ParticleEmitter.DontDestroyOnLoad": {
		"prefix": "ParticleEmitter.DontDestroyOnLoad",
		"body": [
			"ParticleEmitter.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"ParticleEmitter.FindObjectOfType": {
		"prefix": "ParticleEmitter.FindObjectOfType",
		"body": [
			"ParticleEmitter.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"ParticleEmitter.FindObjectsOfType": {
		"prefix": "ParticleEmitter.FindObjectsOfType",
		"body": [
			"ParticleEmitter.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"ParticleEmitter.Instantiate": {
		"prefix": "ParticleEmitter.Instantiate",
		"body": [
			"ParticleEmitter.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"ParticlePhysicsExtensions.GetCollisionEvents": {
		"prefix": "ParticlePhysicsExtensions.GetCollisionEvents",
		"body": [
			"ParticlePhysicsExtensions.GetCollisionEvents"
		],
		"description": "Obsolete public static int GetCollisionEvents(ParticleSystem ps, GameObject go, ParticleCollisionEvent[] collisionEvents); des: Get the particle collision events for a GameObject. Returns the number of events written to the array."
	}
,
	"ParticlePhysicsExtensions.GetSafeCollisionEventSize": {
		"prefix": "ParticlePhysicsExtensions.GetSafeCollisionEventSize",
		"body": [
			"ParticlePhysicsExtensions.GetSafeCollisionEventSize"
		],
		"description": "public static int GetSafeCollisionEventSize(ParticleSystem ps); des: Safe array size for use with ParticleSystem.GetCollisionEvents."
	}
,
	"ParticlePhysicsExtensions.GetSafeTriggerParticlesSize": {
		"prefix": "ParticlePhysicsExtensions.GetSafeTriggerParticlesSize",
		"body": [
			"ParticlePhysicsExtensions.GetSafeTriggerParticlesSize"
		],
		"description": "public static int GetSafeTriggerParticlesSize(ParticleSystem ps, ParticleSystemTriggerEventType type); des: Safe array size for use with ParticleSystem.GetTriggerParticles."
	}
,
	"ParticlePhysicsExtensions.GetTriggerParticles": {
		"prefix": "ParticlePhysicsExtensions.GetTriggerParticles",
		"body": [
			"ParticlePhysicsExtensions.GetTriggerParticles"
		],
		"description": " des: Get the particles that met the condition in the particle trigger module. Returns the number of particles written to the array."
	}
,
	"ParticlePhysicsExtensions.SetTriggerParticles": {
		"prefix": "ParticlePhysicsExtensions.SetTriggerParticles",
		"body": [
			"ParticlePhysicsExtensions.SetTriggerParticles"
		],
		"description": "  des: Write modified particles back to the particle system, during a call to OnParticleTrigger."
	}
,
	"ParticleRenderer.gameObject": {
		"prefix": "ParticleRenderer.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"ParticleRenderer.tag": {
		"prefix": "ParticleRenderer.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"ParticleRenderer.transform": {
		"prefix": "ParticleRenderer.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"ParticleRenderer.hideFlags": {
		"prefix": "ParticleRenderer.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"ParticleRenderer.name": {
		"prefix": "ParticleRenderer.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"ParticleRenderer.allowOcclusionWhenDynamic": {
		"prefix": "ParticleRenderer.allowOcclusionWhenDynamic",
		"body": [
			"allowOcclusionWhenDynamic"
		],
		"description": "return:bool des: Controls if dynamic occlusion culling should be performed for this renderer."
	}
,
	"ParticleRenderer.bounds": {
		"prefix": "ParticleRenderer.bounds",
		"body": [
			"bounds"
		],
		"description": "return:Bounds des: The bounding volume of the renderer (Read Only)."
	}
,
	"ParticleRenderer.enabled": {
		"prefix": "ParticleRenderer.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Makes the rendered 3D object visible if enabled."
	}
,
	"ParticleRenderer.isPartOfStaticBatch": {
		"prefix": "ParticleRenderer.isPartOfStaticBatch",
		"body": [
			"isPartOfStaticBatch"
		],
		"description": "return:bool des: Has this renderer been statically batched with any other renderers?"
	}
,
	"ParticleRenderer.isVisible": {
		"prefix": "ParticleRenderer.isVisible",
		"body": [
			"isVisible"
		],
		"description": "return:bool des: Is this renderer visible in any camera? (Read Only)"
	}
,
	"ParticleRenderer.lightmapIndex": {
		"prefix": "ParticleRenderer.lightmapIndex",
		"body": [
			"lightmapIndex"
		],
		"description": "return:int des: The index of the baked lightmap applied to this renderer."
	}
,
	"ParticleRenderer.lightmapScaleOffset": {
		"prefix": "ParticleRenderer.lightmapScaleOffset",
		"body": [
			"lightmapScaleOffset"
		],
		"description": "return:Vector4 des: The UV scale & offset used for a lightmap."
	}
,
	"ParticleRenderer.lightProbeProxyVolumeOverride": {
		"prefix": "ParticleRenderer.lightProbeProxyVolumeOverride",
		"body": [
			"lightProbeProxyVolumeOverride"
		],
		"description": "return:GameObject des: If set, the Renderer will use the Light Probe Proxy Volume component attached to the source GameObject."
	}
,
	"ParticleRenderer.lightProbeUsage": {
		"prefix": "ParticleRenderer.lightProbeUsage",
		"body": [
			"lightProbeUsage"
		],
		"description": "return:Rendering.LightProbeUsage des: The light probe interpolation type."
	}
,
	"ParticleRenderer.localToWorldMatrix": {
		"prefix": "ParticleRenderer.localToWorldMatrix",
		"body": [
			"localToWorldMatrix"
		],
		"description": "return:Matrix4x4 des: Matrix that transforms a point from local space into world space (Read Only)."
	}
,
	"ParticleRenderer.material": {
		"prefix": "ParticleRenderer.material",
		"body": [
			"material"
		],
		"description": "return:Material des: Returns the first instantiated Material assigned to the renderer."
	}
,
	"ParticleRenderer.materials": {
		"prefix": "ParticleRenderer.materials",
		"body": [
			"materials"
		],
		"description": "return:Material[] des: Returns all the instantiated materials of this object."
	}
,
	"ParticleRenderer.motionVectorGenerationMode": {
		"prefix": "ParticleRenderer.motionVectorGenerationMode",
		"body": [
			"motionVectorGenerationMode"
		],
		"description": "return:MotionVectorGenerationMode des: Specifies the mode for motion vector rendering."
	}
,
	"ParticleRenderer.probeAnchor": {
		"prefix": "ParticleRenderer.probeAnchor",
		"body": [
			"probeAnchor"
		],
		"description": "return:Transform des: If set, Renderer will use this Transform's position to find the light or reflection probe."
	}
,
	"ParticleRenderer.realtimeLightmapIndex": {
		"prefix": "ParticleRenderer.realtimeLightmapIndex",
		"body": [
			"realtimeLightmapIndex"
		],
		"description": "return:int des: The index of the realtime lightmap applied to this renderer."
	}
,
	"ParticleRenderer.realtimeLightmapScaleOffset": {
		"prefix": "ParticleRenderer.realtimeLightmapScaleOffset",
		"body": [
			"realtimeLightmapScaleOffset"
		],
		"description": "return:Vector4 des: The UV scale & offset used for a realtime lightmap."
	}
,
	"ParticleRenderer.receiveShadows": {
		"prefix": "ParticleRenderer.receiveShadows",
		"body": [
			"receiveShadows"
		],
		"description": "return:bool des: Does this object receive shadows?"
	}
,
	"ParticleRenderer.reflectionProbeUsage": {
		"prefix": "ParticleRenderer.reflectionProbeUsage",
		"body": [
			"reflectionProbeUsage"
		],
		"description": "return:Rendering.ReflectionProbeUsage des: Should reflection probes be used for this Renderer?"
	}
,
	"ParticleRenderer.renderingLayerMask": {
		"prefix": "ParticleRenderer.renderingLayerMask",
		"body": [
			"renderingLayerMask"
		],
		"description": "return:uint des: Determines which rendering layer this renderer lives on."
	}
,
	"ParticleRenderer.shadowCastingMode": {
		"prefix": "ParticleRenderer.shadowCastingMode",
		"body": [
			"shadowCastingMode"
		],
		"description": "return:Rendering.ShadowCastingMode des: Does this object cast shadows?"
	}
,
	"ParticleRenderer.sharedMaterial": {
		"prefix": "ParticleRenderer.sharedMaterial",
		"body": [
			"sharedMaterial"
		],
		"description": "return:Material des: The shared material of this object."
	}
,
	"ParticleRenderer.sharedMaterials": {
		"prefix": "ParticleRenderer.sharedMaterials",
		"body": [
			"sharedMaterials"
		],
		"description": "return:Material[] des: All the shared materials of this object."
	}
,
	"ParticleRenderer.sortingLayerID": {
		"prefix": "ParticleRenderer.sortingLayerID",
		"body": [
			"sortingLayerID"
		],
		"description": "return:int des: Unique ID of the Renderer's sorting layer."
	}
,
	"ParticleRenderer.sortingLayerName": {
		"prefix": "ParticleRenderer.sortingLayerName",
		"body": [
			"sortingLayerName"
		],
		"description": "return:string des: Name of the Renderer's sorting layer."
	}
,
	"ParticleRenderer.sortingOrder": {
		"prefix": "ParticleRenderer.sortingOrder",
		"body": [
			"sortingOrder"
		],
		"description": "return:int des: Renderer's order within a sorting layer."
	}
,
	"ParticleRenderer.worldToLocalMatrix": {
		"prefix": "ParticleRenderer.worldToLocalMatrix",
		"body": [
			"worldToLocalMatrix"
		],
		"description": "return:Matrix4x4 des: Matrix that transforms a point from world space into local space (Read Only)."
	}
,
	"ParticleRenderer.BroadcastMessage": {
		"prefix": "ParticleRenderer.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"ParticleRenderer.CompareTag": {
		"prefix": "ParticleRenderer.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"ParticleRenderer.GetComponent": {
		"prefix": "ParticleRenderer.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"ParticleRenderer.GetComponentInChildren": {
		"prefix": "ParticleRenderer.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"ParticleRenderer.GetComponentInParent": {
		"prefix": "ParticleRenderer.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"ParticleRenderer.GetComponents": {
		"prefix": "ParticleRenderer.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"ParticleRenderer.GetComponentsInChildren": {
		"prefix": "ParticleRenderer.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"ParticleRenderer.GetComponentsInParent": {
		"prefix": "ParticleRenderer.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"ParticleRenderer.SendMessage": {
		"prefix": "ParticleRenderer.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"ParticleRenderer.SendMessageUpwards": {
		"prefix": "ParticleRenderer.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"ParticleRenderer.GetInstanceID": {
		"prefix": "ParticleRenderer.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"ParticleRenderer.ToString": {
		"prefix": "ParticleRenderer.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"ParticleRenderer.GetClosestReflectionProbes": {
		"prefix": "ParticleRenderer.GetClosestReflectionProbes",
		"body": [
			"GetClosestReflectionProbes($1)"
		],
		"description": "public void GetClosestReflectionProbes(List<ReflectionProbeBlendInfo> result); des: Returns an array of closest reflection probes with weights, weight shows how much influence the probe has on the renderer, this value is also used when blending between reflection probes occur."
	}
,
	"ParticleRenderer.GetMaterials": {
		"prefix": "ParticleRenderer.GetMaterials",
		"body": [
			"GetMaterials($1)"
		],
		"description": "public void GetMaterials(List<Material> m); des: Returns all the instantiated materials of this object."
	}
,
	"ParticleRenderer.GetPropertyBlock": {
		"prefix": "ParticleRenderer.GetPropertyBlock",
		"body": [
			"GetPropertyBlock($1)"
		],
		"description": "public void GetPropertyBlock(MaterialPropertyBlock properties); public void GetPropertyBlock(MaterialPropertyBlock properties, int materialIndex); des: Get per-Renderer or per-Material property block."
	}
,
	"ParticleRenderer.GetSharedMaterials": {
		"prefix": "ParticleRenderer.GetSharedMaterials",
		"body": [
			"GetSharedMaterials($1)"
		],
		"description": "public void GetSharedMaterials(List<Material> m); des: Returns all the shared materials of this object."
	}
,
	"ParticleRenderer.HasPropertyBlock": {
		"prefix": "ParticleRenderer.HasPropertyBlock",
		"body": [
			"HasPropertyBlock($1)"
		],
		"description": "public bool HasPropertyBlock(); des: Returns true if the Renderer has a material property block attached via SetPropertyBlock."
	}
,
	"ParticleRenderer.SetPropertyBlock": {
		"prefix": "ParticleRenderer.SetPropertyBlock",
		"body": [
			"SetPropertyBlock($1)"
		],
		"description": "public void SetPropertyBlock(MaterialPropertyBlock properties); public void SetPropertyBlock(MaterialPropertyBlock properties, int materialIndex); des: Lets you set or clear per-renderer or per-material parameter overrides."
	}
,
	"ParticleRenderer.Destroy": {
		"prefix": "ParticleRenderer.Destroy",
		"body": [
			"ParticleRenderer.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"ParticleRenderer.DestroyImmediate": {
		"prefix": "ParticleRenderer.DestroyImmediate",
		"body": [
			"ParticleRenderer.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"ParticleRenderer.DontDestroyOnLoad": {
		"prefix": "ParticleRenderer.DontDestroyOnLoad",
		"body": [
			"ParticleRenderer.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"ParticleRenderer.FindObjectOfType": {
		"prefix": "ParticleRenderer.FindObjectOfType",
		"body": [
			"ParticleRenderer.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"ParticleRenderer.FindObjectsOfType": {
		"prefix": "ParticleRenderer.FindObjectsOfType",
		"body": [
			"ParticleRenderer.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"ParticleRenderer.Instantiate": {
		"prefix": "ParticleRenderer.Instantiate",
		"body": [
			"ParticleRenderer.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"ParticleRenderer.OnBecameInvisible": {
		"prefix": "ParticleRenderer.OnBecameInvisible",
		"body": [
			"OnBecameInvisible"
		],
		"description": "OnBecameInvisible is called when the object is no longer visible by any camera."
	}
,
	"ParticleRenderer.OnBecameVisible": {
		"prefix": "ParticleRenderer.OnBecameVisible",
		"body": [
			"OnBecameVisible"
		],
		"description": "OnBecameVisible is called when the object became visible by any camera."
	}
,
	"ParticleSystem.automaticCullingEnabled": {
		"prefix": "ParticleSystem.automaticCullingEnabled",
		"body": [
			"automaticCullingEnabled"
		],
		"description": "return:bool des: Does this system support Automatic Culling?"
	}
,
	"ParticleSystem.collision": {
		"prefix": "ParticleSystem.collision",
		"body": [
			"collision"
		],
		"description": "return:ParticleSystem.CollisionModule des: Access the particle system collision module."
	}
,
	"ParticleSystem.colorBySpeed": {
		"prefix": "ParticleSystem.colorBySpeed",
		"body": [
			"colorBySpeed"
		],
		"description": "return:ParticleSystem.ColorBySpeedModule des: Access the particle system color by lifetime module."
	}
,
	"ParticleSystem.colorOverLifetime": {
		"prefix": "ParticleSystem.colorOverLifetime",
		"body": [
			"colorOverLifetime"
		],
		"description": "return:ParticleSystem.ColorOverLifetimeModule des: Access the particle system color over lifetime module."
	}
,
	"ParticleSystem.customData": {
		"prefix": "ParticleSystem.customData",
		"body": [
			"customData"
		],
		"description": "return:ParticleSystem.CustomDataModule des: Access the particle system Custom Data module."
	}
,
	"ParticleSystem.emission": {
		"prefix": "ParticleSystem.emission",
		"body": [
			"emission"
		],
		"description": "return:ParticleSystem.EmissionModule des: Access the particle system emission module."
	}
,
	"ParticleSystem.externalForces": {
		"prefix": "ParticleSystem.externalForces",
		"body": [
			"externalForces"
		],
		"description": "return:ParticleSystem.ExternalForcesModule des: Access the particle system external forces module."
	}
,
	"ParticleSystem.forceOverLifetime": {
		"prefix": "ParticleSystem.forceOverLifetime",
		"body": [
			"forceOverLifetime"
		],
		"description": "return:ParticleSystem.ForceOverLifetimeModule des: Access the particle system force over lifetime module."
	}
,
	"ParticleSystem.inheritVelocity": {
		"prefix": "ParticleSystem.inheritVelocity",
		"body": [
			"inheritVelocity"
		],
		"description": "return:ParticleSystem.InheritVelocityModule des: Access the particle system velocity inheritance module."
	}
,
	"ParticleSystem.isEmitting": {
		"prefix": "ParticleSystem.isEmitting",
		"body": [
			"isEmitting"
		],
		"description": "return:bool des: Is the Particle System currently emitting particles? A Particle System may stop emitting when its emission module has finished, it has been paused or if the system has been stopped using Stop with the StopEmitting flag. Resume emitting by calling Play."
	}
,
	"ParticleSystem.isPaused": {
		"prefix": "ParticleSystem.isPaused",
		"body": [
			"isPaused"
		],
		"description": "return:bool des: Is the Particle System paused right now?"
	}
,
	"ParticleSystem.isPlaying": {
		"prefix": "ParticleSystem.isPlaying",
		"body": [
			"isPlaying"
		],
		"description": "return:bool des: Is the Particle System playing right now?"
	}
,
	"ParticleSystem.isStopped": {
		"prefix": "ParticleSystem.isStopped",
		"body": [
			"isStopped"
		],
		"description": "return:bool des: Is the Particle System stopped right now?"
	}
,
	"ParticleSystem.lights": {
		"prefix": "ParticleSystem.lights",
		"body": [
			"lights"
		],
		"description": "return:ParticleSystem.LightsModule des: Access the particle system lights module."
	}
,
	"ParticleSystem.limitVelocityOverLifetime": {
		"prefix": "ParticleSystem.limitVelocityOverLifetime",
		"body": [
			"limitVelocityOverLifetime"
		],
		"description": "return:ParticleSystem.LimitVelocityOverLifetimeModule des: Access the particle system limit velocity over lifetime module."
	}
,
	"ParticleSystem.main": {
		"prefix": "ParticleSystem.main",
		"body": [
			"main"
		],
		"description": "return:ParticleSystem.MainModule des: Access the main particle system settings."
	}
,
	"ParticleSystem.noise": {
		"prefix": "ParticleSystem.noise",
		"body": [
			"noise"
		],
		"description": "return:ParticleSystem.NoiseModule des: Access the particle system noise module."
	}
,
	"ParticleSystem.particleCount": {
		"prefix": "ParticleSystem.particleCount",
		"body": [
			"particleCount"
		],
		"description": "return:int des: The current number of particles (Read Only)."
	}
,
	"ParticleSystem.randomSeed": {
		"prefix": "ParticleSystem.randomSeed",
		"body": [
			"randomSeed"
		],
		"description": "return:uint des: Override the random seed used for the particle system emission."
	}
,
	"ParticleSystem.rotationBySpeed": {
		"prefix": "ParticleSystem.rotationBySpeed",
		"body": [
			"rotationBySpeed"
		],
		"description": "return:ParticleSystem.RotationBySpeedModule des: Access the particle system rotation by speed module."
	}
,
	"ParticleSystem.rotationOverLifetime": {
		"prefix": "ParticleSystem.rotationOverLifetime",
		"body": [
			"rotationOverLifetime"
		],
		"description": "return:ParticleSystem.RotationOverLifetimeModule des: Access the particle system rotation over lifetime module."
	}
,
	"ParticleSystem.shape": {
		"prefix": "ParticleSystem.shape",
		"body": [
			"shape"
		],
		"description": "return:ParticleSystem.ShapeModule des: Access the particle system shape module."
	}
,
	"ParticleSystem.sizeBySpeed": {
		"prefix": "ParticleSystem.sizeBySpeed",
		"body": [
			"sizeBySpeed"
		],
		"description": "return:ParticleSystem.SizeBySpeedModule des: Access the particle system size by speed module."
	}
,
	"ParticleSystem.sizeOverLifetime": {
		"prefix": "ParticleSystem.sizeOverLifetime",
		"body": [
			"sizeOverLifetime"
		],
		"description": "return:ParticleSystem.SizeOverLifetimeModule des: Access the particle system size over lifetime module."
	}
,
	"ParticleSystem.subEmitters": {
		"prefix": "ParticleSystem.subEmitters",
		"body": [
			"subEmitters"
		],
		"description": "return:ParticleSystem.SubEmittersModule des: Access the particle system sub emitters module."
	}
,
	"ParticleSystem.textureSheetAnimation": {
		"prefix": "ParticleSystem.textureSheetAnimation",
		"body": [
			"textureSheetAnimation"
		],
		"description": "return:ParticleSystem.TextureSheetAnimationModule des: Access the particle system texture sheet animation module."
	}
,
	"ParticleSystem.time": {
		"prefix": "ParticleSystem.time",
		"body": [
			"time"
		],
		"description": "return:float des: Playback position in seconds."
	}
,
	"ParticleSystem.trails": {
		"prefix": "ParticleSystem.trails",
		"body": [
			"trails"
		],
		"description": "return:ParticleSystem.TrailModule des: Access the particle system trails module."
	}
,
	"ParticleSystem.trigger": {
		"prefix": "ParticleSystem.trigger",
		"body": [
			"trigger"
		],
		"description": "return:ParticleSystem.TriggerModule des: Access the particle system trigger module."
	}
,
	"ParticleSystem.useAutoRandomSeed": {
		"prefix": "ParticleSystem.useAutoRandomSeed",
		"body": [
			"useAutoRandomSeed"
		],
		"description": "return:bool des: Controls whether the Particle System uses an automatically-generated random number to seed the random number generator."
	}
,
	"ParticleSystem.velocityOverLifetime": {
		"prefix": "ParticleSystem.velocityOverLifetime",
		"body": [
			"velocityOverLifetime"
		],
		"description": "return:ParticleSystem.VelocityOverLifetimeModule des: Access the particle system velocity over lifetime module."
	}
,
	"ParticleSystem.Clear": {
		"prefix": "ParticleSystem.Clear",
		"body": [
			"Clear($1)"
		],
		"description": "public void Clear(bool withChildren = true); des: Remove all particles in the particle system."
	}
,
	"ParticleSystem.Emit": {
		"prefix": "ParticleSystem.Emit",
		"body": [
			"Emit($1)"
		],
		"description": "public void Emit(int count); public void Emit(ParticleSystem.EmitParams emitParams, int count); des: Emit count particles immediately."
	}
,
	"ParticleSystem.GetCustomParticleData": {
		"prefix": "ParticleSystem.GetCustomParticleData",
		"body": [
			"GetCustomParticleData($1)"
		],
		"description": "public int GetCustomParticleData(List<Vector4> customData, ParticleSystemCustomData streamIndex); des: Get a stream of custom per-particle data."
	}
,
	"ParticleSystem.GetParticles": {
		"prefix": "ParticleSystem.GetParticles",
		"body": [
			"GetParticles($1)"
		],
		"description": "public int GetParticles(Particle[] particles); des: Gets the particles of this particle system."
	}
,
	"ParticleSystem.IsAlive": {
		"prefix": "ParticleSystem.IsAlive",
		"body": [
			"IsAlive($1)"
		],
		"description": "public bool IsAlive(bool withChildren = true); des: Does the system contain any live particles, or will it produce more?"
	}
,
	"ParticleSystem.Pause": {
		"prefix": "ParticleSystem.Pause",
		"body": [
			"Pause($1)"
		],
		"description": "public void Pause(bool withChildren = true); des: Pauses the system so no new particles are emitted and the existing particles are not updated."
	}
,
	"ParticleSystem.Play": {
		"prefix": "ParticleSystem.Play",
		"body": [
			"Play($1)"
		],
		"description": "public void Play(bool withChildren = true); des: Starts the particle system."
	}
,
	"ParticleSystem.SetCustomParticleData": {
		"prefix": "ParticleSystem.SetCustomParticleData",
		"body": [
			"SetCustomParticleData($1)"
		],
		"description": "public void SetCustomParticleData(List<Vector4> customData, ParticleSystemCustomData streamIndex); des: Set a stream of custom per-particle data."
	}
,
	"ParticleSystem.SetParticles": {
		"prefix": "ParticleSystem.SetParticles",
		"body": [
			"SetParticles($1)"
		],
		"description": "public void SetParticles(Particle[] particles, int size); des: Sets the particles of this particle system."
	}
,
	"ParticleSystem.Simulate": {
		"prefix": "ParticleSystem.Simulate",
		"body": [
			"Simulate($1)"
		],
		"description": "public void Simulate(float t, bool withChildren = true, bool restart = true, bool fixedTimeStep = true); des: Fastforwards the particle system by simulating particles over given period of time, then pauses it."
	}
,
	"ParticleSystem.Stop": {
		"prefix": "ParticleSystem.Stop",
		"body": [
			"Stop($1)"
		],
		"description": "public void Stop(bool withChildren = true, ParticleSystemStopBehavior stopBehavior = ParticleSystemStopBehavior.StopEmitting); des: Stops playing the particle system using the supplied stop behaviour."
	}
,
	"ParticleSystem.TriggerSubEmitter": {
		"prefix": "ParticleSystem.TriggerSubEmitter",
		"body": [
			"TriggerSubEmitter($1)"
		],
		"description": "public void TriggerSubEmitter(int subEmitterIndex); public void TriggerSubEmitter(int subEmitterIndex, ref ParticleSystem.Particle particle); public void TriggerSubEmitter(int subEmitterIndex, List<Particle> particles); des: Triggers the specified sub emitter on all particles of the Particle System."
	}
,
	"ParticleSystem.gameObject": {
		"prefix": "ParticleSystem.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"ParticleSystem.tag": {
		"prefix": "ParticleSystem.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"ParticleSystem.transform": {
		"prefix": "ParticleSystem.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"ParticleSystem.hideFlags": {
		"prefix": "ParticleSystem.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"ParticleSystem.name": {
		"prefix": "ParticleSystem.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"ParticleSystem.BroadcastMessage": {
		"prefix": "ParticleSystem.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"ParticleSystem.CompareTag": {
		"prefix": "ParticleSystem.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"ParticleSystem.GetComponent": {
		"prefix": "ParticleSystem.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"ParticleSystem.GetComponentInChildren": {
		"prefix": "ParticleSystem.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"ParticleSystem.GetComponentInParent": {
		"prefix": "ParticleSystem.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"ParticleSystem.GetComponents": {
		"prefix": "ParticleSystem.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"ParticleSystem.GetComponentsInChildren": {
		"prefix": "ParticleSystem.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"ParticleSystem.GetComponentsInParent": {
		"prefix": "ParticleSystem.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"ParticleSystem.SendMessage": {
		"prefix": "ParticleSystem.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"ParticleSystem.SendMessageUpwards": {
		"prefix": "ParticleSystem.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"ParticleSystem.GetInstanceID": {
		"prefix": "ParticleSystem.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"ParticleSystem.ToString": {
		"prefix": "ParticleSystem.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"ParticleSystem.Destroy": {
		"prefix": "ParticleSystem.Destroy",
		"body": [
			"ParticleSystem.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"ParticleSystem.DestroyImmediate": {
		"prefix": "ParticleSystem.DestroyImmediate",
		"body": [
			"ParticleSystem.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"ParticleSystem.DontDestroyOnLoad": {
		"prefix": "ParticleSystem.DontDestroyOnLoad",
		"body": [
			"ParticleSystem.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"ParticleSystem.FindObjectOfType": {
		"prefix": "ParticleSystem.FindObjectOfType",
		"body": [
			"ParticleSystem.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"ParticleSystem.FindObjectsOfType": {
		"prefix": "ParticleSystem.FindObjectsOfType",
		"body": [
			"ParticleSystem.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"ParticleSystem.Instantiate": {
		"prefix": "ParticleSystem.Instantiate",
		"body": [
			"ParticleSystem.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"ParticleSystem.Burst.count": {
		"prefix": "ParticleSystem.Burst.count",
		"body": [
			"count"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Number of particles to be emitted."
	}
,
	"ParticleSystem.Burst.cycleCount": {
		"prefix": "ParticleSystem.Burst.cycleCount",
		"body": [
			"cycleCount"
		],
		"description": "return:int des: How many times to play the burst. (0 means infinitely)."
	}
,
	"ParticleSystem.Burst.maxCount": {
		"prefix": "ParticleSystem.Burst.maxCount",
		"body": [
			"maxCount"
		],
		"description": "return:short des: Maximum number of particles to be emitted."
	}
,
	"ParticleSystem.Burst.minCount": {
		"prefix": "ParticleSystem.Burst.minCount",
		"body": [
			"minCount"
		],
		"description": "return:short des: Minimum number of particles to be emitted."
	}
,
	"ParticleSystem.Burst.repeatInterval": {
		"prefix": "ParticleSystem.Burst.repeatInterval",
		"body": [
			"repeatInterval"
		],
		"description": "return:float des: How often to repeat the burst, in seconds."
	}
,
	"ParticleSystem.Burst.time": {
		"prefix": "ParticleSystem.Burst.time",
		"body": [
			"time"
		],
		"description": "return:float des: The time that each burst occurs."
	}
,
	"ParticleSystem.CollisionModule.bounce": {
		"prefix": "ParticleSystem.CollisionModule.bounce",
		"body": [
			"bounce"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: How much force is applied to each particle after a collision."
	}
,
	"ParticleSystem.CollisionModule.bounceMultiplier": {
		"prefix": "ParticleSystem.CollisionModule.bounceMultiplier",
		"body": [
			"bounceMultiplier"
		],
		"description": "return:float des: Change the bounce multiplier."
	}
,
	"ParticleSystem.CollisionModule.colliderForce": {
		"prefix": "ParticleSystem.CollisionModule.colliderForce",
		"body": [
			"colliderForce"
		],
		"description": "return:float des: How much force is applied to a Collider when hit by particles from this Particle System."
	}
,
	"ParticleSystem.CollisionModule.collidesWith": {
		"prefix": "ParticleSystem.CollisionModule.collidesWith",
		"body": [
			"collidesWith"
		],
		"description": "return:LayerMask des: Control which layers this particle system collides with."
	}
,
	"ParticleSystem.CollisionModule.dampen": {
		"prefix": "ParticleSystem.CollisionModule.dampen",
		"body": [
			"dampen"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: How much speed is lost from each particle after a collision."
	}
,
	"ParticleSystem.CollisionModule.dampenMultiplier": {
		"prefix": "ParticleSystem.CollisionModule.dampenMultiplier",
		"body": [
			"dampenMultiplier"
		],
		"description": "return:float des: Change the dampen multiplier."
	}
,
	"ParticleSystem.CollisionModule.enabled": {
		"prefix": "ParticleSystem.CollisionModule.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enable/disable the Collision module."
	}
,
	"ParticleSystem.CollisionModule.enableDynamicColliders": {
		"prefix": "ParticleSystem.CollisionModule.enableDynamicColliders",
		"body": [
			"enableDynamicColliders"
		],
		"description": "return:bool des: Allow particles to collide with dynamic colliders when using world collision mode."
	}
,
	"ParticleSystem.CollisionModule.lifetimeLoss": {
		"prefix": "ParticleSystem.CollisionModule.lifetimeLoss",
		"body": [
			"lifetimeLoss"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: How much a particle's lifetime is reduced after a collision."
	}
,
	"ParticleSystem.CollisionModule.lifetimeLossMultiplier": {
		"prefix": "ParticleSystem.CollisionModule.lifetimeLossMultiplier",
		"body": [
			"lifetimeLossMultiplier"
		],
		"description": "return:float des: Change the lifetime loss multiplier."
	}
,
	"ParticleSystem.CollisionModule.maxCollisionShapes": {
		"prefix": "ParticleSystem.CollisionModule.maxCollisionShapes",
		"body": [
			"maxCollisionShapes"
		],
		"description": "return:int des: The maximum number of collision shapes that will be considered for particle collisions. Excess shapes will be ignored. Terrains take priority."
	}
,
	"ParticleSystem.CollisionModule.maxKillSpeed": {
		"prefix": "ParticleSystem.CollisionModule.maxKillSpeed",
		"body": [
			"maxKillSpeed"
		],
		"description": "return:float des: Kill particles whose speed goes above this threshold, after a collision."
	}
,
	"ParticleSystem.CollisionModule.maxPlaneCount": {
		"prefix": "ParticleSystem.CollisionModule.maxPlaneCount",
		"body": [
			"maxPlaneCount"
		],
		"description": "return:int des: The maximum number of planes it is possible to set as colliders."
	}
,
	"ParticleSystem.CollisionModule.minKillSpeed": {
		"prefix": "ParticleSystem.CollisionModule.minKillSpeed",
		"body": [
			"minKillSpeed"
		],
		"description": "return:float des: Kill particles whose speed falls below this threshold, after a collision."
	}
,
	"ParticleSystem.CollisionModule.mode": {
		"prefix": "ParticleSystem.CollisionModule.mode",
		"body": [
			"mode"
		],
		"description": "return:ParticleSystemCollisionMode des: Choose between 2D and 3D world collisions."
	}
,
	"ParticleSystem.CollisionModule.multiplyColliderForceByCollisionAngle": {
		"prefix": "ParticleSystem.CollisionModule.multiplyColliderForceByCollisionAngle",
		"body": [
			"multiplyColliderForceByCollisionAngle"
		],
		"description": "return:bool des: If true, the collision angle is considered when applying forces from particles to Colliders."
	}
,
	"ParticleSystem.CollisionModule.multiplyColliderForceByParticleSize": {
		"prefix": "ParticleSystem.CollisionModule.multiplyColliderForceByParticleSize",
		"body": [
			"multiplyColliderForceByParticleSize"
		],
		"description": "return:bool des: If true, particle sizes are considered when applying forces to Colliders."
	}
,
	"ParticleSystem.CollisionModule.multiplyColliderForceByParticleSpeed": {
		"prefix": "ParticleSystem.CollisionModule.multiplyColliderForceByParticleSpeed",
		"body": [
			"multiplyColliderForceByParticleSpeed"
		],
		"description": "return:bool des: If true, particle speeds are considered when applying forces to Colliders."
	}
,
	"ParticleSystem.CollisionModule.quality": {
		"prefix": "ParticleSystem.CollisionModule.quality",
		"body": [
			"quality"
		],
		"description": "return:ParticleSystemCollisionQuality des: Specifies the accuracy of particle collisions against colliders in the scene."
	}
,
	"ParticleSystem.CollisionModule.radiusScale": {
		"prefix": "ParticleSystem.CollisionModule.radiusScale",
		"body": [
			"radiusScale"
		],
		"description": "return:float des: A multiplier applied to the size of each particle before collisions are processed."
	}
,
	"ParticleSystem.CollisionModule.sendCollisionMessages": {
		"prefix": "ParticleSystem.CollisionModule.sendCollisionMessages",
		"body": [
			"sendCollisionMessages"
		],
		"description": "return:bool des: Send collision callback messages."
	}
,
	"ParticleSystem.CollisionModule.type": {
		"prefix": "ParticleSystem.CollisionModule.type",
		"body": [
			"type"
		],
		"description": "return:ParticleSystemCollisionType des: The type of particle collision to perform."
	}
,
	"ParticleSystem.CollisionModule.voxelSize": {
		"prefix": "ParticleSystem.CollisionModule.voxelSize",
		"body": [
			"voxelSize"
		],
		"description": "return:float des: Size of voxels in the collision cache."
	}
,
	"ParticleSystem.CollisionModule.GetPlane": {
		"prefix": "ParticleSystem.CollisionModule.GetPlane",
		"body": [
			"GetPlane($1)"
		],
		"description": "public Transform GetPlane(int index); des: Get a collision plane associated with this particle system."
	}
,
	"ParticleSystem.CollisionModule.SetPlane": {
		"prefix": "ParticleSystem.CollisionModule.SetPlane",
		"body": [
			"SetPlane($1)"
		],
		"description": "public void SetPlane(int index, Transform transform); des: Set a collision plane to be used with this particle system."
	}
,
	"ParticleSystem.ColorBySpeedModule.color": {
		"prefix": "ParticleSystem.ColorBySpeedModule.color",
		"body": [
			"color"
		],
		"description": "return:ParticleSystem.MinMaxGradient des: The gradient controlling the particle colors."
	}
,
	"ParticleSystem.ColorBySpeedModule.enabled": {
		"prefix": "ParticleSystem.ColorBySpeedModule.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enable/disable the Color By Speed module."
	}
,
	"ParticleSystem.ColorBySpeedModule.range": {
		"prefix": "ParticleSystem.ColorBySpeedModule.range",
		"body": [
			"range"
		],
		"description": "return:Vector2 des: Apply the color gradient between these minimum and maximum speeds."
	}
,
	"ParticleSystem.ColorOverLifetimeModule.color": {
		"prefix": "ParticleSystem.ColorOverLifetimeModule.color",
		"body": [
			"color"
		],
		"description": "return:ParticleSystem.MinMaxGradient des: The gradient controlling the particle colors."
	}
,
	"ParticleSystem.ColorOverLifetimeModule.enabled": {
		"prefix": "ParticleSystem.ColorOverLifetimeModule.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enable/disable the Color Over Lifetime module."
	}
,
	"ParticleSystem.CustomDataModule.enabled": {
		"prefix": "ParticleSystem.CustomDataModule.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enable/disable the Custom Data module."
	}
,
	"ParticleSystem.CustomDataModule.GetColor": {
		"prefix": "ParticleSystem.CustomDataModule.GetColor",
		"body": [
			"GetColor($1)"
		],
		"description": "public ParticleSystem.MinMaxGradient GetColor(ParticleSystemCustomData stream); des: Get a MinMaxGradient, that is being used to generate custom HDR color data."
	}
,
	"ParticleSystem.CustomDataModule.GetMode": {
		"prefix": "ParticleSystem.CustomDataModule.GetMode",
		"body": [
			"GetMode($1)"
		],
		"description": "public ParticleSystemCustomDataMode GetMode(ParticleSystemCustomData stream); des: Find out the type of custom data that is being generated for the chosen data stream."
	}
,
	"ParticleSystem.CustomDataModule.GetVector": {
		"prefix": "ParticleSystem.CustomDataModule.GetVector",
		"body": [
			"GetVector($1)"
		],
		"description": "public ParticleSystem.MinMaxCurve GetVector(ParticleSystemCustomData stream, int component); des: Get a MinMaxCurve, that is being used to generate custom data."
	}
,
	"ParticleSystem.CustomDataModule.GetVectorComponentCount": {
		"prefix": "ParticleSystem.CustomDataModule.GetVectorComponentCount",
		"body": [
			"GetVectorComponentCount($1)"
		],
		"description": "public int GetVectorComponentCount(ParticleSystemCustomData stream); des: Query how many MinMaxCurve elements are being used to generate this stream of custom data."
	}
,
	"ParticleSystem.CustomDataModule.SetColor": {
		"prefix": "ParticleSystem.CustomDataModule.SetColor",
		"body": [
			"SetColor($1)"
		],
		"description": "public void SetColor(ParticleSystemCustomData stream, ParticleSystem.MinMaxGradient gradient); des: Set a MinMaxGradient, in order to generate custom HDR color data."
	}
,
	"ParticleSystem.CustomDataModule.SetMode": {
		"prefix": "ParticleSystem.CustomDataModule.SetMode",
		"body": [
			"SetMode($1)"
		],
		"description": "public void SetMode(ParticleSystemCustomData stream, ParticleSystemCustomDataMode mode); des: Choose the type of custom data to generate for the chosen data stream."
	}
,
	"ParticleSystem.CustomDataModule.SetVector": {
		"prefix": "ParticleSystem.CustomDataModule.SetVector",
		"body": [
			"SetVector($1)"
		],
		"description": "public void SetVector(ParticleSystemCustomData stream, int component, ParticleSystem.MinMaxCurve curve); des: Set a MinMaxCurve, in order to generate custom data."
	}
,
	"ParticleSystem.CustomDataModule.SetVectorComponentCount": {
		"prefix": "ParticleSystem.CustomDataModule.SetVectorComponentCount",
		"body": [
			"SetVectorComponentCount($1)"
		],
		"description": "public void SetVectorComponentCount(ParticleSystemCustomData stream, int count); des: Specify how many curves are used to generate custom data for this stream."
	}
,
	"ParticleSystem.EmissionModule.burstCount": {
		"prefix": "ParticleSystem.EmissionModule.burstCount",
		"body": [
			"burstCount"
		],
		"description": "return:int des: The current number of bursts."
	}
,
	"ParticleSystem.EmissionModule.enabled": {
		"prefix": "ParticleSystem.EmissionModule.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enable/disable the Emission module."
	}
,
	"ParticleSystem.EmissionModule.rateOverDistance": {
		"prefix": "ParticleSystem.EmissionModule.rateOverDistance",
		"body": [
			"rateOverDistance"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: The rate at which new particles are spawned, over distance."
	}
,
	"ParticleSystem.EmissionModule.rateOverDistanceMultiplier": {
		"prefix": "ParticleSystem.EmissionModule.rateOverDistanceMultiplier",
		"body": [
			"rateOverDistanceMultiplier"
		],
		"description": "return:float des: Change the rate over distance multiplier."
	}
,
	"ParticleSystem.EmissionModule.rateOverTime": {
		"prefix": "ParticleSystem.EmissionModule.rateOverTime",
		"body": [
			"rateOverTime"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: The rate at which new particles are spawned, over time."
	}
,
	"ParticleSystem.EmissionModule.rateOverTimeMultiplier": {
		"prefix": "ParticleSystem.EmissionModule.rateOverTimeMultiplier",
		"body": [
			"rateOverTimeMultiplier"
		],
		"description": "return:float des: Change the rate over time multiplier."
	}
,
	"ParticleSystem.EmissionModule.GetBurst": {
		"prefix": "ParticleSystem.EmissionModule.GetBurst",
		"body": [
			"GetBurst($1)"
		],
		"description": "public ParticleSystem.Burst GetBurst(int index); des: Get a single burst from the array of bursts."
	}
,
	"ParticleSystem.EmissionModule.GetBursts": {
		"prefix": "ParticleSystem.EmissionModule.GetBursts",
		"body": [
			"GetBursts($1)"
		],
		"description": "public int GetBursts(Burst[] bursts); des: Get the burst array."
	}
,
	"ParticleSystem.EmissionModule.SetBurst": {
		"prefix": "ParticleSystem.EmissionModule.SetBurst",
		"body": [
			"SetBurst($1)"
		],
		"description": "public void SetBurst(int index, ParticleSystem.Burst burst); des: Set a single burst in the array of bursts."
	}
,
	"ParticleSystem.EmissionModule.SetBursts": {
		"prefix": "ParticleSystem.EmissionModule.SetBursts",
		"body": [
			"SetBursts($1)"
		],
		"description": "public void SetBursts(Burst[] bursts); public void SetBursts(Burst[] bursts, int size); des: Set the burst array."
	}
,
	"ParticleSystem.EmitParams.angularVelocity": {
		"prefix": "ParticleSystem.EmitParams.angularVelocity",
		"body": [
			"angularVelocity"
		],
		"description": "return:float des: Override the angular velocity of emitted particles."
	}
,
	"ParticleSystem.EmitParams.angularVelocity3D": {
		"prefix": "ParticleSystem.EmitParams.angularVelocity3D",
		"body": [
			"angularVelocity3D"
		],
		"description": "return:Vector3 des: Override the 3D angular velocity of emitted particles."
	}
,
	"ParticleSystem.EmitParams.applyShapeToPosition": {
		"prefix": "ParticleSystem.EmitParams.applyShapeToPosition",
		"body": [
			"applyShapeToPosition"
		],
		"description": "return:bool des: When overriding the position of particles, setting this flag to true allows you to retain the influence of the shape module."
	}
,
	"ParticleSystem.EmitParams.axisOfRotation": {
		"prefix": "ParticleSystem.EmitParams.axisOfRotation",
		"body": [
			"axisOfRotation"
		],
		"description": "return:Vector3 des: Override the axis of rotation of emitted particles."
	}
,
	"ParticleSystem.EmitParams.position": {
		"prefix": "ParticleSystem.EmitParams.position",
		"body": [
			"position"
		],
		"description": "return:Vector3 des: Override the position of emitted particles."
	}
,
	"ParticleSystem.EmitParams.randomSeed": {
		"prefix": "ParticleSystem.EmitParams.randomSeed",
		"body": [
			"randomSeed"
		],
		"description": "return:uint des: Override the random seed of emitted particles."
	}
,
	"ParticleSystem.EmitParams.rotation": {
		"prefix": "ParticleSystem.EmitParams.rotation",
		"body": [
			"rotation"
		],
		"description": "return:float des: Override the rotation of emitted particles."
	}
,
	"ParticleSystem.EmitParams.rotation3D": {
		"prefix": "ParticleSystem.EmitParams.rotation3D",
		"body": [
			"rotation3D"
		],
		"description": "return:Vector3 des: Override the 3D rotation of emitted particles."
	}
,
	"ParticleSystem.EmitParams.startColor": {
		"prefix": "ParticleSystem.EmitParams.startColor",
		"body": [
			"startColor"
		],
		"description": "return:Color32 des: Override the initial color of emitted particles."
	}
,
	"ParticleSystem.EmitParams.startLifetime": {
		"prefix": "ParticleSystem.EmitParams.startLifetime",
		"body": [
			"startLifetime"
		],
		"description": "return:float des: Override the lifetime of emitted particles."
	}
,
	"ParticleSystem.EmitParams.startSize": {
		"prefix": "ParticleSystem.EmitParams.startSize",
		"body": [
			"startSize"
		],
		"description": "return:float des: Override the initial size of emitted particles."
	}
,
	"ParticleSystem.EmitParams.startSize3D": {
		"prefix": "ParticleSystem.EmitParams.startSize3D",
		"body": [
			"startSize3D"
		],
		"description": "return:Vector3 des: Override the initial 3D size of emitted particles."
	}
,
	"ParticleSystem.EmitParams.velocity": {
		"prefix": "ParticleSystem.EmitParams.velocity",
		"body": [
			"velocity"
		],
		"description": "return:Vector3 des: Override the velocity of emitted particles."
	}
,
	"ParticleSystem.EmitParams.ResetAngularVelocity": {
		"prefix": "ParticleSystem.EmitParams.ResetAngularVelocity",
		"body": [
			"ResetAngularVelocity($1)"
		],
		"description": "public void ResetAngularVelocity(); des: Reverts angularVelocity and angularVelocity3D back to the values specified in the inspector."
	}
,
	"ParticleSystem.EmitParams.ResetAxisOfRotation": {
		"prefix": "ParticleSystem.EmitParams.ResetAxisOfRotation",
		"body": [
			"ResetAxisOfRotation($1)"
		],
		"description": "public void ResetAxisOfRotation(); des: Revert the axis of rotation back to the value specified in the inspector."
	}
,
	"ParticleSystem.EmitParams.ResetPosition": {
		"prefix": "ParticleSystem.EmitParams.ResetPosition",
		"body": [
			"ResetPosition($1)"
		],
		"description": "public void ResetPosition(); des: Revert the position back to the value specified in the inspector."
	}
,
	"ParticleSystem.EmitParams.ResetRandomSeed": {
		"prefix": "ParticleSystem.EmitParams.ResetRandomSeed",
		"body": [
			"ResetRandomSeed($1)"
		],
		"description": "public void ResetRandomSeed(); des: Revert the random seed back to the value specified in the inspector."
	}
,
	"ParticleSystem.EmitParams.ResetRotation": {
		"prefix": "ParticleSystem.EmitParams.ResetRotation",
		"body": [
			"ResetRotation($1)"
		],
		"description": "public void ResetRotation(); des: Reverts rotation and rotation3D back to the values specified in the inspector."
	}
,
	"ParticleSystem.EmitParams.ResetStartColor": {
		"prefix": "ParticleSystem.EmitParams.ResetStartColor",
		"body": [
			"ResetStartColor($1)"
		],
		"description": "public void ResetStartColor(); des: Revert the initial color back to the value specified in the inspector."
	}
,
	"ParticleSystem.EmitParams.ResetStartLifetime": {
		"prefix": "ParticleSystem.EmitParams.ResetStartLifetime",
		"body": [
			"ResetStartLifetime($1)"
		],
		"description": "public void ResetStartLifetime(); des: Revert the lifetime back to the value specified in the inspector."
	}
,
	"ParticleSystem.EmitParams.ResetStartSize": {
		"prefix": "ParticleSystem.EmitParams.ResetStartSize",
		"body": [
			"ResetStartSize($1)"
		],
		"description": "public void ResetStartSize(); des: Revert the initial size back to the value specified in the inspector."
	}
,
	"ParticleSystem.EmitParams.ResetVelocity": {
		"prefix": "ParticleSystem.EmitParams.ResetVelocity",
		"body": [
			"ResetVelocity($1)"
		],
		"description": "public void ResetVelocity(); des: Revert the velocity back to the value specified in the inspector."
	}
,
	"ParticleSystem.ExternalForcesModule.enabled": {
		"prefix": "ParticleSystem.ExternalForcesModule.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enable/disable the External Forces module."
	}
,
	"ParticleSystem.ExternalForcesModule.multiplier": {
		"prefix": "ParticleSystem.ExternalForcesModule.multiplier",
		"body": [
			"multiplier"
		],
		"description": "return:float des: Multiplies the magnitude of applied external forces."
	}
,
	"ParticleSystem.ForceOverLifetimeModule.enabled": {
		"prefix": "ParticleSystem.ForceOverLifetimeModule.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enable/disable the Force Over Lifetime module."
	}
,
	"ParticleSystem.ForceOverLifetimeModule.randomized": {
		"prefix": "ParticleSystem.ForceOverLifetimeModule.randomized",
		"body": [
			"randomized"
		],
		"description": "return:bool des: When randomly selecting values between two curves or constants, this flag will cause a new random force to be chosen on each frame."
	}
,
	"ParticleSystem.ForceOverLifetimeModule.space": {
		"prefix": "ParticleSystem.ForceOverLifetimeModule.space",
		"body": [
			"space"
		],
		"description": "return:ParticleSystemSimulationSpace des: Are the forces being applied in local or world space?"
	}
,
	"ParticleSystem.ForceOverLifetimeModule.x": {
		"prefix": "ParticleSystem.ForceOverLifetimeModule.x",
		"body": [
			"x"
		],
		"description": "return:ParticleSystem.MinMaCurve des: The curve defining particle forces in the X axis."
	}
,
	"ParticleSystem.ForceOverLifetimeModule.xMultiplier": {
		"prefix": "ParticleSystem.ForceOverLifetimeModule.xMultiplier",
		"body": [
			"xMultiplier"
		],
		"description": "return:float des: Change the X axis mulutiplier."
	}
,
	"ParticleSystem.ForceOverLifetimeModule.y": {
		"prefix": "ParticleSystem.ForceOverLifetimeModule.y",
		"body": [
			"y"
		],
		"description": "return:ParticleSstem.MinMaxCurve des: The curve defining particle forces in the Y axis."
	}
,
	"ParticleSystem.ForceOverLifetimeModule.yMultiplier": {
		"prefix": "ParticleSystem.ForceOverLifetimeModule.yMultiplier",
		"body": [
			"yMultiplier"
		],
		"description": "return:float des: Change the Y axis multiplier."
	}
,
	"ParticleSystem.ForceOverLifetimeModule.z": {
		"prefix": "ParticleSystem.ForceOverLifetimeModule.z",
		"body": [
			"z"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: The curve defining particle forces in the Z axis."
	}
,
	"ParticleSystem.ForceOverLifetimeModule.zMultiplier": {
		"prefix": "ParticleSystem.ForceOverLifetimeModule.zMultiplier",
		"body": [
			"zMultiplier"
		],
		"description": "return:float des: Change the Z axis multiplier."
	}
,
	"ParticleSystem.InheritVelocityModule.curve": {
		"prefix": "ParticleSystem.InheritVelocityModule.curve",
		"body": [
			"curve"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Curve to define how much emitter velocity is applied during the lifetime of a particle."
	}
,
	"ParticleSystem.InheritVelocityModule.curveMultiplier": {
		"prefix": "ParticleSystem.InheritVelocityModule.curveMultiplier",
		"body": [
			"curveMultiplier"
		],
		"description": "return:float des: Change the curve multiplier."
	}
,
	"ParticleSystem.InheritVelocityModule.enabled": {
		"prefix": "ParticleSystem.InheritVelocityModule.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enable/disable the InheritVelocity module."
	}
,
	"ParticleSystem.InheritVelocityModule.mode": {
		"prefix": "ParticleSystem.InheritVelocityModule.mode",
		"body": [
			"mode"
		],
		"description": "return:ParticleSystemInheritVelocityMode des: How to apply emitter velocity to particles."
	}
,
	"ParticleSystem.LightsModule.alphaAffectsIntensity": {
		"prefix": "ParticleSystem.LightsModule.alphaAffectsIntensity",
		"body": [
			"alphaAffectsIntensity"
		],
		"description": "return:bool des: Toggle whether the particle alpha gets multiplied by the light intensity, when computing the final light intensity."
	}
,
	"ParticleSystem.LightsModule.enabled": {
		"prefix": "ParticleSystem.LightsModule.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enable/disable the Lights module."
	}
,
	"ParticleSystem.LightsModule.intensity": {
		"prefix": "ParticleSystem.LightsModule.intensity",
		"body": [
			"intensity"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Define a curve to apply custom intensity scaling to particle lights."
	}
,
	"ParticleSystem.LightsModule.intensityMultiplier": {
		"prefix": "ParticleSystem.LightsModule.intensityMultiplier",
		"body": [
			"intensityMultiplier"
		],
		"description": "return:float des: Intensity multiplier."
	}
,
	"ParticleSystem.LightsModule.light": {
		"prefix": "ParticleSystem.LightsModule.light",
		"body": [
			"light"
		],
		"description": "return:Light des: Select what Light prefab you want to base your particle lights on."
	}
,
	"ParticleSystem.LightsModule.maxLights": {
		"prefix": "ParticleSystem.LightsModule.maxLights",
		"body": [
			"maxLights"
		],
		"description": "return:int des: Set a limit on how many lights this Module can create."
	}
,
	"ParticleSystem.LightsModule.range": {
		"prefix": "ParticleSystem.LightsModule.range",
		"body": [
			"range"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Define a curve to apply custom range scaling to particle lights."
	}
,
	"ParticleSystem.LightsModule.rangeMultiplier": {
		"prefix": "ParticleSystem.LightsModule.rangeMultiplier",
		"body": [
			"rangeMultiplier"
		],
		"description": "return:float des: Range multiplier."
	}
,
	"ParticleSystem.LightsModule.ratio": {
		"prefix": "ParticleSystem.LightsModule.ratio",
		"body": [
			"ratio"
		],
		"description": "return:float des: Choose what proportion of particles will receive a dynamic light."
	}
,
	"ParticleSystem.LightsModule.sizeAffectsRange": {
		"prefix": "ParticleSystem.LightsModule.sizeAffectsRange",
		"body": [
			"sizeAffectsRange"
		],
		"description": "return:bool des: Toggle where the particle size will be multiplied by the light range, to determine the final light range."
	}
,
	"ParticleSystem.LightsModule.useParticleColor": {
		"prefix": "ParticleSystem.LightsModule.useParticleColor",
		"body": [
			"useParticleColor"
		],
		"description": "return:bool des: Toggle whether the particle lights will have their color multiplied by the particle color."
	}
,
	"ParticleSystem.LightsModule.useRandomDistribution": {
		"prefix": "ParticleSystem.LightsModule.useRandomDistribution",
		"body": [
			"useRandomDistribution"
		],
		"description": "return:bool des: Randomly assign lights to new particles based on ParticleSystem.LightsModule.ratio."
	}
,
	"ParticleSystem.LimitVelocityOverLifetimeModule.dampen": {
		"prefix": "ParticleSystem.LimitVelocityOverLifetimeModule.dampen",
		"body": [
			"dampen"
		],
		"description": "return:float des: Controls how much the velocity that exceeds the velocity limit should be dampened."
	}
,
	"ParticleSystem.LimitVelocityOverLifetimeModule.drag": {
		"prefix": "ParticleSystem.LimitVelocityOverLifetimeModule.drag",
		"body": [
			"drag"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Controls the amount of drag applied to the particle velocities."
	}
,
	"ParticleSystem.LimitVelocityOverLifetimeModule.dragMultiplier": {
		"prefix": "ParticleSystem.LimitVelocityOverLifetimeModule.dragMultiplier",
		"body": [
			"dragMultiplier"
		],
		"description": "return:float des: Change the drag multiplier."
	}
,
	"ParticleSystem.LimitVelocityOverLifetimeModule.enabled": {
		"prefix": "ParticleSystem.LimitVelocityOverLifetimeModule.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enable/disable the Limit Force Over Lifetime module."
	}
,
	"ParticleSystem.LimitVelocityOverLifetimeModule.limit": {
		"prefix": "ParticleSystem.LimitVelocityOverLifetimeModule.limit",
		"body": [
			"limit"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Maximum velocity curve, when not using one curve per axis."
	}
,
	"ParticleSystem.LimitVelocityOverLifetimeModule.limitMultiplier": {
		"prefix": "ParticleSystem.LimitVelocityOverLifetimeModule.limitMultiplier",
		"body": [
			"limitMultiplier"
		],
		"description": "return:float des: Change the limit multiplier."
	}
,
	"ParticleSystem.LimitVelocityOverLifetimeModule.limitX": {
		"prefix": "ParticleSystem.LimitVelocityOverLifetimeModule.limitX",
		"body": [
			"limitX"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Maximum velocity curve for the X axis."
	}
,
	"ParticleSystem.LimitVelocityOverLifetimeModule.limitXMultiplier": {
		"prefix": "ParticleSystem.LimitVelocityOverLifetimeModule.limitXMultiplier",
		"body": [
			"limitXMultiplier"
		],
		"description": "return:float des: Change the limit multiplier on the X axis."
	}
,
	"ParticleSystem.LimitVelocityOverLifetimeModule.limitY": {
		"prefix": "ParticleSystem.LimitVelocityOverLifetimeModule.limitY",
		"body": [
			"limitY"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Maximum velocity curve for the Y axis."
	}
,
	"ParticleSystem.LimitVelocityOverLifetimeModule.limitYMultiplier": {
		"prefix": "ParticleSystem.LimitVelocityOverLifetimeModule.limitYMultiplier",
		"body": [
			"limitYMultiplier"
		],
		"description": "return:float des: Change the limit multiplier on the Y axis."
	}
,
	"ParticleSystem.LimitVelocityOverLifetimeModule.limitZ": {
		"prefix": "ParticleSystem.LimitVelocityOverLifetimeModule.limitZ",
		"body": [
			"limitZ"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Maximum velocity curve for the Z axis."
	}
,
	"ParticleSystem.LimitVelocityOverLifetimeModule.limitZMultiplier": {
		"prefix": "ParticleSystem.LimitVelocityOverLifetimeModule.limitZMultiplier",
		"body": [
			"limitZMultiplier"
		],
		"description": "return:float des: Change the limit multiplier on the Z axis."
	}
,
	"ParticleSystem.LimitVelocityOverLifetimeModule.multiplyDragByParticleSize": {
		"prefix": "ParticleSystem.LimitVelocityOverLifetimeModule.multiplyDragByParticleSize",
		"body": [
			"multiplyDragByParticleSize"
		],
		"description": "return:bool des: Adjust the amount of drag applied to particles, based on their sizes."
	}
,
	"ParticleSystem.LimitVelocityOverLifetimeModule.multiplyDragByParticleVelocity": {
		"prefix": "ParticleSystem.LimitVelocityOverLifetimeModule.multiplyDragByParticleVelocity",
		"body": [
			"multiplyDragByParticleVelocity"
		],
		"description": "return:bool des: Adjust the amount of drag applied to particles, based on their speeds."
	}
,
	"ParticleSystem.LimitVelocityOverLifetimeModule.separateAxes": {
		"prefix": "ParticleSystem.LimitVelocityOverLifetimeModule.separateAxes",
		"body": [
			"separateAxes"
		],
		"description": "return:bool des: Set the velocity limit on each axis separately."
	}
,
	"ParticleSystem.LimitVelocityOverLifetimeModule.space": {
		"prefix": "ParticleSystem.LimitVelocityOverLifetimeModule.space",
		"body": [
			"space"
		],
		"description": "return:ParticleSystemSimulationSpace des: Specifies if the velocity limits are in local space (rotated with the transform) or world space."
	}
,
	"ParticleSystem.MainModule.customSimulationSpace": {
		"prefix": "ParticleSystem.MainModule.customSimulationSpace",
		"body": [
			"customSimulationSpace"
		],
		"description": "return:Transform des: Simulate particles relative to a custom transform component."
	}
,
	"ParticleSystem.MainModule.duration": {
		"prefix": "ParticleSystem.MainModule.duration",
		"body": [
			"duration"
		],
		"description": "return:float des: The duration of the particle system in seconds."
	}
,
	"ParticleSystem.MainModule.emitterVelocityMode": {
		"prefix": "ParticleSystem.MainModule.emitterVelocityMode",
		"body": [
			"emitterVelocityMode"
		],
		"description": "return:ParticleSystemEmitterVelocityMode des: Control how the Particle System calculates its velocity, when moving in the world."
	}
,
	"ParticleSystem.MainModule.flipRotation": {
		"prefix": "ParticleSystem.MainModule.flipRotation",
		"body": [
			"flipRotation"
		],
		"description": "return:float des: Makes some particles spin in the opposite direction."
	}
,
	"ParticleSystem.MainModule.gravityModifier": {
		"prefix": "ParticleSystem.MainModule.gravityModifier",
		"body": [
			"gravityModifier"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Scale applied to the gravity, defined by Physics.gravity."
	}
,
	"ParticleSystem.MainModule.gravityModifierMultiplier": {
		"prefix": "ParticleSystem.MainModule.gravityModifierMultiplier",
		"body": [
			"gravityModifierMultiplier"
		],
		"description": "return:float des: Change the gravity mulutiplier."
	}
,
	"ParticleSystem.MainModule.loop": {
		"prefix": "ParticleSystem.MainModule.loop",
		"body": [
			"loop"
		],
		"description": "return:bool des: Is the particle system looping?"
	}
,
	"ParticleSystem.MainModule.maxParticles": {
		"prefix": "ParticleSystem.MainModule.maxParticles",
		"body": [
			"maxParticles"
		],
		"description": "return:int des: The maximum number of particles to emit."
	}
,
	"ParticleSystem.MainModule.playOnAwake": {
		"prefix": "ParticleSystem.MainModule.playOnAwake",
		"body": [
			"playOnAwake"
		],
		"description": "return:bool des: If set to true, the particle system will automatically start playing on startup."
	}
,
	"ParticleSystem.MainModule.prewarm": {
		"prefix": "ParticleSystem.MainModule.prewarm",
		"body": [
			"prewarm"
		],
		"description": "return:bool des: When looping is enabled, this controls whether this particle system will look like it has already simulated for one loop when first becoming visible."
	}
,
	"ParticleSystem.MainModule.scalingMode": {
		"prefix": "ParticleSystem.MainModule.scalingMode",
		"body": [
			"scalingMode"
		],
		"description": "return:ParticleSystemScalingMode des: Control how the particle system's Transform Component is applied to the particle system."
	}
,
	"ParticleSystem.MainModule.simulationSpace": {
		"prefix": "ParticleSystem.MainModule.simulationSpace",
		"body": [
			"simulationSpace"
		],
		"description": "return:ParticleSystemSimulationSpace des: This selects the space in which to simulate particles. It can be either world or local space."
	}
,
	"ParticleSystem.MainModule.simulationSpeed": {
		"prefix": "ParticleSystem.MainModule.simulationSpeed",
		"body": [
			"simulationSpeed"
		],
		"description": "return:float des: Override the default playback speed of the Particle System."
	}
,
	"ParticleSystem.MainModule.startColor": {
		"prefix": "ParticleSystem.MainModule.startColor",
		"body": [
			"startColor"
		],
		"description": "return:ParticleSystem.MinMaxGradient des: The initial color of particles when emitted."
	}
,
	"ParticleSystem.MainModule.startDelay": {
		"prefix": "ParticleSystem.MainModule.startDelay",
		"body": [
			"startDelay"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Start delay in seconds."
	}
,
	"ParticleSystem.MainModule.startDelayMultiplier": {
		"prefix": "ParticleSystem.MainModule.startDelayMultiplier",
		"body": [
			"startDelayMultiplier"
		],
		"description": "return:float des: Start delay multiplier in seconds."
	}
,
	"ParticleSystem.MainModule.startLifetime": {
		"prefix": "ParticleSystem.MainModule.startLifetime",
		"body": [
			"startLifetime"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: The total lifetime in seconds that each new particle will have."
	}
,
	"ParticleSystem.MainModule.startLifetimeMultiplier": {
		"prefix": "ParticleSystem.MainModule.startLifetimeMultiplier",
		"body": [
			"startLifetimeMultiplier"
		],
		"description": "return:float des: Start lifetime multiplier."
	}
,
	"ParticleSystem.MainModule.startRotation": {
		"prefix": "ParticleSystem.MainModule.startRotation",
		"body": [
			"startRotation"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: The initial rotation of particles when emitted."
	}
,
	"ParticleSystem.MainModule.startRotation3D": {
		"prefix": "ParticleSystem.MainModule.startRotation3D",
		"body": [
			"startRotation3D"
		],
		"description": "return:bool des: A flag to enable 3D particle rotation."
	}
,
	"ParticleSystem.MainModule.startRotationMultiplier": {
		"prefix": "ParticleSystem.MainModule.startRotationMultiplier",
		"body": [
			"startRotationMultiplier"
		],
		"description": "return:float des: Start rotation multiplier."
	}
,
	"ParticleSystem.MainModule.startRotationX": {
		"prefix": "ParticleSystem.MainModule.startRotationX",
		"body": [
			"startRotationX"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: The initial rotation of particles around the X axis when emitted."
	}
,
	"ParticleSystem.MainModule.startRotationXMultiplier": {
		"prefix": "ParticleSystem.MainModule.startRotationXMultiplier",
		"body": [
			"startRotationXMultiplier"
		],
		"description": "return:float des: Start rotation multiplier around the X axis."
	}
,
	"ParticleSystem.MainModule.startRotationY": {
		"prefix": "ParticleSystem.MainModule.startRotationY",
		"body": [
			"startRotationY"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: The initial rotation of particles around the Y axis when emitted."
	}
,
	"ParticleSystem.MainModule.startRotationYMultiplier": {
		"prefix": "ParticleSystem.MainModule.startRotationYMultiplier",
		"body": [
			"startRotationYMultiplier"
		],
		"description": "return:float des: Start rotation multiplier around the Y axis."
	}
,
	"ParticleSystem.MainModule.startRotationZ": {
		"prefix": "ParticleSystem.MainModule.startRotationZ",
		"body": [
			"startRotationZ"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: The initial rotation of particles around the Z axis when emitted."
	}
,
	"ParticleSystem.MainModule.startRotationZMultiplier": {
		"prefix": "ParticleSystem.MainModule.startRotationZMultiplier",
		"body": [
			"startRotationZMultiplier"
		],
		"description": "return:float des: Start rotation multiplier around the Z axis."
	}
,
	"ParticleSystem.MainModule.startSize": {
		"prefix": "ParticleSystem.MainModule.startSize",
		"body": [
			"startSize"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: The initial size of particles when emitted."
	}
,
	"ParticleSystem.MainModule.startSize3D": {
		"prefix": "ParticleSystem.MainModule.startSize3D",
		"body": [
			"startSize3D"
		],
		"description": "return:bool des: A flag to enable specifying particle size individually for each axis."
	}
,
	"ParticleSystem.MainModule.startSizeMultiplier": {
		"prefix": "ParticleSystem.MainModule.startSizeMultiplier",
		"body": [
			"startSizeMultiplier"
		],
		"description": "return:float des: Start size multiplier."
	}
,
	"ParticleSystem.MainModule.startSizeX": {
		"prefix": "ParticleSystem.MainModule.startSizeX",
		"body": [
			"startSizeX"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: The initial size of particles along the X axis when emitted."
	}
,
	"ParticleSystem.MainModule.startSizeXMultiplier": {
		"prefix": "ParticleSystem.MainModule.startSizeXMultiplier",
		"body": [
			"startSizeXMultiplier"
		],
		"description": "return:float des: Start rotation multiplier along the X axis."
	}
,
	"ParticleSystem.MainModule.startSizeY": {
		"prefix": "ParticleSystem.MainModule.startSizeY",
		"body": [
			"startSizeY"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: The initial size of particles along the Y axis when emitted."
	}
,
	"ParticleSystem.MainModule.startSizeYMultiplier": {
		"prefix": "ParticleSystem.MainModule.startSizeYMultiplier",
		"body": [
			"startSizeYMultiplier"
		],
		"description": "return:float des: Start rotation multiplier along the Y axis."
	}
,
	"ParticleSystem.MainModule.startSizeZ": {
		"prefix": "ParticleSystem.MainModule.startSizeZ",
		"body": [
			"startSizeZ"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: The initial size of particles along the Z axis when emitted."
	}
,
	"ParticleSystem.MainModule.startSizeZMultiplier": {
		"prefix": "ParticleSystem.MainModule.startSizeZMultiplier",
		"body": [
			"startSizeZMultiplier"
		],
		"description": "return:float des: Start rotation multiplier along the Z axis."
	}
,
	"ParticleSystem.MainModule.startSpeed": {
		"prefix": "ParticleSystem.MainModule.startSpeed",
		"body": [
			"startSpeed"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: The initial speed of particles when emitted."
	}
,
	"ParticleSystem.MainModule.startSpeedMultiplier": {
		"prefix": "ParticleSystem.MainModule.startSpeedMultiplier",
		"body": [
			"startSpeedMultiplier"
		],
		"description": "return:float des: A multiplier of the initial speed of particles when emitted."
	}
,
	"ParticleSystem.MainModule.stopAction": {
		"prefix": "ParticleSystem.MainModule.stopAction",
		"body": [
			"stopAction"
		],
		"description": "return:ParticleSystemStopAction des: Configure whether the GameObject will automatically disable or destroy itself, when the Particle System is stopped and all particles have died."
	}
,
	"ParticleSystem.MainModule.useUnscaledTime": {
		"prefix": "ParticleSystem.MainModule.useUnscaledTime",
		"body": [
			"useUnscaledTime"
		],
		"description": "return:bool des: When true, use the unscaled delta time to simulate the Particle System. Otherwise, use the scaled delta time."
	}
,
	"ParticleSystem.MinMaxCurve.constant": {
		"prefix": "ParticleSystem.MinMaxCurve.constant",
		"body": [
			"constant"
		],
		"description": "return:float des: Set the constant value."
	}
,
	"ParticleSystem.MinMaxCurve.constantMax": {
		"prefix": "ParticleSystem.MinMaxCurve.constantMax",
		"body": [
			"constantMax"
		],
		"description": "return:float des: Set a constant for the upper bound."
	}
,
	"ParticleSystem.MinMaxCurve.constantMin": {
		"prefix": "ParticleSystem.MinMaxCurve.constantMin",
		"body": [
			"constantMin"
		],
		"description": "return:float des: Set a constant for the lower bound."
	}
,
	"ParticleSystem.MinMaxCurve.curve": {
		"prefix": "ParticleSystem.MinMaxCurve.curve",
		"body": [
			"curve"
		],
		"description": "return:AnimationCurve des: Set the curve."
	}
,
	"ParticleSystem.MinMaxCurve.curveMax": {
		"prefix": "ParticleSystem.MinMaxCurve.curveMax",
		"body": [
			"curveMax"
		],
		"description": "return:AnimationCurve des: Set a curve for the upper bound."
	}
,
	"ParticleSystem.MinMaxCurve.curveMin": {
		"prefix": "ParticleSystem.MinMaxCurve.curveMin",
		"body": [
			"curveMin"
		],
		"description": "return:AnimationCurve des: Set a curve for the lower bound."
	}
,
	"ParticleSystem.MinMaxCurve.curveMultiplier": {
		"prefix": "ParticleSystem.MinMaxCurve.curveMultiplier",
		"body": [
			"curveMultiplier"
		],
		"description": "return:float des: Set a multiplier to be applied to the curves."
	}
,
	"ParticleSystem.MinMaxCurve.mode": {
		"prefix": "ParticleSystem.MinMaxCurve.mode",
		"body": [
			"mode"
		],
		"description": "return:ParticleSystemCurveMode des: Set the mode that the min-max curve will use to evaluate values."
	}
,
	"ParticleSystem.MinMaxCurve.Evaluate": {
		"prefix": "ParticleSystem.MinMaxCurve.Evaluate",
		"body": [
			"Evaluate($1)"
		],
		"description": "public float Evaluate(float time); public float Evaluate(float time, float lerpFactor); des: Manually query the curve to calculate values based on what mode it is in."
	}
,
	"ParticleSystem.MinMaxGradient.color": {
		"prefix": "ParticleSystem.MinMaxGradient.color",
		"body": [
			"color"
		],
		"description": "return:Color des: Set a constant color."
	}
,
	"ParticleSystem.MinMaxGradient.colorMax": {
		"prefix": "ParticleSystem.MinMaxGradient.colorMax",
		"body": [
			"colorMax"
		],
		"description": "return:Color des: Set a constant color for the upper bound."
	}
,
	"ParticleSystem.MinMaxGradient.colorMin": {
		"prefix": "ParticleSystem.MinMaxGradient.colorMin",
		"body": [
			"colorMin"
		],
		"description": "return:Color des: Set a constant color for the lower bound."
	}
,
	"ParticleSystem.MinMaxGradient.gradient": {
		"prefix": "ParticleSystem.MinMaxGradient.gradient",
		"body": [
			"gradient"
		],
		"description": "return:Gradient des: Set the gradient."
	}
,
	"ParticleSystem.MinMaxGradient.gradientMax": {
		"prefix": "ParticleSystem.MinMaxGradient.gradientMax",
		"body": [
			"gradientMax"
		],
		"description": "return:Gradient des: Set a gradient for the upper bound."
	}
,
	"ParticleSystem.MinMaxGradient.gradientMin": {
		"prefix": "ParticleSystem.MinMaxGradient.gradientMin",
		"body": [
			"gradientMin"
		],
		"description": "return:Gradient des: Set a gradient for the lower bound."
	}
,
	"ParticleSystem.MinMaxGradient.mode": {
		"prefix": "ParticleSystem.MinMaxGradient.mode",
		"body": [
			"mode"
		],
		"description": "return:ParticleSystemGradientMode des: Set the mode that the min-max gradient will use to evaluate colors."
	}
,
	"ParticleSystem.MinMaxGradient.Evaluate": {
		"prefix": "ParticleSystem.MinMaxGradient.Evaluate",
		"body": [
			"Evaluate($1)"
		],
		"description": "public Color Evaluate(float time); public Color Evaluate(float time, float lerpFactor); des: Manually query the gradient to calculate colors based on what mode it is in."
	}
,
	"ParticleSystem.NoiseModule.damping": {
		"prefix": "ParticleSystem.NoiseModule.damping",
		"body": [
			"damping"
		],
		"description": "return:bool des: Higher frequency noise will reduce the strength by a proportional amount, if enabled."
	}
,
	"ParticleSystem.NoiseModule.enabled": {
		"prefix": "ParticleSystem.NoiseModule.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enable/disable the Noise module."
	}
,
	"ParticleSystem.NoiseModule.frequency": {
		"prefix": "ParticleSystem.NoiseModule.frequency",
		"body": [
			"frequency"
		],
		"description": "return:float des: Low values create soft, smooth noise, and high values create rapidly changing noise."
	}
,
	"ParticleSystem.NoiseModule.octaveCount": {
		"prefix": "ParticleSystem.NoiseModule.octaveCount",
		"body": [
			"octaveCount"
		],
		"description": "return:int des: Layers of noise that combine to produce final noise."
	}
,
	"ParticleSystem.NoiseModule.octaveMultiplier": {
		"prefix": "ParticleSystem.NoiseModule.octaveMultiplier",
		"body": [
			"octaveMultiplier"
		],
		"description": "return:float des: When combining each octave, scale the intensity by this amount."
	}
,
	"ParticleSystem.NoiseModule.octaveScale": {
		"prefix": "ParticleSystem.NoiseModule.octaveScale",
		"body": [
			"octaveScale"
		],
		"description": "return:float des: When combining each octave, zoom in by this amount."
	}
,
	"ParticleSystem.NoiseModule.positionAmount": {
		"prefix": "ParticleSystem.NoiseModule.positionAmount",
		"body": [
			"positionAmount"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: How much the noise affects the particle positions."
	}
,
	"ParticleSystem.NoiseModule.quality": {
		"prefix": "ParticleSystem.NoiseModule.quality",
		"body": [
			"quality"
		],
		"description": "return:ParticleSystemNoiseQuality des: Generate 1D, 2D or 3D noise."
	}
,
	"ParticleSystem.NoiseModule.remap": {
		"prefix": "ParticleSystem.NoiseModule.remap",
		"body": [
			"remap"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Define how the noise values are remapped."
	}
,
	"ParticleSystem.NoiseModule.remapEnabled": {
		"prefix": "ParticleSystem.NoiseModule.remapEnabled",
		"body": [
			"remapEnabled"
		],
		"description": "return:bool des: Enable remapping of the final noise values, allowing for noise values to be translated into different values."
	}
,
	"ParticleSystem.NoiseModule.remapMultiplier": {
		"prefix": "ParticleSystem.NoiseModule.remapMultiplier",
		"body": [
			"remapMultiplier"
		],
		"description": "return:float des: Remap multiplier."
	}
,
	"ParticleSystem.NoiseModule.remapX": {
		"prefix": "ParticleSystem.NoiseModule.remapX",
		"body": [
			"remapX"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Define how the noise values are remapped on the X axis, when using the ParticleSystem.NoiseModule.separateAxes option."
	}
,
	"ParticleSystem.NoiseModule.remapXMultiplier": {
		"prefix": "ParticleSystem.NoiseModule.remapXMultiplier",
		"body": [
			"remapXMultiplier"
		],
		"description": "return:float des: X axis remap multiplier."
	}
,
	"ParticleSystem.NoiseModule.remapY": {
		"prefix": "ParticleSystem.NoiseModule.remapY",
		"body": [
			"remapY"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Define how the noise values are remapped on the Y axis, when using the ParticleSystem.NoiseModule.separateAxes option."
	}
,
	"ParticleSystem.NoiseModule.remapYMultiplier": {
		"prefix": "ParticleSystem.NoiseModule.remapYMultiplier",
		"body": [
			"remapYMultiplier"
		],
		"description": "return:float des: Y axis remap multiplier."
	}
,
	"ParticleSystem.NoiseModule.remapZ": {
		"prefix": "ParticleSystem.NoiseModule.remapZ",
		"body": [
			"remapZ"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Define how the noise values are remapped on the Z axis, when using the ParticleSystem.NoiseModule.separateAxes option."
	}
,
	"ParticleSystem.NoiseModule.remapZMultiplier": {
		"prefix": "ParticleSystem.NoiseModule.remapZMultiplier",
		"body": [
			"remapZMultiplier"
		],
		"description": "return:float des: Z axis remap multiplier."
	}
,
	"ParticleSystem.NoiseModule.rotationAmount": {
		"prefix": "ParticleSystem.NoiseModule.rotationAmount",
		"body": [
			"rotationAmount"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: How much the noise affects the particle rotation, in degrees per second."
	}
,
	"ParticleSystem.NoiseModule.scrollSpeed": {
		"prefix": "ParticleSystem.NoiseModule.scrollSpeed",
		"body": [
			"scrollSpeed"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Scroll the noise map over the particle system."
	}
,
	"ParticleSystem.NoiseModule.scrollSpeedMultiplier": {
		"prefix": "ParticleSystem.NoiseModule.scrollSpeedMultiplier",
		"body": [
			"scrollSpeedMultiplier"
		],
		"description": "return:float des: Scroll speed multiplier."
	}
,
	"ParticleSystem.NoiseModule.separateAxes": {
		"prefix": "ParticleSystem.NoiseModule.separateAxes",
		"body": [
			"separateAxes"
		],
		"description": "return:bool des: Control the noise separately for each axis."
	}
,
	"ParticleSystem.NoiseModule.sizeAmount": {
		"prefix": "ParticleSystem.NoiseModule.sizeAmount",
		"body": [
			"sizeAmount"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: How much the noise affects the particle sizes, applied as a multiplier on the size of each particle."
	}
,
	"ParticleSystem.NoiseModule.strength": {
		"prefix": "ParticleSystem.NoiseModule.strength",
		"body": [
			"strength"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: How strong the overall noise effect is."
	}
,
	"ParticleSystem.NoiseModule.strengthMultiplier": {
		"prefix": "ParticleSystem.NoiseModule.strengthMultiplier",
		"body": [
			"strengthMultiplier"
		],
		"description": "return:float des: Strength multiplier."
	}
,
	"ParticleSystem.NoiseModule.strengthX": {
		"prefix": "ParticleSystem.NoiseModule.strengthX",
		"body": [
			"strengthX"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Define the strength of the effect on the X axis, when using the ParticleSystem.NoiseModule.separateAxes option."
	}
,
	"ParticleSystem.NoiseModule.strengthXMultiplier": {
		"prefix": "ParticleSystem.NoiseModule.strengthXMultiplier",
		"body": [
			"strengthXMultiplier"
		],
		"description": "return:float des: X axis strength multiplier."
	}
,
	"ParticleSystem.NoiseModule.strengthY": {
		"prefix": "ParticleSystem.NoiseModule.strengthY",
		"body": [
			"strengthY"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Define the strength of the effect on the Y axis, when using the ParticleSystem.NoiseModule.separateAxes option."
	}
,
	"ParticleSystem.NoiseModule.strengthYMultiplier": {
		"prefix": "ParticleSystem.NoiseModule.strengthYMultiplier",
		"body": [
			"strengthYMultiplier"
		],
		"description": "return:float des: Y axis strength multiplier."
	}
,
	"ParticleSystem.NoiseModule.strengthZ": {
		"prefix": "ParticleSystem.NoiseModule.strengthZ",
		"body": [
			"strengthZ"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Define the strength of the effect on the Z axis, when using the ParticleSystem.NoiseModule.separateAxes option."
	}
,
	"ParticleSystem.NoiseModule.strengthZMultiplier": {
		"prefix": "ParticleSystem.NoiseModule.strengthZMultiplier",
		"body": [
			"strengthZMultiplier"
		],
		"description": "return:float des: Z axis strength multiplier."
	}
,
	"ParticleSystem.Particle.angularVelocity": {
		"prefix": "ParticleSystem.Particle.angularVelocity",
		"body": [
			"angularVelocity"
		],
		"description": "return:float des: The angular velocity of the particle."
	}
,
	"ParticleSystem.Particle.angularVelocity3D": {
		"prefix": "ParticleSystem.Particle.angularVelocity3D",
		"body": [
			"angularVelocity3D"
		],
		"description": "return:Vector3 des: The 3D angular velocity of the particle."
	}
,
	"ParticleSystem.Particle.animatedVelocity": {
		"prefix": "ParticleSystem.Particle.animatedVelocity",
		"body": [
			"animatedVelocity"
		],
		"description": "return:Vector3 des: The animated velocity of the particle."
	}
,
	"ParticleSystem.Particle.axisOfRotation": {
		"prefix": "ParticleSystem.Particle.axisOfRotation",
		"body": [
			"axisOfRotation"
		],
		"description": "return:Vector3 des: Mesh particles will rotate around this axis."
	}
,
	"ParticleSystem.Particle.position": {
		"prefix": "ParticleSystem.Particle.position",
		"body": [
			"position"
		],
		"description": "return:Vector3 des: The position of the particle."
	}
,
	"ParticleSystem.Particle.randomSeed": {
		"prefix": "ParticleSystem.Particle.randomSeed",
		"body": [
			"randomSeed"
		],
		"description": "return:uint des: The random seed of the particle."
	}
,
	"ParticleSystem.Particle.remainingLifetime": {
		"prefix": "ParticleSystem.Particle.remainingLifetime",
		"body": [
			"remainingLifetime"
		],
		"description": "return:float des: The remaining lifetime of the particle."
	}
,
	"ParticleSystem.Particle.rotation": {
		"prefix": "ParticleSystem.Particle.rotation",
		"body": [
			"rotation"
		],
		"description": "return:float des: The rotation of the particle."
	}
,
	"ParticleSystem.Particle.rotation3D": {
		"prefix": "ParticleSystem.Particle.rotation3D",
		"body": [
			"rotation3D"
		],
		"description": "return:Vector3 des: The 3D rotation of the particle."
	}
,
	"ParticleSystem.Particle.startColor": {
		"prefix": "ParticleSystem.Particle.startColor",
		"body": [
			"startColor"
		],
		"description": "return:Color32 des: The initial color of the particle. The current color of the particle is calculated procedurally based on this value and the active color modules."
	}
,
	"ParticleSystem.Particle.startLifetime": {
		"prefix": "ParticleSystem.Particle.startLifetime",
		"body": [
			"startLifetime"
		],
		"description": "return:float des: The starting lifetime of the particle."
	}
,
	"ParticleSystem.Particle.startSize": {
		"prefix": "ParticleSystem.Particle.startSize",
		"body": [
			"startSize"
		],
		"description": "return:float des: The initial size of the particle. The current size of the particle is calculated procedurally based on this value and the active size modules."
	}
,
	"ParticleSystem.Particle.startSize3D": {
		"prefix": "ParticleSystem.Particle.startSize3D",
		"body": [
			"startSize3D"
		],
		"description": "return:Vector3 des: The initial 3D size of the particle. The current size of the particle is calculated procedurally based on this value and the active size modules."
	}
,
	"ParticleSystem.Particle.totalVelocity": {
		"prefix": "ParticleSystem.Particle.totalVelocity",
		"body": [
			"totalVelocity"
		],
		"description": "return:Vector3 des: The total velocity of the particle."
	}
,
	"ParticleSystem.Particle.velocity": {
		"prefix": "ParticleSystem.Particle.velocity",
		"body": [
			"velocity"
		],
		"description": "return:Vector3 des: The velocity of the particle."
	}
,
	"ParticleSystem.Particle.GetCurrentColor": {
		"prefix": "ParticleSystem.Particle.GetCurrentColor",
		"body": [
			"GetCurrentColor($1)"
		],
		"description": "public Color32 GetCurrentColor(ParticleSystem system); des: Calculate the current color of the particle by applying the relevant curves to its startColor property."
	}
,
	"ParticleSystem.Particle.GetCurrentSize": {
		"prefix": "ParticleSystem.Particle.GetCurrentSize",
		"body": [
			"GetCurrentSize($1)"
		],
		"description": "public float GetCurrentSize(ParticleSystem system); des: Calculate the current size of the particle by applying the relevant curves to its startSize property."
	}
,
	"ParticleSystem.Particle.GetCurrentSize3D": {
		"prefix": "ParticleSystem.Particle.GetCurrentSize3D",
		"body": [
			"GetCurrentSize3D($1)"
		],
		"description": "public Vector3 GetCurrentSize3D(ParticleSystem system); des: Calculate the current 3D size of the particle by applying the relevant curves to its startSize3D property."
	}
,
	"ParticleSystem.RotationBySpeedModule.enabled": {
		"prefix": "ParticleSystem.RotationBySpeedModule.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enable/disable the Rotation By Speed module."
	}
,
	"ParticleSystem.RotationBySpeedModule.range": {
		"prefix": "ParticleSystem.RotationBySpeedModule.range",
		"body": [
			"range"
		],
		"description": "return:Vector2 des: Apply the rotation curve between these minimum and maximum speeds."
	}
,
	"ParticleSystem.RotationBySpeedModule.separateAxes": {
		"prefix": "ParticleSystem.RotationBySpeedModule.separateAxes",
		"body": [
			"separateAxes"
		],
		"description": "return:bool des: Set the rotation by speed on each axis separately."
	}
,
	"ParticleSystem.RotationBySpeedModule.x": {
		"prefix": "ParticleSystem.RotationBySpeedModule.x",
		"body": [
			"x"
		],
		"description": "return:ParticleSystem.MinMaCurve des: Rotation by speed curve for the X axis."
	}
,
	"ParticleSystem.RotationBySpeedModule.xMultiplier": {
		"prefix": "ParticleSystem.RotationBySpeedModule.xMultiplier",
		"body": [
			"xMultiplier"
		],
		"description": "return:float des: Speed multiplier along the X axis."
	}
,
	"ParticleSystem.RotationBySpeedModule.y": {
		"prefix": "ParticleSystem.RotationBySpeedModule.y",
		"body": [
			"y"
		],
		"description": "return:ParticleSstem.MinMaxCurve des: Rotation by speed curve for the Y axis."
	}
,
	"ParticleSystem.RotationBySpeedModule.yMultiplier": {
		"prefix": "ParticleSystem.RotationBySpeedModule.yMultiplier",
		"body": [
			"yMultiplier"
		],
		"description": "return:float des: Speed multiplier along the Y axis."
	}
,
	"ParticleSystem.RotationBySpeedModule.z": {
		"prefix": "ParticleSystem.RotationBySpeedModule.z",
		"body": [
			"z"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Rotation by speed curve for the Z axis."
	}
,
	"ParticleSystem.RotationBySpeedModule.zMultiplier": {
		"prefix": "ParticleSystem.RotationBySpeedModule.zMultiplier",
		"body": [
			"zMultiplier"
		],
		"description": "return:float des: Speed multiplier along the Z axis."
	}
,
	"ParticleSystem.RotationOverLifetimeModule.enabled": {
		"prefix": "ParticleSystem.RotationOverLifetimeModule.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enable/disable the Rotation Over Lifetime module."
	}
,
	"ParticleSystem.RotationOverLifetimeModule.separateAxes": {
		"prefix": "ParticleSystem.RotationOverLifetimeModule.separateAxes",
		"body": [
			"separateAxes"
		],
		"description": "return:bool des: Set the rotation over lifetime on each axis separately."
	}
,
	"ParticleSystem.RotationOverLifetimeModule.x": {
		"prefix": "ParticleSystem.RotationOverLifetimeModule.x",
		"body": [
			"x"
		],
		"description": "return:ParticleSystem.MinMaCurve des: Rotation over lifetime curve for the X axis."
	}
,
	"ParticleSystem.RotationOverLifetimeModule.xMultiplier": {
		"prefix": "ParticleSystem.RotationOverLifetimeModule.xMultiplier",
		"body": [
			"xMultiplier"
		],
		"description": "return:float des: Rotation multiplier around the X axis."
	}
,
	"ParticleSystem.RotationOverLifetimeModule.y": {
		"prefix": "ParticleSystem.RotationOverLifetimeModule.y",
		"body": [
			"y"
		],
		"description": "return:ParticleSstem.MinMaxCurve des: Rotation over lifetime curve for the Y axis."
	}
,
	"ParticleSystem.RotationOverLifetimeModule.yMultiplier": {
		"prefix": "ParticleSystem.RotationOverLifetimeModule.yMultiplier",
		"body": [
			"yMultiplier"
		],
		"description": "return:float des: Rotation multiplier around the Y axis."
	}
,
	"ParticleSystem.RotationOverLifetimeModule.z": {
		"prefix": "ParticleSystem.RotationOverLifetimeModule.z",
		"body": [
			"z"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Rotation over lifetime curve for the Z axis."
	}
,
	"ParticleSystem.RotationOverLifetimeModule.zMultiplier": {
		"prefix": "ParticleSystem.RotationOverLifetimeModule.zMultiplier",
		"body": [
			"zMultiplier"
		],
		"description": "return:float des: Rotation multiplier around the Z axis."
	}
,
	"ParticleSystem.ShapeModule.alignToDirection": {
		"prefix": "ParticleSystem.ShapeModule.alignToDirection",
		"body": [
			"alignToDirection"
		],
		"description": "return:bool des: Align particles based on their initial direction of travel."
	}
,
	"ParticleSystem.ShapeModule.angle": {
		"prefix": "ParticleSystem.ShapeModule.angle",
		"body": [
			"angle"
		],
		"description": "return:float des: Angle of the cone."
	}
,
	"ParticleSystem.ShapeModule.arc": {
		"prefix": "ParticleSystem.ShapeModule.arc",
		"body": [
			"arc"
		],
		"description": "return:float des: Circle arc angle."
	}
,
	"ParticleSystem.ShapeModule.arcMode": {
		"prefix": "ParticleSystem.ShapeModule.arcMode",
		"body": [
			"arcMode"
		],
		"description": "return:ParticleSystemShapeMultiModeValue des: The mode used for generating particles around the arc."
	}
,
	"ParticleSystem.ShapeModule.arcSpeed": {
		"prefix": "ParticleSystem.ShapeModule.arcSpeed",
		"body": [
			"arcSpeed"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: When using one of the animated modes, how quickly to move the emission position around the arc."
	}
,
	"ParticleSystem.ShapeModule.arcSpeedMultiplier": {
		"prefix": "ParticleSystem.ShapeModule.arcSpeedMultiplier",
		"body": [
			"arcSpeedMultiplier"
		],
		"description": "return:float des: A multiplier of the arc speed of the emission shape."
	}
,
	"ParticleSystem.ShapeModule.arcSpread": {
		"prefix": "ParticleSystem.ShapeModule.arcSpread",
		"body": [
			"arcSpread"
		],
		"description": "return:float des: Control the gap between emission points around the arc."
	}
,
	"ParticleSystem.ShapeModule.boxThickness": {
		"prefix": "ParticleSystem.ShapeModule.boxThickness",
		"body": [
			"boxThickness"
		],
		"description": "return:Vector3 des: Thickness of the box."
	}
,
	"ParticleSystem.ShapeModule.donutRadius": {
		"prefix": "ParticleSystem.ShapeModule.donutRadius",
		"body": [
			"donutRadius"
		],
		"description": "return:float des: The radius of the Donut shape."
	}
,
	"ParticleSystem.ShapeModule.enabled": {
		"prefix": "ParticleSystem.ShapeModule.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enable/disable the Shape module."
	}
,
	"ParticleSystem.ShapeModule.length": {
		"prefix": "ParticleSystem.ShapeModule.length",
		"body": [
			"length"
		],
		"description": "return:float des: Length of the cone."
	}
,
	"ParticleSystem.ShapeModule.mesh": {
		"prefix": "ParticleSystem.ShapeModule.mesh",
		"body": [
			"mesh"
		],
		"description": "return:Mesh des: Mesh to emit particles from."
	}
,
	"ParticleSystem.ShapeModule.meshMaterialIndex": {
		"prefix": "ParticleSystem.ShapeModule.meshMaterialIndex",
		"body": [
			"meshMaterialIndex"
		],
		"description": "return:int des: Emit particles from a single material of a mesh."
	}
,
	"ParticleSystem.ShapeModule.meshRenderer": {
		"prefix": "ParticleSystem.ShapeModule.meshRenderer",
		"body": [
			"meshRenderer"
		],
		"description": "return:MeshRenderer des: MeshRenderer to emit particles from."
	}
,
	"ParticleSystem.ShapeModule.meshShapeType": {
		"prefix": "ParticleSystem.ShapeModule.meshShapeType",
		"body": [
			"meshShapeType"
		],
		"description": "return:ParticleSystemMeshShapeType des: Where on the mesh to emit particles from."
	}
,
	"ParticleSystem.ShapeModule.normalOffset": {
		"prefix": "ParticleSystem.ShapeModule.normalOffset",
		"body": [
			"normalOffset"
		],
		"description": "return:float des: Move particles away from the surface of the source mesh."
	}
,
	"ParticleSystem.ShapeModule.position": {
		"prefix": "ParticleSystem.ShapeModule.position",
		"body": [
			"position"
		],
		"description": "return:Vector3 des: Apply an offset to the position from which particles are emitted."
	}
,
	"ParticleSystem.ShapeModule.radius": {
		"prefix": "ParticleSystem.ShapeModule.radius",
		"body": [
			"radius"
		],
		"description": "return:float des: Radius of the shape."
	}
,
	"ParticleSystem.ShapeModule.radiusMode": {
		"prefix": "ParticleSystem.ShapeModule.radiusMode",
		"body": [
			"radiusMode"
		],
		"description": "return:ParticleSystemShapeMultiModeValue des: The mode used for generating particles along the radius."
	}
,
	"ParticleSystem.ShapeModule.radiusSpeed": {
		"prefix": "ParticleSystem.ShapeModule.radiusSpeed",
		"body": [
			"radiusSpeed"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: When using one of the animated modes, how quickly to move the emission position along the radius."
	}
,
	"ParticleSystem.ShapeModule.radiusSpeedMultiplier": {
		"prefix": "ParticleSystem.ShapeModule.radiusSpeedMultiplier",
		"body": [
			"radiusSpeedMultiplier"
		],
		"description": "return:float des: A multiplier of the radius speed of the emission shape."
	}
,
	"ParticleSystem.ShapeModule.radiusSpread": {
		"prefix": "ParticleSystem.ShapeModule.radiusSpread",
		"body": [
			"radiusSpread"
		],
		"description": "return:float des: Control the gap between emission points along the radius."
	}
,
	"ParticleSystem.ShapeModule.radiusThickness": {
		"prefix": "ParticleSystem.ShapeModule.radiusThickness",
		"body": [
			"radiusThickness"
		],
		"description": "return:float des: Thickness of the radius."
	}
,
	"ParticleSystem.ShapeModule.randomDirectionAmount": {
		"prefix": "ParticleSystem.ShapeModule.randomDirectionAmount",
		"body": [
			"randomDirectionAmount"
		],
		"description": "return:float des: Randomizes the starting direction of particles."
	}
,
	"ParticleSystem.ShapeModule.randomPositionAmount": {
		"prefix": "ParticleSystem.ShapeModule.randomPositionAmount",
		"body": [
			"randomPositionAmount"
		],
		"description": "return:float des: Randomizes the starting position of particles."
	}
,
	"ParticleSystem.ShapeModule.rotation": {
		"prefix": "ParticleSystem.ShapeModule.rotation",
		"body": [
			"rotation"
		],
		"description": "return:Vector3 des: Apply a rotation to the shape from which particles are emitted."
	}
,
	"ParticleSystem.ShapeModule.scale": {
		"prefix": "ParticleSystem.ShapeModule.scale",
		"body": [
			"scale"
		],
		"description": "return:Vector3 des: Apply scale to the shape from which particles are emitted."
	}
,
	"ParticleSystem.ShapeModule.shapeType": {
		"prefix": "ParticleSystem.ShapeModule.shapeType",
		"body": [
			"shapeType"
		],
		"description": "return:ParticleSystemShapeType des: Type of shape to emit particles from."
	}
,
	"ParticleSystem.ShapeModule.skinnedMeshRenderer": {
		"prefix": "ParticleSystem.ShapeModule.skinnedMeshRenderer",
		"body": [
			"skinnedMeshRenderer"
		],
		"description": "return:SkinnedMeshRenderer des: SkinnedMeshRenderer to emit particles from."
	}
,
	"ParticleSystem.ShapeModule.sphericalDirectionAmount": {
		"prefix": "ParticleSystem.ShapeModule.sphericalDirectionAmount",
		"body": [
			"sphericalDirectionAmount"
		],
		"description": "return:float des: Spherizes the starting direction of particles."
	}
,
	"ParticleSystem.ShapeModule.sprite": {
		"prefix": "ParticleSystem.ShapeModule.sprite",
		"body": [
			"sprite"
		],
		"description": "return:Sprite des: Sprite to emit particles from."
	}
,
	"ParticleSystem.ShapeModule.spriteRenderer": {
		"prefix": "ParticleSystem.ShapeModule.spriteRenderer",
		"body": [
			"spriteRenderer"
		],
		"description": "return:SpriteRenderer des: SpriteRenderer to emit particles from."
	}
,
	"ParticleSystem.ShapeModule.texture": {
		"prefix": "ParticleSystem.ShapeModule.texture",
		"body": [
			"texture"
		],
		"description": "return:Texture2D des: Selects a texture to be used for tinting particle start colors."
	}
,
	"ParticleSystem.ShapeModule.textureAlphaAffectsParticles": {
		"prefix": "ParticleSystem.ShapeModule.textureAlphaAffectsParticles",
		"body": [
			"textureAlphaAffectsParticles"
		],
		"description": "return:bool des: When enabled, the alpha channel of the texture is applied to the particle alpha when spawned."
	}
,
	"ParticleSystem.ShapeModule.textureBilinearFiltering": {
		"prefix": "ParticleSystem.ShapeModule.textureBilinearFiltering",
		"body": [
			"textureBilinearFiltering"
		],
		"description": "return:bool des: When enabled, 4 neighboring samples are taken from the texture, and combined to give the final particle value."
	}
,
	"ParticleSystem.ShapeModule.textureClipChannel": {
		"prefix": "ParticleSystem.ShapeModule.textureClipChannel",
		"body": [
			"textureClipChannel"
		],
		"description": "return:ParticleSystemShapeTextureChannel des: Selects which channel of the texture is used for discarding particles."
	}
,
	"ParticleSystem.ShapeModule.textureClipThreshold": {
		"prefix": "ParticleSystem.ShapeModule.textureClipThreshold",
		"body": [
			"textureClipThreshold"
		],
		"description": "return:float des: Discards particles when they are spawned on an area of the texture with a value lower than this threshold."
	}
,
	"ParticleSystem.ShapeModule.textureColorAffectsParticles": {
		"prefix": "ParticleSystem.ShapeModule.textureColorAffectsParticles",
		"body": [
			"textureColorAffectsParticles"
		],
		"description": "return:bool des: When enabled, the RGB channels of the texture are applied to the particle color when spawned."
	}
,
	"ParticleSystem.ShapeModule.textureUVChannel": {
		"prefix": "ParticleSystem.ShapeModule.textureUVChannel",
		"body": [
			"textureUVChannel"
		],
		"description": "return:int des: When using a Mesh as a source shape type, this option controls which UV channel on the Mesh is used for reading the source texture."
	}
,
	"ParticleSystem.ShapeModule.useMeshColors": {
		"prefix": "ParticleSystem.ShapeModule.useMeshColors",
		"body": [
			"useMeshColors"
		],
		"description": "return:bool des: Modulate the particle colors with the vertex colors, or the material color if no vertex colors exist."
	}
,
	"ParticleSystem.ShapeModule.useMeshMaterialIndex": {
		"prefix": "ParticleSystem.ShapeModule.useMeshMaterialIndex",
		"body": [
			"useMeshMaterialIndex"
		],
		"description": "return:bool des: Emit from a single material, or the whole mesh."
	}
,
	"ParticleSystem.SizeBySpeedModule.enabled": {
		"prefix": "ParticleSystem.SizeBySpeedModule.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enable/disable the Size By Speed module."
	}
,
	"ParticleSystem.SizeBySpeedModule.range": {
		"prefix": "ParticleSystem.SizeBySpeedModule.range",
		"body": [
			"range"
		],
		"description": "return:Vector2 des: Apply the size curve between these minimum and maximum speeds."
	}
,
	"ParticleSystem.SizeBySpeedModule.separateAxes": {
		"prefix": "ParticleSystem.SizeBySpeedModule.separateAxes",
		"body": [
			"separateAxes"
		],
		"description": "return:bool des: Set the size by speed on each axis separately."
	}
,
	"ParticleSystem.SizeBySpeedModule.size": {
		"prefix": "ParticleSystem.SizeBySpeedModule.size",
		"body": [
			"size"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Curve to control particle size based on speed."
	}
,
	"ParticleSystem.SizeBySpeedModule.sizeMultiplier": {
		"prefix": "ParticleSystem.SizeBySpeedModule.sizeMultiplier",
		"body": [
			"sizeMultiplier"
		],
		"description": "return:float des: Size multiplier."
	}
,
	"ParticleSystem.SizeBySpeedModule.x": {
		"prefix": "ParticleSystem.SizeBySpeedModule.x",
		"body": [
			"x"
		],
		"description": "return:ParticleSystem.MinMaCurve des: Size by speed curve for the X axis."
	}
,
	"ParticleSystem.SizeBySpeedModule.xMultiplier": {
		"prefix": "ParticleSystem.SizeBySpeedModule.xMultiplier",
		"body": [
			"xMultiplier"
		],
		"description": "return:float des: X axis size multiplier."
	}
,
	"ParticleSystem.SizeBySpeedModule.y": {
		"prefix": "ParticleSystem.SizeBySpeedModule.y",
		"body": [
			"y"
		],
		"description": "return:ParticleSstem.MinMaxCurve des: Size by speed curve for the Y axis."
	}
,
	"ParticleSystem.SizeBySpeedModule.yMultiplier": {
		"prefix": "ParticleSystem.SizeBySpeedModule.yMultiplier",
		"body": [
			"yMultiplier"
		],
		"description": "return:float des: Y axis size multiplier."
	}
,
	"ParticleSystem.SizeBySpeedModule.z": {
		"prefix": "ParticleSystem.SizeBySpeedModule.z",
		"body": [
			"z"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Size by speed curve for the Z axis."
	}
,
	"ParticleSystem.SizeBySpeedModule.zMultiplier": {
		"prefix": "ParticleSystem.SizeBySpeedModule.zMultiplier",
		"body": [
			"zMultiplier"
		],
		"description": "return:float des: Z axis size multiplier."
	}
,
	"ParticleSystem.SizeOverLifetimeModule.enabled": {
		"prefix": "ParticleSystem.SizeOverLifetimeModule.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enable/disable the Size Over Lifetime module."
	}
,
	"ParticleSystem.SizeOverLifetimeModule.separateAxes": {
		"prefix": "ParticleSystem.SizeOverLifetimeModule.separateAxes",
		"body": [
			"separateAxes"
		],
		"description": "return:bool des: Set the size over lifetime on each axis separately."
	}
,
	"ParticleSystem.SizeOverLifetimeModule.size": {
		"prefix": "ParticleSystem.SizeOverLifetimeModule.size",
		"body": [
			"size"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Curve to control particle size based on lifetime."
	}
,
	"ParticleSystem.SizeOverLifetimeModule.sizeMultiplier": {
		"prefix": "ParticleSystem.SizeOverLifetimeModule.sizeMultiplier",
		"body": [
			"sizeMultiplier"
		],
		"description": "return:float des: Size multiplier."
	}
,
	"ParticleSystem.SizeOverLifetimeModule.x": {
		"prefix": "ParticleSystem.SizeOverLifetimeModule.x",
		"body": [
			"x"
		],
		"description": "return:ParticleSystem.MinMaCurve des: Size over lifetime curve for the X axis."
	}
,
	"ParticleSystem.SizeOverLifetimeModule.xMultiplier": {
		"prefix": "ParticleSystem.SizeOverLifetimeModule.xMultiplier",
		"body": [
			"xMultiplier"
		],
		"description": "return:float des: X axis size multiplier."
	}
,
	"ParticleSystem.SizeOverLifetimeModule.y": {
		"prefix": "ParticleSystem.SizeOverLifetimeModule.y",
		"body": [
			"y"
		],
		"description": "return:ParticleSstem.MinMaxCurve des: Size over lifetime curve for the Y axis."
	}
,
	"ParticleSystem.SizeOverLifetimeModule.yMultiplier": {
		"prefix": "ParticleSystem.SizeOverLifetimeModule.yMultiplier",
		"body": [
			"yMultiplier"
		],
		"description": "return:float des: Y axis size multiplier."
	}
,
	"ParticleSystem.SizeOverLifetimeModule.z": {
		"prefix": "ParticleSystem.SizeOverLifetimeModule.z",
		"body": [
			"z"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Size over lifetime curve for the Z axis."
	}
,
	"ParticleSystem.SizeOverLifetimeModule.zMultiplier": {
		"prefix": "ParticleSystem.SizeOverLifetimeModule.zMultiplier",
		"body": [
			"zMultiplier"
		],
		"description": "return:float des: Z axis size multiplier."
	}
,
	"ParticleSystem.SubEmittersModule.enabled": {
		"prefix": "ParticleSystem.SubEmittersModule.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enable/disable the Sub Emitters module."
	}
,
	"ParticleSystem.SubEmittersModule.subEmittersCount": {
		"prefix": "ParticleSystem.SubEmittersModule.subEmittersCount",
		"body": [
			"subEmittersCount"
		],
		"description": "return:int des: The total number of sub-emitters."
	}
,
	"ParticleSystem.SubEmittersModule.AddSubEmitter": {
		"prefix": "ParticleSystem.SubEmittersModule.AddSubEmitter",
		"body": [
			"AddSubEmitter($1)"
		],
		"description": "public void AddSubEmitter(ParticleSystem subEmitter, ParticleSystemSubEmitterType type, ParticleSystemSubEmitterProperties properties); des: Add a new sub-emitter."
	}
,
	"ParticleSystem.SubEmittersModule.GetSubEmitterProperties": {
		"prefix": "ParticleSystem.SubEmittersModule.GetSubEmitterProperties",
		"body": [
			"GetSubEmitterProperties($1)"
		],
		"description": "public ParticleSystemSubEmitterProperties GetSubEmitterProperties(int index); des: Get the properties of the sub-emitter at the given index."
	}
,
	"ParticleSystem.SubEmittersModule.GetSubEmitterSystem": {
		"prefix": "ParticleSystem.SubEmittersModule.GetSubEmitterSystem",
		"body": [
			"GetSubEmitterSystem($1)"
		],
		"description": "public ParticleSystem GetSubEmitterSystem(int index); des: Get the sub-emitter Particle System at the given index."
	}
,
	"ParticleSystem.SubEmittersModule.GetSubEmitterType": {
		"prefix": "ParticleSystem.SubEmittersModule.GetSubEmitterType",
		"body": [
			"GetSubEmitterType($1)"
		],
		"description": "public ParticleSystemSubEmitterType GetSubEmitterType(int index); des: Get the type of the sub-emitter at the given index."
	}
,
	"ParticleSystem.SubEmittersModule.RemoveSubEmitter": {
		"prefix": "ParticleSystem.SubEmittersModule.RemoveSubEmitter",
		"body": [
			"RemoveSubEmitter($1)"
		],
		"description": "public void RemoveSubEmitter(int index); des: Remove a sub-emitter from the given index in the array."
	}
,
	"ParticleSystem.SubEmittersModule.SetSubEmitterProperties": {
		"prefix": "ParticleSystem.SubEmittersModule.SetSubEmitterProperties",
		"body": [
			"SetSubEmitterProperties($1)"
		],
		"description": "public void SetSubEmitterProperties(int index, ParticleSystemSubEmitterProperties properties); des: Set the properties of the sub-emitter at the given index."
	}
,
	"ParticleSystem.SubEmittersModule.SetSubEmitterSystem": {
		"prefix": "ParticleSystem.SubEmittersModule.SetSubEmitterSystem",
		"body": [
			"SetSubEmitterSystem($1)"
		],
		"description": "public void SetSubEmitterSystem(int index, ParticleSystem subEmitter); des: Set the Particle System to use as the sub-emitter at the given index."
	}
,
	"ParticleSystem.SubEmittersModule.SetSubEmitterType": {
		"prefix": "ParticleSystem.SubEmittersModule.SetSubEmitterType",
		"body": [
			"SetSubEmitterType($1)"
		],
		"description": "public void SetSubEmitterType(int index, ParticleSystemSubEmitterType type); des: Set the type of the sub-emitter at the given index."
	}
,
	"ParticleSystem.TextureSheetAnimationModule.animation": {
		"prefix": "ParticleSystem.TextureSheetAnimationModule.animation",
		"body": [
			"animation"
		],
		"description": "return:ParticleSystemAnimationType des: Specifies the animation type."
	}
,
	"ParticleSystem.TextureSheetAnimationModule.cycleCount": {
		"prefix": "ParticleSystem.TextureSheetAnimationModule.cycleCount",
		"body": [
			"cycleCount"
		],
		"description": "return:int des: Specifies how many times the animation will loop during the lifetime of the particle."
	}
,
	"ParticleSystem.TextureSheetAnimationModule.enabled": {
		"prefix": "ParticleSystem.TextureSheetAnimationModule.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enable/disable the Texture Sheet Animation module."
	}
,
	"ParticleSystem.TextureSheetAnimationModule.flipU": {
		"prefix": "ParticleSystem.TextureSheetAnimationModule.flipU",
		"body": [
			"flipU"
		],
		"description": "return:float des: Flip the U coordinate on particles, causing them to appear mirrored horizontally."
	}
,
	"ParticleSystem.TextureSheetAnimationModule.flipV": {
		"prefix": "ParticleSystem.TextureSheetAnimationModule.flipV",
		"body": [
			"flipV"
		],
		"description": "return:float des: Flip the V coordinate on particles, causing them to appear mirrored vertically."
	}
,
	"ParticleSystem.TextureSheetAnimationModule.frameOverTime": {
		"prefix": "ParticleSystem.TextureSheetAnimationModule.frameOverTime",
		"body": [
			"frameOverTime"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Curve to control which frame of the texture sheet animation to play."
	}
,
	"ParticleSystem.TextureSheetAnimationModule.frameOverTimeMultiplier": {
		"prefix": "ParticleSystem.TextureSheetAnimationModule.frameOverTimeMultiplier",
		"body": [
			"frameOverTimeMultiplier"
		],
		"description": "return:float des: Frame over time mutiplier."
	}
,
	"ParticleSystem.TextureSheetAnimationModule.mode": {
		"prefix": "ParticleSystem.TextureSheetAnimationModule.mode",
		"body": [
			"mode"
		],
		"description": "return:ParticleSystemAnimationMode des: Select whether the animated texture information comes from a grid of frames on a single texture, or from a list of Sprite objects."
	}
,
	"ParticleSystem.TextureSheetAnimationModule.numTilesX": {
		"prefix": "ParticleSystem.TextureSheetAnimationModule.numTilesX",
		"body": [
			"numTilesX"
		],
		"description": "return:int des: Defines the tiling of the texture in the X axis."
	}
,
	"ParticleSystem.TextureSheetAnimationModule.numTilesY": {
		"prefix": "ParticleSystem.TextureSheetAnimationModule.numTilesY",
		"body": [
			"numTilesY"
		],
		"description": "return:int des: Defines the tiling of the texture in the Y axis."
	}
,
	"ParticleSystem.TextureSheetAnimationModule.rowIndex": {
		"prefix": "ParticleSystem.TextureSheetAnimationModule.rowIndex",
		"body": [
			"rowIndex"
		],
		"description": "return:int des: Explicitly select which row of the texture sheet is used, when ParticleSystem.TextureSheetAnimationModule.useRandomRow is set to false."
	}
,
	"ParticleSystem.TextureSheetAnimationModule.spriteCount": {
		"prefix": "ParticleSystem.TextureSheetAnimationModule.spriteCount",
		"body": [
			"spriteCount"
		],
		"description": "return:int des: The total number of sprites."
	}
,
	"ParticleSystem.TextureSheetAnimationModule.startFrame": {
		"prefix": "ParticleSystem.TextureSheetAnimationModule.startFrame",
		"body": [
			"startFrame"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Define a random starting frame for the texture sheet animation."
	}
,
	"ParticleSystem.TextureSheetAnimationModule.startFrameMultiplier": {
		"prefix": "ParticleSystem.TextureSheetAnimationModule.startFrameMultiplier",
		"body": [
			"startFrameMultiplier"
		],
		"description": "return:float des: Starting frame multiplier."
	}
,
	"ParticleSystem.TextureSheetAnimationModule.useRandomRow": {
		"prefix": "ParticleSystem.TextureSheetAnimationModule.useRandomRow",
		"body": [
			"useRandomRow"
		],
		"description": "return:bool des: Use a random row of the texture sheet for each particle emitted."
	}
,
	"ParticleSystem.TextureSheetAnimationModule.uvChannelMask": {
		"prefix": "ParticleSystem.TextureSheetAnimationModule.uvChannelMask",
		"body": [
			"uvChannelMask"
		],
		"description": "return:Rendering.UVChannelFlags des: Choose which UV channels will receive texture animation."
	}
,
	"ParticleSystem.TextureSheetAnimationModule.AddSprite": {
		"prefix": "ParticleSystem.TextureSheetAnimationModule.AddSprite",
		"body": [
			"AddSprite($1)"
		],
		"description": "public void AddSprite(Sprite sprite); des: Add a new Sprite."
	}
,
	"ParticleSystem.TextureSheetAnimationModule.GetSprite": {
		"prefix": "ParticleSystem.TextureSheetAnimationModule.GetSprite",
		"body": [
			"GetSprite($1)"
		],
		"description": "public Sprite GetSprite(int index); des: Get the Sprite at the given index."
	}
,
	"ParticleSystem.TextureSheetAnimationModule.RemoveSprite": {
		"prefix": "ParticleSystem.TextureSheetAnimationModule.RemoveSprite",
		"body": [
			"RemoveSprite($1)"
		],
		"description": "public void RemoveSprite(int index); des: Remove a Sprite from the given index in the array."
	}
,
	"ParticleSystem.TextureSheetAnimationModule.SetSprite": {
		"prefix": "ParticleSystem.TextureSheetAnimationModule.SetSprite",
		"body": [
			"SetSprite($1)"
		],
		"description": "public void SetSprite(int index, Sprite sprite); des: Set the Sprite at the given index."
	}
,
	"ParticleSystem.TrailModule.colorOverLifetime": {
		"prefix": "ParticleSystem.TrailModule.colorOverLifetime",
		"body": [
			"colorOverLifetime"
		],
		"description": "return:ParticleSystem.MinMaxGradient des: The gradient controlling the trail colors during the lifetime of the attached particle."
	}
,
	"ParticleSystem.TrailModule.colorOverTrail": {
		"prefix": "ParticleSystem.TrailModule.colorOverTrail",
		"body": [
			"colorOverTrail"
		],
		"description": "return:ParticleSystem.MinMaxGradient des: The gradient controlling the trail colors over the length of the trail."
	}
,
	"ParticleSystem.TrailModule.dieWithParticles": {
		"prefix": "ParticleSystem.TrailModule.dieWithParticles",
		"body": [
			"dieWithParticles"
		],
		"description": "return:bool des: If enabled, Trails will disappear immediately when their owning particle dies. Otherwise, the trail will persist until all its points have naturally expired, based on its lifetime."
	}
,
	"ParticleSystem.TrailModule.enabled": {
		"prefix": "ParticleSystem.TrailModule.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enable/disable the Trail module."
	}
,
	"ParticleSystem.TrailModule.generateLightingData": {
		"prefix": "ParticleSystem.TrailModule.generateLightingData",
		"body": [
			"generateLightingData"
		],
		"description": "return:bool des: Configures the trails to generate Normals and Tangents. With this data, Scene lighting can affect the trails via Normal Maps and the Unity Standard Shader, or your own custom-built Shaders."
	}
,
	"ParticleSystem.TrailModule.inheritParticleColor": {
		"prefix": "ParticleSystem.TrailModule.inheritParticleColor",
		"body": [
			"inheritParticleColor"
		],
		"description": "return:bool des: Toggle whether the trail will inherit the particle color as its starting color."
	}
,
	"ParticleSystem.TrailModule.lifetime": {
		"prefix": "ParticleSystem.TrailModule.lifetime",
		"body": [
			"lifetime"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: The curve describing the trail lifetime, throughout the lifetime of the particle."
	}
,
	"ParticleSystem.TrailModule.lifetimeMultiplier": {
		"prefix": "ParticleSystem.TrailModule.lifetimeMultiplier",
		"body": [
			"lifetimeMultiplier"
		],
		"description": "return:float des: Change the lifetime multiplier."
	}
,
	"ParticleSystem.TrailModule.minVertexDistance": {
		"prefix": "ParticleSystem.TrailModule.minVertexDistance",
		"body": [
			"minVertexDistance"
		],
		"description": "return:float des: Set the minimum distance each trail can travel before a new vertex is added to it."
	}
,
	"ParticleSystem.TrailModule.mode": {
		"prefix": "ParticleSystem.TrailModule.mode",
		"body": [
			"mode"
		],
		"description": "return:ParticleSystemTrailMode des: Choose how particle trails are generated."
	}
,
	"ParticleSystem.TrailModule.ratio": {
		"prefix": "ParticleSystem.TrailModule.ratio",
		"body": [
			"ratio"
		],
		"description": "return:float des: Choose what proportion of particles will receive a trail."
	}
,
	"ParticleSystem.TrailModule.ribbonCount": {
		"prefix": "ParticleSystem.TrailModule.ribbonCount",
		"body": [
			"ribbonCount"
		],
		"description": "return:int des: Select how many lines to create through the Particle System."
	}
,
	"ParticleSystem.TrailModule.sizeAffectsLifetime": {
		"prefix": "ParticleSystem.TrailModule.sizeAffectsLifetime",
		"body": [
			"sizeAffectsLifetime"
		],
		"description": "return:bool des: Set whether the particle size will act as a multiplier on top of the trail lifetime."
	}
,
	"ParticleSystem.TrailModule.sizeAffectsWidth": {
		"prefix": "ParticleSystem.TrailModule.sizeAffectsWidth",
		"body": [
			"sizeAffectsWidth"
		],
		"description": "return:bool des: Set whether the particle size will act as a multiplier on top of the trail width."
	}
,
	"ParticleSystem.TrailModule.textureMode": {
		"prefix": "ParticleSystem.TrailModule.textureMode",
		"body": [
			"textureMode"
		],
		"description": "return:ParticleSystemTrailTextureMode des: Choose whether the U coordinate of the trail texture is tiled or stretched."
	}
,
	"ParticleSystem.TrailModule.widthOverTrail": {
		"prefix": "ParticleSystem.TrailModule.widthOverTrail",
		"body": [
			"widthOverTrail"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: The curve describing the width, of each trail point."
	}
,
	"ParticleSystem.TrailModule.widthOverTrailMultiplier": {
		"prefix": "ParticleSystem.TrailModule.widthOverTrailMultiplier",
		"body": [
			"widthOverTrailMultiplier"
		],
		"description": "return:float des: Change the width multiplier."
	}
,
	"ParticleSystem.TrailModule.worldSpace": {
		"prefix": "ParticleSystem.TrailModule.worldSpace",
		"body": [
			"worldSpace"
		],
		"description": "return:bool des: Drop new trail points in world space, regardless of Particle System Simulation Space."
	}
,
	"ParticleSystem.TriggerModule.enabled": {
		"prefix": "ParticleSystem.TriggerModule.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enable/disable the Trigger module."
	}
,
	"ParticleSystem.TriggerModule.enter": {
		"prefix": "ParticleSystem.TriggerModule.enter",
		"body": [
			"enter"
		],
		"description": "return:ParticleSystemOverlapAction des: Choose what action to perform when particles enter the trigger volume."
	}
,
	"ParticleSystem.TriggerModule.exit": {
		"prefix": "ParticleSystem.TriggerModule.exit",
		"body": [
			"exit"
		],
		"description": "return:ParticleSystemOverlapAction des: Choose what action to perform when particles leave the trigger volume."
	}
,
	"ParticleSystem.TriggerModule.inside": {
		"prefix": "ParticleSystem.TriggerModule.inside",
		"body": [
			"inside"
		],
		"description": "return:ParticleSystemOverlapAction des: Choose what action to perform when particles are inside the trigger volume."
	}
,
	"ParticleSystem.TriggerModule.maxColliderCount": {
		"prefix": "ParticleSystem.TriggerModule.maxColliderCount",
		"body": [
			"maxColliderCount"
		],
		"description": "return:int des: The maximum number of collision shapes that can be attached to this particle system trigger."
	}
,
	"ParticleSystem.TriggerModule.outside": {
		"prefix": "ParticleSystem.TriggerModule.outside",
		"body": [
			"outside"
		],
		"description": "return:ParticleSystemOverlapAction des: Choose what action to perform when particles are outside the trigger volume."
	}
,
	"ParticleSystem.TriggerModule.radiusScale": {
		"prefix": "ParticleSystem.TriggerModule.radiusScale",
		"body": [
			"radiusScale"
		],
		"description": "return:float des: A multiplier applied to the size of each particle before overlaps are processed."
	}
,
	"ParticleSystem.TriggerModule.GetCollider": {
		"prefix": "ParticleSystem.TriggerModule.GetCollider",
		"body": [
			"GetCollider($1)"
		],
		"description": "public Component GetCollider(int index); des: Get a collision shape associated with this particle system trigger."
	}
,
	"ParticleSystem.TriggerModule.SetCollider": {
		"prefix": "ParticleSystem.TriggerModule.SetCollider",
		"body": [
			"SetCollider($1)"
		],
		"description": "public void SetCollider(int index, Component collider); des: Set a collision shape associated with this particle system trigger."
	}
,
	"ParticleSystem.VelocityOverLifetimeModule.enabled": {
		"prefix": "ParticleSystem.VelocityOverLifetimeModule.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enable/disable the Velocity Over Lifetime module."
	}
,
	"ParticleSystem.VelocityOverLifetimeModule.orbitalOffsetX": {
		"prefix": "ParticleSystem.VelocityOverLifetimeModule.orbitalOffsetX",
		"body": [
			"orbitalOffsetX"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Specify a custom center of rotation for the orbital and radial velocities."
	}
,
	"ParticleSystem.VelocityOverLifetimeModule.orbitalOffsetXMultiplier": {
		"prefix": "ParticleSystem.VelocityOverLifetimeModule.orbitalOffsetXMultiplier",
		"body": [
			"orbitalOffsetXMultiplier"
		],
		"description": "return:float des: This method is more efficient than accessing the whole curve, if you only want to change the overall offset multiplier."
	}
,
	"ParticleSystem.VelocityOverLifetimeModule.orbitalOffsetY": {
		"prefix": "ParticleSystem.VelocityOverLifetimeModule.orbitalOffsetY",
		"body": [
			"orbitalOffsetY"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Specify a custom center of rotation for the orbital and radial velocities."
	}
,
	"ParticleSystem.VelocityOverLifetimeModule.orbitalOffsetYMultiplier": {
		"prefix": "ParticleSystem.VelocityOverLifetimeModule.orbitalOffsetYMultiplier",
		"body": [
			"orbitalOffsetYMultiplier"
		],
		"description": "return:float des: This method is more efficient than accessing the whole curve, if you only want to change the overall offset multiplier."
	}
,
	"ParticleSystem.VelocityOverLifetimeModule.orbitalOffsetZ": {
		"prefix": "ParticleSystem.VelocityOverLifetimeModule.orbitalOffsetZ",
		"body": [
			"orbitalOffsetZ"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Specify a custom center of rotation for the orbital and radial velocities."
	}
,
	"ParticleSystem.VelocityOverLifetimeModule.orbitalOffsetZMultiplier": {
		"prefix": "ParticleSystem.VelocityOverLifetimeModule.orbitalOffsetZMultiplier",
		"body": [
			"orbitalOffsetZMultiplier"
		],
		"description": "return:float des: This method is more efficient than accessing the whole curve, if you only want to change the overall offset multiplier."
	}
,
	"ParticleSystem.VelocityOverLifetimeModule.orbitalX": {
		"prefix": "ParticleSystem.VelocityOverLifetimeModule.orbitalX",
		"body": [
			"orbitalX"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Curve to control particle speed based on lifetime, around the X axis."
	}
,
	"ParticleSystem.VelocityOverLifetimeModule.orbitalXMultiplier": {
		"prefix": "ParticleSystem.VelocityOverLifetimeModule.orbitalXMultiplier",
		"body": [
			"orbitalXMultiplier"
		],
		"description": "return:float des: X axis speed multiplier."
	}
,
	"ParticleSystem.VelocityOverLifetimeModule.orbitalY": {
		"prefix": "ParticleSystem.VelocityOverLifetimeModule.orbitalY",
		"body": [
			"orbitalY"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Curve to control particle speed based on lifetime, around the Y axis."
	}
,
	"ParticleSystem.VelocityOverLifetimeModule.orbitalYMultiplier": {
		"prefix": "ParticleSystem.VelocityOverLifetimeModule.orbitalYMultiplier",
		"body": [
			"orbitalYMultiplier"
		],
		"description": "return:float des: Y axis speed multiplier."
	}
,
	"ParticleSystem.VelocityOverLifetimeModule.orbitalZ": {
		"prefix": "ParticleSystem.VelocityOverLifetimeModule.orbitalZ",
		"body": [
			"orbitalZ"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Curve to control particle speed based on lifetime, around the Z axis."
	}
,
	"ParticleSystem.VelocityOverLifetimeModule.orbitalZMultiplier": {
		"prefix": "ParticleSystem.VelocityOverLifetimeModule.orbitalZMultiplier",
		"body": [
			"orbitalZMultiplier"
		],
		"description": "return:float des: Z axis speed multiplier."
	}
,
	"ParticleSystem.VelocityOverLifetimeModule.radial": {
		"prefix": "ParticleSystem.VelocityOverLifetimeModule.radial",
		"body": [
			"radial"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Curve to control particle speed based on lifetime, away from a center position."
	}
,
	"ParticleSystem.VelocityOverLifetimeModule.radialMultiplier": {
		"prefix": "ParticleSystem.VelocityOverLifetimeModule.radialMultiplier",
		"body": [
			"radialMultiplier"
		],
		"description": "return:float des: Radial speed multiplier."
	}
,
	"ParticleSystem.VelocityOverLifetimeModule.space": {
		"prefix": "ParticleSystem.VelocityOverLifetimeModule.space",
		"body": [
			"space"
		],
		"description": "return:ParticleSystemSimulationSpace des: Specifies if the velocities are in local space (rotated with the transform) or world space."
	}
,
	"ParticleSystem.VelocityOverLifetimeModule.speedModifier": {
		"prefix": "ParticleSystem.VelocityOverLifetimeModule.speedModifier",
		"body": [
			"speedModifier"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Curve to control particle speed based on lifetime, without affecting the direction of the particles."
	}
,
	"ParticleSystem.VelocityOverLifetimeModule.speedModifierMultiplier": {
		"prefix": "ParticleSystem.VelocityOverLifetimeModule.speedModifierMultiplier",
		"body": [
			"speedModifierMultiplier"
		],
		"description": "return:float des: Speed multiplier."
	}
,
	"ParticleSystem.VelocityOverLifetimeModule.x": {
		"prefix": "ParticleSystem.VelocityOverLifetimeModule.x",
		"body": [
			"x"
		],
		"description": "return:ParticleSystem.MinMaCurve des: Curve to control particle speed based on lifetime, on the X axis."
	}
,
	"ParticleSystem.VelocityOverLifetimeModule.xMultiplier": {
		"prefix": "ParticleSystem.VelocityOverLifetimeModule.xMultiplier",
		"body": [
			"xMultiplier"
		],
		"description": "return:float des: X axis speed multiplier."
	}
,
	"ParticleSystem.VelocityOverLifetimeModule.y": {
		"prefix": "ParticleSystem.VelocityOverLifetimeModule.y",
		"body": [
			"y"
		],
		"description": "return:ParticleSstem.MinMaxCurve des: Curve to control particle speed based on lifetime, on the Y axis."
	}
,
	"ParticleSystem.VelocityOverLifetimeModule.yMultiplier": {
		"prefix": "ParticleSystem.VelocityOverLifetimeModule.yMultiplier",
		"body": [
			"yMultiplier"
		],
		"description": "return:float des: Y axis speed multiplier."
	}
,
	"ParticleSystem.VelocityOverLifetimeModule.z": {
		"prefix": "ParticleSystem.VelocityOverLifetimeModule.z",
		"body": [
			"z"
		],
		"description": "return:ParticleSystem.MinMaxCurve des: Curve to control particle speed based on lifetime, on the Z axis."
	}
,
	"ParticleSystem.VelocityOverLifetimeModule.zMultiplier": {
		"prefix": "ParticleSystem.VelocityOverLifetimeModule.zMultiplier",
		"body": [
			"zMultiplier"
		],
		"description": "return:float des: Z axis speed multiplier."
	}
,
	"ParticleSystemRenderer.activeVertexStreamsCount": {
		"prefix": "ParticleSystemRenderer.activeVertexStreamsCount",
		"body": [
			"activeVertexStreamsCount"
		],
		"description": "return:int des: The number of currently active custom vertex streams."
	}
,
	"ParticleSystemRenderer.alignment": {
		"prefix": "ParticleSystemRenderer.alignment",
		"body": [
			"alignment"
		],
		"description": "return:ParticleSystemRenderSpace des: Control the direction that particles face."
	}
,
	"ParticleSystemRenderer.cameraVelocityScale": {
		"prefix": "ParticleSystemRenderer.cameraVelocityScale",
		"body": [
			"cameraVelocityScale"
		],
		"description": "return:float des: How much are the particles stretched depending on the Camera's speed."
	}
,
	"ParticleSystemRenderer.enableGPUInstancing": {
		"prefix": "ParticleSystemRenderer.enableGPUInstancing",
		"body": [
			"enableGPUInstancing"
		],
		"description": "return:bool des: Enables GPU Instancing on platforms where it is supported."
	}
,
	"ParticleSystemRenderer.lengthScale": {
		"prefix": "ParticleSystemRenderer.lengthScale",
		"body": [
			"lengthScale"
		],
		"description": "return:float des: How much are the particles stretched in their direction of motion."
	}
,
	"ParticleSystemRenderer.maskInteraction": {
		"prefix": "ParticleSystemRenderer.maskInteraction",
		"body": [
			"maskInteraction"
		],
		"description": "return:SpriteMaskInteraction des: Specifies how the Particle System Renderer interacts with SpriteMask."
	}
,
	"ParticleSystemRenderer.maxParticleSize": {
		"prefix": "ParticleSystemRenderer.maxParticleSize",
		"body": [
			"maxParticleSize"
		],
		"description": "return:float des: Clamp the maximum particle size."
	}
,
	"ParticleSystemRenderer.mesh": {
		"prefix": "ParticleSystemRenderer.mesh",
		"body": [
			"mesh"
		],
		"description": "return:Mesh des: Mesh used as particle instead of billboarded texture."
	}
,
	"ParticleSystemRenderer.meshCount": {
		"prefix": "ParticleSystemRenderer.meshCount",
		"body": [
			"meshCount"
		],
		"description": "return:int des: The number of meshes being used for particle rendering."
	}
,
	"ParticleSystemRenderer.minParticleSize": {
		"prefix": "ParticleSystemRenderer.minParticleSize",
		"body": [
			"minParticleSize"
		],
		"description": "return:float des: Clamp the minimum particle size."
	}
,
	"ParticleSystemRenderer.normalDirection": {
		"prefix": "ParticleSystemRenderer.normalDirection",
		"body": [
			"normalDirection"
		],
		"description": "return:float des: How much are billboard particle normals oriented towards the camera."
	}
,
	"ParticleSystemRenderer.pivot": {
		"prefix": "ParticleSystemRenderer.pivot",
		"body": [
			"pivot"
		],
		"description": "return:Vector3 des: Modify the pivot point used for rotating particles."
	}
,
	"ParticleSystemRenderer.renderMode": {
		"prefix": "ParticleSystemRenderer.renderMode",
		"body": [
			"renderMode"
		],
		"description": "return:ParticleSystemRenderMode des: How particles are drawn."
	}
,
	"ParticleSystemRenderer.sortingFudge": {
		"prefix": "ParticleSystemRenderer.sortingFudge",
		"body": [
			"sortingFudge"
		],
		"description": "return:float des: Biases particle system sorting amongst other transparencies."
	}
,
	"ParticleSystemRenderer.sortMode": {
		"prefix": "ParticleSystemRenderer.sortMode",
		"body": [
			"sortMode"
		],
		"description": "return:ParticleSystemSortMode des: Sort particles within a system."
	}
,
	"ParticleSystemRenderer.trailMaterial": {
		"prefix": "ParticleSystemRenderer.trailMaterial",
		"body": [
			"trailMaterial"
		],
		"description": "return:Material des: Set the material used by the Trail module for attaching trails to particles."
	}
,
	"ParticleSystemRenderer.velocityScale": {
		"prefix": "ParticleSystemRenderer.velocityScale",
		"body": [
			"velocityScale"
		],
		"description": "return:float des: How much are the particles stretched depending on \"how fast they move\"."
	}
,
	"ParticleSystemRenderer.BakeMesh": {
		"prefix": "ParticleSystemRenderer.BakeMesh",
		"body": [
			"BakeMesh($1)"
		],
		"description": "public void BakeMesh(Mesh mesh, bool useTransform); public void BakeMesh(Mesh mesh, Camera camera, bool useTransform); des: Creates a snapshot of ParticleSystemRenderer and stores it in mesh."
	}
,
	"ParticleSystemRenderer.BakeTrailsMesh": {
		"prefix": "ParticleSystemRenderer.BakeTrailsMesh",
		"body": [
			"BakeTrailsMesh($1)"
		],
		"description": "public void BakeTrailsMesh(Mesh mesh, bool useTransform); public void BakeTrailsMesh(Mesh mesh, Camera camera, bool useTransform); des: Creates a snapshot of ParticleSystem Trails and stores them in mesh."
	}
,
	"ParticleSystemRenderer.GetActiveVertexStreams": {
		"prefix": "ParticleSystemRenderer.GetActiveVertexStreams",
		"body": [
			"GetActiveVertexStreams($1)"
		],
		"description": "public void GetActiveVertexStreams(List<ParticleSystemVertexStream> streams); des: Query which vertex shader streams are enabled on the ParticleSystemRenderer."
	}
,
	"ParticleSystemRenderer.GetMeshes": {
		"prefix": "ParticleSystemRenderer.GetMeshes",
		"body": [
			"GetMeshes($1)"
		],
		"description": "public int GetMeshes(Mesh[] meshes); des: Get the array of meshes to be used as particles."
	}
,
	"ParticleSystemRenderer.SetActiveVertexStreams": {
		"prefix": "ParticleSystemRenderer.SetActiveVertexStreams",
		"body": [
			"SetActiveVertexStreams($1)"
		],
		"description": "public void SetActiveVertexStreams(List<ParticleSystemVertexStream> streams); des: Enable a set of vertex shader streams on the ParticleSystemRenderer."
	}
,
	"ParticleSystemRenderer.SetMeshes": {
		"prefix": "ParticleSystemRenderer.SetMeshes",
		"body": [
			"SetMeshes($1)"
		],
		"description": "public void SetMeshes(Mesh[] meshes); public void SetMeshes(Mesh[] meshes, int size); des: Set an array of meshes to be used as particles when the ParticleSystemRenderer.renderMode is set to ParticleSystemRenderMode.Mesh."
	}
,
	"ParticleSystemRenderer.gameObject": {
		"prefix": "ParticleSystemRenderer.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"ParticleSystemRenderer.tag": {
		"prefix": "ParticleSystemRenderer.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"ParticleSystemRenderer.transform": {
		"prefix": "ParticleSystemRenderer.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"ParticleSystemRenderer.hideFlags": {
		"prefix": "ParticleSystemRenderer.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"ParticleSystemRenderer.name": {
		"prefix": "ParticleSystemRenderer.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"ParticleSystemRenderer.allowOcclusionWhenDynamic": {
		"prefix": "ParticleSystemRenderer.allowOcclusionWhenDynamic",
		"body": [
			"allowOcclusionWhenDynamic"
		],
		"description": "return:bool des: Controls if dynamic occlusion culling should be performed for this renderer."
	}
,
	"ParticleSystemRenderer.bounds": {
		"prefix": "ParticleSystemRenderer.bounds",
		"body": [
			"bounds"
		],
		"description": "return:Bounds des: The bounding volume of the renderer (Read Only)."
	}
,
	"ParticleSystemRenderer.enabled": {
		"prefix": "ParticleSystemRenderer.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Makes the rendered 3D object visible if enabled."
	}
,
	"ParticleSystemRenderer.isPartOfStaticBatch": {
		"prefix": "ParticleSystemRenderer.isPartOfStaticBatch",
		"body": [
			"isPartOfStaticBatch"
		],
		"description": "return:bool des: Has this renderer been statically batched with any other renderers?"
	}
,
	"ParticleSystemRenderer.isVisible": {
		"prefix": "ParticleSystemRenderer.isVisible",
		"body": [
			"isVisible"
		],
		"description": "return:bool des: Is this renderer visible in any camera? (Read Only)"
	}
,
	"ParticleSystemRenderer.lightmapIndex": {
		"prefix": "ParticleSystemRenderer.lightmapIndex",
		"body": [
			"lightmapIndex"
		],
		"description": "return:int des: The index of the baked lightmap applied to this renderer."
	}
,
	"ParticleSystemRenderer.lightmapScaleOffset": {
		"prefix": "ParticleSystemRenderer.lightmapScaleOffset",
		"body": [
			"lightmapScaleOffset"
		],
		"description": "return:Vector4 des: The UV scale & offset used for a lightmap."
	}
,
	"ParticleSystemRenderer.lightProbeProxyVolumeOverride": {
		"prefix": "ParticleSystemRenderer.lightProbeProxyVolumeOverride",
		"body": [
			"lightProbeProxyVolumeOverride"
		],
		"description": "return:GameObject des: If set, the Renderer will use the Light Probe Proxy Volume component attached to the source GameObject."
	}
,
	"ParticleSystemRenderer.lightProbeUsage": {
		"prefix": "ParticleSystemRenderer.lightProbeUsage",
		"body": [
			"lightProbeUsage"
		],
		"description": "return:Rendering.LightProbeUsage des: The light probe interpolation type."
	}
,
	"ParticleSystemRenderer.localToWorldMatrix": {
		"prefix": "ParticleSystemRenderer.localToWorldMatrix",
		"body": [
			"localToWorldMatrix"
		],
		"description": "return:Matrix4x4 des: Matrix that transforms a point from local space into world space (Read Only)."
	}
,
	"ParticleSystemRenderer.material": {
		"prefix": "ParticleSystemRenderer.material",
		"body": [
			"material"
		],
		"description": "return:Material des: Returns the first instantiated Material assigned to the renderer."
	}
,
	"ParticleSystemRenderer.materials": {
		"prefix": "ParticleSystemRenderer.materials",
		"body": [
			"materials"
		],
		"description": "return:Material[] des: Returns all the instantiated materials of this object."
	}
,
	"ParticleSystemRenderer.motionVectorGenerationMode": {
		"prefix": "ParticleSystemRenderer.motionVectorGenerationMode",
		"body": [
			"motionVectorGenerationMode"
		],
		"description": "return:MotionVectorGenerationMode des: Specifies the mode for motion vector rendering."
	}
,
	"ParticleSystemRenderer.probeAnchor": {
		"prefix": "ParticleSystemRenderer.probeAnchor",
		"body": [
			"probeAnchor"
		],
		"description": "return:Transform des: If set, Renderer will use this Transform's position to find the light or reflection probe."
	}
,
	"ParticleSystemRenderer.realtimeLightmapIndex": {
		"prefix": "ParticleSystemRenderer.realtimeLightmapIndex",
		"body": [
			"realtimeLightmapIndex"
		],
		"description": "return:int des: The index of the realtime lightmap applied to this renderer."
	}
,
	"ParticleSystemRenderer.realtimeLightmapScaleOffset": {
		"prefix": "ParticleSystemRenderer.realtimeLightmapScaleOffset",
		"body": [
			"realtimeLightmapScaleOffset"
		],
		"description": "return:Vector4 des: The UV scale & offset used for a realtime lightmap."
	}
,
	"ParticleSystemRenderer.receiveShadows": {
		"prefix": "ParticleSystemRenderer.receiveShadows",
		"body": [
			"receiveShadows"
		],
		"description": "return:bool des: Does this object receive shadows?"
	}
,
	"ParticleSystemRenderer.reflectionProbeUsage": {
		"prefix": "ParticleSystemRenderer.reflectionProbeUsage",
		"body": [
			"reflectionProbeUsage"
		],
		"description": "return:Rendering.ReflectionProbeUsage des: Should reflection probes be used for this Renderer?"
	}
,
	"ParticleSystemRenderer.renderingLayerMask": {
		"prefix": "ParticleSystemRenderer.renderingLayerMask",
		"body": [
			"renderingLayerMask"
		],
		"description": "return:uint des: Determines which rendering layer this renderer lives on."
	}
,
	"ParticleSystemRenderer.shadowCastingMode": {
		"prefix": "ParticleSystemRenderer.shadowCastingMode",
		"body": [
			"shadowCastingMode"
		],
		"description": "return:Rendering.ShadowCastingMode des: Does this object cast shadows?"
	}
,
	"ParticleSystemRenderer.sharedMaterial": {
		"prefix": "ParticleSystemRenderer.sharedMaterial",
		"body": [
			"sharedMaterial"
		],
		"description": "return:Material des: The shared material of this object."
	}
,
	"ParticleSystemRenderer.sharedMaterials": {
		"prefix": "ParticleSystemRenderer.sharedMaterials",
		"body": [
			"sharedMaterials"
		],
		"description": "return:Material[] des: All the shared materials of this object."
	}
,
	"ParticleSystemRenderer.sortingLayerID": {
		"prefix": "ParticleSystemRenderer.sortingLayerID",
		"body": [
			"sortingLayerID"
		],
		"description": "return:int des: Unique ID of the Renderer's sorting layer."
	}
,
	"ParticleSystemRenderer.sortingLayerName": {
		"prefix": "ParticleSystemRenderer.sortingLayerName",
		"body": [
			"sortingLayerName"
		],
		"description": "return:string des: Name of the Renderer's sorting layer."
	}
,
	"ParticleSystemRenderer.sortingOrder": {
		"prefix": "ParticleSystemRenderer.sortingOrder",
		"body": [
			"sortingOrder"
		],
		"description": "return:int des: Renderer's order within a sorting layer."
	}
,
	"ParticleSystemRenderer.worldToLocalMatrix": {
		"prefix": "ParticleSystemRenderer.worldToLocalMatrix",
		"body": [
			"worldToLocalMatrix"
		],
		"description": "return:Matrix4x4 des: Matrix that transforms a point from world space into local space (Read Only)."
	}
,
	"ParticleSystemRenderer.BroadcastMessage": {
		"prefix": "ParticleSystemRenderer.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"ParticleSystemRenderer.CompareTag": {
		"prefix": "ParticleSystemRenderer.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"ParticleSystemRenderer.GetComponent": {
		"prefix": "ParticleSystemRenderer.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"ParticleSystemRenderer.GetComponentInChildren": {
		"prefix": "ParticleSystemRenderer.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"ParticleSystemRenderer.GetComponentInParent": {
		"prefix": "ParticleSystemRenderer.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"ParticleSystemRenderer.GetComponents": {
		"prefix": "ParticleSystemRenderer.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"ParticleSystemRenderer.GetComponentsInChildren": {
		"prefix": "ParticleSystemRenderer.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"ParticleSystemRenderer.GetComponentsInParent": {
		"prefix": "ParticleSystemRenderer.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"ParticleSystemRenderer.SendMessage": {
		"prefix": "ParticleSystemRenderer.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"ParticleSystemRenderer.SendMessageUpwards": {
		"prefix": "ParticleSystemRenderer.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"ParticleSystemRenderer.GetInstanceID": {
		"prefix": "ParticleSystemRenderer.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"ParticleSystemRenderer.ToString": {
		"prefix": "ParticleSystemRenderer.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"ParticleSystemRenderer.GetClosestReflectionProbes": {
		"prefix": "ParticleSystemRenderer.GetClosestReflectionProbes",
		"body": [
			"GetClosestReflectionProbes($1)"
		],
		"description": "public void GetClosestReflectionProbes(List<ReflectionProbeBlendInfo> result); des: Returns an array of closest reflection probes with weights, weight shows how much influence the probe has on the renderer, this value is also used when blending between reflection probes occur."
	}
,
	"ParticleSystemRenderer.GetMaterials": {
		"prefix": "ParticleSystemRenderer.GetMaterials",
		"body": [
			"GetMaterials($1)"
		],
		"description": "public void GetMaterials(List<Material> m); des: Returns all the instantiated materials of this object."
	}
,
	"ParticleSystemRenderer.GetPropertyBlock": {
		"prefix": "ParticleSystemRenderer.GetPropertyBlock",
		"body": [
			"GetPropertyBlock($1)"
		],
		"description": "public void GetPropertyBlock(MaterialPropertyBlock properties); public void GetPropertyBlock(MaterialPropertyBlock properties, int materialIndex); des: Get per-Renderer or per-Material property block."
	}
,
	"ParticleSystemRenderer.GetSharedMaterials": {
		"prefix": "ParticleSystemRenderer.GetSharedMaterials",
		"body": [
			"GetSharedMaterials($1)"
		],
		"description": "public void GetSharedMaterials(List<Material> m); des: Returns all the shared materials of this object."
	}
,
	"ParticleSystemRenderer.HasPropertyBlock": {
		"prefix": "ParticleSystemRenderer.HasPropertyBlock",
		"body": [
			"HasPropertyBlock($1)"
		],
		"description": "public bool HasPropertyBlock(); des: Returns true if the Renderer has a material property block attached via SetPropertyBlock."
	}
,
	"ParticleSystemRenderer.SetPropertyBlock": {
		"prefix": "ParticleSystemRenderer.SetPropertyBlock",
		"body": [
			"SetPropertyBlock($1)"
		],
		"description": "public void SetPropertyBlock(MaterialPropertyBlock properties); public void SetPropertyBlock(MaterialPropertyBlock properties, int materialIndex); des: Lets you set or clear per-renderer or per-material parameter overrides."
	}
,
	"ParticleSystemRenderer.Destroy": {
		"prefix": "ParticleSystemRenderer.Destroy",
		"body": [
			"ParticleSystemRenderer.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"ParticleSystemRenderer.DestroyImmediate": {
		"prefix": "ParticleSystemRenderer.DestroyImmediate",
		"body": [
			"ParticleSystemRenderer.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"ParticleSystemRenderer.DontDestroyOnLoad": {
		"prefix": "ParticleSystemRenderer.DontDestroyOnLoad",
		"body": [
			"ParticleSystemRenderer.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"ParticleSystemRenderer.FindObjectOfType": {
		"prefix": "ParticleSystemRenderer.FindObjectOfType",
		"body": [
			"ParticleSystemRenderer.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"ParticleSystemRenderer.FindObjectsOfType": {
		"prefix": "ParticleSystemRenderer.FindObjectsOfType",
		"body": [
			"ParticleSystemRenderer.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"ParticleSystemRenderer.Instantiate": {
		"prefix": "ParticleSystemRenderer.Instantiate",
		"body": [
			"ParticleSystemRenderer.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"ParticleSystemRenderer.OnBecameInvisible": {
		"prefix": "ParticleSystemRenderer.OnBecameInvisible",
		"body": [
			"OnBecameInvisible"
		],
		"description": "OnBecameInvisible is called when the object is no longer visible by any camera."
	}
,
	"ParticleSystemRenderer.OnBecameVisible": {
		"prefix": "ParticleSystemRenderer.OnBecameVisible",
		"body": [
			"OnBecameVisible"
		],
		"description": "OnBecameVisible is called when the object became visible by any camera."
	}
,
	"PatchExtents.max": {
		"prefix": "PatchExtents.max",
		"body": [
			"max"
		],
		"description": "return:float des: Maximum height of a terrain patch."
	}
,
	"PatchExtents.min": {
		"prefix": "PatchExtents.min",
		"body": [
			"min"
		],
		"description": "return:float des: Minimum height of a terrain patch."
	}
,
	"PhysicMaterial.bounceCombine": {
		"prefix": "PhysicMaterial.bounceCombine",
		"body": [
			"bounceCombine"
		],
		"description": "return:PhysicMaterialCombine des: Determines how the bounciness is combined."
	}
,
	"PhysicMaterial.bounciness": {
		"prefix": "PhysicMaterial.bounciness",
		"body": [
			"bounciness"
		],
		"description": "return:float des: How bouncy is the surface? A value of 0 will not bounce. A value of 1 will bounce without any loss of energy."
	}
,
	"PhysicMaterial.dynamicFriction": {
		"prefix": "PhysicMaterial.dynamicFriction",
		"body": [
			"dynamicFriction"
		],
		"description": "return:float des: The friction used when already moving. This value is usually between 0 and 1."
	}
,
	"PhysicMaterial.frictionCombine": {
		"prefix": "PhysicMaterial.frictionCombine",
		"body": [
			"frictionCombine"
		],
		"description": "return:PhysicMaterialCombine des: Determines how the friction is combined."
	}
,
	"PhysicMaterial.staticFriction": {
		"prefix": "PhysicMaterial.staticFriction",
		"body": [
			"staticFriction"
		],
		"description": "return:float des: The friction coefficient used when an object is lying on a surface."
	}
,
	"PhysicMaterial.hideFlags": {
		"prefix": "PhysicMaterial.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"PhysicMaterial.name": {
		"prefix": "PhysicMaterial.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"PhysicMaterial.GetInstanceID": {
		"prefix": "PhysicMaterial.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"PhysicMaterial.ToString": {
		"prefix": "PhysicMaterial.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"PhysicMaterial.Destroy": {
		"prefix": "PhysicMaterial.Destroy",
		"body": [
			"PhysicMaterial.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"PhysicMaterial.DestroyImmediate": {
		"prefix": "PhysicMaterial.DestroyImmediate",
		"body": [
			"PhysicMaterial.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"PhysicMaterial.DontDestroyOnLoad": {
		"prefix": "PhysicMaterial.DontDestroyOnLoad",
		"body": [
			"PhysicMaterial.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"PhysicMaterial.FindObjectOfType": {
		"prefix": "PhysicMaterial.FindObjectOfType",
		"body": [
			"PhysicMaterial.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"PhysicMaterial.FindObjectsOfType": {
		"prefix": "PhysicMaterial.FindObjectsOfType",
		"body": [
			"PhysicMaterial.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"PhysicMaterial.Instantiate": {
		"prefix": "PhysicMaterial.Instantiate",
		"body": [
			"PhysicMaterial.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"Physics.BoxCast": {
		"prefix": "Physics.BoxCast",
		"body": [
			"Physics.BoxCast"
		],
		"description": "public static bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation = Quaternion.identity, float maxDistance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); public static bool BoxCast(Vector3 center, Vector3 halfExtents, Vector3 direction, out RaycastHit hitInfo, Quaternion orientation = Quaternion.identity, float maxDistance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); des: Casts the box along a ray and returns detailed information on what was hit."
	}
,
	"Physics.BoxCastAll": {
		"prefix": "Physics.BoxCastAll",
		"body": [
			"Physics.BoxCastAll"
		],
		"description": "public static RaycastHit[] BoxCastAll(Vector3 center, Vector3 halfExtents, Vector3 direction, Quaternion orientation = Quaternion.identity, float maxDistance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); des: Like Physics.BoxCast, but returns all hits."
	}
,
	"Physics.BoxCastNonAlloc": {
		"prefix": "Physics.BoxCastNonAlloc",
		"body": [
			"Physics.BoxCastNonAlloc"
		],
		"description": "public static int BoxCastNonAlloc(Vector3 center, Vector3 halfExtents, Vector3 direction, RaycastHit[] results, Quaternion orientation = Quaternion.identity, float maxDistance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); des: Cast the box along the direction, and store hits in the provided buffer."
	}
,
	"Physics.CapsuleCast": {
		"prefix": "Physics.CapsuleCast",
		"body": [
			"Physics.CapsuleCast"
		],
		"description": "public static bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction, float maxDistance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); public static bool CapsuleCast(Vector3 point1, Vector3 point2, float radius, Vector3 direction, out RaycastHit hitInfo, float maxDistance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); des: Casts a capsule against all colliders in the scene and returns detailed information on what was hit."
	}
,
	"Physics.CapsuleCastAll": {
		"prefix": "Physics.CapsuleCastAll",
		"body": [
			"Physics.CapsuleCastAll"
		],
		"description": "public static RaycastHit[] CapsuleCastAll(Vector3 point1, Vector3 point2, float radius, Vector3 direction, float maxDistance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); des: Like Physics.CapsuleCast, but this function will return all hits the capsule sweep intersects."
	}
,
	"Physics.CapsuleCastNonAlloc": {
		"prefix": "Physics.CapsuleCastNonAlloc",
		"body": [
			"Physics.CapsuleCastNonAlloc"
		],
		"description": "public static int CapsuleCastNonAlloc(Vector3 point1, Vector3 point2, float radius, Vector3 direction, RaycastHit[] results, float maxDistance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); des: Casts a capsule against all colliders in the scene and returns detailed information on what was hit into the buffer."
	}
,
	"Physics.CheckBox": {
		"prefix": "Physics.CheckBox",
		"body": [
			"Physics.CheckBox"
		],
		"description": "public static bool CheckBox(Vector3 center, Vector3 halfExtents, Quaternion orientation = Quaternion.identity, int layermask = DefaultRaycastLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); des: Check whether the given box overlaps with other colliders or not."
	}
,
	"Physics.CheckCapsule": {
		"prefix": "Physics.CheckCapsule",
		"body": [
			"Physics.CheckCapsule"
		],
		"description": "public static bool CheckCapsule(Vector3 start, Vector3 end, float radius, int layerMask = DefaultRaycastLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); des: Checks if any colliders overlap a capsule-shaped volume in world space."
	}
,
	"Physics.CheckSphere": {
		"prefix": "Physics.CheckSphere",
		"body": [
			"Physics.CheckSphere"
		],
		"description": "public static bool CheckSphere(Vector3 position, float radius, int layerMask = DefaultRaycastLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); des: Returns true if there are any colliders overlapping the sphere defined by position and radius in world coordinates."
	}
,
	"Physics.ClosestPoint": {
		"prefix": "Physics.ClosestPoint",
		"body": [
			"Physics.ClosestPoint"
		],
		"description": "public static Vector3 ClosestPoint(Vector3 point, Collider collider, Vector3 position, Quaternion rotation); des: Returns a point on the given collider that is closest to the specified location."
	}
,
	"Physics.ComputePenetration": {
		"prefix": "Physics.ComputePenetration",
		"body": [
			"Physics.ComputePenetration"
		],
		"description": "public static bool ComputePenetration(Collider colliderA, Vector3 positionA, Quaternion rotationA, Collider colliderB, Vector3 positionB, Quaternion rotationB, out Vector3 direction, out float distance); des: Compute the minimal translation required to separate the given colliders apart at specified poses."
	}
,
	"Physics.GetIgnoreLayerCollision": {
		"prefix": "Physics.GetIgnoreLayerCollision",
		"body": [
			"Physics.GetIgnoreLayerCollision"
		],
		"description": "public static bool GetIgnoreLayerCollision(int layer1, int layer2); des: Are collisions between layer1 and layer2 being ignored?"
	}
,
	"Physics.IgnoreCollision": {
		"prefix": "Physics.IgnoreCollision",
		"body": [
			"Physics.IgnoreCollision"
		],
		"description": "public static void IgnoreCollision(Collider collider1, Collider collider2, bool ignore = true); des: Makes the collision detection system ignore all collisions between collider1 and collider2."
	}
,
	"Physics.IgnoreLayerCollision": {
		"prefix": "Physics.IgnoreLayerCollision",
		"body": [
			"Physics.IgnoreLayerCollision"
		],
		"description": "public static void IgnoreLayerCollision(int layer1, int layer2, bool ignore = true); des: Makes the collision detection system ignore all collisions between any collider in layer1 and any collider in layer2."
	}
,
	"Physics.Linecast": {
		"prefix": "Physics.Linecast",
		"body": [
			"Physics.Linecast"
		],
		"description": "public static bool Linecast(Vector3 start, Vector3 end, int layerMask = DefaultRaycastLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); public static bool Linecast(Vector3 start, Vector3 end, out RaycastHit hitInfo, int layerMask = DefaultRaycastLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); des: Returns true if there is any collider intersecting the line between start and end."
	}
,
	"Physics.OverlapBox": {
		"prefix": "Physics.OverlapBox",
		"body": [
			"Physics.OverlapBox"
		],
		"description": "public static Collider[] OverlapBox(Vector3 center, Vector3 halfExtents, Quaternion orientation = Quaternion.identity, int layerMask = AllLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); des: Find all colliders touching or inside of the given box."
	}
,
	"Physics.OverlapBoxNonAlloc": {
		"prefix": "Physics.OverlapBoxNonAlloc",
		"body": [
			"Physics.OverlapBoxNonAlloc"
		],
		"description": "public static int OverlapBoxNonAlloc(Vector3 center, Vector3 halfExtents, out Collider[] results, Quaternion orientation = Quaternion.identity, int mask = AllLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); des: Find all colliders touching or inside of the given box, and store them into the buffer."
	}
,
	"Physics.OverlapCapsule": {
		"prefix": "Physics.OverlapCapsule",
		"body": [
			"Physics.OverlapCapsule"
		],
		"description": "public static Collider[] OverlapCapsule(Vector3 point0, Vector3 point1, float radius, int layerMask = AllLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); des: Check the given capsule against the physics world and return all overlapping colliders."
	}
,
	"Physics.OverlapCapsuleNonAlloc": {
		"prefix": "Physics.OverlapCapsuleNonAlloc",
		"body": [
			"Physics.OverlapCapsuleNonAlloc"
		],
		"description": "public static int OverlapCapsuleNonAlloc(Vector3 point0, Vector3 point1, float radius, out Collider[] results, int layerMask = AllLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); des: Check the given capsule against the physics world and return all overlapping colliders in the user-provided buffer."
	}
,
	"Physics.OverlapSphere": {
		"prefix": "Physics.OverlapSphere",
		"body": [
			"Physics.OverlapSphere"
		],
		"description": "public static Collider[] OverlapSphere(Vector3 position, float radius, int layerMask = AllLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); des: Returns an array with all colliders touching or inside the sphere."
	}
,
	"Physics.OverlapSphereNonAlloc": {
		"prefix": "Physics.OverlapSphereNonAlloc",
		"body": [
			"Physics.OverlapSphereNonAlloc"
		],
		"description": "public static int OverlapSphereNonAlloc(Vector3 position, float radius, out Collider[] results, int layerMask = AllLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); des: Computes and stores colliders touching or inside the sphere into the provided buffer."
	}
,
	"Physics.Raycast": {
		"prefix": "Physics.Raycast",
		"body": [
			"Physics.Raycast"
		],
		"description": "public static bool Raycast(Vector3 origin, Vector3 direction, float maxDistance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); public static bool Raycast(Vector3 origin, Vector3 direction, out RaycastHit hitInfo, float maxDistance, int layerMask, QueryTriggerInteraction queryTriggerInteraction); public static bool Raycast(Ray ray, float maxDistance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); public static bool Raycast(Ray ray, out RaycastHit hitInfo, float maxDistance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); des: Casts a ray, from point origin, in direction direction, of length maxDistance, against all colliders in the scene."
	}
,
	"Physics.RaycastAll": {
		"prefix": "Physics.RaycastAll",
		"body": [
			"Physics.RaycastAll"
		],
		"description": "public static RaycastHit[] RaycastAll(Ray ray, float maxDistance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); public static RaycastHit[] RaycastAll(Vector3 origin, Vector3 direction, float maxDistance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); des: Casts a ray through the scene and returns all hits. Note that order is not guaranteed."
	}
,
	"Physics.RaycastNonAlloc": {
		"prefix": "Physics.RaycastNonAlloc",
		"body": [
			"Physics.RaycastNonAlloc"
		],
		"description": "public static int RaycastNonAlloc(Ray ray, RaycastHit[] results, float maxDistance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); public static int RaycastNonAlloc(Vector3 origin, Vector3 direction, RaycastHit[] results, float maxDistance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); des: Cast a ray through the scene and store the hits into the buffer."
	}
,
	"Physics.RebuildBroadphaseRegions": {
		"prefix": "Physics.RebuildBroadphaseRegions",
		"body": [
			"Physics.RebuildBroadphaseRegions"
		],
		"description": "public static void RebuildBroadphaseRegions(Bounds worldBounds, int subdivisions); des: Rebuild the broadphase interest regions as well as set the world boundaries."
	}
,
	"Physics.Simulate": {
		"prefix": "Physics.Simulate",
		"body": [
			"Physics.Simulate"
		],
		"description": "public static void Simulate(float step); des: Simulate physics in the scene."
	}
,
	"Physics.SphereCast": {
		"prefix": "Physics.SphereCast",
		"body": [
			"Physics.SphereCast"
		],
		"description": "public static bool SphereCast(Vector3 origin, float radius, Vector3 direction, out RaycastHit hitInfo, float maxDistance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); public static bool SphereCast(Ray ray, float radius, float maxDistance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); public static bool SphereCast(Ray ray, float radius, out RaycastHit hitInfo, float maxDistance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); des: Casts a sphere along a ray and returns detailed information on what was hit."
	}
,
	"Physics.SphereCastAll": {
		"prefix": "Physics.SphereCastAll",
		"body": [
			"Physics.SphereCastAll"
		],
		"description": "public static RaycastHit[] SphereCastAll(Vector3 origin, float radius, Vector3 direction, float maxDistance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); public static RaycastHit[] SphereCastAll(Ray ray, float radius, float maxDistance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); des: Like Physics.SphereCast, but this function will return all hits the sphere sweep intersects."
	}
,
	"Physics.SphereCastNonAlloc": {
		"prefix": "Physics.SphereCastNonAlloc",
		"body": [
			"Physics.SphereCastNonAlloc"
		],
		"description": "public static int SphereCastNonAlloc(Vector3 origin, float radius, Vector3 direction, RaycastHit[] results, float maxDistance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); public static int SphereCastNonAlloc(Ray ray, float radius, RaycastHit[] results, float maxDistance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); des: Cast sphere along the direction and store the results into buffer."
	}
,
	"Physics.SyncTransforms": {
		"prefix": "Physics.SyncTransforms",
		"body": [
			"Physics.SyncTransforms"
		],
		"description": "public static void SyncTransforms(); des: Apply Transform changes to the physics engine."
	}
,
	"Physics2D.BoxCast": {
		"prefix": "Physics2D.BoxCast",
		"body": [
			"Physics2D.BoxCast"
		],
		"description": "public static RaycastHit2D BoxCast(Vector2 origin, Vector2 size, float angle, Vector2 direction, float distance = Mathf.Infinity, int layerMask = Physics2D.AllLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); public static int BoxCast(Vector2 origin, Vector2 size, float angle, Vector2 direction, ContactFilter2D contactFilter, RaycastHit2D[] results, float distance = Mathf.Infinity); des: Casts a box against colliders in the scene, returning the first collider to contact with it."
	}
,
	"Physics2D.BoxCastAll": {
		"prefix": "Physics2D.BoxCastAll",
		"body": [
			"Physics2D.BoxCastAll"
		],
		"description": "public static RaycastHit2D[] BoxCastAll(Vector2 origin, Vector2 size, float angle, Vector2 direction, float distance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); des: Casts a box against colliders in the scene, returning all colliders that contact with it."
	}
,
	"Physics2D.BoxCastNonAlloc": {
		"prefix": "Physics2D.BoxCastNonAlloc",
		"body": [
			"Physics2D.BoxCastNonAlloc"
		],
		"description": "public static int BoxCastNonAlloc(Vector2 origin, Vector2 size, float angle, Vector2 direction, RaycastHit2D[] results, float distance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); des: Casts a box into the scene, returning colliders that contact with it into the provided results array."
	}
,
	"Physics2D.CapsuleCast": {
		"prefix": "Physics2D.CapsuleCast",
		"body": [
			"Physics2D.CapsuleCast"
		],
		"description": "public static RaycastHit2D CapsuleCast(Vector2 origin, Vector2 size, CapsuleDirection2D capsuleDirection, float angle, Vector2 direction, float distance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); public static int CapsuleCast(Vector2 origin, Vector2 size, CapsuleDirection2D capsuleDirection, float angle, Vector2 direction, ContactFilter2D contactFilter, RaycastHit2D[] results, float distance = Mathf.Infinity); des: Casts a capsule against colliders in the scene, returning the first collider to contact with it."
	}
,
	"Physics2D.CapsuleCastAll": {
		"prefix": "Physics2D.CapsuleCastAll",
		"body": [
			"Physics2D.CapsuleCastAll"
		],
		"description": "public static RaycastHit2D[] CapsuleCastAll(Vector2 origin, Vector2 size, CapsuleDirection2D capsuleDirection, float angle, Vector2 direction, float distance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); des: Casts a capsule against colliders in the scene, returning all colliders that contact with it."
	}
,
	"Physics2D.CapsuleCastNonAlloc": {
		"prefix": "Physics2D.CapsuleCastNonAlloc",
		"body": [
			"Physics2D.CapsuleCastNonAlloc"
		],
		"description": "public static int CapsuleCastNonAlloc(Vector2 origin, Vector2 size, CapsuleDirection2D capsuleDirection, float angle, Vector2 direction, RaycastHit2D[] results, float distance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); des: Casts a capsule into the scene, returning colliders that contact with it into the provided results array."
	}
,
	"Physics2D.CircleCast": {
		"prefix": "Physics2D.CircleCast",
		"body": [
			"Physics2D.CircleCast"
		],
		"description": "public static RaycastHit2D CircleCast(Vector2 origin, float radius, Vector2 direction, float distance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); public static int CircleCast(Vector2 origin, float radius, Vector2 direction, ContactFilter2D contactFilter, RaycastHit2D[] results, float distance = Mathf.Infinity); des: Casts a circle against colliders in the scene, returning the first collider to contact with it."
	}
,
	"Physics2D.CircleCastAll": {
		"prefix": "Physics2D.CircleCastAll",
		"body": [
			"Physics2D.CircleCastAll"
		],
		"description": "public static RaycastHit2D[] CircleCastAll(Vector2 origin, float radius, Vector2 direction, float distance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); des: Casts a circle against colliders in the scene, returning all colliders that contact with it."
	}
,
	"Physics2D.CircleCastNonAlloc": {
		"prefix": "Physics2D.CircleCastNonAlloc",
		"body": [
			"Physics2D.CircleCastNonAlloc"
		],
		"description": "public static int CircleCastNonAlloc(Vector2 origin, float radius, Vector2 direction, RaycastHit2D[] results, float distance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); des: Casts a circle into the scene, returning colliders that contact with it into the provided results array."
	}
,
	"Physics2D.Distance": {
		"prefix": "Physics2D.Distance",
		"body": [
			"Physics2D.Distance"
		],
		"description": "public static ColliderDistance2D Distance(Collider2D colliderA, Collider2D colliderB); des: Calculates the minimum distance between two colliders."
	}
,
	"Physics2D.GetContacts": {
		"prefix": "Physics2D.GetContacts",
		"body": [
			"Physics2D.GetContacts"
		],
		"description": "public static int GetContacts(Collider2D collider, Collider2D[] colliders); public static int GetContacts(Collider2D collider, ContactPoint2D[] contacts); public static int GetContacts(Collider2D collider, ContactFilter2D contactFilter, ContactPoint2D[] contacts); public static int GetContacts(Collider2D collider, ContactFilter2D contactFilter, Collider2D[] colliders); public static int GetContacts(Collider2D collider1, Collider2D collider2, ContactFilter2D contactFilter, ContactPoint2D[] contacts); public static int GetContacts(Rigidbody2D rigidbody, ContactPoint2D[] contacts); public static int GetContacts(Rigidbody2D rigidbody, Collider2D[] colliders); public static int GetContacts(Rigidbody2D rigidbody, ContactFilter2D contactFilter, ContactPoint2D[] contacts); public static int GetContacts(Rigidbody2D rigidbody, ContactFilter2D contactFilter, Collider2D[] colliders); des: Retrieves all colliders in contact with the collider."
	}
,
	"Physics2D.GetIgnoreCollision": {
		"prefix": "Physics2D.GetIgnoreCollision",
		"body": [
			"Physics2D.GetIgnoreCollision"
		],
		"description": "public static bool GetIgnoreCollision(Collider2D collider1, Collider2D collider2); des: Checks whether the collision detection system will ignore all collisions/triggers between collider1 and collider2 or not."
	}
,
	"Physics2D.GetIgnoreLayerCollision": {
		"prefix": "Physics2D.GetIgnoreLayerCollision",
		"body": [
			"Physics2D.GetIgnoreLayerCollision"
		],
		"description": "public static bool GetIgnoreLayerCollision(int layer1, int layer2); des: Checks whether collisions between the specified layers be ignored or not."
	}
,
	"Physics2D.GetLayerCollisionMask": {
		"prefix": "Physics2D.GetLayerCollisionMask",
		"body": [
			"Physics2D.GetLayerCollisionMask"
		],
		"description": "public static int GetLayerCollisionMask(int layer); des: Get the collision layer mask that indicates which layer(s) the specified layer can collide with."
	}
,
	"Physics2D.GetRayIntersection": {
		"prefix": "Physics2D.GetRayIntersection",
		"body": [
			"Physics2D.GetRayIntersection"
		],
		"description": "public static RaycastHit2D GetRayIntersection(Ray ray, float distance = Mathf.Infinity, int layerMask = DefaultRaycastLayers); des: Cast a 3D ray against the colliders in the scene returning the first collider along the ray."
	}
,
	"Physics2D.GetRayIntersectionAll": {
		"prefix": "Physics2D.GetRayIntersectionAll",
		"body": [
			"Physics2D.GetRayIntersectionAll"
		],
		"description": "public static RaycastHit2D[] GetRayIntersectionAll(Ray ray, float distance = Mathf.Infinity, int layerMask = DefaultRaycastLayers); des: Cast a 3D ray against the colliders in the scene returning all the colliders along the ray."
	}
,
	"Physics2D.GetRayIntersectionNonAlloc": {
		"prefix": "Physics2D.GetRayIntersectionNonAlloc",
		"body": [
			"Physics2D.GetRayIntersectionNonAlloc"
		],
		"description": "public static int GetRayIntersectionNonAlloc(Ray ray, RaycastHit2D[] results, float distance = Mathf.Infinity, int layerMask = DefaultRaycastLayers); des: Cast a 3D ray against the colliders in the scene returning the colliders along the ray."
	}
,
	"Physics2D.IgnoreCollision": {
		"prefix": "Physics2D.IgnoreCollision",
		"body": [
			"Physics2D.IgnoreCollision"
		],
		"description": "public static void IgnoreCollision(Collider2D collider1, Collider2D collider2, bool ignore = true); des: Makes the collision detection system ignore all collisions/triggers between collider1 and collider2."
	}
,
	"Physics2D.IgnoreLayerCollision": {
		"prefix": "Physics2D.IgnoreLayerCollision",
		"body": [
			"Physics2D.IgnoreLayerCollision"
		],
		"description": "public static void IgnoreLayerCollision(int layer1, int layer2, bool ignore); des: Choose whether to detect or ignore collisions between a specified pair of layers."
	}
,
	"Physics2D.IsTouching": {
		"prefix": "Physics2D.IsTouching",
		"body": [
			"Physics2D.IsTouching"
		],
		"description": "public static bool IsTouching(Collider2D collider1, Collider2D collider2); public static bool IsTouching(Collider2D collider, ContactFilter2D contactFilter); public static bool IsTouching(Collider2D collider1, Collider2D collider2, ContactFilter2D contactFilter); des: Checks whether the passed colliders are in contact or not."
	}
,
	"Physics2D.IsTouchingLayers": {
		"prefix": "Physics2D.IsTouchingLayers",
		"body": [
			"Physics2D.IsTouchingLayers"
		],
		"description": "public static bool IsTouchingLayers(Collider2D collider, int layerMask = Physics2D.AllLayers); des: Checks whether the collider is touching any colliders on the specified layerMask or not."
	}
,
	"Physics2D.Linecast": {
		"prefix": "Physics2D.Linecast",
		"body": [
			"Physics2D.Linecast"
		],
		"description": "public static RaycastHit2D Linecast(Vector2 start, Vector2 end, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); public static int Linecast(Vector2 start, Vector2 end, ContactFilter2D contactFilter, RaycastHit2D[] results); des: Casts a line segment against colliders in the Scene."
	}
,
	"Physics2D.LinecastAll": {
		"prefix": "Physics2D.LinecastAll",
		"body": [
			"Physics2D.LinecastAll"
		],
		"description": "public static RaycastHit2D[] LinecastAll(Vector2 start, Vector2 end, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); des: Casts a line against colliders in the scene."
	}
,
	"Physics2D.LinecastNonAlloc": {
		"prefix": "Physics2D.LinecastNonAlloc",
		"body": [
			"Physics2D.LinecastNonAlloc"
		],
		"description": "public static int LinecastNonAlloc(Vector2 start, Vector2 end, RaycastHit2D[] results, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); des: Casts a line against colliders in the scene."
	}
,
	"Physics2D.OverlapArea": {
		"prefix": "Physics2D.OverlapArea",
		"body": [
			"Physics2D.OverlapArea"
		],
		"description": "public static Collider2D OverlapArea(Vector2 pointA, Vector2 pointB, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); public static int OverlapArea(Vector2 pointA, Vector2 pointB, ContactFilter2D contactFilter, Collider2D[] results); des: Checks if a collider falls within a rectangular area."
	}
,
	"Physics2D.OverlapAreaAll": {
		"prefix": "Physics2D.OverlapAreaAll",
		"body": [
			"Physics2D.OverlapAreaAll"
		],
		"description": "public static Collider2D[] OverlapAreaAll(Vector2 pointA, Vector2 pointB, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); des: Get a list of all colliders that fall within a rectangular area."
	}
,
	"Physics2D.OverlapAreaNonAlloc": {
		"prefix": "Physics2D.OverlapAreaNonAlloc",
		"body": [
			"Physics2D.OverlapAreaNonAlloc"
		],
		"description": "public static int OverlapAreaNonAlloc(Vector2 pointA, Vector2 pointB, Collider2D[] results, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); des: Get a list of all colliders that fall within a specified area."
	}
,
	"Physics2D.OverlapBox": {
		"prefix": "Physics2D.OverlapBox",
		"body": [
			"Physics2D.OverlapBox"
		],
		"description": "public static Collider2D OverlapBox(Vector2 point, Vector2 size, float angle, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); public static int OverlapBox(Vector2 point, Vector2 size, float angle, ContactFilter2D contactFilter, Collider2D[] results); des: Checks if a collider falls within a box area."
	}
,
	"Physics2D.OverlapBoxAll": {
		"prefix": "Physics2D.OverlapBoxAll",
		"body": [
			"Physics2D.OverlapBoxAll"
		],
		"description": "public static Collider2D[] OverlapBoxAll(Vector2 point, Vector2 size, float angle, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); des: Get a list of all colliders that fall within a box area."
	}
,
	"Physics2D.OverlapBoxNonAlloc": {
		"prefix": "Physics2D.OverlapBoxNonAlloc",
		"body": [
			"Physics2D.OverlapBoxNonAlloc"
		],
		"description": "public static int OverlapBoxNonAlloc(Vector2 point, Vector2 size, float angle, Collider2D[] results, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); des: Get a list of all colliders that fall within a box area."
	}
,
	"Physics2D.OverlapCapsule": {
		"prefix": "Physics2D.OverlapCapsule",
		"body": [
			"Physics2D.OverlapCapsule"
		],
		"description": "public static Collider2D OverlapCapsule(Vector2 point, Vector2 size, CapsuleDirection2D direction, float angle, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); public static int OverlapCapsule(Vector2 point, Vector2 size, CapsuleDirection2D direction, float angle, ContactFilter2D contactFilter, Collider2D[] results); des: Checks if a collider falls within a capsule area."
	}
,
	"Physics2D.OverlapCapsuleAll": {
		"prefix": "Physics2D.OverlapCapsuleAll",
		"body": [
			"Physics2D.OverlapCapsuleAll"
		],
		"description": "public static Collider2D[] OverlapCapsuleAll(Vector2 point, Vector2 size, CapsuleDirection2D direction, float angle, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); des: Get a list of all colliders that fall within a capsule area."
	}
,
	"Physics2D.OverlapCapsuleNonAlloc": {
		"prefix": "Physics2D.OverlapCapsuleNonAlloc",
		"body": [
			"Physics2D.OverlapCapsuleNonAlloc"
		],
		"description": "public static int OverlapCapsuleNonAlloc(Vector2 point, Vector2 size, CapsuleDirection2D direction, float angle, Collider2D[] results, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); des: Get a list of all colliders that fall within a capsule area."
	}
,
	"Physics2D.OverlapCircle": {
		"prefix": "Physics2D.OverlapCircle",
		"body": [
			"Physics2D.OverlapCircle"
		],
		"description": "public static Collider2D OverlapCircle(Vector2 point, float radius, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); public static int OverlapCircle(Vector2 point, float radius, ContactFilter2D contactFilter, Collider2D[] results); des: Checks if a collider falls within a circular area."
	}
,
	"Physics2D.OverlapCircleAll": {
		"prefix": "Physics2D.OverlapCircleAll",
		"body": [
			"Physics2D.OverlapCircleAll"
		],
		"description": "public static Collider2D[] OverlapCircleAll(Vector2 point, float radius, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); des: Get a list of all colliders that fall within a circular area."
	}
,
	"Physics2D.OverlapCircleNonAlloc": {
		"prefix": "Physics2D.OverlapCircleNonAlloc",
		"body": [
			"Physics2D.OverlapCircleNonAlloc"
		],
		"description": "public static int OverlapCircleNonAlloc(Vector2 point, float radius, Collider2D[] results, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); des: Get a list of all colliders that fall within a circular area."
	}
,
	"Physics2D.OverlapCollider": {
		"prefix": "Physics2D.OverlapCollider",
		"body": [
			"Physics2D.OverlapCollider"
		],
		"description": "public static int OverlapCollider(Collider2D collider, ContactFilter2D contactFilter, out Collider2D[] results); des: Get a list of all colliders that overlap collider."
	}
,
	"Physics2D.OverlapPoint": {
		"prefix": "Physics2D.OverlapPoint",
		"body": [
			"Physics2D.OverlapPoint"
		],
		"description": "public static Collider2D OverlapPoint(Vector2 point, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); public static int OverlapPoint(Vector2 point, ContactFilter2D contactFilter, Collider2D[] results); des: Checks if a collider overlaps a point in space."
	}
,
	"Physics2D.OverlapPointAll": {
		"prefix": "Physics2D.OverlapPointAll",
		"body": [
			"Physics2D.OverlapPointAll"
		],
		"description": "public static Collider2D[] OverlapPointAll(Vector2 point, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); des: Get a list of all colliders that overlap a point in space."
	}
,
	"Physics2D.OverlapPointNonAlloc": {
		"prefix": "Physics2D.OverlapPointNonAlloc",
		"body": [
			"Physics2D.OverlapPointNonAlloc"
		],
		"description": "public static int OverlapPointNonAlloc(Vector2 point, Collider2D[] results, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); des: Get a list of all colliders that overlap a point in space."
	}
,
	"Physics2D.Raycast": {
		"prefix": "Physics2D.Raycast",
		"body": [
			"Physics2D.Raycast"
		],
		"description": "public static RaycastHit2D Raycast(Vector2 origin, Vector2 direction, float distance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); public static int Raycast(Vector2 origin, Vector2 direction, ContactFilter2D contactFilter, RaycastHit2D[] results, float distance = Mathf.Infinity); des: Casts a ray against colliders in the scene."
	}
,
	"Physics2D.RaycastAll": {
		"prefix": "Physics2D.RaycastAll",
		"body": [
			"Physics2D.RaycastAll"
		],
		"description": "public static RaycastHit2D[] RaycastAll(Vector2 origin, Vector2 direction, float distance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); des: Casts a ray against colliders in the scene, returning all colliders that contact with it."
	}
,
	"Physics2D.RaycastNonAlloc": {
		"prefix": "Physics2D.RaycastNonAlloc",
		"body": [
			"Physics2D.RaycastNonAlloc"
		],
		"description": "public static int RaycastNonAlloc(Vector2 origin, Vector2 direction, RaycastHit2D[] results, float distance = Mathf.Infinity, int layerMask = DefaultRaycastLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); des: Casts a ray into the scene."
	}
,
	"Physics2D.SetLayerCollisionMask": {
		"prefix": "Physics2D.SetLayerCollisionMask",
		"body": [
			"Physics2D.SetLayerCollisionMask"
		],
		"description": "public static void SetLayerCollisionMask(int layer, int layerMask); des: Set the collision layer mask that indicates which layer(s) the specified layer can collide with."
	}
,
	"Physics2D.Simulate": {
		"prefix": "Physics2D.Simulate",
		"body": [
			"Physics2D.Simulate"
		],
		"description": "public static bool Simulate(float step); des: Simulate physics in the scene."
	}
,
	"Physics2D.SyncTransforms": {
		"prefix": "Physics2D.SyncTransforms",
		"body": [
			"Physics2D.SyncTransforms"
		],
		"description": "public static void SyncTransforms(); des: Synchronizes."
	}
,
	"PhysicsJobOptions2D.clearBodyForcesPerJob": {
		"prefix": "PhysicsJobOptions2D.clearBodyForcesPerJob",
		"body": [
			"clearBodyForcesPerJob"
		],
		"description": "return:int des: Controls the minimum number of bodies to be cleared in each simulation job."
	}
,
	"PhysicsJobOptions2D.clearFlagsPerJob": {
		"prefix": "PhysicsJobOptions2D.clearFlagsPerJob",
		"body": [
			"clearFlagsPerJob"
		],
		"description": "return:int des: Controls the minimum number of flags to be cleared in each simulation job."
	}
,
	"PhysicsJobOptions2D.collideContactsPerJob": {
		"prefix": "PhysicsJobOptions2D.collideContactsPerJob",
		"body": [
			"collideContactsPerJob"
		],
		"description": "return:int des: Controls the minimum number of contacts to collide in each simulation job."
	}
,
	"PhysicsJobOptions2D.findNearestContactsPerJob": {
		"prefix": "PhysicsJobOptions2D.findNearestContactsPerJob",
		"body": [
			"findNearestContactsPerJob"
		],
		"description": "return:int des: Controls the minimum number of nearest contacts to find in each simulation job."
	}
,
	"PhysicsJobOptions2D.interpolationPosesPerJob": {
		"prefix": "PhysicsJobOptions2D.interpolationPosesPerJob",
		"body": [
			"interpolationPosesPerJob"
		],
		"description": "return:int des: Controls the minimum number of Rigidbody2D being interpolated in each simulation job."
	}
,
	"PhysicsJobOptions2D.islandSolverBodiesPerJob": {
		"prefix": "PhysicsJobOptions2D.islandSolverBodiesPerJob",
		"body": [
			"islandSolverBodiesPerJob"
		],
		"description": "return:int des: Controls the minimum number of bodies to solve in each simulation job when performing island solving."
	}
,
	"PhysicsJobOptions2D.islandSolverBodyCostScale": {
		"prefix": "PhysicsJobOptions2D.islandSolverBodyCostScale",
		"body": [
			"islandSolverBodyCostScale"
		],
		"description": "return:int des: Scales the cost of each body during discrete island solving."
	}
,
	"PhysicsJobOptions2D.islandSolverContactCostScale": {
		"prefix": "PhysicsJobOptions2D.islandSolverContactCostScale",
		"body": [
			"islandSolverContactCostScale"
		],
		"description": "return:int des: Scales the cost of each contact during discrete island solving."
	}
,
	"PhysicsJobOptions2D.islandSolverContactsPerJob": {
		"prefix": "PhysicsJobOptions2D.islandSolverContactsPerJob",
		"body": [
			"islandSolverContactsPerJob"
		],
		"description": "return:int des: Controls the minimum number of contacts to solve in each simulation job when performing island solving."
	}
,
	"PhysicsJobOptions2D.islandSolverCostThreshold": {
		"prefix": "PhysicsJobOptions2D.islandSolverCostThreshold",
		"body": [
			"islandSolverCostThreshold"
		],
		"description": "return:int des: The minimum threshold cost of all bodies, contacts and joints in an island during discrete island solving."
	}
,
	"PhysicsJobOptions2D.islandSolverJointCostScale": {
		"prefix": "PhysicsJobOptions2D.islandSolverJointCostScale",
		"body": [
			"islandSolverJointCostScale"
		],
		"description": "return:int des: Scales the cost of each joint during discrete island solving."
	}
,
	"PhysicsJobOptions2D.newContactsPerJob": {
		"prefix": "PhysicsJobOptions2D.newContactsPerJob",
		"body": [
			"newContactsPerJob"
		],
		"description": "return:int des: Controls the minimum number of new contacts to find in each simulation job."
	}
,
	"PhysicsJobOptions2D.syncContinuousFixturesPerJob": {
		"prefix": "PhysicsJobOptions2D.syncContinuousFixturesPerJob",
		"body": [
			"syncContinuousFixturesPerJob"
		],
		"description": "return:int des: Controls the minimum number of fixtures to synchronize in the broadphase during continuous island solving in each simulation job."
	}
,
	"PhysicsJobOptions2D.syncDiscreteFixturesPerJob": {
		"prefix": "PhysicsJobOptions2D.syncDiscreteFixturesPerJob",
		"body": [
			"syncDiscreteFixturesPerJob"
		],
		"description": "return:int des: Controls the minimum number of fixtures to synchronize in the broadphase during discrete island solving in each simulation job."
	}
,
	"PhysicsJobOptions2D.updateTriggerContactsPerJob": {
		"prefix": "PhysicsJobOptions2D.updateTriggerContactsPerJob",
		"body": [
			"updateTriggerContactsPerJob"
		],
		"description": "return:int des: Controls the minimum number of trigger contacts to update in each simulation job."
	}
,
	"PhysicsJobOptions2D.useConsistencySorting": {
		"prefix": "PhysicsJobOptions2D.useConsistencySorting",
		"body": [
			"useConsistencySorting"
		],
		"description": "return:bool des: Should physics simulation sort multi-threaded results to maintain processing order consistency?"
	}
,
	"PhysicsJobOptions2D.useMultithreading": {
		"prefix": "PhysicsJobOptions2D.useMultithreading",
		"body": [
			"useMultithreading"
		],
		"description": "return:bool des: Should physics simulation use multithreading?"
	}
,
	"PhysicsMaterial2D.bounciness": {
		"prefix": "PhysicsMaterial2D.bounciness",
		"body": [
			"bounciness"
		],
		"description": "return:float des: The degree of elasticity during collisions."
	}
,
	"PhysicsMaterial2D.friction": {
		"prefix": "PhysicsMaterial2D.friction",
		"body": [
			"friction"
		],
		"description": "return:float des: Coefficient of friction."
	}
,
	"PhysicsMaterial2D.hideFlags": {
		"prefix": "PhysicsMaterial2D.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"PhysicsMaterial2D.name": {
		"prefix": "PhysicsMaterial2D.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"PhysicsMaterial2D.GetInstanceID": {
		"prefix": "PhysicsMaterial2D.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"PhysicsMaterial2D.ToString": {
		"prefix": "PhysicsMaterial2D.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"PhysicsMaterial2D.Destroy": {
		"prefix": "PhysicsMaterial2D.Destroy",
		"body": [
			"PhysicsMaterial2D.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"PhysicsMaterial2D.DestroyImmediate": {
		"prefix": "PhysicsMaterial2D.DestroyImmediate",
		"body": [
			"PhysicsMaterial2D.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"PhysicsMaterial2D.DontDestroyOnLoad": {
		"prefix": "PhysicsMaterial2D.DontDestroyOnLoad",
		"body": [
			"PhysicsMaterial2D.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"PhysicsMaterial2D.FindObjectOfType": {
		"prefix": "PhysicsMaterial2D.FindObjectOfType",
		"body": [
			"PhysicsMaterial2D.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"PhysicsMaterial2D.FindObjectsOfType": {
		"prefix": "PhysicsMaterial2D.FindObjectsOfType",
		"body": [
			"PhysicsMaterial2D.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"PhysicsMaterial2D.Instantiate": {
		"prefix": "PhysicsMaterial2D.Instantiate",
		"body": [
			"PhysicsMaterial2D.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"PhysicsUpdateBehaviour2D.enabled": {
		"prefix": "PhysicsUpdateBehaviour2D.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"PhysicsUpdateBehaviour2D.isActiveAndEnabled": {
		"prefix": "PhysicsUpdateBehaviour2D.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"PhysicsUpdateBehaviour2D.gameObject": {
		"prefix": "PhysicsUpdateBehaviour2D.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"PhysicsUpdateBehaviour2D.tag": {
		"prefix": "PhysicsUpdateBehaviour2D.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"PhysicsUpdateBehaviour2D.transform": {
		"prefix": "PhysicsUpdateBehaviour2D.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"PhysicsUpdateBehaviour2D.hideFlags": {
		"prefix": "PhysicsUpdateBehaviour2D.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"PhysicsUpdateBehaviour2D.name": {
		"prefix": "PhysicsUpdateBehaviour2D.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"PhysicsUpdateBehaviour2D.BroadcastMessage": {
		"prefix": "PhysicsUpdateBehaviour2D.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"PhysicsUpdateBehaviour2D.CompareTag": {
		"prefix": "PhysicsUpdateBehaviour2D.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"PhysicsUpdateBehaviour2D.GetComponent": {
		"prefix": "PhysicsUpdateBehaviour2D.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"PhysicsUpdateBehaviour2D.GetComponentInChildren": {
		"prefix": "PhysicsUpdateBehaviour2D.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"PhysicsUpdateBehaviour2D.GetComponentInParent": {
		"prefix": "PhysicsUpdateBehaviour2D.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"PhysicsUpdateBehaviour2D.GetComponents": {
		"prefix": "PhysicsUpdateBehaviour2D.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"PhysicsUpdateBehaviour2D.GetComponentsInChildren": {
		"prefix": "PhysicsUpdateBehaviour2D.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"PhysicsUpdateBehaviour2D.GetComponentsInParent": {
		"prefix": "PhysicsUpdateBehaviour2D.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"PhysicsUpdateBehaviour2D.SendMessage": {
		"prefix": "PhysicsUpdateBehaviour2D.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"PhysicsUpdateBehaviour2D.SendMessageUpwards": {
		"prefix": "PhysicsUpdateBehaviour2D.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"PhysicsUpdateBehaviour2D.GetInstanceID": {
		"prefix": "PhysicsUpdateBehaviour2D.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"PhysicsUpdateBehaviour2D.ToString": {
		"prefix": "PhysicsUpdateBehaviour2D.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"PhysicsUpdateBehaviour2D.Destroy": {
		"prefix": "PhysicsUpdateBehaviour2D.Destroy",
		"body": [
			"PhysicsUpdateBehaviour2D.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"PhysicsUpdateBehaviour2D.DestroyImmediate": {
		"prefix": "PhysicsUpdateBehaviour2D.DestroyImmediate",
		"body": [
			"PhysicsUpdateBehaviour2D.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"PhysicsUpdateBehaviour2D.DontDestroyOnLoad": {
		"prefix": "PhysicsUpdateBehaviour2D.DontDestroyOnLoad",
		"body": [
			"PhysicsUpdateBehaviour2D.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"PhysicsUpdateBehaviour2D.FindObjectOfType": {
		"prefix": "PhysicsUpdateBehaviour2D.FindObjectOfType",
		"body": [
			"PhysicsUpdateBehaviour2D.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"PhysicsUpdateBehaviour2D.FindObjectsOfType": {
		"prefix": "PhysicsUpdateBehaviour2D.FindObjectsOfType",
		"body": [
			"PhysicsUpdateBehaviour2D.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"PhysicsUpdateBehaviour2D.Instantiate": {
		"prefix": "PhysicsUpdateBehaviour2D.Instantiate",
		"body": [
			"PhysicsUpdateBehaviour2D.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"Ping.ip": {
		"prefix": "Ping.ip",
		"body": [
			"ip"
		],
		"description": "return:string des: The IP target of the ping."
	}
,
	"Ping.isDone": {
		"prefix": "Ping.isDone",
		"body": [
			"isDone"
		],
		"description": "return:bool des: Has the ping function completed?"
	}
,
	"Ping.time": {
		"prefix": "Ping.time",
		"body": [
			"time"
		],
		"description": "return:int des: This property contains the ping time result after isDone returns true."
	}
,
	"Plane.distance": {
		"prefix": "Plane.distance",
		"body": [
			"distance"
		],
		"description": "return:float des: Distance from the origin to the plane."
	}
,
	"Plane.flipped": {
		"prefix": "Plane.flipped",
		"body": [
			"flipped"
		],
		"description": "return:Plane des: Returns a copy of the plane that faces in the opposite direction."
	}
,
	"Plane.normal": {
		"prefix": "Plane.normal",
		"body": [
			"normal"
		],
		"description": "return:Vector3 des: Normal vector of the plane."
	}
,
	"Plane.ClosestPointOnPlane": {
		"prefix": "Plane.ClosestPointOnPlane",
		"body": [
			"ClosestPointOnPlane($1)"
		],
		"description": "public Vector3 ClosestPointOnPlane(Vector3 point); des: For a given point returns the closest point on the plane."
	}
,
	"Plane.Flip": {
		"prefix": "Plane.Flip",
		"body": [
			"Flip($1)"
		],
		"description": "public void Flip(); des: Makes the plane face in the opposite direction."
	}
,
	"Plane.GetDistanceToPoint": {
		"prefix": "Plane.GetDistanceToPoint",
		"body": [
			"GetDistanceToPoint($1)"
		],
		"description": "public float GetDistanceToPoint(Vector3 point); des: Returns a signed distance from plane to point."
	}
,
	"Plane.GetSide": {
		"prefix": "Plane.GetSide",
		"body": [
			"GetSide($1)"
		],
		"description": "public bool GetSide(Vector3 point); des: Is a point on the positive side of the plane?"
	}
,
	"Plane.Raycast": {
		"prefix": "Plane.Raycast",
		"body": [
			"Raycast($1)"
		],
		"description": "public bool Raycast(Ray ray, out float enter); des: Intersects a ray with the plane."
	}
,
	"Plane.SameSide": {
		"prefix": "Plane.SameSide",
		"body": [
			"SameSide($1)"
		],
		"description": "public bool SameSide(Vector3 inPt0, Vector3 inPt1); des: Are two points on the same side of the plane?"
	}
,
	"Plane.Set3Points": {
		"prefix": "Plane.Set3Points",
		"body": [
			"Set3Points($1)"
		],
		"description": "public void Set3Points(Vector3 a, Vector3 b, Vector3 c); des: Sets a plane using three points that lie within it. The points go around clockwise as you look down on the top surface of the plane."
	}
,
	"Plane.SetNormalAndPosition": {
		"prefix": "Plane.SetNormalAndPosition",
		"body": [
			"SetNormalAndPosition($1)"
		],
		"description": "public void SetNormalAndPosition(Vector3 inNormal, Vector3 inPoint); des: Sets a plane using a point that lies within it along with a normal to orient it."
	}
,
	"Plane.Translate": {
		"prefix": "Plane.Translate",
		"body": [
			"Translate($1)"
		],
		"description": "public static Plane Translate(Plane plane, Vector3 translation); public void Translate(Vector3 translation); des: Returns a copy of the given plane that is moved in space by the given translation."
	}
,
	"PlatformEffector2D.rotationalOffset": {
		"prefix": "PlatformEffector2D.rotationalOffset",
		"body": [
			"rotationalOffset"
		],
		"description": "return:float des: The rotational offset angle from the local 'up'."
	}
,
	"PlatformEffector2D.sideArc": {
		"prefix": "PlatformEffector2D.sideArc",
		"body": [
			"sideArc"
		],
		"description": "return:float des: The angle of an arc that defines the sides of the platform centered on the local 'left' and 'right' of the effector. Any collision normals within this arc are considered for the 'side' behaviours."
	}
,
	"PlatformEffector2D.surfaceArc": {
		"prefix": "PlatformEffector2D.surfaceArc",
		"body": [
			"surfaceArc"
		],
		"description": "return:float des: The angle of an arc that defines the surface of the platform centered of the local 'up' of the effector."
	}
,
	"PlatformEffector2D.useOneWay": {
		"prefix": "PlatformEffector2D.useOneWay",
		"body": [
			"useOneWay"
		],
		"description": "return:bool des: Should the one-way collision behaviour be used?"
	}
,
	"PlatformEffector2D.useOneWayGrouping": {
		"prefix": "PlatformEffector2D.useOneWayGrouping",
		"body": [
			"useOneWayGrouping"
		],
		"description": "return:bool des: Ensures that all contacts controlled by the one-way behaviour act the same."
	}
,
	"PlatformEffector2D.useSideBounce": {
		"prefix": "PlatformEffector2D.useSideBounce",
		"body": [
			"useSideBounce"
		],
		"description": "return:bool des: Should bounce be used on the platform sides?"
	}
,
	"PlatformEffector2D.useSideFriction": {
		"prefix": "PlatformEffector2D.useSideFriction",
		"body": [
			"useSideFriction"
		],
		"description": "return:bool des: Should friction be used on the platform sides?"
	}
,
	"PlatformEffector2D.enabled": {
		"prefix": "PlatformEffector2D.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"PlatformEffector2D.isActiveAndEnabled": {
		"prefix": "PlatformEffector2D.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"PlatformEffector2D.gameObject": {
		"prefix": "PlatformEffector2D.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"PlatformEffector2D.tag": {
		"prefix": "PlatformEffector2D.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"PlatformEffector2D.transform": {
		"prefix": "PlatformEffector2D.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"PlatformEffector2D.colliderMask": {
		"prefix": "PlatformEffector2D.colliderMask",
		"body": [
			"colliderMask"
		],
		"description": "return:int des: The mask used to select specific layers allowed to interact with the effector."
	}
,
	"PlatformEffector2D.useColliderMask": {
		"prefix": "PlatformEffector2D.useColliderMask",
		"body": [
			"useColliderMask"
		],
		"description": "return:bool des: Should the collider-mask be used or the global collision matrix?"
	}
,
	"PlatformEffector2D.hideFlags": {
		"prefix": "PlatformEffector2D.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"PlatformEffector2D.name": {
		"prefix": "PlatformEffector2D.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"PlatformEffector2D.BroadcastMessage": {
		"prefix": "PlatformEffector2D.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"PlatformEffector2D.CompareTag": {
		"prefix": "PlatformEffector2D.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"PlatformEffector2D.GetComponent": {
		"prefix": "PlatformEffector2D.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"PlatformEffector2D.GetComponentInChildren": {
		"prefix": "PlatformEffector2D.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"PlatformEffector2D.GetComponentInParent": {
		"prefix": "PlatformEffector2D.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"PlatformEffector2D.GetComponents": {
		"prefix": "PlatformEffector2D.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"PlatformEffector2D.GetComponentsInChildren": {
		"prefix": "PlatformEffector2D.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"PlatformEffector2D.GetComponentsInParent": {
		"prefix": "PlatformEffector2D.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"PlatformEffector2D.SendMessage": {
		"prefix": "PlatformEffector2D.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"PlatformEffector2D.SendMessageUpwards": {
		"prefix": "PlatformEffector2D.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"PlatformEffector2D.GetInstanceID": {
		"prefix": "PlatformEffector2D.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"PlatformEffector2D.ToString": {
		"prefix": "PlatformEffector2D.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"PlatformEffector2D.Destroy": {
		"prefix": "PlatformEffector2D.Destroy",
		"body": [
			"PlatformEffector2D.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"PlatformEffector2D.DestroyImmediate": {
		"prefix": "PlatformEffector2D.DestroyImmediate",
		"body": [
			"PlatformEffector2D.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"PlatformEffector2D.DontDestroyOnLoad": {
		"prefix": "PlatformEffector2D.DontDestroyOnLoad",
		"body": [
			"PlatformEffector2D.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"PlatformEffector2D.FindObjectOfType": {
		"prefix": "PlatformEffector2D.FindObjectOfType",
		"body": [
			"PlatformEffector2D.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"PlatformEffector2D.FindObjectsOfType": {
		"prefix": "PlatformEffector2D.FindObjectsOfType",
		"body": [
			"PlatformEffector2D.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"PlatformEffector2D.Instantiate": {
		"prefix": "PlatformEffector2D.Instantiate",
		"body": [
			"PlatformEffector2D.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"PlayerPrefs.DeleteAll": {
		"prefix": "PlayerPrefs.DeleteAll",
		"body": [
			"PlayerPrefs.DeleteAll"
		],
		"description": "public static void DeleteAll(); des: Removes all keys and values from the preferences. Use with caution."
	}
,
	"PlayerPrefs.DeleteKey": {
		"prefix": "PlayerPrefs.DeleteKey",
		"body": [
			"PlayerPrefs.DeleteKey"
		],
		"description": "public static void DeleteKey(string key); des: Removes key and its corresponding value from the preferences."
	}
,
	"PlayerPrefs.GetFloat": {
		"prefix": "PlayerPrefs.GetFloat",
		"body": [
			"PlayerPrefs.GetFloat"
		],
		"description": "public static float GetFloat(string key); public static float GetFloat(string key, float defaultValue); des: Returns the value corresponding to key in the preference file if it exists."
	}
,
	"PlayerPrefs.GetInt": {
		"prefix": "PlayerPrefs.GetInt",
		"body": [
			"PlayerPrefs.GetInt"
		],
		"description": "public static int GetInt(string key); public static int GetInt(string key, int defaultValue); des: Returns the value corresponding to key in the preference file if it exists."
	}
,
	"PlayerPrefs.GetString": {
		"prefix": "PlayerPrefs.GetString",
		"body": [
			"PlayerPrefs.GetString"
		],
		"description": "public static string GetString(string key); public static string GetString(string key, string defaultValue); des: Returns the value corresponding to key in the preference file if it exists."
	}
,
	"PlayerPrefs.HasKey": {
		"prefix": "PlayerPrefs.HasKey",
		"body": [
			"PlayerPrefs.HasKey"
		],
		"description": "public static bool HasKey(string key); des: Returns true if key exists in the preferences."
	}
,
	"PlayerPrefs.Save": {
		"prefix": "PlayerPrefs.Save",
		"body": [
			"PlayerPrefs.Save"
		],
		"description": "public static void Save(); des: Writes all modified preferences to disk."
	}
,
	"PlayerPrefs.SetFloat": {
		"prefix": "PlayerPrefs.SetFloat",
		"body": [
			"PlayerPrefs.SetFloat"
		],
		"description": "public static void SetFloat(string key, float value); des: Sets the value of the preference identified by key."
	}
,
	"PlayerPrefs.SetInt": {
		"prefix": "PlayerPrefs.SetInt",
		"body": [
			"PlayerPrefs.SetInt"
		],
		"description": "public static void SetInt(string key, int value); des: Sets the value of the preference identified by key."
	}
,
	"PlayerPrefs.SetString": {
		"prefix": "PlayerPrefs.SetString",
		"body": [
			"PlayerPrefs.SetString"
		],
		"description": "public static void SetString(string key, string value); des: Sets the value of the preference identified by key."
	}
,
	"PointEffector2D.angularDrag": {
		"prefix": "PointEffector2D.angularDrag",
		"body": [
			"angularDrag"
		],
		"description": "return:float des: The angular drag to apply to rigid-bodies."
	}
,
	"PointEffector2D.distanceScale": {
		"prefix": "PointEffector2D.distanceScale",
		"body": [
			"distanceScale"
		],
		"description": "return:float des: The scale applied to the calculated distance between source and target."
	}
,
	"PointEffector2D.drag": {
		"prefix": "PointEffector2D.drag",
		"body": [
			"drag"
		],
		"description": "return:float des: The linear drag to apply to rigid-bodies."
	}
,
	"PointEffector2D.forceMagnitude": {
		"prefix": "PointEffector2D.forceMagnitude",
		"body": [
			"forceMagnitude"
		],
		"description": "return:float des: The magnitude of the force to be applied."
	}
,
	"PointEffector2D.forceMode": {
		"prefix": "PointEffector2D.forceMode",
		"body": [
			"forceMode"
		],
		"description": "return:EffectorForceMode2D des: The mode used to apply the effector force."
	}
,
	"PointEffector2D.forceSource": {
		"prefix": "PointEffector2D.forceSource",
		"body": [
			"forceSource"
		],
		"description": "return:EffectorSelection2D des: The source which is used to calculate the centroid point of the effector. The distance from the target is defined from this point."
	}
,
	"PointEffector2D.forceTarget": {
		"prefix": "PointEffector2D.forceTarget",
		"body": [
			"forceTarget"
		],
		"description": "return:EffectorSelection2D des: The target for where the effector applies any force."
	}
,
	"PointEffector2D.forceVariation": {
		"prefix": "PointEffector2D.forceVariation",
		"body": [
			"forceVariation"
		],
		"description": "return:float des: The variation of the magnitude of the force to be applied."
	}
,
	"PointEffector2D.enabled": {
		"prefix": "PointEffector2D.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"PointEffector2D.isActiveAndEnabled": {
		"prefix": "PointEffector2D.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"PointEffector2D.gameObject": {
		"prefix": "PointEffector2D.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"PointEffector2D.tag": {
		"prefix": "PointEffector2D.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"PointEffector2D.transform": {
		"prefix": "PointEffector2D.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"PointEffector2D.colliderMask": {
		"prefix": "PointEffector2D.colliderMask",
		"body": [
			"colliderMask"
		],
		"description": "return:int des: The mask used to select specific layers allowed to interact with the effector."
	}
,
	"PointEffector2D.useColliderMask": {
		"prefix": "PointEffector2D.useColliderMask",
		"body": [
			"useColliderMask"
		],
		"description": "return:bool des: Should the collider-mask be used or the global collision matrix?"
	}
,
	"PointEffector2D.hideFlags": {
		"prefix": "PointEffector2D.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"PointEffector2D.name": {
		"prefix": "PointEffector2D.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"PointEffector2D.BroadcastMessage": {
		"prefix": "PointEffector2D.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"PointEffector2D.CompareTag": {
		"prefix": "PointEffector2D.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"PointEffector2D.GetComponent": {
		"prefix": "PointEffector2D.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"PointEffector2D.GetComponentInChildren": {
		"prefix": "PointEffector2D.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"PointEffector2D.GetComponentInParent": {
		"prefix": "PointEffector2D.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"PointEffector2D.GetComponents": {
		"prefix": "PointEffector2D.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"PointEffector2D.GetComponentsInChildren": {
		"prefix": "PointEffector2D.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"PointEffector2D.GetComponentsInParent": {
		"prefix": "PointEffector2D.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"PointEffector2D.SendMessage": {
		"prefix": "PointEffector2D.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"PointEffector2D.SendMessageUpwards": {
		"prefix": "PointEffector2D.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"PointEffector2D.GetInstanceID": {
		"prefix": "PointEffector2D.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"PointEffector2D.ToString": {
		"prefix": "PointEffector2D.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"PointEffector2D.Destroy": {
		"prefix": "PointEffector2D.Destroy",
		"body": [
			"PointEffector2D.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"PointEffector2D.DestroyImmediate": {
		"prefix": "PointEffector2D.DestroyImmediate",
		"body": [
			"PointEffector2D.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"PointEffector2D.DontDestroyOnLoad": {
		"prefix": "PointEffector2D.DontDestroyOnLoad",
		"body": [
			"PointEffector2D.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"PointEffector2D.FindObjectOfType": {
		"prefix": "PointEffector2D.FindObjectOfType",
		"body": [
			"PointEffector2D.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"PointEffector2D.FindObjectsOfType": {
		"prefix": "PointEffector2D.FindObjectsOfType",
		"body": [
			"PointEffector2D.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"PointEffector2D.Instantiate": {
		"prefix": "PointEffector2D.Instantiate",
		"body": [
			"PointEffector2D.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"PolygonCollider2D.autoTiling": {
		"prefix": "PolygonCollider2D.autoTiling",
		"body": [
			"autoTiling"
		],
		"description": "return:bool des: Determines whether the PolygonCollider2D's shape is automatically updated based on a SpriteRenderer's tiling properties."
	}
,
	"PolygonCollider2D.pathCount": {
		"prefix": "PolygonCollider2D.pathCount",
		"body": [
			"pathCount"
		],
		"description": "return:int des: The number of paths in the polygon."
	}
,
	"PolygonCollider2D.points": {
		"prefix": "PolygonCollider2D.points",
		"body": [
			"points"
		],
		"description": "return:Vector2[] des: Corner points that define the collider's shape in local space."
	}
,
	"PolygonCollider2D.CreatePrimitive": {
		"prefix": "PolygonCollider2D.CreatePrimitive",
		"body": [
			"CreatePrimitive($1)"
		],
		"description": "public void CreatePrimitive(int sides, Vector2 scale = Vector2.one, Vector2 offset = Vector2.zero); des: Creates as regular primitive polygon with the specified number of sides."
	}
,
	"PolygonCollider2D.GetPath": {
		"prefix": "PolygonCollider2D.GetPath",
		"body": [
			"GetPath($1)"
		],
		"description": "public Vector2[] GetPath(int index); des: Gets a path from the Collider by its index."
	}
,
	"PolygonCollider2D.GetTotalPointCount": {
		"prefix": "PolygonCollider2D.GetTotalPointCount",
		"body": [
			"GetTotalPointCount($1)"
		],
		"description": "public int GetTotalPointCount(); des: Return the total number of points in the polygon in all paths."
	}
,
	"PolygonCollider2D.SetPath": {
		"prefix": "PolygonCollider2D.SetPath",
		"body": [
			"SetPath($1)"
		],
		"description": "public void SetPath(int index, Vector2[] points); des: Define a path by its constituent points."
	}
,
	"PolygonCollider2D.enabled": {
		"prefix": "PolygonCollider2D.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"PolygonCollider2D.isActiveAndEnabled": {
		"prefix": "PolygonCollider2D.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"PolygonCollider2D.attachedRigidbody": {
		"prefix": "PolygonCollider2D.attachedRigidbody",
		"body": [
			"attachedRigidbody"
		],
		"description": "return:Rigidbody2D des: The Rigidbody2D attached to the Collider2D."
	}
,
	"PolygonCollider2D.bounciness": {
		"prefix": "PolygonCollider2D.bounciness",
		"body": [
			"bounciness"
		],
		"description": "return:float des: Get the bounciness used by the collider."
	}
,
	"PolygonCollider2D.bounds": {
		"prefix": "PolygonCollider2D.bounds",
		"body": [
			"bounds"
		],
		"description": "return:Bounds des: The world space bounding area of the collider."
	}
,
	"PolygonCollider2D.composite": {
		"prefix": "PolygonCollider2D.composite",
		"body": [
			"composite"
		],
		"description": "return:CompositeCollider2D des: Get the CompositeCollider2D that is available to be attached to the collider."
	}
,
	"PolygonCollider2D.density": {
		"prefix": "PolygonCollider2D.density",
		"body": [
			"density"
		],
		"description": "return:float des: The density of the collider used to calculate its mass (when auto mass is enabled)."
	}
,
	"PolygonCollider2D.friction": {
		"prefix": "PolygonCollider2D.friction",
		"body": [
			"friction"
		],
		"description": "return:float des: Get the friction used by the collider."
	}
,
	"PolygonCollider2D.isTrigger": {
		"prefix": "PolygonCollider2D.isTrigger",
		"body": [
			"isTrigger"
		],
		"description": "return:bool des: Is this collider configured as a trigger?"
	}
,
	"PolygonCollider2D.offset": {
		"prefix": "PolygonCollider2D.offset",
		"body": [
			"offset"
		],
		"description": "return:Vector2 des: The local offset of the collider geometry."
	}
,
	"PolygonCollider2D.shapeCount": {
		"prefix": "PolygonCollider2D.shapeCount",
		"body": [
			"shapeCount"
		],
		"description": "return:int des: The number of separate shaped regions in the collider."
	}
,
	"PolygonCollider2D.sharedMaterial": {
		"prefix": "PolygonCollider2D.sharedMaterial",
		"body": [
			"sharedMaterial"
		],
		"description": "return:PhysicsMaterial2D des: The PhysicsMaterial2D that is applied to this collider."
	}
,
	"PolygonCollider2D.usedByComposite": {
		"prefix": "PolygonCollider2D.usedByComposite",
		"body": [
			"usedByComposite"
		],
		"description": "return:bool des: Sets whether the Collider will be used or not used by a CompositeCollider2D."
	}
,
	"PolygonCollider2D.usedByEffector": {
		"prefix": "PolygonCollider2D.usedByEffector",
		"body": [
			"usedByEffector"
		],
		"description": "return:bool des: Whether the collider is used by an attached effector or not."
	}
,
	"PolygonCollider2D.gameObject": {
		"prefix": "PolygonCollider2D.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"PolygonCollider2D.tag": {
		"prefix": "PolygonCollider2D.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"PolygonCollider2D.transform": {
		"prefix": "PolygonCollider2D.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"PolygonCollider2D.hideFlags": {
		"prefix": "PolygonCollider2D.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"PolygonCollider2D.name": {
		"prefix": "PolygonCollider2D.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"PolygonCollider2D.Cast": {
		"prefix": "PolygonCollider2D.Cast",
		"body": [
			"Cast($1)"
		],
		"description": "public int Cast(Vector2 direction, RaycastHit2D[] results, float distance = Mathf.Infinity, bool ignoreSiblingColliders = true); public int Cast(Vector2 direction, ContactFilter2D contactFilter, RaycastHit2D[] results, float distance = Mathf.Infinity, bool ignoreSiblingColliders = true); des: Casts the collider shape into the scene starting at the collider position ignoring the collider itself."
	}
,
	"PolygonCollider2D.Distance": {
		"prefix": "PolygonCollider2D.Distance",
		"body": [
			"Distance($1)"
		],
		"description": "public ColliderDistance2D Distance(Collider2D collider); des: Calculates the minimum separation of this collider against another collider."
	}
,
	"PolygonCollider2D.GetContacts": {
		"prefix": "PolygonCollider2D.GetContacts",
		"body": [
			"GetContacts($1)"
		],
		"description": "public int GetContacts(ContactPoint2D[] contacts); public int GetContacts(Collider2D[] colliders); public int GetContacts(ContactFilter2D contactFilter, ContactPoint2D[] contacts); public int GetContacts(ContactFilter2D contactFilter, Collider2D[] colliders); des: Retrieves all contact points for this collider."
	}
,
	"PolygonCollider2D.IsTouching": {
		"prefix": "PolygonCollider2D.IsTouching",
		"body": [
			"IsTouching($1)"
		],
		"description": "public bool IsTouching(Collider2D collider); public bool IsTouching(Collider2D collider, ContactFilter2D contactFilter); public bool IsTouching(ContactFilter2D contactFilter); des: Check whether this collider is touching the collider or not."
	}
,
	"PolygonCollider2D.IsTouchingLayers": {
		"prefix": "PolygonCollider2D.IsTouchingLayers",
		"body": [
			"IsTouchingLayers($1)"
		],
		"description": "public bool IsTouchingLayers(int layerMask = Physics2D.AllLayers); des: Checks whether this collider is touching any colliders on the specified layerMask or not."
	}
,
	"PolygonCollider2D.OverlapCollider": {
		"prefix": "PolygonCollider2D.OverlapCollider",
		"body": [
			"OverlapCollider($1)"
		],
		"description": "public int OverlapCollider(ContactFilter2D contactFilter, Collider2D[] results); des: Get a list of all colliders that overlap this collider."
	}
,
	"PolygonCollider2D.OverlapPoint": {
		"prefix": "PolygonCollider2D.OverlapPoint",
		"body": [
			"OverlapPoint($1)"
		],
		"description": "public bool OverlapPoint(Vector2 point); des: Check if a collider overlaps a point in space."
	}
,
	"PolygonCollider2D.Raycast": {
		"prefix": "PolygonCollider2D.Raycast",
		"body": [
			"Raycast($1)"
		],
		"description": "public int Raycast(Vector2 direction, RaycastHit2D[] results, float distance = Mathf.Infinity, int layerMask = Physics2D.AllLayers, float minDepth = -Mathf.Infinity, float maxDepth = Mathf.Infinity); public int Raycast(Vector2 direction, ContactFilter2D contactFilter, RaycastHit2D[] results, float distance = Mathf.Infinity); des: Casts a ray into the scene starting at the collider position ignoring the collider itself."
	}
,
	"PolygonCollider2D.BroadcastMessage": {
		"prefix": "PolygonCollider2D.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"PolygonCollider2D.CompareTag": {
		"prefix": "PolygonCollider2D.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"PolygonCollider2D.GetComponent": {
		"prefix": "PolygonCollider2D.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"PolygonCollider2D.GetComponentInChildren": {
		"prefix": "PolygonCollider2D.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"PolygonCollider2D.GetComponentInParent": {
		"prefix": "PolygonCollider2D.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"PolygonCollider2D.GetComponents": {
		"prefix": "PolygonCollider2D.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"PolygonCollider2D.GetComponentsInChildren": {
		"prefix": "PolygonCollider2D.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"PolygonCollider2D.GetComponentsInParent": {
		"prefix": "PolygonCollider2D.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"PolygonCollider2D.SendMessage": {
		"prefix": "PolygonCollider2D.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"PolygonCollider2D.SendMessageUpwards": {
		"prefix": "PolygonCollider2D.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"PolygonCollider2D.GetInstanceID": {
		"prefix": "PolygonCollider2D.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"PolygonCollider2D.ToString": {
		"prefix": "PolygonCollider2D.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"PolygonCollider2D.Destroy": {
		"prefix": "PolygonCollider2D.Destroy",
		"body": [
			"PolygonCollider2D.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"PolygonCollider2D.DestroyImmediate": {
		"prefix": "PolygonCollider2D.DestroyImmediate",
		"body": [
			"PolygonCollider2D.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"PolygonCollider2D.DontDestroyOnLoad": {
		"prefix": "PolygonCollider2D.DontDestroyOnLoad",
		"body": [
			"PolygonCollider2D.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"PolygonCollider2D.FindObjectOfType": {
		"prefix": "PolygonCollider2D.FindObjectOfType",
		"body": [
			"PolygonCollider2D.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"PolygonCollider2D.FindObjectsOfType": {
		"prefix": "PolygonCollider2D.FindObjectsOfType",
		"body": [
			"PolygonCollider2D.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"PolygonCollider2D.Instantiate": {
		"prefix": "PolygonCollider2D.Instantiate",
		"body": [
			"PolygonCollider2D.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"PolygonCollider2D.OnCollisionEnter2D": {
		"prefix": "PolygonCollider2D.OnCollisionEnter2D",
		"body": [
			"OnCollisionEnter2D"
		],
		"description": "Sent when an incoming collider makes contact with this object's collider (2D physics only)."
	}
,
	"PolygonCollider2D.OnCollisionExit2D": {
		"prefix": "PolygonCollider2D.OnCollisionExit2D",
		"body": [
			"OnCollisionExit2D"
		],
		"description": "Sent when a collider on another object stops touching this object's collider (2D physics only)."
	}
,
	"PolygonCollider2D.OnCollisionStay2D": {
		"prefix": "PolygonCollider2D.OnCollisionStay2D",
		"body": [
			"OnCollisionStay2D"
		],
		"description": "Sent each frame where a collider on another object is touching this object's collider (2D physics only)."
	}
,
	"PolygonCollider2D.OnTriggerEnter2D": {
		"prefix": "PolygonCollider2D.OnTriggerEnter2D",
		"body": [
			"OnTriggerEnter2D"
		],
		"description": "Sent when another object enters a trigger collider attached to this object (2D physics only)."
	}
,
	"PolygonCollider2D.OnTriggerExit2D": {
		"prefix": "PolygonCollider2D.OnTriggerExit2D",
		"body": [
			"OnTriggerExit2D"
		],
		"description": "Sent when another object leaves a trigger collider attached to this object (2D physics only)."
	}
,
	"PolygonCollider2D.OnTriggerStay2D": {
		"prefix": "PolygonCollider2D.OnTriggerStay2D",
		"body": [
			"OnTriggerStay2D"
		],
		"description": "Sent each frame where another object is within a trigger collider attached to this object (2D physics only)."
	}
,
	"Pose.forward": {
		"prefix": "Pose.forward",
		"body": [
			"forward"
		],
		"description": "return:Vector3 des: Returns the forward vector of the pose."
	}
,
	"Pose.position": {
		"prefix": "Pose.position",
		"body": [
			"position"
		],
		"description": "return:Vector3 des: The position component of the pose."
	}
,
	"Pose.right": {
		"prefix": "Pose.right",
		"body": [
			"right"
		],
		"description": "return:Vector3 des: Returns the right vector of the pose."
	}
,
	"Pose.rotation": {
		"prefix": "Pose.rotation",
		"body": [
			"rotation"
		],
		"description": "return:Quaternion des: The rotation component of the pose."
	}
,
	"Pose.up": {
		"prefix": "Pose.up",
		"body": [
			"up"
		],
		"description": "return:Vector3 des: Returns the up vector of the pose."
	}
,
	"Pose.GetTransformedBy": {
		"prefix": "Pose.GetTransformedBy",
		"body": [
			"GetTransformedBy($1)"
		],
		"description": "public Pose GetTransformedBy(Pose lhs); public Pose GetTransformedBy(Transform lhs); des: Transforms the current pose into the local space of the provided pose."
	}
,
	"ProceduralMaterial.color": {
		"prefix": "ProceduralMaterial.color",
		"body": [
			"color"
		],
		"description": "return:Color des: The main material's color."
	}
,
	"ProceduralMaterial.doubleSidedGI": {
		"prefix": "ProceduralMaterial.doubleSidedGI",
		"body": [
			"doubleSidedGI"
		],
		"description": "return:bool des: Gets and sets whether the Double Sided Global Illumination setting is enabled for this material."
	}
,
	"ProceduralMaterial.enableInstancing": {
		"prefix": "ProceduralMaterial.enableInstancing",
		"body": [
			"enableInstancing"
		],
		"description": "return:bool des: Gets and sets whether GPU instancing is enabled for this material."
	}
,
	"ProceduralMaterial.globalIlluminationFlags": {
		"prefix": "ProceduralMaterial.globalIlluminationFlags",
		"body": [
			"globalIlluminationFlags"
		],
		"description": "return:MaterialGlobalIlluminationFlags des: Defines how the material should interact with lightmaps and lightprobes."
	}
,
	"ProceduralMaterial.mainTexture": {
		"prefix": "ProceduralMaterial.mainTexture",
		"body": [
			"mainTexture"
		],
		"description": "return:Texture des: The material's texture."
	}
,
	"ProceduralMaterial.mainTextureOffset": {
		"prefix": "ProceduralMaterial.mainTextureOffset",
		"body": [
			"mainTextureOffset"
		],
		"description": "return:Vector2 des: The texture offset of the main texture."
	}
,
	"ProceduralMaterial.mainTextureScale": {
		"prefix": "ProceduralMaterial.mainTextureScale",
		"body": [
			"mainTextureScale"
		],
		"description": "return:Vector2 des: The texture scale of the main texture."
	}
,
	"ProceduralMaterial.passCount": {
		"prefix": "ProceduralMaterial.passCount",
		"body": [
			"passCount"
		],
		"description": "return:int des: How many passes are in this material (Read Only)."
	}
,
	"ProceduralMaterial.renderQueue": {
		"prefix": "ProceduralMaterial.renderQueue",
		"body": [
			"renderQueue"
		],
		"description": "return:int des: Render queue of this material."
	}
,
	"ProceduralMaterial.shader": {
		"prefix": "ProceduralMaterial.shader",
		"body": [
			"shader"
		],
		"description": "return:Shader des: The shader used by the material."
	}
,
	"ProceduralMaterial.shaderKeywords": {
		"prefix": "ProceduralMaterial.shaderKeywords",
		"body": [
			"shaderKeywords"
		],
		"description": "return:string[] des: Additional shader keywords set by this material."
	}
,
	"ProceduralMaterial.hideFlags": {
		"prefix": "ProceduralMaterial.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"ProceduralMaterial.name": {
		"prefix": "ProceduralMaterial.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"ProceduralMaterial.CopyPropertiesFromMaterial": {
		"prefix": "ProceduralMaterial.CopyPropertiesFromMaterial",
		"body": [
			"CopyPropertiesFromMaterial($1)"
		],
		"description": "public void CopyPropertiesFromMaterial(Material mat); des: Copy properties from other material into this material."
	}
,
	"ProceduralMaterial.DisableKeyword": {
		"prefix": "ProceduralMaterial.DisableKeyword",
		"body": [
			"DisableKeyword($1)"
		],
		"description": "public void DisableKeyword(string keyword); des: Unset a shader keyword."
	}
,
	"ProceduralMaterial.EnableKeyword": {
		"prefix": "ProceduralMaterial.EnableKeyword",
		"body": [
			"EnableKeyword($1)"
		],
		"description": "public void EnableKeyword(string keyword); des: Sets a shader keyword that is enabled by this material."
	}
,
	"ProceduralMaterial.FindPass": {
		"prefix": "ProceduralMaterial.FindPass",
		"body": [
			"FindPass($1)"
		],
		"description": "public int FindPass(string passName); des: Returns the index of the pass passName."
	}
,
	"ProceduralMaterial.GetColor": {
		"prefix": "ProceduralMaterial.GetColor",
		"body": [
			"GetColor($1)"
		],
		"description": "public Color GetColor(string name); public Color GetColor(int nameID); des: Get a named color value."
	}
,
	"ProceduralMaterial.GetColorArray": {
		"prefix": "ProceduralMaterial.GetColorArray",
		"body": [
			"GetColorArray($1)"
		],
		"description": "public Color[] GetColorArray(string name); public Color[] GetColorArray(int nameID); public void GetColorArray(string name, List<Color> values); public void GetColorArray(int nameID, List<Color> values); des: Get a named color array."
	}
,
	"ProceduralMaterial.GetFloat": {
		"prefix": "ProceduralMaterial.GetFloat",
		"body": [
			"GetFloat($1)"
		],
		"description": "public float GetFloat(string name); public float GetFloat(int nameID); des: Get a named float value."
	}
,
	"ProceduralMaterial.GetFloatArray": {
		"prefix": "ProceduralMaterial.GetFloatArray",
		"body": [
			"GetFloatArray($1)"
		],
		"description": "public float[] GetFloatArray(string name); public float[] GetFloatArray(int nameID); public void GetFloatArray(string name, List<float> values); public void GetFloatArray(int nameID, List<float> values); des: Get a named float array."
	}
,
	"ProceduralMaterial.GetInt": {
		"prefix": "ProceduralMaterial.GetInt",
		"body": [
			"GetInt($1)"
		],
		"description": "public int GetInt(string name); public int GetInt(int nameID); des: Get a named integer value."
	}
,
	"ProceduralMaterial.GetMatrix": {
		"prefix": "ProceduralMaterial.GetMatrix",
		"body": [
			"GetMatrix($1)"
		],
		"description": "public Matrix4x4 GetMatrix(string name); public Matrix4x4 GetMatrix(int nameID); des: Get a named matrix value from the shader."
	}
,
	"ProceduralMaterial.GetMatrixArray": {
		"prefix": "ProceduralMaterial.GetMatrixArray",
		"body": [
			"GetMatrixArray($1)"
		],
		"description": "public Matrix4x4[] GetMatrixArray(string name); public Matrix4x4[] GetMatrixArray(int nameID); public void GetMatrixArray(string name, List<Matrix4x4> values); public void GetMatrixArray(int nameID, List<Matrix4x4> values); des: Get a named matrix array."
	}
,
	"ProceduralMaterial.GetPassName": {
		"prefix": "ProceduralMaterial.GetPassName",
		"body": [
			"GetPassName($1)"
		],
		"description": "public string GetPassName(int pass); des: Returns the name of the shader pass at index pass."
	}
,
	"ProceduralMaterial.GetShaderPassEnabled": {
		"prefix": "ProceduralMaterial.GetShaderPassEnabled",
		"body": [
			"GetShaderPassEnabled($1)"
		],
		"description": "public bool GetShaderPassEnabled(string passName); des: Checks whether a given Shader pass is enabled on this Material."
	}
,
	"ProceduralMaterial.GetTag": {
		"prefix": "ProceduralMaterial.GetTag",
		"body": [
			"GetTag($1)"
		],
		"description": "public string GetTag(string tag, bool searchFallbacks); public string GetTag(string tag, bool searchFallbacks, string defaultValue); des: Get the value of material's shader tag."
	}
,
	"ProceduralMaterial.GetTexture": {
		"prefix": "ProceduralMaterial.GetTexture",
		"body": [
			"GetTexture($1)"
		],
		"description": "public Texture GetTexture(string name); public Texture GetTexture(int nameID); des: Get a named texture."
	}
,
	"ProceduralMaterial.GetTextureOffset": {
		"prefix": "ProceduralMaterial.GetTextureOffset",
		"body": [
			"GetTextureOffset($1)"
		],
		"description": "public Vector2 GetTextureOffset(string name); public Vector2 GetTextureOffset(int nameID); des: Gets the placement offset of texture propertyName."
	}
,
	"ProceduralMaterial.GetTexturePropertyNameIDs": {
		"prefix": "ProceduralMaterial.GetTexturePropertyNameIDs",
		"body": [
			"GetTexturePropertyNameIDs($1)"
		],
		"description": "public int[] GetTexturePropertyNameIDs(); public void GetTexturePropertyNameIDs(List<int> outNames); des: Return the name IDs of all texture properties exposed on this material."
	}
,
	"ProceduralMaterial.GetTexturePropertyNames": {
		"prefix": "ProceduralMaterial.GetTexturePropertyNames",
		"body": [
			"GetTexturePropertyNames($1)"
		],
		"description": "public string[] GetTexturePropertyNames(); public void GetTexturePropertyNames(List<string> outNames); des: Returns the names of all texture properties exposed on this material."
	}
,
	"ProceduralMaterial.GetTextureScale": {
		"prefix": "ProceduralMaterial.GetTextureScale",
		"body": [
			"GetTextureScale($1)"
		],
		"description": "public Vector2 GetTextureScale(string name); public Vector2 GetTextureScale(int nameID); des: Gets the placement scale of texture propertyName."
	}
,
	"ProceduralMaterial.GetVector": {
		"prefix": "ProceduralMaterial.GetVector",
		"body": [
			"GetVector($1)"
		],
		"description": "public Vector4 GetVector(string name); public Vector4 GetVector(int nameID); des: Get a named vector value."
	}
,
	"ProceduralMaterial.GetVectorArray": {
		"prefix": "ProceduralMaterial.GetVectorArray",
		"body": [
			"GetVectorArray($1)"
		],
		"description": "public Vector4[] GetVectorArray(string name); public Vector4[] GetVectorArray(int nameID); public void GetVectorArray(string name, List<Vector4> values); public void GetVectorArray(int nameID, List<Vector4> values); des: Get a named vector array."
	}
,
	"ProceduralMaterial.HasProperty": {
		"prefix": "ProceduralMaterial.HasProperty",
		"body": [
			"HasProperty($1)"
		],
		"description": "public bool HasProperty(string name); public bool HasProperty(int nameID); des: Checks if material's shader has a property of a given name."
	}
,
	"ProceduralMaterial.IsKeywordEnabled": {
		"prefix": "ProceduralMaterial.IsKeywordEnabled",
		"body": [
			"IsKeywordEnabled($1)"
		],
		"description": "public bool IsKeywordEnabled(string keyword); des: Is the shader keyword enabled on this material?"
	}
,
	"ProceduralMaterial.Lerp": {
		"prefix": "ProceduralMaterial.Lerp",
		"body": [
			"Lerp($1)"
		],
		"description": "public void Lerp(Material start, Material end, float t); des: Interpolate properties between two materials."
	}
,
	"ProceduralMaterial.SetBuffer": {
		"prefix": "ProceduralMaterial.SetBuffer",
		"body": [
			"SetBuffer($1)"
		],
		"description": "public void SetBuffer(string name, ComputeBuffer value); public void SetBuffer(int nameID, ComputeBuffer value); des: Sets a named ComputeBuffer value."
	}
,
	"ProceduralMaterial.SetColor": {
		"prefix": "ProceduralMaterial.SetColor",
		"body": [
			"SetColor($1)"
		],
		"description": "public void SetColor(string name, Color value); public void SetColor(int nameID, Color value); des: Sets a named color value."
	}
,
	"ProceduralMaterial.SetColorArray": {
		"prefix": "ProceduralMaterial.SetColorArray",
		"body": [
			"SetColorArray($1)"
		],
		"description": "public void SetColorArray(string name, Color[] values); public void SetColorArray(int nameID, Color[] values); public void SetColorArray(string name, List<Color> values); public void SetColorArray(int nameID, List<Color> values); des: Sets a color array property."
	}
,
	"ProceduralMaterial.SetFloat": {
		"prefix": "ProceduralMaterial.SetFloat",
		"body": [
			"SetFloat($1)"
		],
		"description": "public void SetFloat(string name, float value); public void SetFloat(int nameID, float value); des: Sets a named float value."
	}
,
	"ProceduralMaterial.SetFloatArray": {
		"prefix": "ProceduralMaterial.SetFloatArray",
		"body": [
			"SetFloatArray($1)"
		],
		"description": "public void SetFloatArray(string name, float[] values); public void SetFloatArray(int nameID, float[] values); public void SetFloatArray(string name, List<float> values); public void SetFloatArray(int nameID, List<float> values); des: Sets a float array property."
	}
,
	"ProceduralMaterial.SetInt": {
		"prefix": "ProceduralMaterial.SetInt",
		"body": [
			"SetInt($1)"
		],
		"description": "public void SetInt(string name, int value); public void SetInt(int nameID, int value); des: Sets a named integer value."
	}
,
	"ProceduralMaterial.SetMatrix": {
		"prefix": "ProceduralMaterial.SetMatrix",
		"body": [
			"SetMatrix($1)"
		],
		"description": "public void SetMatrix(string name, Matrix4x4 value); public void SetMatrix(int nameID, Matrix4x4 value); des: Sets a named matrix for the shader."
	}
,
	"ProceduralMaterial.SetMatrixArray": {
		"prefix": "ProceduralMaterial.SetMatrixArray",
		"body": [
			"SetMatrixArray($1)"
		],
		"description": "public void SetMatrixArray(string name, Matrix4x4[] values); public void SetMatrixArray(int nameID, Matrix4x4[] values); public void SetMatrixArray(string name, List<Matrix4x4> values); public void SetMatrixArray(int nameID, List<Matrix4x4> values); des: Sets a matrix array property."
	}
,
	"ProceduralMaterial.SetOverrideTag": {
		"prefix": "ProceduralMaterial.SetOverrideTag",
		"body": [
			"SetOverrideTag($1)"
		],
		"description": "public void SetOverrideTag(string tag, string val); des: Sets an override tag/value on the material."
	}
,
	"ProceduralMaterial.SetPass": {
		"prefix": "ProceduralMaterial.SetPass",
		"body": [
			"SetPass($1)"
		],
		"description": "public bool SetPass(int pass); des: Activate the given pass for rendering."
	}
,
	"ProceduralMaterial.SetShaderPassEnabled": {
		"prefix": "ProceduralMaterial.SetShaderPassEnabled",
		"body": [
			"SetShaderPassEnabled($1)"
		],
		"description": "public void SetShaderPassEnabled(string passName, bool enabled); des: Enables or disables a Shader pass on a per-Material level."
	}
,
	"ProceduralMaterial.SetTexture": {
		"prefix": "ProceduralMaterial.SetTexture",
		"body": [
			"SetTexture($1)"
		],
		"description": "public void SetTexture(string name, Texture value); public void SetTexture(int nameID, Texture value); des: Sets a named texture."
	}
,
	"ProceduralMaterial.SetTextureOffset": {
		"prefix": "ProceduralMaterial.SetTextureOffset",
		"body": [
			"SetTextureOffset($1)"
		],
		"description": "public void SetTextureOffset(string name, Vector2 value); public void SetTextureOffset(int nameID, Vector2 value); des: Sets the placement offset of texture propertyName."
	}
,
	"ProceduralMaterial.SetTextureScale": {
		"prefix": "ProceduralMaterial.SetTextureScale",
		"body": [
			"SetTextureScale($1)"
		],
		"description": "public void SetTextureScale(string name, Vector2 value); public void SetTextureScale(int nameID, Vector2 value); des: Sets the placement scale of texture propertyName."
	}
,
	"ProceduralMaterial.SetVector": {
		"prefix": "ProceduralMaterial.SetVector",
		"body": [
			"SetVector($1)"
		],
		"description": "public void SetVector(string name, Vector4 value); public void SetVector(int nameID, Vector4 value); des: Sets a named vector value."
	}
,
	"ProceduralMaterial.SetVectorArray": {
		"prefix": "ProceduralMaterial.SetVectorArray",
		"body": [
			"SetVectorArray($1)"
		],
		"description": "public void SetVectorArray(string name, Vector4[] values); public void SetVectorArray(int nameID, Vector4[] values); public void SetVectorArray(string name, List<Vector4> values); public void SetVectorArray(int nameID, List<Vector4> values); des: Sets a vector array property."
	}
,
	"ProceduralMaterial.GetInstanceID": {
		"prefix": "ProceduralMaterial.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"ProceduralMaterial.ToString": {
		"prefix": "ProceduralMaterial.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"ProceduralMaterial.Destroy": {
		"prefix": "ProceduralMaterial.Destroy",
		"body": [
			"ProceduralMaterial.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"ProceduralMaterial.DestroyImmediate": {
		"prefix": "ProceduralMaterial.DestroyImmediate",
		"body": [
			"ProceduralMaterial.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"ProceduralMaterial.DontDestroyOnLoad": {
		"prefix": "ProceduralMaterial.DontDestroyOnLoad",
		"body": [
			"ProceduralMaterial.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"ProceduralMaterial.FindObjectOfType": {
		"prefix": "ProceduralMaterial.FindObjectOfType",
		"body": [
			"ProceduralMaterial.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"ProceduralMaterial.FindObjectsOfType": {
		"prefix": "ProceduralMaterial.FindObjectsOfType",
		"body": [
			"ProceduralMaterial.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"ProceduralMaterial.Instantiate": {
		"prefix": "ProceduralMaterial.Instantiate",
		"body": [
			"ProceduralMaterial.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"ProceduralTexture.hideFlags": {
		"prefix": "ProceduralTexture.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"ProceduralTexture.name": {
		"prefix": "ProceduralTexture.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"ProceduralTexture.anisoLevel": {
		"prefix": "ProceduralTexture.anisoLevel",
		"body": [
			"anisoLevel"
		],
		"description": "return:int des: Anisotropic filtering level of the texture."
	}
,
	"ProceduralTexture.dimension": {
		"prefix": "ProceduralTexture.dimension",
		"body": [
			"dimension"
		],
		"description": "return:Rendering.TextureDimension des: Dimensionality (type) of the texture (Read Only)."
	}
,
	"ProceduralTexture.filterMode": {
		"prefix": "ProceduralTexture.filterMode",
		"body": [
			"filterMode"
		],
		"description": "return:FilterMode des: Filtering mode of the texture."
	}
,
	"ProceduralTexture.height": {
		"prefix": "ProceduralTexture.height",
		"body": [
			"height"
		],
		"description": "return:int des: Height of the texture in pixels. (Read Only)"
	}
,
	"ProceduralTexture.imageContentsHash": {
		"prefix": "ProceduralTexture.imageContentsHash",
		"body": [
			"imageContentsHash"
		],
		"description": "return:Hash128 des: The hash value of the Texture."
	}
,
	"ProceduralTexture.mipMapBias": {
		"prefix": "ProceduralTexture.mipMapBias",
		"body": [
			"mipMapBias"
		],
		"description": "return:float des: Mip map bias of the texture."
	}
,
	"ProceduralTexture.updateCount": {
		"prefix": "ProceduralTexture.updateCount",
		"body": [
			"updateCount"
		],
		"description": "return:uint des: This counter is incremented when the texture is updated."
	}
,
	"ProceduralTexture.width": {
		"prefix": "ProceduralTexture.width",
		"body": [
			"width"
		],
		"description": "return:int des: Width of the texture in pixels. (Read Only)"
	}
,
	"ProceduralTexture.wrapMode": {
		"prefix": "ProceduralTexture.wrapMode",
		"body": [
			"wrapMode"
		],
		"description": "return:TextureWrapMode des: Texture coordinate wrapping mode."
	}
,
	"ProceduralTexture.wrapModeU": {
		"prefix": "ProceduralTexture.wrapModeU",
		"body": [
			"wrapModeU"
		],
		"description": "return:TextureWrapMode des: Texture U coordinate wrapping mode."
	}
,
	"ProceduralTexture.wrapModeV": {
		"prefix": "ProceduralTexture.wrapModeV",
		"body": [
			"wrapModeV"
		],
		"description": "return:TextureWrapMode des: Texture V coordinate wrapping mode."
	}
,
	"ProceduralTexture.wrapModeW": {
		"prefix": "ProceduralTexture.wrapModeW",
		"body": [
			"wrapModeW"
		],
		"description": "return:TextureWrapMode des: Texture W coordinate wrapping mode for Texture3D."
	}
,
	"ProceduralTexture.GetInstanceID": {
		"prefix": "ProceduralTexture.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"ProceduralTexture.ToString": {
		"prefix": "ProceduralTexture.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"ProceduralTexture.GetNativeTexturePtr": {
		"prefix": "ProceduralTexture.GetNativeTexturePtr",
		"body": [
			"GetNativeTexturePtr($1)"
		],
		"description": "public IntPtr GetNativeTexturePtr(); des: Retrieve a native (underlying graphics API) pointer to the texture resource."
	}
,
	"ProceduralTexture.IncrementUpdateCount": {
		"prefix": "ProceduralTexture.IncrementUpdateCount",
		"body": [
			"IncrementUpdateCount($1)"
		],
		"description": "public void IncrementUpdateCount(); des: Increment the update counter."
	}
,
	"ProceduralTexture.Destroy": {
		"prefix": "ProceduralTexture.Destroy",
		"body": [
			"ProceduralTexture.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"ProceduralTexture.DestroyImmediate": {
		"prefix": "ProceduralTexture.DestroyImmediate",
		"body": [
			"ProceduralTexture.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"ProceduralTexture.DontDestroyOnLoad": {
		"prefix": "ProceduralTexture.DontDestroyOnLoad",
		"body": [
			"ProceduralTexture.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"ProceduralTexture.FindObjectOfType": {
		"prefix": "ProceduralTexture.FindObjectOfType",
		"body": [
			"ProceduralTexture.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"ProceduralTexture.FindObjectsOfType": {
		"prefix": "ProceduralTexture.FindObjectsOfType",
		"body": [
			"ProceduralTexture.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"ProceduralTexture.Instantiate": {
		"prefix": "ProceduralTexture.Instantiate",
		"body": [
			"ProceduralTexture.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"ProceduralTexture.SetGlobalAnisotropicFilteringLimits": {
		"prefix": "ProceduralTexture.SetGlobalAnisotropicFilteringLimits",
		"body": [
			"ProceduralTexture.SetGlobalAnisotropicFilteringLimits"
		],
		"description": "public static void SetGlobalAnisotropicFilteringLimits(int forcedMin, int globalMax); des: Sets Anisotropic limits."
	}
,
	"ProceduralTexture.SetStreamingTextureMaterialDebugProperties": {
		"prefix": "ProceduralTexture.SetStreamingTextureMaterialDebugProperties",
		"body": [
			"ProceduralTexture.SetStreamingTextureMaterialDebugProperties"
		],
		"description": "public static void SetStreamingTextureMaterialDebugProperties(); des: Uploads additional debug information to materials using textures set to stream mip maps."
	}
,
	"Projector.aspectRatio": {
		"prefix": "Projector.aspectRatio",
		"body": [
			"aspectRatio"
		],
		"description": "return:float des: The aspect ratio of the projection."
	}
,
	"Projector.farClipPlane": {
		"prefix": "Projector.farClipPlane",
		"body": [
			"farClipPlane"
		],
		"description": "return:float des: The far clipping plane distance."
	}
,
	"Projector.fieldOfView": {
		"prefix": "Projector.fieldOfView",
		"body": [
			"fieldOfView"
		],
		"description": "return:float des: The field of view of the projection in degrees."
	}
,
	"Projector.ignoreLayers": {
		"prefix": "Projector.ignoreLayers",
		"body": [
			"ignoreLayers"
		],
		"description": "return:int des: Which object layers are ignored by the projector."
	}
,
	"Projector.material": {
		"prefix": "Projector.material",
		"body": [
			"material"
		],
		"description": "return:Material des: The material that will be projected onto every object."
	}
,
	"Projector.nearClipPlane": {
		"prefix": "Projector.nearClipPlane",
		"body": [
			"nearClipPlane"
		],
		"description": "return:float des: The near clipping plane distance."
	}
,
	"Projector.orthographic": {
		"prefix": "Projector.orthographic",
		"body": [
			"orthographic"
		],
		"description": "return:bool des: Is the projection orthographic (true) or perspective (false)?"
	}
,
	"Projector.orthographicSize": {
		"prefix": "Projector.orthographicSize",
		"body": [
			"orthographicSize"
		],
		"description": "return:float des: Projection's half-size when in orthographic mode."
	}
,
	"Projector.enabled": {
		"prefix": "Projector.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"Projector.isActiveAndEnabled": {
		"prefix": "Projector.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"Projector.gameObject": {
		"prefix": "Projector.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"Projector.tag": {
		"prefix": "Projector.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"Projector.transform": {
		"prefix": "Projector.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"Projector.hideFlags": {
		"prefix": "Projector.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Projector.name": {
		"prefix": "Projector.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Projector.BroadcastMessage": {
		"prefix": "Projector.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"Projector.CompareTag": {
		"prefix": "Projector.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"Projector.GetComponent": {
		"prefix": "Projector.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"Projector.GetComponentInChildren": {
		"prefix": "Projector.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"Projector.GetComponentInParent": {
		"prefix": "Projector.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"Projector.GetComponents": {
		"prefix": "Projector.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"Projector.GetComponentsInChildren": {
		"prefix": "Projector.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"Projector.GetComponentsInParent": {
		"prefix": "Projector.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"Projector.SendMessage": {
		"prefix": "Projector.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"Projector.SendMessageUpwards": {
		"prefix": "Projector.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"Projector.GetInstanceID": {
		"prefix": "Projector.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Projector.ToString": {
		"prefix": "Projector.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Projector.Destroy": {
		"prefix": "Projector.Destroy",
		"body": [
			"Projector.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Projector.DestroyImmediate": {
		"prefix": "Projector.DestroyImmediate",
		"body": [
			"Projector.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Projector.DontDestroyOnLoad": {
		"prefix": "Projector.DontDestroyOnLoad",
		"body": [
			"Projector.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Projector.FindObjectOfType": {
		"prefix": "Projector.FindObjectOfType",
		"body": [
			"Projector.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Projector.FindObjectsOfType": {
		"prefix": "Projector.FindObjectsOfType",
		"body": [
			"Projector.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Projector.Instantiate": {
		"prefix": "Projector.Instantiate",
		"body": [
			"Projector.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"PropertyName.Equals": {
		"prefix": "PropertyName.Equals",
		"body": [
			"Equals($1)"
		],
		"description": "public bool Equals(object other); des: Determines whether this instance and a specified object, which must also be a PropertyName object, have the same value."
	}
,
	"PropertyName.GetHashCode": {
		"prefix": "PropertyName.GetHashCode",
		"body": [
			"GetHashCode($1)"
		],
		"description": "public int GetHashCode(); des: Returns the hash code for this PropertyName."
	}
,
	"PropertyName.ToString": {
		"prefix": "PropertyName.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: For debugging purposes only. Returns the string value representing the string in the Editor. Returns \"UnityEngine.PropertyName\" in the player."
	}
,
	"PropertyName.IsNullOrEmpty": {
		"prefix": "PropertyName.IsNullOrEmpty",
		"body": [
			"PropertyName.IsNullOrEmpty"
		],
		"description": "public static bool IsNullOrEmpty(PropertyName prop); des: Indicates whether the specified PropertyName is an Empty string."
	}
,
	"QualitySettings.DecreaseLevel": {
		"prefix": "QualitySettings.DecreaseLevel",
		"body": [
			"QualitySettings.DecreaseLevel"
		],
		"description": "public static void DecreaseLevel(bool applyExpensiveChanges = false); des: Decrease the current quality level."
	}
,
	"QualitySettings.GetQualityLevel": {
		"prefix": "QualitySettings.GetQualityLevel",
		"body": [
			"QualitySettings.GetQualityLevel"
		],
		"description": "public static int GetQualityLevel(); des: Returns the current graphics quality level."
	}
,
	"QualitySettings.IncreaseLevel": {
		"prefix": "QualitySettings.IncreaseLevel",
		"body": [
			"QualitySettings.IncreaseLevel"
		],
		"description": "public static void IncreaseLevel(bool applyExpensiveChanges = false); des: Increase the current quality level."
	}
,
	"QualitySettings.SetQualityLevel": {
		"prefix": "QualitySettings.SetQualityLevel",
		"body": [
			"QualitySettings.SetQualityLevel"
		],
		"description": "public static void SetQualityLevel(int index, bool applyExpensiveChanges = true); des: Sets a new graphics quality level."
	}
,
	"QualitySettings.hideFlags": {
		"prefix": "QualitySettings.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"QualitySettings.name": {
		"prefix": "QualitySettings.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"QualitySettings.GetInstanceID": {
		"prefix": "QualitySettings.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"QualitySettings.ToString": {
		"prefix": "QualitySettings.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"QualitySettings.Destroy": {
		"prefix": "QualitySettings.Destroy",
		"body": [
			"QualitySettings.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"QualitySettings.DestroyImmediate": {
		"prefix": "QualitySettings.DestroyImmediate",
		"body": [
			"QualitySettings.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"QualitySettings.DontDestroyOnLoad": {
		"prefix": "QualitySettings.DontDestroyOnLoad",
		"body": [
			"QualitySettings.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"QualitySettings.FindObjectOfType": {
		"prefix": "QualitySettings.FindObjectOfType",
		"body": [
			"QualitySettings.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"QualitySettings.FindObjectsOfType": {
		"prefix": "QualitySettings.FindObjectsOfType",
		"body": [
			"QualitySettings.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"QualitySettings.Instantiate": {
		"prefix": "QualitySettings.Instantiate",
		"body": [
			"QualitySettings.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"Quaternion.eulerAngles": {
		"prefix": "Quaternion.eulerAngles",
		"body": [
			"eulerAngles"
		],
		"description": "return:Vector3 des: Returns or sets the euler angle representation of the rotation."
	}
,
	"Quaternion.normalized": {
		"prefix": "Quaternion.normalized",
		"body": [
			"normalized"
		],
		"description": "return:Quaternion des: Returns this quaternion with a magnitude of 1 (Read Only)."
	}
,
	"Quaternion.this[int]": {
		"prefix": "Quaternion.this[int]",
		"body": [
			"this[int]"
		],
		"description": "return:float des: Access the x, y, z, w components using [0], [1], [2], [3] respectively."
	}
,
	"Quaternion.w": {
		"prefix": "Quaternion.w",
		"body": [
			"w"
		],
		"description": "return:float des: W component of the Quaternion. Do not directly modify quaternions."
	}
,
	"Quaternion.x": {
		"prefix": "Quaternion.x",
		"body": [
			"x"
		],
		"description": "return:float des: X component of the Quaternion. Don't modify this directly unless you know quaternions inside out."
	}
,
	"Quaternion.y": {
		"prefix": "Quaternion.y",
		"body": [
			"y"
		],
		"description": "return:float des: Y component of the Quaternion. Don't modify this directly unless you know quaternions inside out."
	}
,
	"Quaternion.z": {
		"prefix": "Quaternion.z",
		"body": [
			"z"
		],
		"description": "return:float des: Z component of the Quaternion. Don't modify this directly unless you know quaternions inside out."
	}
,
	"Quaternion.Set": {
		"prefix": "Quaternion.Set",
		"body": [
			"Set($1)"
		],
		"description": "public void Set(float newX, float newY, float newZ, float newW); des: Set x, y, z and w components of an existing Quaternion."
	}
,
	"Quaternion.SetFromToRotation": {
		"prefix": "Quaternion.SetFromToRotation",
		"body": [
			"SetFromToRotation($1)"
		],
		"description": "public void SetFromToRotation(Vector3 fromDirection, Vector3 toDirection); des: Creates a rotation which rotates from fromDirection to toDirection."
	}
,
	"Quaternion.SetLookRotation": {
		"prefix": "Quaternion.SetLookRotation",
		"body": [
			"SetLookRotation($1)"
		],
		"description": "public void SetLookRotation(Vector3 view, Vector3 up = Vector3.up); des: Creates a rotation with the specified forward and upwards directions."
	}
,
	"Quaternion.ToAngleAxis": {
		"prefix": "Quaternion.ToAngleAxis",
		"body": [
			"ToAngleAxis($1)"
		],
		"description": "public void ToAngleAxis(out float angle, out Vector3 axis); des: Converts a rotation to angle-axis representation (angles in degrees)."
	}
,
	"Quaternion.ToString": {
		"prefix": "Quaternion.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); public string ToString(string format); des: Returns a nicely formatted string of the Quaternion."
	}
,
	"Quaternion.Angle": {
		"prefix": "Quaternion.Angle",
		"body": [
			"Quaternion.Angle"
		],
		"description": "public static float Angle(Quaternion a, Quaternion b); des: Returns the angle in degrees between two rotations a and b."
	}
,
	"Quaternion.AngleAxis": {
		"prefix": "Quaternion.AngleAxis",
		"body": [
			"Quaternion.AngleAxis"
		],
		"description": "public static Quaternion AngleAxis(float angle, Vector3 axis); des: Creates a rotation which rotates angle degrees around axis."
	}
,
	"Quaternion.Dot": {
		"prefix": "Quaternion.Dot",
		"body": [
			"Quaternion.Dot"
		],
		"description": "public static float Dot(Quaternion a, Quaternion b); des: The dot product between two rotations."
	}
,
	"Quaternion.Euler": {
		"prefix": "Quaternion.Euler",
		"body": [
			"Quaternion.Euler"
		],
		"description": "public static Quaternion Euler(float x, float y, float z); public static Quaternion Euler(Vector3 euler); des: Returns a rotation that rotates z degrees around the z axis, x degrees around the x axis, and y degrees around the y axis."
	}
,
	"Quaternion.FromToRotation": {
		"prefix": "Quaternion.FromToRotation",
		"body": [
			"Quaternion.FromToRotation"
		],
		"description": "public static Quaternion FromToRotation(Vector3 fromDirection, Vector3 toDirection); des: Creates a rotation which rotates from fromDirection to toDirection."
	}
,
	"Quaternion.Inverse": {
		"prefix": "Quaternion.Inverse",
		"body": [
			"Quaternion.Inverse"
		],
		"description": "public static Quaternion Inverse(Quaternion rotation); des: Returns the Inverse of rotation."
	}
,
	"Quaternion.Lerp": {
		"prefix": "Quaternion.Lerp",
		"body": [
			"Quaternion.Lerp"
		],
		"description": "public static Quaternion Lerp(Quaternion a, Quaternion b, float t); des: Interpolates between a and b by t and normalizes the result afterwards. The parameter t is clamped to the range [0, 1]."
	}
,
	"Quaternion.LerpUnclamped": {
		"prefix": "Quaternion.LerpUnclamped",
		"body": [
			"Quaternion.LerpUnclamped"
		],
		"description": "public static Quaternion LerpUnclamped(Quaternion a, Quaternion b, float t); des: Interpolates between a and b by t and normalizes the result afterwards. The parameter t is not clamped."
	}
,
	"Quaternion.LookRotation": {
		"prefix": "Quaternion.LookRotation",
		"body": [
			"Quaternion.LookRotation"
		],
		"description": "public static Quaternion LookRotation(Vector3 forward, Vector3 upwards = Vector3.up); des: Creates a rotation with the specified forward and upwards directions."
	}
,
	"Quaternion.Normalize": {
		"prefix": "Quaternion.Normalize",
		"body": [
			"Quaternion.Normalize"
		],
		"description": "public static Quaternion Normalize(Quaternion q); des: Converts this quaternion to one with the same orientation but with a magnitude of 1."
	}
,
	"Quaternion.RotateTowards": {
		"prefix": "Quaternion.RotateTowards",
		"body": [
			"Quaternion.RotateTowards"
		],
		"description": "public static Quaternion RotateTowards(Quaternion from, Quaternion to, float maxDegreesDelta); des: Rotates a rotation from towards to."
	}
,
	"Quaternion.Slerp": {
		"prefix": "Quaternion.Slerp",
		"body": [
			"Quaternion.Slerp"
		],
		"description": "public static Quaternion Slerp(Quaternion a, Quaternion b, float t); des: Spherically interpolates between a and b by t. The parameter t is clamped to the range [0, 1]."
	}
,
	"Quaternion.SlerpUnclamped": {
		"prefix": "Quaternion.SlerpUnclamped",
		"body": [
			"Quaternion.SlerpUnclamped"
		],
		"description": "public static Quaternion SlerpUnclamped(Quaternion a, Quaternion b, float t); des: Spherically interpolates between a and b by t. The parameter t is not clamped."
	}
,
	"Random.ColorHSV": {
		"prefix": "Random.ColorHSV",
		"body": [
			"Random.ColorHSV"
		],
		"description": "public static Color ColorHSV(); public static Color ColorHSV(float hueMin, float hueMax); public static Color ColorHSV(float hueMin, float hueMax, float saturationMin, float saturationMax); public static Color ColorHSV(float hueMin, float hueMax, float saturationMin, float saturationMax, float valueMin, float valueMax); public static Color ColorHSV(float hueMin, float hueMax, float saturationMin, float saturationMax, float valueMin, float valueMax, float alphaMin, float alphaMax); des: Generates a random color from HSV and alpha ranges."
	}
,
	"Random.InitState": {
		"prefix": "Random.InitState",
		"body": [
			"Random.InitState"
		],
		"description": "public static void InitState(int seed); des: Initializes the random number generator state with a seed."
	}
,
	"Random.Range": {
		"prefix": "Random.Range",
		"body": [
			"Random.Range"
		],
		"description": "public static float Range(float min, float max); public static int Range(int min, int max); des: Returns a random float number between and min [inclusive] and max [inclusive] (Read Only)."
	}
,
	"RangeInt.end": {
		"prefix": "RangeInt.end",
		"body": [
			"end"
		],
		"description": "return:int des: The end index of the range (not inclusive)."
	}
,
	"RangeInt.length": {
		"prefix": "RangeInt.length",
		"body": [
			"length"
		],
		"description": "return:int des: The length of the range."
	}
,
	"RangeInt.start": {
		"prefix": "RangeInt.start",
		"body": [
			"start"
		],
		"description": "return:int des: The starting index of the range, where 0 is the first position, 1 is the second, 2 is the third, and so on."
	}
,
	"Ray.direction": {
		"prefix": "Ray.direction",
		"body": [
			"direction"
		],
		"description": "return:Vector3 des: The direction of the ray."
	}
,
	"Ray.origin": {
		"prefix": "Ray.origin",
		"body": [
			"origin"
		],
		"description": "return:Vector3 des: The origin point of the ray."
	}
,
	"Ray.GetPoint": {
		"prefix": "Ray.GetPoint",
		"body": [
			"GetPoint($1)"
		],
		"description": "public Vector3 GetPoint(float distance); des: Returns a point at distance units along the ray."
	}
,
	"Ray.ToString": {
		"prefix": "Ray.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); public string ToString(string format); des: Returns a nicely formatted string for this ray."
	}
,
	"Ray2D.direction": {
		"prefix": "Ray2D.direction",
		"body": [
			"direction"
		],
		"description": "return:Vector2 des: The direction of the ray in world space."
	}
,
	"Ray2D.origin": {
		"prefix": "Ray2D.origin",
		"body": [
			"origin"
		],
		"description": "return:Vector2 des: The starting point of the ray in world space."
	}
,
	"Ray2D.GetPoint": {
		"prefix": "Ray2D.GetPoint",
		"body": [
			"GetPoint($1)"
		],
		"description": "public Vector2 GetPoint(float distance); des: Get a point that lies a given distance along a ray."
	}
,
	"RaycastCommand.direction": {
		"prefix": "RaycastCommand.direction",
		"body": [
			"direction"
		],
		"description": "return:Vector3 des: The direction of the ray."
	}
,
	"RaycastCommand.distance": {
		"prefix": "RaycastCommand.distance",
		"body": [
			"distance"
		],
		"description": "return:float des: The maximum distance the ray should check for collisions."
	}
,
	"RaycastCommand.from": {
		"prefix": "RaycastCommand.from",
		"body": [
			"from"
		],
		"description": "return:Vector3 des: The starting point of the ray in world coordinates."
	}
,
	"RaycastCommand.layerMask": {
		"prefix": "RaycastCommand.layerMask",
		"body": [
			"layerMask"
		],
		"description": "return:int des: A LayerMask that is used to selectively ignore Colliders when casting a ray."
	}
,
	"RaycastCommand.maxHits": {
		"prefix": "RaycastCommand.maxHits",
		"body": [
			"maxHits"
		],
		"description": "return:int des: The maximum number of Colliders the ray can hit."
	}
,
	"RaycastCommand.ScheduleBatch": {
		"prefix": "RaycastCommand.ScheduleBatch",
		"body": [
			"RaycastCommand.ScheduleBatch"
		],
		"description": " des: Schedule a batch of raycasts which are performed in a job."
	}
,
	"RaycastHit.barycentricCoordinate": {
		"prefix": "RaycastHit.barycentricCoordinate",
		"body": [
			"barycentricCoordinate"
		],
		"description": "return:Vector3 des: The barycentric coordinate of the triangle we hit."
	}
,
	"RaycastHit.collider": {
		"prefix": "RaycastHit.collider",
		"body": [
			"collider"
		],
		"description": "return:Collider des: The Collider that was hit."
	}
,
	"RaycastHit.distance": {
		"prefix": "RaycastHit.distance",
		"body": [
			"distance"
		],
		"description": "return:float des: The distance from the ray's origin to the impact point."
	}
,
	"RaycastHit.lightmapCoord": {
		"prefix": "RaycastHit.lightmapCoord",
		"body": [
			"lightmapCoord"
		],
		"description": "return:Vector2 des: The uv lightmap coordinate at the impact point."
	}
,
	"RaycastHit.normal": {
		"prefix": "RaycastHit.normal",
		"body": [
			"normal"
		],
		"description": "return:Vector3 des: The normal of the surface the ray hit."
	}
,
	"RaycastHit.point": {
		"prefix": "RaycastHit.point",
		"body": [
			"point"
		],
		"description": "return:Vector3 des: The impact point in world space where the ray hit the collider."
	}
,
	"RaycastHit.rigidbody": {
		"prefix": "RaycastHit.rigidbody",
		"body": [
			"rigidbody"
		],
		"description": "return:Rigidbody des: The Rigidbody of the collider that was hit. If the collider is not attached to a rigidbody then it is null."
	}
,
	"RaycastHit.textureCoord": {
		"prefix": "RaycastHit.textureCoord",
		"body": [
			"textureCoord"
		],
		"description": "return:Vector2 des: The uv texture coordinate at the collision location."
	}
,
	"RaycastHit.textureCoord2": {
		"prefix": "RaycastHit.textureCoord2",
		"body": [
			"textureCoord2"
		],
		"description": "return:Vector2 des: The secondary uv texture coordinate at the impact point."
	}
,
	"RaycastHit.transform": {
		"prefix": "RaycastHit.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform of the rigidbody or collider that was hit."
	}
,
	"RaycastHit.triangleIndex": {
		"prefix": "RaycastHit.triangleIndex",
		"body": [
			"triangleIndex"
		],
		"description": "return:int des: The index of the triangle that was hit."
	}
,
	"RaycastHit2D.centroid": {
		"prefix": "RaycastHit2D.centroid",
		"body": [
			"centroid"
		],
		"description": "return:Vector2 des: The centroid of the primitive used to perform the cast."
	}
,
	"RaycastHit2D.collider": {
		"prefix": "RaycastHit2D.collider",
		"body": [
			"collider"
		],
		"description": "return:Collider2D des: The collider hit by the ray."
	}
,
	"RaycastHit2D.distance": {
		"prefix": "RaycastHit2D.distance",
		"body": [
			"distance"
		],
		"description": "return:float des: The distance from the ray origin to the impact point."
	}
,
	"RaycastHit2D.fraction": {
		"prefix": "RaycastHit2D.fraction",
		"body": [
			"fraction"
		],
		"description": "return:float des: Fraction of the distance along the ray that the hit occurred."
	}
,
	"RaycastHit2D.normal": {
		"prefix": "RaycastHit2D.normal",
		"body": [
			"normal"
		],
		"description": "return:Vector2 des: The normal vector of the surface hit by the ray."
	}
,
	"RaycastHit2D.point": {
		"prefix": "RaycastHit2D.point",
		"body": [
			"point"
		],
		"description": "return:Vector2 des: The point in world space where the ray hit the collider's surface."
	}
,
	"RaycastHit2D.rigidbody": {
		"prefix": "RaycastHit2D.rigidbody",
		"body": [
			"rigidbody"
		],
		"description": "return:Rigidbody2D des: The Rigidbody2D attached to the object that was hit."
	}
,
	"RaycastHit2D.transform": {
		"prefix": "RaycastHit2D.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform of the object that was hit."
	}
,
	"Rect.center": {
		"prefix": "Rect.center",
		"body": [
			"center"
		],
		"description": "return:Vector2 des: The position of the center of the rectangle."
	}
,
	"Rect.height": {
		"prefix": "Rect.height",
		"body": [
			"height"
		],
		"description": "return:float des: The height of the rectangle, measured from the Y position."
	}
,
	"Rect.max": {
		"prefix": "Rect.max",
		"body": [
			"max"
		],
		"description": "return:Vector2 des: The position of the maximum corner of the rectangle."
	}
,
	"Rect.min": {
		"prefix": "Rect.min",
		"body": [
			"min"
		],
		"description": "return:Vector2 des: The position of the minimum corner of the rectangle."
	}
,
	"Rect.position": {
		"prefix": "Rect.position",
		"body": [
			"position"
		],
		"description": "return:Vector2 des: The X and Y position of the rectangle."
	}
,
	"Rect.size": {
		"prefix": "Rect.size",
		"body": [
			"size"
		],
		"description": "return:Vector2 des: The width and height of the rectangle."
	}
,
	"Rect.width": {
		"prefix": "Rect.width",
		"body": [
			"width"
		],
		"description": "return:float des: The width of the rectangle, measured from the X position."
	}
,
	"Rect.x": {
		"prefix": "Rect.x",
		"body": [
			"x"
		],
		"description": "return:float des: The X coordinate of the rectangle."
	}
,
	"Rect.xMax": {
		"prefix": "Rect.xMax",
		"body": [
			"xMax"
		],
		"description": "return:float des: The maximum X coordinate of the rectangle."
	}
,
	"Rect.xMin": {
		"prefix": "Rect.xMin",
		"body": [
			"xMin"
		],
		"description": "return:float des: The minimum X coordinate of the rectangle."
	}
,
	"Rect.y": {
		"prefix": "Rect.y",
		"body": [
			"y"
		],
		"description": "return:float des: The Y coordinate of the rectangle."
	}
,
	"Rect.yMax": {
		"prefix": "Rect.yMax",
		"body": [
			"yMax"
		],
		"description": "return:float des: The maximum Y coordinate of the rectangle."
	}
,
	"Rect.yMin": {
		"prefix": "Rect.yMin",
		"body": [
			"yMin"
		],
		"description": "return:float des: The minimum Y coordinate of the rectangle."
	}
,
	"Rect.Contains": {
		"prefix": "Rect.Contains",
		"body": [
			"Contains($1)"
		],
		"description": "public bool Contains(Vector2 point); public bool Contains(Vector3 point); public bool Contains(Vector3 point, bool allowInverse); des: Returns true if the x and y components of point is a point inside this rectangle. If allowInverse is present and true, the width and height of the Rect are allowed to take negative values (ie, the min value is greater than the max), and the test will still work."
	}
,
	"Rect.Overlaps": {
		"prefix": "Rect.Overlaps",
		"body": [
			"Overlaps($1)"
		],
		"description": "public bool Overlaps(Rect other); public bool Overlaps(Rect other, bool allowInverse); des: Returns true if the other rectangle overlaps this one. If allowInverse is present and true, the widths and heights of the Rects are allowed to take negative values (ie, the min value is greater than the max), and the test will still work."
	}
,
	"Rect.Set": {
		"prefix": "Rect.Set",
		"body": [
			"Set($1)"
		],
		"description": "public void Set(float x, float y, float width, float height); des: Set components of an existing Rect."
	}
,
	"Rect.ToString": {
		"prefix": "Rect.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); public string ToString(string format); des: Returns a nicely formatted string for this Rect."
	}
,
	"Rect.MinMaxRect": {
		"prefix": "Rect.MinMaxRect",
		"body": [
			"Rect.MinMaxRect"
		],
		"description": "public static Rect MinMaxRect(float xmin, float ymin, float xmax, float ymax); des: Creates a rectangle from min/max coordinate values."
	}
,
	"Rect.NormalizedToPoint": {
		"prefix": "Rect.NormalizedToPoint",
		"body": [
			"Rect.NormalizedToPoint"
		],
		"description": "public static Vector2 NormalizedToPoint(Rect rectangle, Vector2 normalizedRectCoordinates); des: Returns a point inside a rectangle, given normalized coordinates."
	}
,
	"Rect.PointToNormalized": {
		"prefix": "Rect.PointToNormalized",
		"body": [
			"Rect.PointToNormalized"
		],
		"description": "public static Vector2 PointToNormalized(Rect rectangle, Vector2 point); des: Returns the normalized coordinates cooresponding the the point."
	}
,
	"RectInt.allPositionsWithin": {
		"prefix": "RectInt.allPositionsWithin",
		"body": [
			"allPositionsWithin"
		],
		"description": "return:BoundsInt.PositionEnumerator des: A RectInt.PositionCollection that contains all positions within the RectInt."
	}
,
	"RectInt.center": {
		"prefix": "RectInt.center",
		"body": [
			"center"
		],
		"description": "return:Vector2 des: Center coordinate of the rectangle."
	}
,
	"RectInt.height": {
		"prefix": "RectInt.height",
		"body": [
			"height"
		],
		"description": "return:int des: Height of the rectangle."
	}
,
	"RectInt.max": {
		"prefix": "RectInt.max",
		"body": [
			"max"
		],
		"description": "return:Vector2Int des: Upper right corner of the rectangle."
	}
,
	"RectInt.min": {
		"prefix": "RectInt.min",
		"body": [
			"min"
		],
		"description": "return:Vector2Int des: Lower left corner of the rectangle."
	}
,
	"RectInt.position": {
		"prefix": "RectInt.position",
		"body": [
			"position"
		],
		"description": "return:Vector2Int des: Returns the position (x, y) of the RectInt."
	}
,
	"RectInt.size": {
		"prefix": "RectInt.size",
		"body": [
			"size"
		],
		"description": "return:Vector2Int des: Returns the width and height of the RectInt."
	}
,
	"RectInt.width": {
		"prefix": "RectInt.width",
		"body": [
			"width"
		],
		"description": "return:int des: Width of the rectangle."
	}
,
	"RectInt.x": {
		"prefix": "RectInt.x",
		"body": [
			"x"
		],
		"description": "return:int des: Left coordinate of the rectangle."
	}
,
	"RectInt.xMax": {
		"prefix": "RectInt.xMax",
		"body": [
			"xMax"
		],
		"description": "return:int des: Returns the maximum X value of the RectInt."
	}
,
	"RectInt.xMin": {
		"prefix": "RectInt.xMin",
		"body": [
			"xMin"
		],
		"description": "return:int des: Returns the minimum X value of the RectInt."
	}
,
	"RectInt.y": {
		"prefix": "RectInt.y",
		"body": [
			"y"
		],
		"description": "return:int des: Top coordinate of the rectangle."
	}
,
	"RectInt.yMax": {
		"prefix": "RectInt.yMax",
		"body": [
			"yMax"
		],
		"description": "return:int des: Returns the maximum Y value of the RectInt."
	}
,
	"RectInt.yMin": {
		"prefix": "RectInt.yMin",
		"body": [
			"yMin"
		],
		"description": "return:int des: Returns the minimum Y value of the RectInt."
	}
,
	"RectInt.ClampToBounds": {
		"prefix": "RectInt.ClampToBounds",
		"body": [
			"ClampToBounds($1)"
		],
		"description": "public void ClampToBounds(RectInt bounds); des: Clamps the position and size of the RectInt to the given bounds."
	}
,
	"RectInt.Contains": {
		"prefix": "RectInt.Contains",
		"body": [
			"Contains($1)"
		],
		"description": "public bool Contains(Vector2Int position);  des: Returns true if the given position is within the RectInt."
	}
,
	"RectInt.SetMinMax": {
		"prefix": "RectInt.SetMinMax",
		"body": [
			"SetMinMax($1)"
		],
		"description": "public void SetMinMax(Vector2Int minPosition, Vector2Int maxPosition); des: Sets the bounds to the min and max value of the rect."
	}
,
	"RectInt.ToString": {
		"prefix": "RectInt.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the x, y, width and height of the RectInt."
	}
,
	"RectInt.PositionEnumerator.Current": {
		"prefix": "RectInt.PositionEnumerator.Current",
		"body": [
			"Current"
		],
		"description": "return:Vector2Int des: Current position of the enumerator."
	}
,
	"RectInt.PositionEnumerator.GetEnumerator": {
		"prefix": "RectInt.PositionEnumerator.GetEnumerator",
		"body": [
			"GetEnumerator($1)"
		],
		"description": "public BoundsInt.PositionEnumerator GetEnumerator(); des: Returns this as an iterator that allows you to iterate over all positions within the RectInt."
	}
,
	"RectInt.PositionEnumerator.MoveNext": {
		"prefix": "RectInt.PositionEnumerator.MoveNext",
		"body": [
			"MoveNext($1)"
		],
		"description": "public bool MoveNext(); des: Moves the enumerator to the next position."
	}
,
	"RectInt.PositionEnumerator.Reset": {
		"prefix": "RectInt.PositionEnumerator.Reset",
		"body": [
			"Reset($1)"
		],
		"description": "public void Reset(); des: Resets this enumerator to its starting state."
	}
,
	"RectOffset.bottom": {
		"prefix": "RectOffset.bottom",
		"body": [
			"bottom"
		],
		"description": "return:int des: Bottom edge size."
	}
,
	"RectOffset.horizontal": {
		"prefix": "RectOffset.horizontal",
		"body": [
			"horizontal"
		],
		"description": "return:int des: Shortcut for left + right. (Read Only)"
	}
,
	"RectOffset.left": {
		"prefix": "RectOffset.left",
		"body": [
			"left"
		],
		"description": "return:int des: Left edge size."
	}
,
	"RectOffset.right": {
		"prefix": "RectOffset.right",
		"body": [
			"right"
		],
		"description": "return:int des: Right edge size."
	}
,
	"RectOffset.top": {
		"prefix": "RectOffset.top",
		"body": [
			"top"
		],
		"description": "return:int des: Top edge size."
	}
,
	"RectOffset.vertical": {
		"prefix": "RectOffset.vertical",
		"body": [
			"vertical"
		],
		"description": "return:int des: Shortcut for top + bottom. (Read Only)"
	}
,
	"RectOffset.Add": {
		"prefix": "RectOffset.Add",
		"body": [
			"Add($1)"
		],
		"description": "public Rect Add(Rect rect); des: Add the border offsets to a rect."
	}
,
	"RectOffset.Remove": {
		"prefix": "RectOffset.Remove",
		"body": [
			"Remove($1)"
		],
		"description": "public Rect Remove(Rect rect); des: Remove the border offsets from a rect."
	}
,
	"RectTransform.anchoredPosition": {
		"prefix": "RectTransform.anchoredPosition",
		"body": [
			"anchoredPosition"
		],
		"description": "return:Vector2 des: The position of the pivot of this RectTransform relative to the anchor reference point."
	}
,
	"RectTransform.anchoredPosition3D": {
		"prefix": "RectTransform.anchoredPosition3D",
		"body": [
			"anchoredPosition3D"
		],
		"description": "return:Vector3 des: The 3D position of the pivot of this RectTransform relative to the anchor reference point."
	}
,
	"RectTransform.anchorMax": {
		"prefix": "RectTransform.anchorMax",
		"body": [
			"anchorMax"
		],
		"description": "return:Vector2 des: The normalized position in the parent RectTransform that the upper right corner is anchored to."
	}
,
	"RectTransform.anchorMin": {
		"prefix": "RectTransform.anchorMin",
		"body": [
			"anchorMin"
		],
		"description": "return:Vector2 des: The normalized position in the parent RectTransform that the lower left corner is anchored to."
	}
,
	"RectTransform.offsetMax": {
		"prefix": "RectTransform.offsetMax",
		"body": [
			"offsetMax"
		],
		"description": "return:Vector2 des: The offset of the upper right corner of the rectangle relative to the upper right anchor."
	}
,
	"RectTransform.offsetMin": {
		"prefix": "RectTransform.offsetMin",
		"body": [
			"offsetMin"
		],
		"description": "return:Vector2 des: The offset of the lower left corner of the rectangle relative to the lower left anchor."
	}
,
	"RectTransform.pivot": {
		"prefix": "RectTransform.pivot",
		"body": [
			"pivot"
		],
		"description": "return:Vector2 des: The normalized position in this RectTransform that it rotates around."
	}
,
	"RectTransform.rect": {
		"prefix": "RectTransform.rect",
		"body": [
			"rect"
		],
		"description": "return:Rect des: The calculated rectangle in the local space of the Transform."
	}
,
	"RectTransform.sizeDelta": {
		"prefix": "RectTransform.sizeDelta",
		"body": [
			"sizeDelta"
		],
		"description": "return:Vector2 des: The size of this RectTransform relative to the distances between the anchors."
	}
,
	"RectTransform.ForceUpdateRectTransforms": {
		"prefix": "RectTransform.ForceUpdateRectTransforms",
		"body": [
			"ForceUpdateRectTransforms($1)"
		],
		"description": "public void ForceUpdateRectTransforms(); des: Force the recalculation of RectTransforms internal data."
	}
,
	"RectTransform.GetLocalCorners": {
		"prefix": "RectTransform.GetLocalCorners",
		"body": [
			"GetLocalCorners($1)"
		],
		"description": "public void GetLocalCorners(Vector3[] fourCornersArray); des: Get the corners of the calculated rectangle in the local space of its Transform."
	}
,
	"RectTransform.GetWorldCorners": {
		"prefix": "RectTransform.GetWorldCorners",
		"body": [
			"GetWorldCorners($1)"
		],
		"description": "public void GetWorldCorners(Vector3[] fourCornersArray); des: Get the corners of the calculated rectangle in world space."
	}
,
	"RectTransform.SetInsetAndSizeFromParentEdge": {
		"prefix": "RectTransform.SetInsetAndSizeFromParentEdge",
		"body": [
			"SetInsetAndSizeFromParentEdge($1)"
		],
		"description": "public void SetInsetAndSizeFromParentEdge(RectTransform.Edge edge, float inset, float size); des: Set the distance of this rectangle relative to a specified edge of the parent rectangle, while also setting its size."
	}
,
	"RectTransform.SetSizeWithCurrentAnchors": {
		"prefix": "RectTransform.SetSizeWithCurrentAnchors",
		"body": [
			"SetSizeWithCurrentAnchors($1)"
		],
		"description": "public void SetSizeWithCurrentAnchors(Animations.Axis axis, float size); des: Makes the RectTransform calculated rect be a given size on the specified axis."
	}
,
	"RectTransform.gameObject": {
		"prefix": "RectTransform.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"RectTransform.tag": {
		"prefix": "RectTransform.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"RectTransform.transform": {
		"prefix": "RectTransform.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"RectTransform.hideFlags": {
		"prefix": "RectTransform.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"RectTransform.name": {
		"prefix": "RectTransform.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"RectTransform.childCount": {
		"prefix": "RectTransform.childCount",
		"body": [
			"childCount"
		],
		"description": "return:int des: The number of children the parent Transform has."
	}
,
	"RectTransform.eulerAngles": {
		"prefix": "RectTransform.eulerAngles",
		"body": [
			"eulerAngles"
		],
		"description": "return:Vector3 des: The rotation as Euler angles in degrees."
	}
,
	"RectTransform.forward": {
		"prefix": "RectTransform.forward",
		"body": [
			"forward"
		],
		"description": "return:Vector3 des: The blue axis of the transform in world space."
	}
,
	"RectTransform.hasChanged": {
		"prefix": "RectTransform.hasChanged",
		"body": [
			"hasChanged"
		],
		"description": "return:bool des: Has the transform changed since the last time the flag was set to 'false'?"
	}
,
	"RectTransform.hierarchyCapacity": {
		"prefix": "RectTransform.hierarchyCapacity",
		"body": [
			"hierarchyCapacity"
		],
		"description": "return:int des: The transform capacity of the transform's hierarchy data structure."
	}
,
	"RectTransform.hierarchyCount": {
		"prefix": "RectTransform.hierarchyCount",
		"body": [
			"hierarchyCount"
		],
		"description": "return:int des: The number of transforms in the transform's hierarchy data structure."
	}
,
	"RectTransform.localEulerAngles": {
		"prefix": "RectTransform.localEulerAngles",
		"body": [
			"localEulerAngles"
		],
		"description": "return:Vector3 des: The rotation as Euler angles in degrees relative to the parent transform's rotation."
	}
,
	"RectTransform.localPosition": {
		"prefix": "RectTransform.localPosition",
		"body": [
			"localPosition"
		],
		"description": "return:Vector3 des: Position of the transform relative to the parent transform."
	}
,
	"RectTransform.localRotation": {
		"prefix": "RectTransform.localRotation",
		"body": [
			"localRotation"
		],
		"description": "return:Quaternion des: The rotation of the transform relative to the transform rotation of the parent."
	}
,
	"RectTransform.localScale": {
		"prefix": "RectTransform.localScale",
		"body": [
			"localScale"
		],
		"description": "return:Vector3 des: The scale of the transform relative to the parent."
	}
,
	"RectTransform.localToWorldMatrix": {
		"prefix": "RectTransform.localToWorldMatrix",
		"body": [
			"localToWorldMatrix"
		],
		"description": "return:Matrix4x4 des: Matrix that transforms a point from local space into world space (Read Only)."
	}
,
	"RectTransform.lossyScale": {
		"prefix": "RectTransform.lossyScale",
		"body": [
			"lossyScale"
		],
		"description": "return:Vector3 des: The global scale of the object (Read Only)."
	}
,
	"RectTransform.parent": {
		"prefix": "RectTransform.parent",
		"body": [
			"parent"
		],
		"description": "return:Transform des: The parent of the transform."
	}
,
	"RectTransform.position": {
		"prefix": "RectTransform.position",
		"body": [
			"position"
		],
		"description": "return:Vector3 des: The position of the transform in world space."
	}
,
	"RectTransform.right": {
		"prefix": "RectTransform.right",
		"body": [
			"right"
		],
		"description": "return:Vector3 des: The red axis of the transform in world space."
	}
,
	"RectTransform.root": {
		"prefix": "RectTransform.root",
		"body": [
			"root"
		],
		"description": "return:Transform des: Returns the topmost transform in the hierarchy."
	}
,
	"RectTransform.rotation": {
		"prefix": "RectTransform.rotation",
		"body": [
			"rotation"
		],
		"description": "return:Quaternion des: The rotation of the transform in world space stored as a Quaternion."
	}
,
	"RectTransform.up": {
		"prefix": "RectTransform.up",
		"body": [
			"up"
		],
		"description": "return:Vector3 des: The green axis of the transform in world space."
	}
,
	"RectTransform.worldToLocalMatrix": {
		"prefix": "RectTransform.worldToLocalMatrix",
		"body": [
			"worldToLocalMatrix"
		],
		"description": "return:Matrix4x4 des: Matrix that transforms a point from world space into local space (Read Only)."
	}
,
	"RectTransform.BroadcastMessage": {
		"prefix": "RectTransform.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"RectTransform.CompareTag": {
		"prefix": "RectTransform.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"RectTransform.GetComponent": {
		"prefix": "RectTransform.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"RectTransform.GetComponentInChildren": {
		"prefix": "RectTransform.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"RectTransform.GetComponentInParent": {
		"prefix": "RectTransform.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"RectTransform.GetComponents": {
		"prefix": "RectTransform.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"RectTransform.GetComponentsInChildren": {
		"prefix": "RectTransform.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"RectTransform.GetComponentsInParent": {
		"prefix": "RectTransform.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"RectTransform.SendMessage": {
		"prefix": "RectTransform.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"RectTransform.SendMessageUpwards": {
		"prefix": "RectTransform.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"RectTransform.GetInstanceID": {
		"prefix": "RectTransform.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"RectTransform.ToString": {
		"prefix": "RectTransform.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"RectTransform.DetachChildren": {
		"prefix": "RectTransform.DetachChildren",
		"body": [
			"DetachChildren($1)"
		],
		"description": "public void DetachChildren(); des: Unparents all children."
	}
,
	"RectTransform.Find": {
		"prefix": "RectTransform.Find",
		"body": [
			"Find($1)"
		],
		"description": "public Transform Find(string n); des: Finds a child by n and returns it."
	}
,
	"RectTransform.GetChild": {
		"prefix": "RectTransform.GetChild",
		"body": [
			"GetChild($1)"
		],
		"description": "public Transform GetChild(int index); des: Returns a transform child by index."
	}
,
	"RectTransform.GetSiblingIndex": {
		"prefix": "RectTransform.GetSiblingIndex",
		"body": [
			"GetSiblingIndex($1)"
		],
		"description": "public int GetSiblingIndex(); des: Gets the sibling index."
	}
,
	"RectTransform.InverseTransformDirection": {
		"prefix": "RectTransform.InverseTransformDirection",
		"body": [
			"InverseTransformDirection($1)"
		],
		"description": "public Vector3 InverseTransformDirection(Vector3 direction); public Vector3 InverseTransformDirection(float x, float y, float z); des: Transforms a direction from world space to local space. The opposite of Transform.TransformDirection."
	}
,
	"RectTransform.InverseTransformPoint": {
		"prefix": "RectTransform.InverseTransformPoint",
		"body": [
			"InverseTransformPoint($1)"
		],
		"description": "public Vector3 InverseTransformPoint(Vector3 position); public Vector3 InverseTransformPoint(float x, float y, float z); des: Transforms position from world space to local space."
	}
,
	"RectTransform.InverseTransformVector": {
		"prefix": "RectTransform.InverseTransformVector",
		"body": [
			"InverseTransformVector($1)"
		],
		"description": "public Vector3 InverseTransformVector(Vector3 vector); public Vector3 InverseTransformVector(float x, float y, float z); des: Transforms a vector from world space to local space. The opposite of Transform.TransformVector."
	}
,
	"RectTransform.IsChildOf": {
		"prefix": "RectTransform.IsChildOf",
		"body": [
			"IsChildOf($1)"
		],
		"description": "public bool IsChildOf(Transform parent); des: Is this transform a child of parent?"
	}
,
	"RectTransform.LookAt": {
		"prefix": "RectTransform.LookAt",
		"body": [
			"LookAt($1)"
		],
		"description": "public void LookAt(Transform target); public void LookAt(Transform target, Vector3 worldUp = Vector3.up); public void LookAt(Vector3 worldPosition); public void LookAt(Vector3 worldPosition, Vector3 worldUp = Vector3.up); des: Rotates the transform so the forward vector points at /target/'s current position."
	}
,
	"RectTransform.Rotate": {
		"prefix": "RectTransform.Rotate",
		"body": [
			"Rotate($1)"
		],
		"description": "public void Rotate(Vector3 eulers, Space relativeTo = Space.Self); public void Rotate(float xAngle, float yAngle, float zAngle, Space relativeTo = Space.Self); public void Rotate(Vector3 axis, float angle, Space relativeTo = Space.Self); des: Applies a rotation of eulerAngles.z degrees around the z axis, eulerAngles.x degrees around the x axis, and eulerAngles.y degrees around the y axis (in that order)."
	}
,
	"RectTransform.RotateAround": {
		"prefix": "RectTransform.RotateAround",
		"body": [
			"RotateAround($1)"
		],
		"description": "public void RotateAround(Vector3 point, Vector3 axis, float angle); des: Rotates the transform about axis passing through point in world coordinates by angle degrees."
	}
,
	"RectTransform.SetAsFirstSibling": {
		"prefix": "RectTransform.SetAsFirstSibling",
		"body": [
			"SetAsFirstSibling($1)"
		],
		"description": "public void SetAsFirstSibling(); des: Move the transform to the start of the local transform list."
	}
,
	"RectTransform.SetAsLastSibling": {
		"prefix": "RectTransform.SetAsLastSibling",
		"body": [
			"SetAsLastSibling($1)"
		],
		"description": "public void SetAsLastSibling(); des: Move the transform to the end of the local transform list."
	}
,
	"RectTransform.SetParent": {
		"prefix": "RectTransform.SetParent",
		"body": [
			"SetParent($1)"
		],
		"description": "public void SetParent(Transform p); public void SetParent(Transform parent, bool worldPositionStays); des: Set the parent of the transform."
	}
,
	"RectTransform.SetPositionAndRotation": {
		"prefix": "RectTransform.SetPositionAndRotation",
		"body": [
			"SetPositionAndRotation($1)"
		],
		"description": "public void SetPositionAndRotation(Vector3 position, Quaternion rotation); des: Sets the world space position and rotation of the Transform component."
	}
,
	"RectTransform.SetSiblingIndex": {
		"prefix": "RectTransform.SetSiblingIndex",
		"body": [
			"SetSiblingIndex($1)"
		],
		"description": "public void SetSiblingIndex(int index); des: Sets the sibling index."
	}
,
	"RectTransform.TransformDirection": {
		"prefix": "RectTransform.TransformDirection",
		"body": [
			"TransformDirection($1)"
		],
		"description": "public Vector3 TransformDirection(Vector3 direction); public Vector3 TransformDirection(float x, float y, float z); des: Transforms direction from local space to world space."
	}
,
	"RectTransform.TransformPoint": {
		"prefix": "RectTransform.TransformPoint",
		"body": [
			"TransformPoint($1)"
		],
		"description": "public Vector3 TransformPoint(Vector3 position); public Vector3 TransformPoint(float x, float y, float z); des: Transforms position from local space to world space."
	}
,
	"RectTransform.TransformVector": {
		"prefix": "RectTransform.TransformVector",
		"body": [
			"TransformVector($1)"
		],
		"description": "public Vector3 TransformVector(Vector3 vector); public Vector3 TransformVector(float x, float y, float z); des: Transforms vector from local space to world space."
	}
,
	"RectTransform.Translate": {
		"prefix": "RectTransform.Translate",
		"body": [
			"Translate($1)"
		],
		"description": "public void Translate(Vector3 translation); public void Translate(Vector3 translation, Space relativeTo = Space.Self); public void Translate(float x, float y, float z); public void Translate(float x, float y, float z, Space relativeTo = Space.Self); public void Translate(Vector3 translation, Transform relativeTo); public void Translate(float x, float y, float z, Transform relativeTo); des: Moves the transform in the direction and distance of translation."
	}
,
	"RectTransform.Destroy": {
		"prefix": "RectTransform.Destroy",
		"body": [
			"RectTransform.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"RectTransform.DestroyImmediate": {
		"prefix": "RectTransform.DestroyImmediate",
		"body": [
			"RectTransform.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"RectTransform.DontDestroyOnLoad": {
		"prefix": "RectTransform.DontDestroyOnLoad",
		"body": [
			"RectTransform.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"RectTransform.FindObjectOfType": {
		"prefix": "RectTransform.FindObjectOfType",
		"body": [
			"RectTransform.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"RectTransform.FindObjectsOfType": {
		"prefix": "RectTransform.FindObjectsOfType",
		"body": [
			"RectTransform.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"RectTransform.Instantiate": {
		"prefix": "RectTransform.Instantiate",
		"body": [
			"RectTransform.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"RectTransform.Axis.Horizontal": {
		"prefix": "RectTransform.Axis.Horizontal",
		"body": [
			"Horizontal"
		],
		"description": "return: des: Horizontal."
	}
,
	"RectTransform.Axis.Vertical": {
		"prefix": "RectTransform.Axis.Vertical",
		"body": [
			"Vertical"
		],
		"description": "return: des: Vertical."
	}
,
	"RectTransform.Edge.Left": {
		"prefix": "RectTransform.Edge.Left",
		"body": [
			"Left"
		],
		"description": "return: des: The left edge."
	}
,
	"RectTransform.Edge.Right": {
		"prefix": "RectTransform.Edge.Right",
		"body": [
			"Right"
		],
		"description": "return: des: The right edge."
	}
,
	"RectTransform.Edge.Top": {
		"prefix": "RectTransform.Edge.Top",
		"body": [
			"Top"
		],
		"description": "return: des: The top edge."
	}
,
	"RectTransform.Edge.Bottom": {
		"prefix": "RectTransform.Edge.Bottom",
		"body": [
			"Bottom"
		],
		"description": "return: des: The bottom edge."
	}
,
	"RectTransformUtility.FlipLayoutAxes": {
		"prefix": "RectTransformUtility.FlipLayoutAxes",
		"body": [
			"RectTransformUtility.FlipLayoutAxes"
		],
		"description": "public static void FlipLayoutAxes(RectTransform rect, bool keepPositioning, bool recursive); des: Flips the horizontal and vertical axes of the RectTransform size and alignment, and optionally its children as well."
	}
,
	"RectTransformUtility.FlipLayoutOnAxis": {
		"prefix": "RectTransformUtility.FlipLayoutOnAxis",
		"body": [
			"RectTransformUtility.FlipLayoutOnAxis"
		],
		"description": "public static void FlipLayoutOnAxis(RectTransform rect, int axis, bool keepPositioning, bool recursive); des: Flips the alignment of the RectTransform along the horizontal or vertical axis, and optionally its children as well."
	}
,
	"RectTransformUtility.PixelAdjustPoint": {
		"prefix": "RectTransformUtility.PixelAdjustPoint",
		"body": [
			"RectTransformUtility.PixelAdjustPoint"
		],
		"description": "public static Vector2 PixelAdjustPoint(Vector2 point, Transform elementTransform, Canvas canvas); des: Convert a given point in screen space into a pixel correct point."
	}
,
	"RectTransformUtility.PixelAdjustRect": {
		"prefix": "RectTransformUtility.PixelAdjustRect",
		"body": [
			"RectTransformUtility.PixelAdjustRect"
		],
		"description": "public static Rect PixelAdjustRect(RectTransform rectTransform, Canvas canvas); des: Given a rect transform, return the corner points in pixel accurate coordinates."
	}
,
	"RectTransformUtility.RectangleContainsScreenPoint": {
		"prefix": "RectTransformUtility.RectangleContainsScreenPoint",
		"body": [
			"RectTransformUtility.RectangleContainsScreenPoint"
		],
		"description": "public static bool RectangleContainsScreenPoint(RectTransform rect, Vector2 screenPoint, Camera cam); des: Does the RectTransform contain the screen point as seen from the given camera?"
	}
,
	"RectTransformUtility.ScreenPointToLocalPointInRectangle": {
		"prefix": "RectTransformUtility.ScreenPointToLocalPointInRectangle",
		"body": [
			"RectTransformUtility.ScreenPointToLocalPointInRectangle"
		],
		"description": "public static bool ScreenPointToLocalPointInRectangle(RectTransform rect, Vector2 screenPoint, Camera cam, out Vector2 localPoint); des: Transform a screen space point to a position in the local space of a RectTransform that is on the plane of its rectangle."
	}
,
	"RectTransformUtility.ScreenPointToWorldPointInRectangle": {
		"prefix": "RectTransformUtility.ScreenPointToWorldPointInRectangle",
		"body": [
			"RectTransformUtility.ScreenPointToWorldPointInRectangle"
		],
		"description": "public static bool ScreenPointToWorldPointInRectangle(RectTransform rect, Vector2 screenPoint, Camera cam, out Vector3 worldPoint); des: Transform a screen space point to a position in world space that is on the plane of the given RectTransform."
	}
,
	"ReflectionProbe.backgroundColor": {
		"prefix": "ReflectionProbe.backgroundColor",
		"body": [
			"backgroundColor"
		],
		"description": "return:Color des: The color with which the texture of reflection probe will be cleared."
	}
,
	"ReflectionProbe.bakedTexture": {
		"prefix": "ReflectionProbe.bakedTexture",
		"body": [
			"bakedTexture"
		],
		"description": "return:Texture des: Reference to the baked texture of the reflection probe's surrounding."
	}
,
	"ReflectionProbe.blendDistance": {
		"prefix": "ReflectionProbe.blendDistance",
		"body": [
			"blendDistance"
		],
		"description": "return:float des: Distance around probe used for blending (used in deferred probes)."
	}
,
	"ReflectionProbe.bounds": {
		"prefix": "ReflectionProbe.bounds",
		"body": [
			"bounds"
		],
		"description": "return:Bounds des: The bounding volume of the reflection probe (Read Only)."
	}
,
	"ReflectionProbe.boxProjection": {
		"prefix": "ReflectionProbe.boxProjection",
		"body": [
			"boxProjection"
		],
		"description": "return:bool des: Should this reflection probe use box projection?"
	}
,
	"ReflectionProbe.center": {
		"prefix": "ReflectionProbe.center",
		"body": [
			"center"
		],
		"description": "return:Vector3 des: The center of the box area in which reflections will be applied to the objects. Measured in the probes's local space."
	}
,
	"ReflectionProbe.clearFlags": {
		"prefix": "ReflectionProbe.clearFlags",
		"body": [
			"clearFlags"
		],
		"description": "return:Rendering.ReflectionProbeClearFlags des: How the reflection probe clears the background."
	}
,
	"ReflectionProbe.cullingMask": {
		"prefix": "ReflectionProbe.cullingMask",
		"body": [
			"cullingMask"
		],
		"description": "return:int des: This is used to render parts of the reflecion probe's surrounding selectively."
	}
,
	"ReflectionProbe.customBakedTexture": {
		"prefix": "ReflectionProbe.customBakedTexture",
		"body": [
			"customBakedTexture"
		],
		"description": "return:Texture des: Reference to the baked texture of the reflection probe's surrounding. Use this to assign custom reflection texture."
	}
,
	"ReflectionProbe.farClipPlane": {
		"prefix": "ReflectionProbe.farClipPlane",
		"body": [
			"farClipPlane"
		],
		"description": "return:float des: The far clipping plane distance when rendering the probe."
	}
,
	"ReflectionProbe.hdr": {
		"prefix": "ReflectionProbe.hdr",
		"body": [
			"hdr"
		],
		"description": "return:bool des: Should this reflection probe use HDR rendering?"
	}
,
	"ReflectionProbe.importance": {
		"prefix": "ReflectionProbe.importance",
		"body": [
			"importance"
		],
		"description": "return:int des: Reflection probe importance."
	}
,
	"ReflectionProbe.intensity": {
		"prefix": "ReflectionProbe.intensity",
		"body": [
			"intensity"
		],
		"description": "return:float des: The intensity modifier that is applied to the texture of reflection probe in the shader."
	}
,
	"ReflectionProbe.mode": {
		"prefix": "ReflectionProbe.mode",
		"body": [
			"mode"
		],
		"description": "return:Rendering.ReflectionProbeMode des: Should reflection probe texture be generated in the Editor (ReflectionProbeMode.Baked) or should probe use custom specified texure (ReflectionProbeMode.Custom)?"
	}
,
	"ReflectionProbe.nearClipPlane": {
		"prefix": "ReflectionProbe.nearClipPlane",
		"body": [
			"nearClipPlane"
		],
		"description": "return:float des: The near clipping plane distance when rendering the probe."
	}
,
	"ReflectionProbe.refreshMode": {
		"prefix": "ReflectionProbe.refreshMode",
		"body": [
			"refreshMode"
		],
		"description": "return:Rendering.ReflectionProbeRefreshMode des: Sets the way the probe will refresh."
	}
,
	"ReflectionProbe.resolution": {
		"prefix": "ReflectionProbe.resolution",
		"body": [
			"resolution"
		],
		"description": "return:int des: Resolution of the underlying reflection texture in pixels."
	}
,
	"ReflectionProbe.shadowDistance": {
		"prefix": "ReflectionProbe.shadowDistance",
		"body": [
			"shadowDistance"
		],
		"description": "return:float des: Shadow drawing distance when rendering the probe."
	}
,
	"ReflectionProbe.size": {
		"prefix": "ReflectionProbe.size",
		"body": [
			"size"
		],
		"description": "return:Vector3 des: The size of the box area in which reflections will be applied to the objects. Measured in the probes's local space."
	}
,
	"ReflectionProbe.texture": {
		"prefix": "ReflectionProbe.texture",
		"body": [
			"texture"
		],
		"description": "return:Texture des: Texture which is passed to the shader of the objects in the vicinity of the reflection probe (Read Only)."
	}
,
	"ReflectionProbe.textureHDRDecodeValues": {
		"prefix": "ReflectionProbe.textureHDRDecodeValues",
		"body": [
			"textureHDRDecodeValues"
		],
		"description": "return:Vector4 des: HDR decode values of the reflection probe texture."
	}
,
	"ReflectionProbe.timeSlicingMode": {
		"prefix": "ReflectionProbe.timeSlicingMode",
		"body": [
			"timeSlicingMode"
		],
		"description": "return:Rendering.ReflectionProbeTimeSlicingMode des: Sets this probe time-slicing mode"
	}
,
	"ReflectionProbe.IsFinishedRendering": {
		"prefix": "ReflectionProbe.IsFinishedRendering",
		"body": [
			"IsFinishedRendering($1)"
		],
		"description": "public bool IsFinishedRendering(int renderId); des: Checks if a probe has finished a time-sliced render."
	}
,
	"ReflectionProbe.RenderProbe": {
		"prefix": "ReflectionProbe.RenderProbe",
		"body": [
			"RenderProbe($1)"
		],
		"description": "public int RenderProbe(RenderTexture targetTexture = null); des: Refreshes the probe's cubemap."
	}
,
	"ReflectionProbe.BlendCubemap": {
		"prefix": "ReflectionProbe.BlendCubemap",
		"body": [
			"ReflectionProbe.BlendCubemap"
		],
		"description": "public static bool BlendCubemap(Texture src, Texture dst, float blend, RenderTexture target); des: Utility method to blend 2 cubemaps into a target render texture."
	}
,
	"ReflectionProbe.enabled": {
		"prefix": "ReflectionProbe.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"ReflectionProbe.isActiveAndEnabled": {
		"prefix": "ReflectionProbe.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"ReflectionProbe.gameObject": {
		"prefix": "ReflectionProbe.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"ReflectionProbe.tag": {
		"prefix": "ReflectionProbe.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"ReflectionProbe.transform": {
		"prefix": "ReflectionProbe.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"ReflectionProbe.hideFlags": {
		"prefix": "ReflectionProbe.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"ReflectionProbe.name": {
		"prefix": "ReflectionProbe.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"ReflectionProbe.BroadcastMessage": {
		"prefix": "ReflectionProbe.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"ReflectionProbe.CompareTag": {
		"prefix": "ReflectionProbe.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"ReflectionProbe.GetComponent": {
		"prefix": "ReflectionProbe.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"ReflectionProbe.GetComponentInChildren": {
		"prefix": "ReflectionProbe.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"ReflectionProbe.GetComponentInParent": {
		"prefix": "ReflectionProbe.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"ReflectionProbe.GetComponents": {
		"prefix": "ReflectionProbe.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"ReflectionProbe.GetComponentsInChildren": {
		"prefix": "ReflectionProbe.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"ReflectionProbe.GetComponentsInParent": {
		"prefix": "ReflectionProbe.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"ReflectionProbe.SendMessage": {
		"prefix": "ReflectionProbe.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"ReflectionProbe.SendMessageUpwards": {
		"prefix": "ReflectionProbe.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"ReflectionProbe.GetInstanceID": {
		"prefix": "ReflectionProbe.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"ReflectionProbe.ToString": {
		"prefix": "ReflectionProbe.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"ReflectionProbe.Destroy": {
		"prefix": "ReflectionProbe.Destroy",
		"body": [
			"ReflectionProbe.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"ReflectionProbe.DestroyImmediate": {
		"prefix": "ReflectionProbe.DestroyImmediate",
		"body": [
			"ReflectionProbe.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"ReflectionProbe.DontDestroyOnLoad": {
		"prefix": "ReflectionProbe.DontDestroyOnLoad",
		"body": [
			"ReflectionProbe.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"ReflectionProbe.FindObjectOfType": {
		"prefix": "ReflectionProbe.FindObjectOfType",
		"body": [
			"ReflectionProbe.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"ReflectionProbe.FindObjectsOfType": {
		"prefix": "ReflectionProbe.FindObjectsOfType",
		"body": [
			"ReflectionProbe.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"ReflectionProbe.Instantiate": {
		"prefix": "ReflectionProbe.Instantiate",
		"body": [
			"ReflectionProbe.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"ReflectionProbe.ReflectionProbeEvent.ReflectionProbeAdded": {
		"prefix": "ReflectionProbe.ReflectionProbeEvent.ReflectionProbeAdded",
		"body": [
			"ReflectionProbeAdded"
		],
		"description": "return: des: An event that occurs when a Reflection Probe component is added to a scene or enabled in a scene."
	}
,
	"ReflectionProbe.ReflectionProbeEvent.ReflectionProbeRemoved": {
		"prefix": "ReflectionProbe.ReflectionProbeEvent.ReflectionProbeRemoved",
		"body": [
			"ReflectionProbeRemoved"
		],
		"description": "return: des: An event that occurs when a Reflection Probe component is unloaded from a scene or disabled in a scene."
	}
,
	"RelativeJoint2D.angularOffset": {
		"prefix": "RelativeJoint2D.angularOffset",
		"body": [
			"angularOffset"
		],
		"description": "return:float des: The current angular offset between the Rigidbody2D that the joint connects."
	}
,
	"RelativeJoint2D.autoConfigureOffset": {
		"prefix": "RelativeJoint2D.autoConfigureOffset",
		"body": [
			"autoConfigureOffset"
		],
		"description": "return:bool des: Should both the linearOffset and angularOffset be calculated automatically?"
	}
,
	"RelativeJoint2D.correctionScale": {
		"prefix": "RelativeJoint2D.correctionScale",
		"body": [
			"correctionScale"
		],
		"description": "return:float des: Scales both the linear and angular forces used to correct the required relative orientation."
	}
,
	"RelativeJoint2D.linearOffset": {
		"prefix": "RelativeJoint2D.linearOffset",
		"body": [
			"linearOffset"
		],
		"description": "return:Vector2 des: The current linear offset between the Rigidbody2D that the joint connects."
	}
,
	"RelativeJoint2D.maxForce": {
		"prefix": "RelativeJoint2D.maxForce",
		"body": [
			"maxForce"
		],
		"description": "return:float des: The maximum force that can be generated when trying to maintain the relative joint constraint."
	}
,
	"RelativeJoint2D.maxTorque": {
		"prefix": "RelativeJoint2D.maxTorque",
		"body": [
			"maxTorque"
		],
		"description": "return:float des: The maximum torque that can be generated when trying to maintain the relative joint constraint."
	}
,
	"RelativeJoint2D.target": {
		"prefix": "RelativeJoint2D.target",
		"body": [
			"target"
		],
		"description": "return:Vector2 des: The world-space position that is currently trying to be maintained."
	}
,
	"RelativeJoint2D.enabled": {
		"prefix": "RelativeJoint2D.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"RelativeJoint2D.isActiveAndEnabled": {
		"prefix": "RelativeJoint2D.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"RelativeJoint2D.gameObject": {
		"prefix": "RelativeJoint2D.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"RelativeJoint2D.tag": {
		"prefix": "RelativeJoint2D.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"RelativeJoint2D.transform": {
		"prefix": "RelativeJoint2D.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"RelativeJoint2D.attachedRigidbody": {
		"prefix": "RelativeJoint2D.attachedRigidbody",
		"body": [
			"attachedRigidbody"
		],
		"description": "return:Rigidbody2D des: The Rigidbody2D attached to the Joint2D."
	}
,
	"RelativeJoint2D.breakForce": {
		"prefix": "RelativeJoint2D.breakForce",
		"body": [
			"breakForce"
		],
		"description": "return:float des: The force that needs to be applied for this joint to break."
	}
,
	"RelativeJoint2D.breakTorque": {
		"prefix": "RelativeJoint2D.breakTorque",
		"body": [
			"breakTorque"
		],
		"description": "return:float des: The torque that needs to be applied for this joint to break."
	}
,
	"RelativeJoint2D.connectedBody": {
		"prefix": "RelativeJoint2D.connectedBody",
		"body": [
			"connectedBody"
		],
		"description": "return:Rigidbody2D des: The Rigidbody2D object to which the other end of the joint is attached (ie, the object without the joint component)."
	}
,
	"RelativeJoint2D.enableCollision": {
		"prefix": "RelativeJoint2D.enableCollision",
		"body": [
			"enableCollision"
		],
		"description": "return:bool des: Should the two rigid bodies connected with this joint collide with each other?"
	}
,
	"RelativeJoint2D.reactionForce": {
		"prefix": "RelativeJoint2D.reactionForce",
		"body": [
			"reactionForce"
		],
		"description": "return:Vector2 des: Gets the reaction force of the joint."
	}
,
	"RelativeJoint2D.reactionTorque": {
		"prefix": "RelativeJoint2D.reactionTorque",
		"body": [
			"reactionTorque"
		],
		"description": "return:float des: Gets the reaction torque of the joint."
	}
,
	"RelativeJoint2D.hideFlags": {
		"prefix": "RelativeJoint2D.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"RelativeJoint2D.name": {
		"prefix": "RelativeJoint2D.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"RelativeJoint2D.BroadcastMessage": {
		"prefix": "RelativeJoint2D.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"RelativeJoint2D.CompareTag": {
		"prefix": "RelativeJoint2D.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"RelativeJoint2D.GetComponent": {
		"prefix": "RelativeJoint2D.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"RelativeJoint2D.GetComponentInChildren": {
		"prefix": "RelativeJoint2D.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"RelativeJoint2D.GetComponentInParent": {
		"prefix": "RelativeJoint2D.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"RelativeJoint2D.GetComponents": {
		"prefix": "RelativeJoint2D.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"RelativeJoint2D.GetComponentsInChildren": {
		"prefix": "RelativeJoint2D.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"RelativeJoint2D.GetComponentsInParent": {
		"prefix": "RelativeJoint2D.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"RelativeJoint2D.SendMessage": {
		"prefix": "RelativeJoint2D.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"RelativeJoint2D.SendMessageUpwards": {
		"prefix": "RelativeJoint2D.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"RelativeJoint2D.GetReactionForce": {
		"prefix": "RelativeJoint2D.GetReactionForce",
		"body": [
			"GetReactionForce($1)"
		],
		"description": "public Vector2 GetReactionForce(float timeStep); des: Gets the reaction force of the joint given the specified timeStep."
	}
,
	"RelativeJoint2D.GetReactionTorque": {
		"prefix": "RelativeJoint2D.GetReactionTorque",
		"body": [
			"GetReactionTorque($1)"
		],
		"description": "public float GetReactionTorque(float timeStep); des: Gets the reaction torque of the joint given the specified timeStep."
	}
,
	"RelativeJoint2D.GetInstanceID": {
		"prefix": "RelativeJoint2D.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"RelativeJoint2D.ToString": {
		"prefix": "RelativeJoint2D.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"RelativeJoint2D.Destroy": {
		"prefix": "RelativeJoint2D.Destroy",
		"body": [
			"RelativeJoint2D.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"RelativeJoint2D.DestroyImmediate": {
		"prefix": "RelativeJoint2D.DestroyImmediate",
		"body": [
			"RelativeJoint2D.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"RelativeJoint2D.DontDestroyOnLoad": {
		"prefix": "RelativeJoint2D.DontDestroyOnLoad",
		"body": [
			"RelativeJoint2D.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"RelativeJoint2D.FindObjectOfType": {
		"prefix": "RelativeJoint2D.FindObjectOfType",
		"body": [
			"RelativeJoint2D.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"RelativeJoint2D.FindObjectsOfType": {
		"prefix": "RelativeJoint2D.FindObjectsOfType",
		"body": [
			"RelativeJoint2D.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"RelativeJoint2D.Instantiate": {
		"prefix": "RelativeJoint2D.Instantiate",
		"body": [
			"RelativeJoint2D.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"RelativeJoint2D.OnJointBreak2D": {
		"prefix": "RelativeJoint2D.OnJointBreak2D",
		"body": [
			"OnJointBreak2D"
		],
		"description": "Called when a Joint2D attached to the same game object breaks."
	}
,
	"RemoteSettings.ForceUpdate": {
		"prefix": "RemoteSettings.ForceUpdate",
		"body": [
			"RemoteSettings.ForceUpdate"
		],
		"description": "public static void ForceUpdate(); des: Forces the game to download the newest settings from the server and update its values."
	}
,
	"RemoteSettings.GetBool": {
		"prefix": "RemoteSettings.GetBool",
		"body": [
			"RemoteSettings.GetBool"
		],
		"description": "public static bool GetBool(string key, bool defaultValue = false); des: Gets the value corresponding to remote setting identified by key, if it exists."
	}
,
	"RemoteSettings.GetCount": {
		"prefix": "RemoteSettings.GetCount",
		"body": [
			"RemoteSettings.GetCount"
		],
		"description": "public static int GetCount(); des: Gets the number of keys in the remote settings configuration."
	}
,
	"RemoteSettings.GetFloat": {
		"prefix": "RemoteSettings.GetFloat",
		"body": [
			"RemoteSettings.GetFloat"
		],
		"description": "public static float GetFloat(string key, float defaultValue = 0.0F); des: Gets the value corresponding to remote setting identified by key, if it exists."
	}
,
	"RemoteSettings.GetInt": {
		"prefix": "RemoteSettings.GetInt",
		"body": [
			"RemoteSettings.GetInt"
		],
		"description": "public static int GetInt(string key, int defaultValue = 0); des: Gets the value corresponding to remote setting identified by key, if it exists."
	}
,
	"RemoteSettings.GetKeys": {
		"prefix": "RemoteSettings.GetKeys",
		"body": [
			"RemoteSettings.GetKeys"
		],
		"description": "public static string[] GetKeys(); des: Gets an array containing all the keys in the remote settings configuration."
	}
,
	"RemoteSettings.GetLong": {
		"prefix": "RemoteSettings.GetLong",
		"body": [
			"RemoteSettings.GetLong"
		],
		"description": "public static long GetLong(string key, long defaultValue = 0); des: Gets the value corresponding to remote setting identified by key, if it exists."
	}
,
	"RemoteSettings.GetString": {
		"prefix": "RemoteSettings.GetString",
		"body": [
			"RemoteSettings.GetString"
		],
		"description": "public static string GetString(string key, string defaultValue = \"\"); des: Gets the value corresponding to remote setting identified by key, if it exists."
	}
,
	"RemoteSettings.HasKey": {
		"prefix": "RemoteSettings.HasKey",
		"body": [
			"RemoteSettings.HasKey"
		],
		"description": "public static bool HasKey(string key); des: Reports whether the specified key exists in the remote settings configuration."
	}
,
	"RemoteSettings.WasLastUpdatedFromServer": {
		"prefix": "RemoteSettings.WasLastUpdatedFromServer",
		"body": [
			"RemoteSettings.WasLastUpdatedFromServer"
		],
		"description": "public static bool WasLastUpdatedFromServer(); des: Reports whether or not the settings available from the RemoteSettings object were received from the Analytics Service during the current session."
	}
,
	"RenderBuffer.GetNativeRenderBufferPtr": {
		"prefix": "RenderBuffer.GetNativeRenderBufferPtr",
		"body": [
			"GetNativeRenderBufferPtr($1)"
		],
		"description": "public IntPtr GetNativeRenderBufferPtr(); des: Returns native RenderBuffer. Be warned this is not native Texture, but rather pointer to unity struct that can be used with native unity API. Currently such API exists only on iOS."
	}
,
	"Renderer.allowOcclusionWhenDynamic": {
		"prefix": "Renderer.allowOcclusionWhenDynamic",
		"body": [
			"allowOcclusionWhenDynamic"
		],
		"description": "return:bool des: Controls if dynamic occlusion culling should be performed for this renderer."
	}
,
	"Renderer.bounds": {
		"prefix": "Renderer.bounds",
		"body": [
			"bounds"
		],
		"description": "return:Bounds des: The bounding volume of the renderer (Read Only)."
	}
,
	"Renderer.enabled": {
		"prefix": "Renderer.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Makes the rendered 3D object visible if enabled."
	}
,
	"Renderer.isPartOfStaticBatch": {
		"prefix": "Renderer.isPartOfStaticBatch",
		"body": [
			"isPartOfStaticBatch"
		],
		"description": "return:bool des: Has this renderer been statically batched with any other renderers?"
	}
,
	"Renderer.isVisible": {
		"prefix": "Renderer.isVisible",
		"body": [
			"isVisible"
		],
		"description": "return:bool des: Is this renderer visible in any camera? (Read Only)"
	}
,
	"Renderer.lightmapIndex": {
		"prefix": "Renderer.lightmapIndex",
		"body": [
			"lightmapIndex"
		],
		"description": "return:int des: The index of the baked lightmap applied to this renderer."
	}
,
	"Renderer.lightmapScaleOffset": {
		"prefix": "Renderer.lightmapScaleOffset",
		"body": [
			"lightmapScaleOffset"
		],
		"description": "return:Vector4 des: The UV scale & offset used for a lightmap."
	}
,
	"Renderer.lightProbeProxyVolumeOverride": {
		"prefix": "Renderer.lightProbeProxyVolumeOverride",
		"body": [
			"lightProbeProxyVolumeOverride"
		],
		"description": "return:GameObject des: If set, the Renderer will use the Light Probe Proxy Volume component attached to the source GameObject."
	}
,
	"Renderer.lightProbeUsage": {
		"prefix": "Renderer.lightProbeUsage",
		"body": [
			"lightProbeUsage"
		],
		"description": "return:Rendering.LightProbeUsage des: The light probe interpolation type."
	}
,
	"Renderer.localToWorldMatrix": {
		"prefix": "Renderer.localToWorldMatrix",
		"body": [
			"localToWorldMatrix"
		],
		"description": "return:Matrix4x4 des: Matrix that transforms a point from local space into world space (Read Only)."
	}
,
	"Renderer.material": {
		"prefix": "Renderer.material",
		"body": [
			"material"
		],
		"description": "return:Material des: Returns the first instantiated Material assigned to the renderer."
	}
,
	"Renderer.materials": {
		"prefix": "Renderer.materials",
		"body": [
			"materials"
		],
		"description": "return:Material[] des: Returns all the instantiated materials of this object."
	}
,
	"Renderer.motionVectorGenerationMode": {
		"prefix": "Renderer.motionVectorGenerationMode",
		"body": [
			"motionVectorGenerationMode"
		],
		"description": "return:MotionVectorGenerationMode des: Specifies the mode for motion vector rendering."
	}
,
	"Renderer.probeAnchor": {
		"prefix": "Renderer.probeAnchor",
		"body": [
			"probeAnchor"
		],
		"description": "return:Transform des: If set, Renderer will use this Transform's position to find the light or reflection probe."
	}
,
	"Renderer.realtimeLightmapIndex": {
		"prefix": "Renderer.realtimeLightmapIndex",
		"body": [
			"realtimeLightmapIndex"
		],
		"description": "return:int des: The index of the realtime lightmap applied to this renderer."
	}
,
	"Renderer.realtimeLightmapScaleOffset": {
		"prefix": "Renderer.realtimeLightmapScaleOffset",
		"body": [
			"realtimeLightmapScaleOffset"
		],
		"description": "return:Vector4 des: The UV scale & offset used for a realtime lightmap."
	}
,
	"Renderer.receiveShadows": {
		"prefix": "Renderer.receiveShadows",
		"body": [
			"receiveShadows"
		],
		"description": "return:bool des: Does this object receive shadows?"
	}
,
	"Renderer.reflectionProbeUsage": {
		"prefix": "Renderer.reflectionProbeUsage",
		"body": [
			"reflectionProbeUsage"
		],
		"description": "return:Rendering.ReflectionProbeUsage des: Should reflection probes be used for this Renderer?"
	}
,
	"Renderer.renderingLayerMask": {
		"prefix": "Renderer.renderingLayerMask",
		"body": [
			"renderingLayerMask"
		],
		"description": "return:uint des: Determines which rendering layer this renderer lives on."
	}
,
	"Renderer.shadowCastingMode": {
		"prefix": "Renderer.shadowCastingMode",
		"body": [
			"shadowCastingMode"
		],
		"description": "return:Rendering.ShadowCastingMode des: Does this object cast shadows?"
	}
,
	"Renderer.sharedMaterial": {
		"prefix": "Renderer.sharedMaterial",
		"body": [
			"sharedMaterial"
		],
		"description": "return:Material des: The shared material of this object."
	}
,
	"Renderer.sharedMaterials": {
		"prefix": "Renderer.sharedMaterials",
		"body": [
			"sharedMaterials"
		],
		"description": "return:Material[] des: All the shared materials of this object."
	}
,
	"Renderer.sortingLayerID": {
		"prefix": "Renderer.sortingLayerID",
		"body": [
			"sortingLayerID"
		],
		"description": "return:int des: Unique ID of the Renderer's sorting layer."
	}
,
	"Renderer.sortingLayerName": {
		"prefix": "Renderer.sortingLayerName",
		"body": [
			"sortingLayerName"
		],
		"description": "return:string des: Name of the Renderer's sorting layer."
	}
,
	"Renderer.sortingOrder": {
		"prefix": "Renderer.sortingOrder",
		"body": [
			"sortingOrder"
		],
		"description": "return:int des: Renderer's order within a sorting layer."
	}
,
	"Renderer.worldToLocalMatrix": {
		"prefix": "Renderer.worldToLocalMatrix",
		"body": [
			"worldToLocalMatrix"
		],
		"description": "return:Matrix4x4 des: Matrix that transforms a point from world space into local space (Read Only)."
	}
,
	"Renderer.GetClosestReflectionProbes": {
		"prefix": "Renderer.GetClosestReflectionProbes",
		"body": [
			"GetClosestReflectionProbes($1)"
		],
		"description": "public void GetClosestReflectionProbes(List<ReflectionProbeBlendInfo> result); des: Returns an array of closest reflection probes with weights, weight shows how much influence the probe has on the renderer, this value is also used when blending between reflection probes occur."
	}
,
	"Renderer.GetMaterials": {
		"prefix": "Renderer.GetMaterials",
		"body": [
			"GetMaterials($1)"
		],
		"description": "public void GetMaterials(List<Material> m); des: Returns all the instantiated materials of this object."
	}
,
	"Renderer.GetPropertyBlock": {
		"prefix": "Renderer.GetPropertyBlock",
		"body": [
			"GetPropertyBlock($1)"
		],
		"description": "public void GetPropertyBlock(MaterialPropertyBlock properties); public void GetPropertyBlock(MaterialPropertyBlock properties, int materialIndex); des: Get per-Renderer or per-Material property block."
	}
,
	"Renderer.GetSharedMaterials": {
		"prefix": "Renderer.GetSharedMaterials",
		"body": [
			"GetSharedMaterials($1)"
		],
		"description": "public void GetSharedMaterials(List<Material> m); des: Returns all the shared materials of this object."
	}
,
	"Renderer.HasPropertyBlock": {
		"prefix": "Renderer.HasPropertyBlock",
		"body": [
			"HasPropertyBlock($1)"
		],
		"description": "public bool HasPropertyBlock(); des: Returns true if the Renderer has a material property block attached via SetPropertyBlock."
	}
,
	"Renderer.SetPropertyBlock": {
		"prefix": "Renderer.SetPropertyBlock",
		"body": [
			"SetPropertyBlock($1)"
		],
		"description": "public void SetPropertyBlock(MaterialPropertyBlock properties); public void SetPropertyBlock(MaterialPropertyBlock properties, int materialIndex); des: Lets you set or clear per-renderer or per-material parameter overrides."
	}
,
	"Renderer.OnBecameInvisible": {
		"prefix": "Renderer.OnBecameInvisible",
		"body": [
			"OnBecameInvisible"
		],
		"description": "OnBecameInvisible is called when the object is no longer visible by any camera."
	}
,
	"Renderer.OnBecameVisible": {
		"prefix": "Renderer.OnBecameVisible",
		"body": [
			"OnBecameVisible"
		],
		"description": "OnBecameVisible is called when the object became visible by any camera."
	}
,
	"Renderer.gameObject": {
		"prefix": "Renderer.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"Renderer.tag": {
		"prefix": "Renderer.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"Renderer.transform": {
		"prefix": "Renderer.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"Renderer.hideFlags": {
		"prefix": "Renderer.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Renderer.name": {
		"prefix": "Renderer.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Renderer.BroadcastMessage": {
		"prefix": "Renderer.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"Renderer.CompareTag": {
		"prefix": "Renderer.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"Renderer.GetComponent": {
		"prefix": "Renderer.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"Renderer.GetComponentInChildren": {
		"prefix": "Renderer.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"Renderer.GetComponentInParent": {
		"prefix": "Renderer.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"Renderer.GetComponents": {
		"prefix": "Renderer.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"Renderer.GetComponentsInChildren": {
		"prefix": "Renderer.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"Renderer.GetComponentsInParent": {
		"prefix": "Renderer.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"Renderer.SendMessage": {
		"prefix": "Renderer.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"Renderer.SendMessageUpwards": {
		"prefix": "Renderer.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"Renderer.GetInstanceID": {
		"prefix": "Renderer.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Renderer.ToString": {
		"prefix": "Renderer.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Renderer.Destroy": {
		"prefix": "Renderer.Destroy",
		"body": [
			"Renderer.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Renderer.DestroyImmediate": {
		"prefix": "Renderer.DestroyImmediate",
		"body": [
			"Renderer.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Renderer.DontDestroyOnLoad": {
		"prefix": "Renderer.DontDestroyOnLoad",
		"body": [
			"Renderer.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Renderer.FindObjectOfType": {
		"prefix": "Renderer.FindObjectOfType",
		"body": [
			"Renderer.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Renderer.FindObjectsOfType": {
		"prefix": "Renderer.FindObjectsOfType",
		"body": [
			"Renderer.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Renderer.Instantiate": {
		"prefix": "Renderer.Instantiate",
		"body": [
			"Renderer.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"RendererExtensions.UpdateGIMaterials": {
		"prefix": "RendererExtensions.UpdateGIMaterials",
		"body": [
			"RendererExtensions.UpdateGIMaterials"
		],
		"description": "public static void UpdateGIMaterials(Renderer renderer); des: Schedules an update of the albedo and emissive Textures of a system that contains the Renderer."
	}
,
	"RenderSettings.hideFlags": {
		"prefix": "RenderSettings.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"RenderSettings.name": {
		"prefix": "RenderSettings.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"RenderSettings.GetInstanceID": {
		"prefix": "RenderSettings.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"RenderSettings.ToString": {
		"prefix": "RenderSettings.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"RenderSettings.Destroy": {
		"prefix": "RenderSettings.Destroy",
		"body": [
			"RenderSettings.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"RenderSettings.DestroyImmediate": {
		"prefix": "RenderSettings.DestroyImmediate",
		"body": [
			"RenderSettings.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"RenderSettings.DontDestroyOnLoad": {
		"prefix": "RenderSettings.DontDestroyOnLoad",
		"body": [
			"RenderSettings.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"RenderSettings.FindObjectOfType": {
		"prefix": "RenderSettings.FindObjectOfType",
		"body": [
			"RenderSettings.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"RenderSettings.FindObjectsOfType": {
		"prefix": "RenderSettings.FindObjectsOfType",
		"body": [
			"RenderSettings.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"RenderSettings.Instantiate": {
		"prefix": "RenderSettings.Instantiate",
		"body": [
			"RenderSettings.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"RenderTargetSetup.color": {
		"prefix": "RenderTargetSetup.color",
		"body": [
			"color"
		],
		"description": "return:RenderBuffer[] des: Color Buffers to set."
	}
,
	"RenderTargetSetup.colorLoad": {
		"prefix": "RenderTargetSetup.colorLoad",
		"body": [
			"colorLoad"
		],
		"description": "return:RenderBufferLoadAction[] des: Load Actions for Color Buffers. It will override any actions set on RenderBuffers themselves."
	}
,
	"RenderTargetSetup.colorStore": {
		"prefix": "RenderTargetSetup.colorStore",
		"body": [
			"colorStore"
		],
		"description": "return:RenderBufferStoreAction[] des: Store Actions for Color Buffers. It will override any actions set on RenderBuffers themselves."
	}
,
	"RenderTargetSetup.cubemapFace": {
		"prefix": "RenderTargetSetup.cubemapFace",
		"body": [
			"cubemapFace"
		],
		"description": "return:CubemapFace des: Cubemap face to render to."
	}
,
	"RenderTargetSetup.depth": {
		"prefix": "RenderTargetSetup.depth",
		"body": [
			"depth"
		],
		"description": "return:RenderBuffer des: Depth Buffer to set."
	}
,
	"RenderTargetSetup.depthLoad": {
		"prefix": "RenderTargetSetup.depthLoad",
		"body": [
			"depthLoad"
		],
		"description": "return:Rendering.RenderBufferLoadAction des: Load Action for Depth Buffer. It will override any actions set on RenderBuffer itself."
	}
,
	"RenderTargetSetup.depthSlice": {
		"prefix": "RenderTargetSetup.depthSlice",
		"body": [
			"depthSlice"
		],
		"description": "return:int des: Slice of a Texture3D or Texture2DArray to set as a render target."
	}
,
	"RenderTargetSetup.depthStore": {
		"prefix": "RenderTargetSetup.depthStore",
		"body": [
			"depthStore"
		],
		"description": "return:Rendering.RenderBufferStoreAction des: Store Actions for Depth Buffer. It will override any actions set on RenderBuffer itself."
	}
,
	"RenderTargetSetup.mipLevel": {
		"prefix": "RenderTargetSetup.mipLevel",
		"body": [
			"mipLevel"
		],
		"description": "return:int des: Mip Level to render to."
	}
,
	"RenderTexture.antiAliasing": {
		"prefix": "RenderTexture.antiAliasing",
		"body": [
			"antiAliasing"
		],
		"description": "return:int des: The antialiasing level for the RenderTexture."
	}
,
	"RenderTexture.autoGenerateMips": {
		"prefix": "RenderTexture.autoGenerateMips",
		"body": [
			"autoGenerateMips"
		],
		"description": "return:bool des: Mipmap levels are generated automatically when this flag is set."
	}
,
	"RenderTexture.bindTextureMS": {
		"prefix": "RenderTexture.bindTextureMS",
		"body": [
			"bindTextureMS"
		],
		"description": "return:bool des: If true and antiAliasing is greater than 1, the render texture will not be resolved by default. Use this if the render texture needs to be bound as a multisampled texture in a shader."
	}
,
	"RenderTexture.colorBuffer": {
		"prefix": "RenderTexture.colorBuffer",
		"body": [
			"colorBuffer"
		],
		"description": "return:RenderBuffer des: Color buffer of the render texture (Read Only)."
	}
,
	"RenderTexture.depth": {
		"prefix": "RenderTexture.depth",
		"body": [
			"depth"
		],
		"description": "return:int des: The precision of the render texture's depth buffer in bits (0, 16, 24/32 are supported)."
	}
,
	"RenderTexture.depthBuffer": {
		"prefix": "RenderTexture.depthBuffer",
		"body": [
			"depthBuffer"
		],
		"description": "return:RenderBuffer des: Depth/stencil buffer of the render texture (Read Only)."
	}
,
	"RenderTexture.descriptor": {
		"prefix": "RenderTexture.descriptor",
		"body": [
			"descriptor"
		],
		"description": "return:RenderTextureDescriptor des: This struct contains all the information required to create a RenderTexture. It can be copied, cached, and reused to easily create RenderTextures that all share the same properties."
	}
,
	"RenderTexture.enableRandomWrite": {
		"prefix": "RenderTexture.enableRandomWrite",
		"body": [
			"enableRandomWrite"
		],
		"description": "return:bool des: Enable random access write into this render texture on Shader Model 5.0 level shaders."
	}
,
	"RenderTexture.format": {
		"prefix": "RenderTexture.format",
		"body": [
			"format"
		],
		"description": "return:RenderTextureFormat des: The color format of the render texture."
	}
,
	"RenderTexture.memorylessMode": {
		"prefix": "RenderTexture.memorylessMode",
		"body": [
			"memorylessMode"
		],
		"description": "return:RenderTextureMemoryless des: The render texture memoryless mode property."
	}
,
	"RenderTexture.sRGB": {
		"prefix": "RenderTexture.sRGB",
		"body": [
			"sRGB"
		],
		"description": "return:bool des: Does this render texture use sRGB read/write conversions? (Read Only)."
	}
,
	"RenderTexture.useDynamicScale": {
		"prefix": "RenderTexture.useDynamicScale",
		"body": [
			"useDynamicScale"
		],
		"description": "return:bool des: Is the render texture marked to be scaled by the Dynamic Resolution system."
	}
,
	"RenderTexture.useMipMap": {
		"prefix": "RenderTexture.useMipMap",
		"body": [
			"useMipMap"
		],
		"description": "return:bool des: Render texture has mipmaps when this flag is set."
	}
,
	"RenderTexture.volumeDepth": {
		"prefix": "RenderTexture.volumeDepth",
		"body": [
			"volumeDepth"
		],
		"description": "return:int des: Volume extent of a 3D render texture or number of slices of array texture."
	}
,
	"RenderTexture.vrUsage": {
		"prefix": "RenderTexture.vrUsage",
		"body": [
			"vrUsage"
		],
		"description": "return:VRTextureUsage des: If this RenderTexture is a VR eye texture used in stereoscopic rendering, this property decides what special rendering occurs, if any."
	}
,
	"RenderTexture.ConvertToEquirect": {
		"prefix": "RenderTexture.ConvertToEquirect",
		"body": [
			"ConvertToEquirect($1)"
		],
		"description": "public void ConvertToEquirect(RenderTexture equirect, Camera.MonoOrStereoscopicEye eye); des: Converts the render texture to equirectangular format (both stereoscopic or monoscopic equirect). The left eye will occupy the top half and the right eye will occupy the bottom. The monoscopic version will occupy the whole texture. Texture dimension must be of type TextureDimension.Cube."
	}
,
	"RenderTexture.Create": {
		"prefix": "RenderTexture.Create",
		"body": [
			"Create($1)"
		],
		"description": "public bool Create(); des: Actually creates the RenderTexture."
	}
,
	"RenderTexture.DiscardContents": {
		"prefix": "RenderTexture.DiscardContents",
		"body": [
			"DiscardContents($1)"
		],
		"description": "public void DiscardContents(); public void DiscardContents(bool discardColor, bool discardDepth); des: Hint the GPU driver that the contents of the RenderTexture will not be used."
	}
,
	"RenderTexture.GenerateMips": {
		"prefix": "RenderTexture.GenerateMips",
		"body": [
			"GenerateMips($1)"
		],
		"description": "public void GenerateMips(); des: Generate mipmap levels of a render texture."
	}
,
	"RenderTexture.GetNativeDepthBufferPtr": {
		"prefix": "RenderTexture.GetNativeDepthBufferPtr",
		"body": [
			"GetNativeDepthBufferPtr($1)"
		],
		"description": "public IntPtr GetNativeDepthBufferPtr(); des: Retrieve a native (underlying graphics API) pointer to the depth buffer resource."
	}
,
	"RenderTexture.IsCreated": {
		"prefix": "RenderTexture.IsCreated",
		"body": [
			"IsCreated($1)"
		],
		"description": "public bool IsCreated(); des: Is the render texture actually created?"
	}
,
	"RenderTexture.MarkRestoreExpected": {
		"prefix": "RenderTexture.MarkRestoreExpected",
		"body": [
			"MarkRestoreExpected($1)"
		],
		"description": "public void MarkRestoreExpected(); des: Indicate that there's a RenderTexture restore operation expected."
	}
,
	"RenderTexture.Release": {
		"prefix": "RenderTexture.Release",
		"body": [
			"Release($1)"
		],
		"description": "public void Release(); des: Releases the RenderTexture."
	}
,
	"RenderTexture.ResolveAntiAliasedSurface": {
		"prefix": "RenderTexture.ResolveAntiAliasedSurface",
		"body": [
			"ResolveAntiAliasedSurface($1)"
		],
		"description": "public void ResolveAntiAliasedSurface(); public void ResolveAntiAliasedSurface(RenderTexture target); des: Force an antialiased render texture to be resolved."
	}
,
	"RenderTexture.SetGlobalShaderProperty": {
		"prefix": "RenderTexture.SetGlobalShaderProperty",
		"body": [
			"SetGlobalShaderProperty($1)"
		],
		"description": "public void SetGlobalShaderProperty(string propertyName); des: Assigns this RenderTexture as a global shader property named propertyName."
	}
,
	"RenderTexture.GetTemporary": {
		"prefix": "RenderTexture.GetTemporary",
		"body": [
			"RenderTexture.GetTemporary"
		],
		"description": "public static RenderTexture GetTemporary(RenderTextureDescriptor desc); public static RenderTexture GetTemporary(int width, int height, int depthBuffer = 0, RenderTextureFormat format = RenderTextureFormat.Default, RenderTextureReadWrite readWrite = RenderTextureReadWrite.Default, int antiAliasing = 1, RenderTextureMemoryless memorylessMode = RenderTextureMemoryless.None, VRTextureUsage vrUsage = VRTextureUsage.None, bool useDynamicScale = false); des: Allocate a temporary render texture."
	}
,
	"RenderTexture.ReleaseTemporary": {
		"prefix": "RenderTexture.ReleaseTemporary",
		"body": [
			"RenderTexture.ReleaseTemporary"
		],
		"description": "public static void ReleaseTemporary(RenderTexture temp); des: Release a temporary texture allocated with GetTemporary."
	}
,
	"RenderTexture.SupportsStencil": {
		"prefix": "RenderTexture.SupportsStencil",
		"body": [
			"RenderTexture.SupportsStencil"
		],
		"description": "public static bool SupportsStencil(RenderTexture rt); des: Does a RenderTexture have stencil buffer?"
	}
,
	"RenderTexture.hideFlags": {
		"prefix": "RenderTexture.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"RenderTexture.name": {
		"prefix": "RenderTexture.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"RenderTexture.anisoLevel": {
		"prefix": "RenderTexture.anisoLevel",
		"body": [
			"anisoLevel"
		],
		"description": "return:int des: Anisotropic filtering level of the texture."
	}
,
	"RenderTexture.dimension": {
		"prefix": "RenderTexture.dimension",
		"body": [
			"dimension"
		],
		"description": "return:Rendering.TextureDimension des: Dimensionality (type) of the texture (Read Only)."
	}
,
	"RenderTexture.filterMode": {
		"prefix": "RenderTexture.filterMode",
		"body": [
			"filterMode"
		],
		"description": "return:FilterMode des: Filtering mode of the texture."
	}
,
	"RenderTexture.height": {
		"prefix": "RenderTexture.height",
		"body": [
			"height"
		],
		"description": "return:int des: Height of the texture in pixels. (Read Only)"
	}
,
	"RenderTexture.imageContentsHash": {
		"prefix": "RenderTexture.imageContentsHash",
		"body": [
			"imageContentsHash"
		],
		"description": "return:Hash128 des: The hash value of the Texture."
	}
,
	"RenderTexture.mipMapBias": {
		"prefix": "RenderTexture.mipMapBias",
		"body": [
			"mipMapBias"
		],
		"description": "return:float des: Mip map bias of the texture."
	}
,
	"RenderTexture.updateCount": {
		"prefix": "RenderTexture.updateCount",
		"body": [
			"updateCount"
		],
		"description": "return:uint des: This counter is incremented when the texture is updated."
	}
,
	"RenderTexture.width": {
		"prefix": "RenderTexture.width",
		"body": [
			"width"
		],
		"description": "return:int des: Width of the texture in pixels. (Read Only)"
	}
,
	"RenderTexture.wrapMode": {
		"prefix": "RenderTexture.wrapMode",
		"body": [
			"wrapMode"
		],
		"description": "return:TextureWrapMode des: Texture coordinate wrapping mode."
	}
,
	"RenderTexture.wrapModeU": {
		"prefix": "RenderTexture.wrapModeU",
		"body": [
			"wrapModeU"
		],
		"description": "return:TextureWrapMode des: Texture U coordinate wrapping mode."
	}
,
	"RenderTexture.wrapModeV": {
		"prefix": "RenderTexture.wrapModeV",
		"body": [
			"wrapModeV"
		],
		"description": "return:TextureWrapMode des: Texture V coordinate wrapping mode."
	}
,
	"RenderTexture.wrapModeW": {
		"prefix": "RenderTexture.wrapModeW",
		"body": [
			"wrapModeW"
		],
		"description": "return:TextureWrapMode des: Texture W coordinate wrapping mode for Texture3D."
	}
,
	"RenderTexture.GetInstanceID": {
		"prefix": "RenderTexture.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"RenderTexture.ToString": {
		"prefix": "RenderTexture.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"RenderTexture.GetNativeTexturePtr": {
		"prefix": "RenderTexture.GetNativeTexturePtr",
		"body": [
			"GetNativeTexturePtr($1)"
		],
		"description": "public IntPtr GetNativeTexturePtr(); des: Retrieve a native (underlying graphics API) pointer to the texture resource."
	}
,
	"RenderTexture.IncrementUpdateCount": {
		"prefix": "RenderTexture.IncrementUpdateCount",
		"body": [
			"IncrementUpdateCount($1)"
		],
		"description": "public void IncrementUpdateCount(); des: Increment the update counter."
	}
,
	"RenderTexture.Destroy": {
		"prefix": "RenderTexture.Destroy",
		"body": [
			"RenderTexture.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"RenderTexture.DestroyImmediate": {
		"prefix": "RenderTexture.DestroyImmediate",
		"body": [
			"RenderTexture.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"RenderTexture.DontDestroyOnLoad": {
		"prefix": "RenderTexture.DontDestroyOnLoad",
		"body": [
			"RenderTexture.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"RenderTexture.FindObjectOfType": {
		"prefix": "RenderTexture.FindObjectOfType",
		"body": [
			"RenderTexture.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"RenderTexture.FindObjectsOfType": {
		"prefix": "RenderTexture.FindObjectsOfType",
		"body": [
			"RenderTexture.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"RenderTexture.Instantiate": {
		"prefix": "RenderTexture.Instantiate",
		"body": [
			"RenderTexture.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"RenderTexture.SetGlobalAnisotropicFilteringLimits": {
		"prefix": "RenderTexture.SetGlobalAnisotropicFilteringLimits",
		"body": [
			"RenderTexture.SetGlobalAnisotropicFilteringLimits"
		],
		"description": "public static void SetGlobalAnisotropicFilteringLimits(int forcedMin, int globalMax); des: Sets Anisotropic limits."
	}
,
	"RenderTexture.SetStreamingTextureMaterialDebugProperties": {
		"prefix": "RenderTexture.SetStreamingTextureMaterialDebugProperties",
		"body": [
			"RenderTexture.SetStreamingTextureMaterialDebugProperties"
		],
		"description": "public static void SetStreamingTextureMaterialDebugProperties(); des: Uploads additional debug information to materials using textures set to stream mip maps."
	}
,
	"RenderTextureDescriptor.autoGenerateMips": {
		"prefix": "RenderTextureDescriptor.autoGenerateMips",
		"body": [
			"autoGenerateMips"
		],
		"description": "return:bool des: Mipmap levels are generated automatically when this flag is set."
	}
,
	"RenderTextureDescriptor.bindMS": {
		"prefix": "RenderTextureDescriptor.bindMS",
		"body": [
			"bindMS"
		],
		"description": "return:bool des: If true and msaaSamples is greater than 1, the render texture will not be resolved by default. Use this if the render texture needs to be bound as a multisampled texture in a shader."
	}
,
	"RenderTextureDescriptor.colorFormat": {
		"prefix": "RenderTextureDescriptor.colorFormat",
		"body": [
			"colorFormat"
		],
		"description": "return:RenderTextureFormat des: The color format for the RenderTexture."
	}
,
	"RenderTextureDescriptor.depthBufferBits": {
		"prefix": "RenderTextureDescriptor.depthBufferBits",
		"body": [
			"depthBufferBits"
		],
		"description": "return:int des: The precision of the render texture's depth buffer in bits (0, 16, 24/32 are supported)."
	}
,
	"RenderTextureDescriptor.dimension": {
		"prefix": "RenderTextureDescriptor.dimension",
		"body": [
			"dimension"
		],
		"description": "return:Rendering.TextureDimension des: Dimensionality (type) of the render texture."
	}
,
	"RenderTextureDescriptor.enableRandomWrite": {
		"prefix": "RenderTextureDescriptor.enableRandomWrite",
		"body": [
			"enableRandomWrite"
		],
		"description": "return:bool des: Enable random access write into this render texture on Shader Model 5.0 level shaders."
	}
,
	"RenderTextureDescriptor.flags": {
		"prefix": "RenderTextureDescriptor.flags",
		"body": [
			"flags"
		],
		"description": "return:RenderTextureCreationFlags des: A set of RenderTextureCreationFlags that control how the texture is created."
	}
,
	"RenderTextureDescriptor.height": {
		"prefix": "RenderTextureDescriptor.height",
		"body": [
			"height"
		],
		"description": "return:int des: The height of the render texture in pixels."
	}
,
	"RenderTextureDescriptor.memoryless": {
		"prefix": "RenderTextureDescriptor.memoryless",
		"body": [
			"memoryless"
		],
		"description": "return:RenderTextureMemoryless des: The render texture memoryless mode property."
	}
,
	"RenderTextureDescriptor.msaaSamples": {
		"prefix": "RenderTextureDescriptor.msaaSamples",
		"body": [
			"msaaSamples"
		],
		"description": "return:int des: The multisample antialiasing level for the RenderTexture."
	}
,
	"RenderTextureDescriptor.shadowSamplingMode": {
		"prefix": "RenderTextureDescriptor.shadowSamplingMode",
		"body": [
			"shadowSamplingMode"
		],
		"description": "return:Rendering.ShadowSamplingMode des: Determines how the RenderTexture is sampled if it is used as a shadow map."
	}
,
	"RenderTextureDescriptor.sRGB": {
		"prefix": "RenderTextureDescriptor.sRGB",
		"body": [
			"sRGB"
		],
		"description": "return:bool des: This flag causes the render texture uses sRGB read/write conversions."
	}
,
	"RenderTextureDescriptor.useMipMap": {
		"prefix": "RenderTextureDescriptor.useMipMap",
		"body": [
			"useMipMap"
		],
		"description": "return:bool des: Render texture has mipmaps when this flag is set."
	}
,
	"RenderTextureDescriptor.volumeDepth": {
		"prefix": "RenderTextureDescriptor.volumeDepth",
		"body": [
			"volumeDepth"
		],
		"description": "return:int des: Volume extent of a 3D render texture."
	}
,
	"RenderTextureDescriptor.vrUsage": {
		"prefix": "RenderTextureDescriptor.vrUsage",
		"body": [
			"vrUsage"
		],
		"description": "return:VRTextureUsage des: If this RenderTexture is a VR eye texture used in stereoscopic rendering, this property decides what special rendering occurs, if any. Instead of setting this manually, use the value returned by eyeTextureDesc or other VR functions returning a RenderTextureDescriptor."
	}
,
	"RenderTextureDescriptor.width": {
		"prefix": "RenderTextureDescriptor.width",
		"body": [
			"width"
		],
		"description": "return:int des: The width of the render texture in pixels."
	}
,
	"Resolution.height": {
		"prefix": "Resolution.height",
		"body": [
			"height"
		],
		"description": "return:int des: Resolution height in pixels."
	}
,
	"Resolution.refreshRate": {
		"prefix": "Resolution.refreshRate",
		"body": [
			"refreshRate"
		],
		"description": "return:int des: Resolution's vertical refresh rate in Hz."
	}
,
	"Resolution.width": {
		"prefix": "Resolution.width",
		"body": [
			"width"
		],
		"description": "return:int des: Resolution width in pixels."
	}
,
	"Resolution.ToString": {
		"prefix": "Resolution.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns a nicely formatted string of the resolution."
	}
,
	"ResourceRequest.asset": {
		"prefix": "ResourceRequest.asset",
		"body": [
			"asset"
		],
		"description": "return:Object des: Asset object being loaded (Read Only)."
	}
,
	"ResourceRequest.allowSceneActivation": {
		"prefix": "ResourceRequest.allowSceneActivation",
		"body": [
			"allowSceneActivation"
		],
		"description": "return:bool des: Allow scenes to be activated as soon as it is ready."
	}
,
	"ResourceRequest.isDone": {
		"prefix": "ResourceRequest.isDone",
		"body": [
			"isDone"
		],
		"description": "return:bool des: Has the operation finished? (Read Only)"
	}
,
	"ResourceRequest.priority": {
		"prefix": "ResourceRequest.priority",
		"body": [
			"priority"
		],
		"description": "return:int des: Priority lets you tweak in which order async operation calls will be performed."
	}
,
	"ResourceRequest.progress": {
		"prefix": "ResourceRequest.progress",
		"body": [
			"progress"
		],
		"description": "return:float des: What's the operation's progress. (Read Only)"
	}
,
	"Resources.FindObjectsOfTypeAll": {
		"prefix": "Resources.FindObjectsOfTypeAll",
		"body": [
			"Resources.FindObjectsOfTypeAll"
		],
		"description": "public static Object[] FindObjectsOfTypeAll(Type type); public static T[] FindObjectsOfTypeAll(); des: Returns a list of all objects of Type type."
	}
,
	"Resources.Load": {
		"prefix": "Resources.Load",
		"body": [
			"Resources.Load"
		],
		"description": "public static T Load(string path); public static Object Load(string path); public static Object Load(string path, Type systemTypeInstance); des: Loads an asset stored at path in a folder called Resources."
	}
,
	"Resources.LoadAll": {
		"prefix": "Resources.LoadAll",
		"body": [
			"Resources.LoadAll"
		],
		"description": "public static Object[] LoadAll(string path); public static Object[] LoadAll(string path, Type systemTypeInstance); public static T[] LoadAll(string path); des: Loads all assets in a folder or file at path in a Resources folder."
	}
,
	"Resources.LoadAsync": {
		"prefix": "Resources.LoadAsync",
		"body": [
			"Resources.LoadAsync"
		],
		"description": "public static ResourceRequest LoadAsync(string path); public static ResourceRequest LoadAsync(string path, Type type); public static ResourceRequest LoadAsync(string path); des: Asynchronously loads an asset stored at path in a Resources folder."
	}
,
	"Resources.UnloadAsset": {
		"prefix": "Resources.UnloadAsset",
		"body": [
			"Resources.UnloadAsset"
		],
		"description": "public static void UnloadAsset(Object assetToUnload); des: Unloads assetToUnload from memory."
	}
,
	"Resources.UnloadUnusedAssets": {
		"prefix": "Resources.UnloadUnusedAssets",
		"body": [
			"Resources.UnloadUnusedAssets"
		],
		"description": "public static AsyncOperation UnloadUnusedAssets(); des: Unloads assets that are not used."
	}
,
	"Rigidbody.angularDrag": {
		"prefix": "Rigidbody.angularDrag",
		"body": [
			"angularDrag"
		],
		"description": "return:float des: The angular drag of the object."
	}
,
	"Rigidbody.angularVelocity": {
		"prefix": "Rigidbody.angularVelocity",
		"body": [
			"angularVelocity"
		],
		"description": "return:Vector3 des: The angular velocity vector of the rigidbody measured in radians per second."
	}
,
	"Rigidbody.centerOfMass": {
		"prefix": "Rigidbody.centerOfMass",
		"body": [
			"centerOfMass"
		],
		"description": "return:Vector3 des: The center of mass relative to the transform's origin."
	}
,
	"Rigidbody.collisionDetectionMode": {
		"prefix": "Rigidbody.collisionDetectionMode",
		"body": [
			"collisionDetectionMode"
		],
		"description": "return:CollisionDetectionMode des: The Rigidbody's collision detection mode."
	}
,
	"Rigidbody.constraints": {
		"prefix": "Rigidbody.constraints",
		"body": [
			"constraints"
		],
		"description": "return:RigidbodyConstraints des: Controls which degrees of freedom are allowed for the simulation of this Rigidbody."
	}
,
	"Rigidbody.detectCollisions": {
		"prefix": "Rigidbody.detectCollisions",
		"body": [
			"detectCollisions"
		],
		"description": "return:bool des: Should collision detection be enabled? (By default always enabled)."
	}
,
	"Rigidbody.drag": {
		"prefix": "Rigidbody.drag",
		"body": [
			"drag"
		],
		"description": "return:float des: The drag of the object."
	}
,
	"Rigidbody.freezeRotation": {
		"prefix": "Rigidbody.freezeRotation",
		"body": [
			"freezeRotation"
		],
		"description": "return:bool des: Controls whether physics will change the rotation of the object."
	}
,
	"Rigidbody.inertiaTensor": {
		"prefix": "Rigidbody.inertiaTensor",
		"body": [
			"inertiaTensor"
		],
		"description": "return:Vector3 des: The diagonal inertia tensor of mass relative to the center of mass."
	}
,
	"Rigidbody.inertiaTensorRotation": {
		"prefix": "Rigidbody.inertiaTensorRotation",
		"body": [
			"inertiaTensorRotation"
		],
		"description": "return:Quaternion des: The rotation of the inertia tensor."
	}
,
	"Rigidbody.interpolation": {
		"prefix": "Rigidbody.interpolation",
		"body": [
			"interpolation"
		],
		"description": "return:RigidbodyInterpolation des: Interpolation allows you to smooth out the effect of running physics at a fixed frame rate."
	}
,
	"Rigidbody.isKinematic": {
		"prefix": "Rigidbody.isKinematic",
		"body": [
			"isKinematic"
		],
		"description": "return:bool des: Controls whether physics affects the rigidbody."
	}
,
	"Rigidbody.mass": {
		"prefix": "Rigidbody.mass",
		"body": [
			"mass"
		],
		"description": "return:float des: The mass of the rigidbody."
	}
,
	"Rigidbody.maxAngularVelocity": {
		"prefix": "Rigidbody.maxAngularVelocity",
		"body": [
			"maxAngularVelocity"
		],
		"description": "return:float des: The maximimum angular velocity of the rigidbody. (Default 7) range { 0, infinity }."
	}
,
	"Rigidbody.maxDepenetrationVelocity": {
		"prefix": "Rigidbody.maxDepenetrationVelocity",
		"body": [
			"maxDepenetrationVelocity"
		],
		"description": "return:float des: Maximum velocity of a rigidbody when moving out of penetrating state."
	}
,
	"Rigidbody.position": {
		"prefix": "Rigidbody.position",
		"body": [
			"position"
		],
		"description": "return:Vector3 des: The position of the rigidbody."
	}
,
	"Rigidbody.rotation": {
		"prefix": "Rigidbody.rotation",
		"body": [
			"rotation"
		],
		"description": "return:Quaternion des: The rotation of the rigidbody."
	}
,
	"Rigidbody.sleepThreshold": {
		"prefix": "Rigidbody.sleepThreshold",
		"body": [
			"sleepThreshold"
		],
		"description": "return:float des: The mass-normalized energy threshold, below which objects start going to sleep."
	}
,
	"Rigidbody.solverIterations": {
		"prefix": "Rigidbody.solverIterations",
		"body": [
			"solverIterations"
		],
		"description": "return:int des: The solverIterations determines how accurately Rigidbody joints and collision contacts are resolved. Overrides Physics.defaultSolverIterations. Must be positive."
	}
,
	"Rigidbody.solverVelocityIterations": {
		"prefix": "Rigidbody.solverVelocityIterations",
		"body": [
			"solverVelocityIterations"
		],
		"description": "return:int des: The solverVelocityIterations affects how how accurately Rigidbody joints and collision contacts are resolved. Overrides Physics.defaultSolverVelocityIterations. Must be positive."
	}
,
	"Rigidbody.useGravity": {
		"prefix": "Rigidbody.useGravity",
		"body": [
			"useGravity"
		],
		"description": "return:bool des: Controls whether gravity affects this rigidbody."
	}
,
	"Rigidbody.velocity": {
		"prefix": "Rigidbody.velocity",
		"body": [
			"velocity"
		],
		"description": "return:Vector3 des: The velocity vector of the rigidbody."
	}
,
	"Rigidbody.worldCenterOfMass": {
		"prefix": "Rigidbody.worldCenterOfMass",
		"body": [
			"worldCenterOfMass"
		],
		"description": "return:Vector3 des: The center of mass of the rigidbody in world space (Read Only)."
	}
,
	"Rigidbody.AddExplosionForce": {
		"prefix": "Rigidbody.AddExplosionForce",
		"body": [
			"AddExplosionForce($1)"
		],
		"description": "public void AddExplosionForce(float explosionForce, Vector3 explosionPosition, float explosionRadius, float upwardsModifier = 0.0f, ForceMode mode = ForceMode.Force)); des: Applies a force to a rigidbody that simulates explosion effects."
	}
,
	"Rigidbody.AddForce": {
		"prefix": "Rigidbody.AddForce",
		"body": [
			"AddForce($1)"
		],
		"description": "public void AddForce(Vector3 force, ForceMode mode = ForceMode.Force); public void AddForce(float x, float y, float z, ForceMode mode = ForceMode.Force); des: Adds a force to the Rigidbody."
	}
,
	"Rigidbody.AddForceAtPosition": {
		"prefix": "Rigidbody.AddForceAtPosition",
		"body": [
			"AddForceAtPosition($1)"
		],
		"description": "public void AddForceAtPosition(Vector3 force, Vector3 position, ForceMode mode = ForceMode.Force); des: Applies force at position. As a result this will apply a torque and force on the object."
	}
,
	"Rigidbody.AddRelativeForce": {
		"prefix": "Rigidbody.AddRelativeForce",
		"body": [
			"AddRelativeForce($1)"
		],
		"description": "public void AddRelativeForce(Vector3 force, ForceMode mode = ForceMode.Force); public void AddRelativeForce(float x, float y, float z, ForceMode mode = ForceMode.Force); des: Adds a force to the rigidbody relative to its coordinate system."
	}
,
	"Rigidbody.AddRelativeTorque": {
		"prefix": "Rigidbody.AddRelativeTorque",
		"body": [
			"AddRelativeTorque($1)"
		],
		"description": "public void AddRelativeTorque(Vector3 torque, ForceMode mode = ForceMode.Force); public void AddRelativeTorque(float x, float y, float z, ForceMode mode = ForceMode.Force); des: Adds a torque to the rigidbody relative to its coordinate system."
	}
,
	"Rigidbody.AddTorque": {
		"prefix": "Rigidbody.AddTorque",
		"body": [
			"AddTorque($1)"
		],
		"description": "public void AddTorque(Vector3 torque, ForceMode mode = ForceMode.Force); public void AddTorque(float x, float y, float z, ForceMode mode = ForceMode.Force); des: Adds a torque to the rigidbody."
	}
,
	"Rigidbody.ClosestPointOnBounds": {
		"prefix": "Rigidbody.ClosestPointOnBounds",
		"body": [
			"ClosestPointOnBounds($1)"
		],
		"description": "public Vector3 ClosestPointOnBounds(Vector3 position); des: The closest point to the bounding box of the attached colliders."
	}
,
	"Rigidbody.GetPointVelocity": {
		"prefix": "Rigidbody.GetPointVelocity",
		"body": [
			"GetPointVelocity($1)"
		],
		"description": "public Vector3 GetPointVelocity(Vector3 worldPoint); des: The velocity of the rigidbody at the point worldPoint in global space."
	}
,
	"Rigidbody.GetRelativePointVelocity": {
		"prefix": "Rigidbody.GetRelativePointVelocity",
		"body": [
			"GetRelativePointVelocity($1)"
		],
		"description": "public Vector3 GetRelativePointVelocity(Vector3 relativePoint); des: The velocity relative to the rigidbody at the point relativePoint."
	}
,
	"Rigidbody.IsSleeping": {
		"prefix": "Rigidbody.IsSleeping",
		"body": [
			"IsSleeping($1)"
		],
		"description": "public bool IsSleeping(); des: Is the rigidbody sleeping?"
	}
,
	"Rigidbody.MovePosition": {
		"prefix": "Rigidbody.MovePosition",
		"body": [
			"MovePosition($1)"
		],
		"description": "public void MovePosition(Vector3 position); des: Moves the rigidbody to position."
	}
,
	"Rigidbody.MoveRotation": {
		"prefix": "Rigidbody.MoveRotation",
		"body": [
			"MoveRotation($1)"
		],
		"description": "public void MoveRotation(Quaternion rot); des: Rotates the rigidbody to rotation."
	}
,
	"Rigidbody.ResetCenterOfMass": {
		"prefix": "Rigidbody.ResetCenterOfMass",
		"body": [
			"ResetCenterOfMass($1)"
		],
		"description": "public void ResetCenterOfMass(); des: Reset the center of mass of the rigidbody."
	}
,
	"Rigidbody.ResetInertiaTensor": {
		"prefix": "Rigidbody.ResetInertiaTensor",
		"body": [
			"ResetInertiaTensor($1)"
		],
		"description": "public void ResetInertiaTensor(); des: Reset the inertia tensor value and rotation."
	}
,
	"Rigidbody.SetDensity": {
		"prefix": "Rigidbody.SetDensity",
		"body": [
			"SetDensity($1)"
		],
		"description": "public void SetDensity(float density); des: Sets the mass based on the attached colliders assuming a constant density."
	}
,
	"Rigidbody.Sleep": {
		"prefix": "Rigidbody.Sleep",
		"body": [
			"Sleep($1)"
		],
		"description": "public void Sleep(); des: Forces a rigidbody to sleep at least one frame."
	}
,
	"Rigidbody.SweepTest": {
		"prefix": "Rigidbody.SweepTest",
		"body": [
			"SweepTest($1)"
		],
		"description": "public bool SweepTest(Vector3 direction, out RaycastHit hitInfo, float maxDistance = Mathf.Infinity, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); des: Tests if a rigidbody would collide with anything, if it was moved through the scene."
	}
,
	"Rigidbody.SweepTestAll": {
		"prefix": "Rigidbody.SweepTestAll",
		"body": [
			"SweepTestAll($1)"
		],
		"description": "public RaycastHit[] SweepTestAll(Vector3 direction, float maxDistance = Mathf.Infinity, QueryTriggerInteraction queryTriggerInteraction = QueryTriggerInteraction.UseGlobal); des: Like Rigidbody.SweepTest, but returns all hits."
	}
,
	"Rigidbody.WakeUp": {
		"prefix": "Rigidbody.WakeUp",
		"body": [
			"WakeUp($1)"
		],
		"description": "public void WakeUp(); des: Forces a rigidbody to wake up."
	}
,
	"Rigidbody.OnCollisionEnter": {
		"prefix": "Rigidbody.OnCollisionEnter",
		"body": [
			"OnCollisionEnter"
		],
		"description": "OnCollisionEnter is called when this collider/rigidbody has begun touching another rigidbody/collider."
	}
,
	"Rigidbody.OnCollisionExit": {
		"prefix": "Rigidbody.OnCollisionExit",
		"body": [
			"OnCollisionExit"
		],
		"description": "OnCollisionEnter is called when this collider/rigidbody has stopped touching another rigidbody/collider."
	}
,
	"Rigidbody.OnCollisionStay": {
		"prefix": "Rigidbody.OnCollisionStay",
		"body": [
			"OnCollisionStay"
		],
		"description": "OnCollisionStay is called once per frame for every collider/rigidbody that is touching rigidbody/collider."
	}
,
	"Rigidbody.gameObject": {
		"prefix": "Rigidbody.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"Rigidbody.tag": {
		"prefix": "Rigidbody.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"Rigidbody.transform": {
		"prefix": "Rigidbody.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"Rigidbody.hideFlags": {
		"prefix": "Rigidbody.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Rigidbody.name": {
		"prefix": "Rigidbody.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Rigidbody.BroadcastMessage": {
		"prefix": "Rigidbody.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"Rigidbody.CompareTag": {
		"prefix": "Rigidbody.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"Rigidbody.GetComponent": {
		"prefix": "Rigidbody.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"Rigidbody.GetComponentInChildren": {
		"prefix": "Rigidbody.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"Rigidbody.GetComponentInParent": {
		"prefix": "Rigidbody.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"Rigidbody.GetComponents": {
		"prefix": "Rigidbody.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"Rigidbody.GetComponentsInChildren": {
		"prefix": "Rigidbody.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"Rigidbody.GetComponentsInParent": {
		"prefix": "Rigidbody.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"Rigidbody.SendMessage": {
		"prefix": "Rigidbody.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"Rigidbody.SendMessageUpwards": {
		"prefix": "Rigidbody.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"Rigidbody.GetInstanceID": {
		"prefix": "Rigidbody.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Rigidbody.ToString": {
		"prefix": "Rigidbody.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Rigidbody.Destroy": {
		"prefix": "Rigidbody.Destroy",
		"body": [
			"Rigidbody.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Rigidbody.DestroyImmediate": {
		"prefix": "Rigidbody.DestroyImmediate",
		"body": [
			"Rigidbody.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Rigidbody.DontDestroyOnLoad": {
		"prefix": "Rigidbody.DontDestroyOnLoad",
		"body": [
			"Rigidbody.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Rigidbody.FindObjectOfType": {
		"prefix": "Rigidbody.FindObjectOfType",
		"body": [
			"Rigidbody.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Rigidbody.FindObjectsOfType": {
		"prefix": "Rigidbody.FindObjectsOfType",
		"body": [
			"Rigidbody.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Rigidbody.Instantiate": {
		"prefix": "Rigidbody.Instantiate",
		"body": [
			"Rigidbody.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"Rigidbody2D.angularDrag": {
		"prefix": "Rigidbody2D.angularDrag",
		"body": [
			"angularDrag"
		],
		"description": "return:float des: Coefficient of angular drag."
	}
,
	"Rigidbody2D.angularVelocity": {
		"prefix": "Rigidbody2D.angularVelocity",
		"body": [
			"angularVelocity"
		],
		"description": "return:float des: Angular velocity in degrees per second."
	}
,
	"Rigidbody2D.attachedColliderCount": {
		"prefix": "Rigidbody2D.attachedColliderCount",
		"body": [
			"attachedColliderCount"
		],
		"description": "return:int des: Returns the number of Collider2D attached to this Rigidbody2D."
	}
,
	"Rigidbody2D.bodyType": {
		"prefix": "Rigidbody2D.bodyType",
		"body": [
			"bodyType"
		],
		"description": "return:Rigid2D des: The physical behaviour type of the Rigidbody2D."
	}
,
	"Rigidbody2D.centerOfMass": {
		"prefix": "Rigidbody2D.centerOfMass",
		"body": [
			"centerOfMass"
		],
		"description": "return:Vector2 des: The center of mass of the rigidBody in local space."
	}
,
	"Rigidbody2D.collisionDetectionMode": {
		"prefix": "Rigidbody2D.collisionDetectionMode",
		"body": [
			"collisionDetectionMode"
		],
		"description": "return:CollisionDetectionMode2D des: The method used by the physics engine to check if two objects have collided."
	}
,
	"Rigidbody2D.constraints": {
		"prefix": "Rigidbody2D.constraints",
		"body": [
			"constraints"
		],
		"description": "return:RigidbodyConstraints2D des: Controls which degrees of freedom are allowed for the simulation of this Rigidbody2D."
	}
,
	"Rigidbody2D.drag": {
		"prefix": "Rigidbody2D.drag",
		"body": [
			"drag"
		],
		"description": "return:float des: Coefficient of drag."
	}
,
	"Rigidbody2D.freezeRotation": {
		"prefix": "Rigidbody2D.freezeRotation",
		"body": [
			"freezeRotation"
		],
		"description": "return:bool des: Controls whether physics will change the rotation of the object."
	}
,
	"Rigidbody2D.gravityScale": {
		"prefix": "Rigidbody2D.gravityScale",
		"body": [
			"gravityScale"
		],
		"description": "return:float des: The degree to which this object is affected by gravity."
	}
,
	"Rigidbody2D.inertia": {
		"prefix": "Rigidbody2D.inertia",
		"body": [
			"inertia"
		],
		"description": "return:float des: The rigidBody rotational inertia."
	}
,
	"Rigidbody2D.interpolation": {
		"prefix": "Rigidbody2D.interpolation",
		"body": [
			"interpolation"
		],
		"description": "return:RigidbodyInterpolation2D des: Physics interpolation used between updates."
	}
,
	"Rigidbody2D.isKinematic": {
		"prefix": "Rigidbody2D.isKinematic",
		"body": [
			"isKinematic"
		],
		"description": "return:bool des: Should this rigidbody be taken out of physics control?"
	}
,
	"Rigidbody2D.mass": {
		"prefix": "Rigidbody2D.mass",
		"body": [
			"mass"
		],
		"description": "return:float des: Mass of the Rigidbody."
	}
,
	"Rigidbody2D.position": {
		"prefix": "Rigidbody2D.position",
		"body": [
			"position"
		],
		"description": "return:Vector2 des: The position of the rigidbody."
	}
,
	"Rigidbody2D.rotation": {
		"prefix": "Rigidbody2D.rotation",
		"body": [
			"rotation"
		],
		"description": "return:float des: The rotation of the rigidbody."
	}
,
	"Rigidbody2D.sharedMaterial": {
		"prefix": "Rigidbody2D.sharedMaterial",
		"body": [
			"sharedMaterial"
		],
		"description": "return:PhysicsMaterial2D des: The PhysicsMaterial2D that is applied to all Collider2D attached to this Rigidbody2D."
	}
,
	"Rigidbody2D.simulated": {
		"prefix": "Rigidbody2D.simulated",
		"body": [
			"simulated"
		],
		"description": "return:bool des: Indicates whether the rigid body should be simulated or not by the physics system."
	}
,
	"Rigidbody2D.sleepMode": {
		"prefix": "Rigidbody2D.sleepMode",
		"body": [
			"sleepMode"
		],
		"description": "return:RigidbodySleepMode2D des: The sleep state that the rigidbody will initially be in."
	}
,
	"Rigidbody2D.useAutoMass": {
		"prefix": "Rigidbody2D.useAutoMass",
		"body": [
			"useAutoMass"
		],
		"description": "return:bool des: Should the total rigid-body mass be automatically calculated from the [[Collider2D.density]] of attached colliders?"
	}
,
	"Rigidbody2D.useFullKinematicContacts": {
		"prefix": "Rigidbody2D.useFullKinematicContacts",
		"body": [
			"useFullKinematicContacts"
		],
		"description": "return:bool des: Should kinematic/kinematic and kinematic/static collisions be allowed?"
	}
,
	"Rigidbody2D.velocity": {
		"prefix": "Rigidbody2D.velocity",
		"body": [
			"velocity"
		],
		"description": "return:Vector2 des: Linear velocity of the rigidbody."
	}
,
	"Rigidbody2D.worldCenterOfMass": {
		"prefix": "Rigidbody2D.worldCenterOfMass",
		"body": [
			"worldCenterOfMass"
		],
		"description": "return:Vector2 des: Gets the center of mass of the rigidBody in global space."
	}
,
	"Rigidbody2D.AddForce": {
		"prefix": "Rigidbody2D.AddForce",
		"body": [
			"AddForce($1)"
		],
		"description": "public void AddForce(Vector2 force, ForceMode2D mode = ForceMode2D.Force); des: Apply a force to the rigidbody."
	}
,
	"Rigidbody2D.AddForceAtPosition": {
		"prefix": "Rigidbody2D.AddForceAtPosition",
		"body": [
			"AddForceAtPosition($1)"
		],
		"description": "public void AddForceAtPosition(Vector2 force, Vector2 position, ForceMode2D mode = ForceMode2D.Force); des: Apply a force at a given position in space."
	}
,
	"Rigidbody2D.AddRelativeForce": {
		"prefix": "Rigidbody2D.AddRelativeForce",
		"body": [
			"AddRelativeForce($1)"
		],
		"description": "public void AddRelativeForce(Vector2 relativeForce, ForceMode2D mode = ForceMode2D.Force); des: Adds a force to the rigidbody2D relative to its coordinate system."
	}
,
	"Rigidbody2D.AddTorque": {
		"prefix": "Rigidbody2D.AddTorque",
		"body": [
			"AddTorque($1)"
		],
		"description": "public void AddTorque(float torque, ForceMode2D mode = ForceMode2D.Force); des: Apply a torque at the rigidbody's centre of mass."
	}
,
	"Rigidbody2D.Cast": {
		"prefix": "Rigidbody2D.Cast",
		"body": [
			"Cast($1)"
		],
		"description": "public int Cast(Vector2 direction, RaycastHit2D[] results, float distance = Mathf.Infinity); public int Cast(Vector2 direction, ContactFilter2D contactFilter, RaycastHit2D[] results, float distance = Mathf.Infinity); des: All the Collider2D shapes attached to the Rigidbody2D are cast into the scene starting at each collider position ignoring the colliders attached to the same Rigidbody2D."
	}
,
	"Rigidbody2D.Distance": {
		"prefix": "Rigidbody2D.Distance",
		"body": [
			"Distance($1)"
		],
		"description": "public ColliderDistance2D Distance(Collider2D collider); des: Calculates the minimum distance of this collider against all Collider2D attached to this Rigidbody2D."
	}
,
	"Rigidbody2D.GetAttachedColliders": {
		"prefix": "Rigidbody2D.GetAttachedColliders",
		"body": [
			"GetAttachedColliders($1)"
		],
		"description": "public int GetAttachedColliders(out Collider2D[] results); des: Returns all Collider2D that are attached to this Rigidbody2D."
	}
,
	"Rigidbody2D.GetContacts": {
		"prefix": "Rigidbody2D.GetContacts",
		"body": [
			"GetContacts($1)"
		],
		"description": "public int GetContacts(ContactPoint2D[] contacts); public int GetContacts(Collider2D[] colliders); public int GetContacts(ContactFilter2D contactFilter, ContactPoint2D[] contacts); public int GetContacts(ContactFilter2D contactFilter, Collider2D[] colliders); des: Retrieves all contact points for all of the collider(s) attached to this rigidbody."
	}
,
	"Rigidbody2D.GetPoint": {
		"prefix": "Rigidbody2D.GetPoint",
		"body": [
			"GetPoint($1)"
		],
		"description": "public Vector2 GetPoint(Vector2 point); des: Get a local space point given the point point in rigidBody global space."
	}
,
	"Rigidbody2D.GetPointVelocity": {
		"prefix": "Rigidbody2D.GetPointVelocity",
		"body": [
			"GetPointVelocity($1)"
		],
		"description": "public Vector2 GetPointVelocity(Vector2 point); des: The velocity of the rigidbody at the point Point in global space."
	}
,
	"Rigidbody2D.GetRelativePoint": {
		"prefix": "Rigidbody2D.GetRelativePoint",
		"body": [
			"GetRelativePoint($1)"
		],
		"description": "public Vector2 GetRelativePoint(Vector2 relativePoint); des: Get a global space point given the point relativePoint in rigidBody local space."
	}
,
	"Rigidbody2D.GetRelativePointVelocity": {
		"prefix": "Rigidbody2D.GetRelativePointVelocity",
		"body": [
			"GetRelativePointVelocity($1)"
		],
		"description": "public Vector2 GetRelativePointVelocity(Vector2 relativePoint); des: The velocity of the rigidbody at the point Point in local space."
	}
,
	"Rigidbody2D.GetRelativeVector": {
		"prefix": "Rigidbody2D.GetRelativeVector",
		"body": [
			"GetRelativeVector($1)"
		],
		"description": "public Vector2 GetRelativeVector(Vector2 relativeVector); des: Get a global space vector given the vector relativeVector in rigidBody local space."
	}
,
	"Rigidbody2D.GetVector": {
		"prefix": "Rigidbody2D.GetVector",
		"body": [
			"GetVector($1)"
		],
		"description": "public Vector2 GetVector(Vector2 vector); des: Get a local space vector given the vector vector in rigidBody global space."
	}
,
	"Rigidbody2D.IsAwake": {
		"prefix": "Rigidbody2D.IsAwake",
		"body": [
			"IsAwake($1)"
		],
		"description": "public bool IsAwake(); des: Is the rigidbody \"awake\"?"
	}
,
	"Rigidbody2D.IsSleeping": {
		"prefix": "Rigidbody2D.IsSleeping",
		"body": [
			"IsSleeping($1)"
		],
		"description": "public bool IsSleeping(); des: Is the rigidbody \"sleeping\"?"
	}
,
	"Rigidbody2D.IsTouching": {
		"prefix": "Rigidbody2D.IsTouching",
		"body": [
			"IsTouching($1)"
		],
		"description": "public bool IsTouching(Collider2D collider); public bool IsTouching(Collider2D collider, ContactFilter2D contactFilter); public bool IsTouching(ContactFilter2D contactFilter); des: Checks whether the collider is touching any of the collider(s) attached to this rigidbody or not."
	}
,
	"Rigidbody2D.IsTouchingLayers": {
		"prefix": "Rigidbody2D.IsTouchingLayers",
		"body": [
			"IsTouchingLayers($1)"
		],
		"description": "public bool IsTouchingLayers(int layerMask = Physics2D.AllLayers); des: Checks whether any of the collider(s) attached to this rigidbody are touching any colliders on the specified layerMask or not."
	}
,
	"Rigidbody2D.MovePosition": {
		"prefix": "Rigidbody2D.MovePosition",
		"body": [
			"MovePosition($1)"
		],
		"description": "public void MovePosition(Vector2 position); des: Moves the rigidbody to position."
	}
,
	"Rigidbody2D.MoveRotation": {
		"prefix": "Rigidbody2D.MoveRotation",
		"body": [
			"MoveRotation($1)"
		],
		"description": "public void MoveRotation(float angle); des: Rotates the rigidbody to angle (given in degrees)."
	}
,
	"Rigidbody2D.OverlapCollider": {
		"prefix": "Rigidbody2D.OverlapCollider",
		"body": [
			"OverlapCollider($1)"
		],
		"description": "public int OverlapCollider(ContactFilter2D contactFilter, out Collider2D[] results); des: Get a list of all colliders that overlap all colliders attached to this Rigidbody2D."
	}
,
	"Rigidbody2D.OverlapPoint": {
		"prefix": "Rigidbody2D.OverlapPoint",
		"body": [
			"OverlapPoint($1)"
		],
		"description": "public bool OverlapPoint(Vector2 point); des: Check if any of the Rigidbody2D colliders overlap a point in space."
	}
,
	"Rigidbody2D.Sleep": {
		"prefix": "Rigidbody2D.Sleep",
		"body": [
			"Sleep($1)"
		],
		"description": "public void Sleep(); des: Make the rigidbody \"sleep\"."
	}
,
	"Rigidbody2D.WakeUp": {
		"prefix": "Rigidbody2D.WakeUp",
		"body": [
			"WakeUp($1)"
		],
		"description": "public void WakeUp(); des: Disables the \"sleeping\" state of a rigidbody."
	}
,
	"Rigidbody2D.gameObject": {
		"prefix": "Rigidbody2D.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"Rigidbody2D.tag": {
		"prefix": "Rigidbody2D.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"Rigidbody2D.transform": {
		"prefix": "Rigidbody2D.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"Rigidbody2D.hideFlags": {
		"prefix": "Rigidbody2D.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Rigidbody2D.name": {
		"prefix": "Rigidbody2D.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Rigidbody2D.BroadcastMessage": {
		"prefix": "Rigidbody2D.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"Rigidbody2D.CompareTag": {
		"prefix": "Rigidbody2D.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"Rigidbody2D.GetComponent": {
		"prefix": "Rigidbody2D.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"Rigidbody2D.GetComponentInChildren": {
		"prefix": "Rigidbody2D.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"Rigidbody2D.GetComponentInParent": {
		"prefix": "Rigidbody2D.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"Rigidbody2D.GetComponents": {
		"prefix": "Rigidbody2D.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"Rigidbody2D.GetComponentsInChildren": {
		"prefix": "Rigidbody2D.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"Rigidbody2D.GetComponentsInParent": {
		"prefix": "Rigidbody2D.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"Rigidbody2D.SendMessage": {
		"prefix": "Rigidbody2D.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"Rigidbody2D.SendMessageUpwards": {
		"prefix": "Rigidbody2D.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"Rigidbody2D.GetInstanceID": {
		"prefix": "Rigidbody2D.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Rigidbody2D.ToString": {
		"prefix": "Rigidbody2D.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Rigidbody2D.Destroy": {
		"prefix": "Rigidbody2D.Destroy",
		"body": [
			"Rigidbody2D.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Rigidbody2D.DestroyImmediate": {
		"prefix": "Rigidbody2D.DestroyImmediate",
		"body": [
			"Rigidbody2D.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Rigidbody2D.DontDestroyOnLoad": {
		"prefix": "Rigidbody2D.DontDestroyOnLoad",
		"body": [
			"Rigidbody2D.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Rigidbody2D.FindObjectOfType": {
		"prefix": "Rigidbody2D.FindObjectOfType",
		"body": [
			"Rigidbody2D.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Rigidbody2D.FindObjectsOfType": {
		"prefix": "Rigidbody2D.FindObjectsOfType",
		"body": [
			"Rigidbody2D.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Rigidbody2D.Instantiate": {
		"prefix": "Rigidbody2D.Instantiate",
		"body": [
			"Rigidbody2D.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"RuntimeAnimatorController.animationClips": {
		"prefix": "RuntimeAnimatorController.animationClips",
		"body": [
			"animationClips"
		],
		"description": "return:AnimationClip[] des: Retrieves all AnimationClip used by the controller."
	}
,
	"RuntimeAnimatorController.hideFlags": {
		"prefix": "RuntimeAnimatorController.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"RuntimeAnimatorController.name": {
		"prefix": "RuntimeAnimatorController.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"RuntimeAnimatorController.GetInstanceID": {
		"prefix": "RuntimeAnimatorController.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"RuntimeAnimatorController.ToString": {
		"prefix": "RuntimeAnimatorController.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"RuntimeAnimatorController.Destroy": {
		"prefix": "RuntimeAnimatorController.Destroy",
		"body": [
			"RuntimeAnimatorController.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"RuntimeAnimatorController.DestroyImmediate": {
		"prefix": "RuntimeAnimatorController.DestroyImmediate",
		"body": [
			"RuntimeAnimatorController.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"RuntimeAnimatorController.DontDestroyOnLoad": {
		"prefix": "RuntimeAnimatorController.DontDestroyOnLoad",
		"body": [
			"RuntimeAnimatorController.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"RuntimeAnimatorController.FindObjectOfType": {
		"prefix": "RuntimeAnimatorController.FindObjectOfType",
		"body": [
			"RuntimeAnimatorController.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"RuntimeAnimatorController.FindObjectsOfType": {
		"prefix": "RuntimeAnimatorController.FindObjectsOfType",
		"body": [
			"RuntimeAnimatorController.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"RuntimeAnimatorController.Instantiate": {
		"prefix": "RuntimeAnimatorController.Instantiate",
		"body": [
			"RuntimeAnimatorController.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"ScalableBufferManager.ResizeBuffers": {
		"prefix": "ScalableBufferManager.ResizeBuffers",
		"body": [
			"ScalableBufferManager.ResizeBuffers"
		],
		"description": "public static void ResizeBuffers(float widthScale, float heightScale); des: Function to resize all buffers marked as DynamicallyScalable."
	}
,
	"Screen.SetResolution": {
		"prefix": "Screen.SetResolution",
		"body": [
			"Screen.SetResolution"
		],
		"description": "public static void SetResolution(int width, int height, bool fullscreen); public static void SetResolution(int width, int height, bool fullscreen, int preferredRefreshRate = 0); public static void SetResolution(int width, int height, FullScreenMode fullscreenMode, int preferredRefreshRate = 0); des: Switches the screen resolution."
	}
,
	"ScreenCapture.CaptureScreenshot": {
		"prefix": "ScreenCapture.CaptureScreenshot",
		"body": [
			"ScreenCapture.CaptureScreenshot"
		],
		"description": "public static void CaptureScreenshot(string filename, int superSize); public static void CaptureScreenshot(string filename, ScreenCapture.StereoScreenCaptureMode stereoCaptureMode); des: Captures a screenshot at path filename as a PNG file."
	}
,
	"ScreenCapture.CaptureScreenshotAsTexture": {
		"prefix": "ScreenCapture.CaptureScreenshotAsTexture",
		"body": [
			"ScreenCapture.CaptureScreenshotAsTexture"
		],
		"description": "public static Texture2D CaptureScreenshotAsTexture(int superSize); public static Texture2D CaptureScreenshotAsTexture(ScreenCapture.StereoScreenCaptureMode stereoCaptureMode); des: Captures a screenshot of the game view into a Texture2D object."
	}
,
	"ScreenCapture.StereoScreenCaptureMode.LeftEye": {
		"prefix": "ScreenCapture.StereoScreenCaptureMode.LeftEye",
		"body": [
			"LeftEye"
		],
		"description": "return: des: The Left Eye is captured. This is the default setting for the CaptureScreenshot method."
	}
,
	"ScreenCapture.StereoScreenCaptureMode.RightEye": {
		"prefix": "ScreenCapture.StereoScreenCaptureMode.RightEye",
		"body": [
			"RightEye"
		],
		"description": "return: des: The Right Eye is captured."
	}
,
	"ScreenCapture.StereoScreenCaptureMode.BothEyes": {
		"prefix": "ScreenCapture.StereoScreenCaptureMode.BothEyes",
		"body": [
			"BothEyes"
		],
		"description": "return: des: Both the left and right eyes are captured and composited into one image."
	}
,
	"ScriptableObject.CreateInstance": {
		"prefix": "ScriptableObject.CreateInstance",
		"body": [
			"ScriptableObject.CreateInstance"
		],
		"description": "public static ScriptableObject CreateInstance(string className); public static ScriptableObject CreateInstance(Type type); public static T CreateInstance(); des: Creates an instance of a scriptable object."
	}
,
	"ScriptableObject.Awake": {
		"prefix": "ScriptableObject.Awake",
		"body": [
			"Awake"
		],
		"description": "This function is called when the ScriptableObject script is started."
	}
,
	"ScriptableObject.OnDestroy": {
		"prefix": "ScriptableObject.OnDestroy",
		"body": [
			"OnDestroy"
		],
		"description": "This function is called when the scriptable object will be destroyed."
	}
,
	"ScriptableObject.OnDisable": {
		"prefix": "ScriptableObject.OnDisable",
		"body": [
			"OnDisable"
		],
		"description": "This function is called when the scriptable object goes out of scope."
	}
,
	"ScriptableObject.OnEnable": {
		"prefix": "ScriptableObject.OnEnable",
		"body": [
			"OnEnable"
		],
		"description": "This function is called when the object is loaded."
	}
,
	"ScriptableObject.hideFlags": {
		"prefix": "ScriptableObject.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"ScriptableObject.name": {
		"prefix": "ScriptableObject.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"ScriptableObject.GetInstanceID": {
		"prefix": "ScriptableObject.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"ScriptableObject.ToString": {
		"prefix": "ScriptableObject.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"ScriptableObject.Destroy": {
		"prefix": "ScriptableObject.Destroy",
		"body": [
			"ScriptableObject.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"ScriptableObject.DestroyImmediate": {
		"prefix": "ScriptableObject.DestroyImmediate",
		"body": [
			"ScriptableObject.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"ScriptableObject.DontDestroyOnLoad": {
		"prefix": "ScriptableObject.DontDestroyOnLoad",
		"body": [
			"ScriptableObject.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"ScriptableObject.FindObjectOfType": {
		"prefix": "ScriptableObject.FindObjectOfType",
		"body": [
			"ScriptableObject.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"ScriptableObject.FindObjectsOfType": {
		"prefix": "ScriptableObject.FindObjectsOfType",
		"body": [
			"ScriptableObject.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"ScriptableObject.Instantiate": {
		"prefix": "ScriptableObject.Instantiate",
		"body": [
			"ScriptableObject.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"Shader.isSupported": {
		"prefix": "Shader.isSupported",
		"body": [
			"isSupported"
		],
		"description": "return:bool des: Can this shader run on the end-users graphics card? (Read Only)"
	}
,
	"Shader.maximumLOD": {
		"prefix": "Shader.maximumLOD",
		"body": [
			"maximumLOD"
		],
		"description": "return:int des: Shader LOD level for this shader."
	}
,
	"Shader.renderQueue": {
		"prefix": "Shader.renderQueue",
		"body": [
			"renderQueue"
		],
		"description": "return:int des: Render queue of this shader. (Read Only)"
	}
,
	"Shader.DisableKeyword": {
		"prefix": "Shader.DisableKeyword",
		"body": [
			"Shader.DisableKeyword"
		],
		"description": "public static void DisableKeyword(string keyword); des: Unset a global shader keyword."
	}
,
	"Shader.EnableKeyword": {
		"prefix": "Shader.EnableKeyword",
		"body": [
			"Shader.EnableKeyword"
		],
		"description": "public static void EnableKeyword(string keyword); des: Set a global shader keyword."
	}
,
	"Shader.Find": {
		"prefix": "Shader.Find",
		"body": [
			"Shader.Find"
		],
		"description": "public static Shader Find(string name); des: Finds a shader with the given name."
	}
,
	"Shader.GetGlobalColor": {
		"prefix": "Shader.GetGlobalColor",
		"body": [
			"Shader.GetGlobalColor"
		],
		"description": "public static Color GetGlobalColor(string name); public static Color GetGlobalColor(int nameID); des: Gets a global color property for all shaders previously set using SetGlobalColor."
	}
,
	"Shader.GetGlobalFloat": {
		"prefix": "Shader.GetGlobalFloat",
		"body": [
			"Shader.GetGlobalFloat"
		],
		"description": "public static float GetGlobalFloat(string name); public static float GetGlobalFloat(int nameID); des: Gets a global float property for all shaders previously set using SetGlobalFloat."
	}
,
	"Shader.GetGlobalFloatArray": {
		"prefix": "Shader.GetGlobalFloatArray",
		"body": [
			"Shader.GetGlobalFloatArray"
		],
		"description": "public static float[] GetGlobalFloatArray(string name); public static float[] GetGlobalFloatArray(int nameID); public static void GetGlobalFloatArray(string name, List<float> values); public static void GetGlobalFloatArray(int nameID, List<float> values); des: Gets a global float array for all shaders previously set using SetGlobalFloatArray."
	}
,
	"Shader.GetGlobalInt": {
		"prefix": "Shader.GetGlobalInt",
		"body": [
			"Shader.GetGlobalInt"
		],
		"description": "public static int GetGlobalInt(string name); public static int GetGlobalInt(int nameID); des: Gets a global int property for all shaders previously set using SetGlobalInt."
	}
,
	"Shader.GetGlobalMatrix": {
		"prefix": "Shader.GetGlobalMatrix",
		"body": [
			"Shader.GetGlobalMatrix"
		],
		"description": "public static Matrix4x4 GetGlobalMatrix(string name); public static Matrix4x4 GetGlobalMatrix(int nameID); des: Gets a global matrix property for all shaders previously set using SetGlobalMatrix."
	}
,
	"Shader.GetGlobalMatrixArray": {
		"prefix": "Shader.GetGlobalMatrixArray",
		"body": [
			"Shader.GetGlobalMatrixArray"
		],
		"description": "public static Matrix4x4[] GetGlobalMatrixArray(string name); public static Matrix4x4[] GetGlobalMatrixArray(int nameID); public static void GetGlobalMatrixArray(string name, List<Matrix4x4> values); public static void GetGlobalMatrixArray(int nameID, List<Matrix4x4> values); des: Gets a global matrix array for all shaders previously set using SetGlobalMatrixArray."
	}
,
	"Shader.GetGlobalTexture": {
		"prefix": "Shader.GetGlobalTexture",
		"body": [
			"Shader.GetGlobalTexture"
		],
		"description": "public static Texture GetGlobalTexture(string name); public static Texture GetGlobalTexture(int nameID); des: Gets a global texture property for all shaders previously set using SetGlobalTexture."
	}
,
	"Shader.GetGlobalVector": {
		"prefix": "Shader.GetGlobalVector",
		"body": [
			"Shader.GetGlobalVector"
		],
		"description": "public static Vector4 GetGlobalVector(string name); public static Vector4 GetGlobalVector(int nameID); des: Gets a global vector property for all shaders previously set using SetGlobalVector."
	}
,
	"Shader.GetGlobalVectorArray": {
		"prefix": "Shader.GetGlobalVectorArray",
		"body": [
			"Shader.GetGlobalVectorArray"
		],
		"description": "public static Vector4[] GetGlobalVectorArray(string name); public static Vector4[] GetGlobalVectorArray(int nameID); public static void GetGlobalVectorArray(string name, List<Vector4> values); public static void GetGlobalVectorArray(int nameID, List<Vector4> values); des: Gets a global vector array for all shaders previously set using SetGlobalVectorArray."
	}
,
	"Shader.IsKeywordEnabled": {
		"prefix": "Shader.IsKeywordEnabled",
		"body": [
			"Shader.IsKeywordEnabled"
		],
		"description": "public static bool IsKeywordEnabled(string keyword); des: Is global shader keyword enabled?"
	}
,
	"Shader.PropertyToID": {
		"prefix": "Shader.PropertyToID",
		"body": [
			"Shader.PropertyToID"
		],
		"description": "public static int PropertyToID(string name); des: Gets unique identifier for a shader property name."
	}
,
	"Shader.SetGlobalBuffer": {
		"prefix": "Shader.SetGlobalBuffer",
		"body": [
			"Shader.SetGlobalBuffer"
		],
		"description": "public static void SetGlobalBuffer(string name, ComputeBuffer value); public static void SetGlobalBuffer(int nameID, ComputeBuffer value); des: Sets a global compute buffer property for all shaders."
	}
,
	"Shader.SetGlobalColor": {
		"prefix": "Shader.SetGlobalColor",
		"body": [
			"Shader.SetGlobalColor"
		],
		"description": "public static void SetGlobalColor(string name, Color value); public static void SetGlobalColor(int nameID, Color value); des: Sets a global color property for all shaders."
	}
,
	"Shader.SetGlobalFloat": {
		"prefix": "Shader.SetGlobalFloat",
		"body": [
			"Shader.SetGlobalFloat"
		],
		"description": "public static void SetGlobalFloat(string name, float value); public static void SetGlobalFloat(int nameID, float value); des: Sets a global float property for all shaders."
	}
,
	"Shader.SetGlobalFloatArray": {
		"prefix": "Shader.SetGlobalFloatArray",
		"body": [
			"Shader.SetGlobalFloatArray"
		],
		"description": "public static void SetGlobalFloatArray(string name, float[] values); public static void SetGlobalFloatArray(int nameID, float[] values); public static void SetGlobalFloatArray(string name, List<float> values); public static void SetGlobalFloatArray(int nameID, List<float> values); des: Sets a global float array property for all shaders."
	}
,
	"Shader.SetGlobalInt": {
		"prefix": "Shader.SetGlobalInt",
		"body": [
			"Shader.SetGlobalInt"
		],
		"description": "public static void SetGlobalInt(string name, int value); public static void SetGlobalInt(int nameID, int value); des: Sets a global int property for all shaders."
	}
,
	"Shader.SetGlobalMatrix": {
		"prefix": "Shader.SetGlobalMatrix",
		"body": [
			"Shader.SetGlobalMatrix"
		],
		"description": "public static void SetGlobalMatrix(string name, Matrix4x4 value); public static void SetGlobalMatrix(int nameID, Matrix4x4 value); des: Sets a global matrix property for all shaders."
	}
,
	"Shader.SetGlobalMatrixArray": {
		"prefix": "Shader.SetGlobalMatrixArray",
		"body": [
			"Shader.SetGlobalMatrixArray"
		],
		"description": "public static void SetGlobalMatrixArray(string name, Matrix4x4[] values); public static void SetGlobalMatrixArray(int nameID, Matrix4x4[] values); public static void SetGlobalMatrixArray(string name, List<Matrix4x4> values); public static void SetGlobalMatrixArray(int nameID, List<Matrix4x4> values); des: Sets a global matrix array property for all shaders."
	}
,
	"Shader.SetGlobalTexture": {
		"prefix": "Shader.SetGlobalTexture",
		"body": [
			"Shader.SetGlobalTexture"
		],
		"description": "public static void SetGlobalTexture(string name, Texture value); public static void SetGlobalTexture(int nameID, Texture value); des: Sets a global texture property for all shaders."
	}
,
	"Shader.SetGlobalVector": {
		"prefix": "Shader.SetGlobalVector",
		"body": [
			"Shader.SetGlobalVector"
		],
		"description": "public static void SetGlobalVector(string name, Vector4 value); public static void SetGlobalVector(int nameID, Vector4 value); des: Sets a global vector property for all shaders."
	}
,
	"Shader.SetGlobalVectorArray": {
		"prefix": "Shader.SetGlobalVectorArray",
		"body": [
			"Shader.SetGlobalVectorArray"
		],
		"description": "public static void SetGlobalVectorArray(string name, Vector4[] values); public static void SetGlobalVectorArray(int nameID, Vector4[] values); public static void SetGlobalVectorArray(string name, List<Vector4> values); public static void SetGlobalVectorArray(int nameID, List<Vector4> values); des: Sets a global vector array property for all shaders."
	}
,
	"Shader.WarmupAllShaders": {
		"prefix": "Shader.WarmupAllShaders",
		"body": [
			"Shader.WarmupAllShaders"
		],
		"description": "public static void WarmupAllShaders(); des: Fully load all shaders to prevent future performance hiccups."
	}
,
	"Shader.hideFlags": {
		"prefix": "Shader.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Shader.name": {
		"prefix": "Shader.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Shader.GetInstanceID": {
		"prefix": "Shader.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Shader.ToString": {
		"prefix": "Shader.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Shader.Destroy": {
		"prefix": "Shader.Destroy",
		"body": [
			"Shader.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Shader.DestroyImmediate": {
		"prefix": "Shader.DestroyImmediate",
		"body": [
			"Shader.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Shader.DontDestroyOnLoad": {
		"prefix": "Shader.DontDestroyOnLoad",
		"body": [
			"Shader.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Shader.FindObjectOfType": {
		"prefix": "Shader.FindObjectOfType",
		"body": [
			"Shader.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Shader.FindObjectsOfType": {
		"prefix": "Shader.FindObjectsOfType",
		"body": [
			"Shader.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Shader.Instantiate": {
		"prefix": "Shader.Instantiate",
		"body": [
			"Shader.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"ShaderVariantCollection.isWarmedUp": {
		"prefix": "ShaderVariantCollection.isWarmedUp",
		"body": [
			"isWarmedUp"
		],
		"description": "return:bool des: Is this ShaderVariantCollection already warmed up? (Read Only)"
	}
,
	"ShaderVariantCollection.shaderCount": {
		"prefix": "ShaderVariantCollection.shaderCount",
		"body": [
			"shaderCount"
		],
		"description": "return:int des: Number of shaders in this collection (Read Only)."
	}
,
	"ShaderVariantCollection.variantCount": {
		"prefix": "ShaderVariantCollection.variantCount",
		"body": [
			"variantCount"
		],
		"description": "return:int des: Number of total varians in this collection (Read Only)."
	}
,
	"ShaderVariantCollection.Add": {
		"prefix": "ShaderVariantCollection.Add",
		"body": [
			"Add($1)"
		],
		"description": "public bool Add(ShaderVariantCollection.ShaderVariant variant); des: Adds a new shader variant to the collection."
	}
,
	"ShaderVariantCollection.Clear": {
		"prefix": "ShaderVariantCollection.Clear",
		"body": [
			"Clear($1)"
		],
		"description": "public void Clear(); des: Remove all shader variants from the collection."
	}
,
	"ShaderVariantCollection.Contains": {
		"prefix": "ShaderVariantCollection.Contains",
		"body": [
			"Contains($1)"
		],
		"description": "public bool Contains(ShaderVariantCollection.ShaderVariant variant); des: Checks if a shader variant is in the collection."
	}
,
	"ShaderVariantCollection.Remove": {
		"prefix": "ShaderVariantCollection.Remove",
		"body": [
			"Remove($1)"
		],
		"description": "public bool Remove(ShaderVariantCollection.ShaderVariant variant); des: Adds shader variant from the collection."
	}
,
	"ShaderVariantCollection.WarmUp": {
		"prefix": "ShaderVariantCollection.WarmUp",
		"body": [
			"WarmUp($1)"
		],
		"description": "public void WarmUp(); des: Fully load shaders in ShaderVariantCollection."
	}
,
	"ShaderVariantCollection.hideFlags": {
		"prefix": "ShaderVariantCollection.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"ShaderVariantCollection.name": {
		"prefix": "ShaderVariantCollection.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"ShaderVariantCollection.GetInstanceID": {
		"prefix": "ShaderVariantCollection.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"ShaderVariantCollection.ToString": {
		"prefix": "ShaderVariantCollection.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"ShaderVariantCollection.Destroy": {
		"prefix": "ShaderVariantCollection.Destroy",
		"body": [
			"ShaderVariantCollection.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"ShaderVariantCollection.DestroyImmediate": {
		"prefix": "ShaderVariantCollection.DestroyImmediate",
		"body": [
			"ShaderVariantCollection.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"ShaderVariantCollection.DontDestroyOnLoad": {
		"prefix": "ShaderVariantCollection.DontDestroyOnLoad",
		"body": [
			"ShaderVariantCollection.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"ShaderVariantCollection.FindObjectOfType": {
		"prefix": "ShaderVariantCollection.FindObjectOfType",
		"body": [
			"ShaderVariantCollection.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"ShaderVariantCollection.FindObjectsOfType": {
		"prefix": "ShaderVariantCollection.FindObjectsOfType",
		"body": [
			"ShaderVariantCollection.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"ShaderVariantCollection.Instantiate": {
		"prefix": "ShaderVariantCollection.Instantiate",
		"body": [
			"ShaderVariantCollection.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"ShaderVariantCollection.ShaderVariant.keywords": {
		"prefix": "ShaderVariantCollection.ShaderVariant.keywords",
		"body": [
			"keywords"
		],
		"description": "return:string[] des: Array of shader keywords to use in this variant."
	}
,
	"ShaderVariantCollection.ShaderVariant.passType": {
		"prefix": "ShaderVariantCollection.ShaderVariant.passType",
		"body": [
			"passType"
		],
		"description": "return:Rendering.PassType des: Pass type to use in this variant."
	}
,
	"ShaderVariantCollection.ShaderVariant.shader": {
		"prefix": "ShaderVariantCollection.ShaderVariant.shader",
		"body": [
			"shader"
		],
		"description": "return:Shader des: Shader to use in this variant."
	}
,
	"SkeletonBone.name": {
		"prefix": "SkeletonBone.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the Transform mapped to the bone."
	}
,
	"SkeletonBone.position": {
		"prefix": "SkeletonBone.position",
		"body": [
			"position"
		],
		"description": "return:Vector3 des: The T-pose position of the bone in local space."
	}
,
	"SkeletonBone.rotation": {
		"prefix": "SkeletonBone.rotation",
		"body": [
			"rotation"
		],
		"description": "return:Quaternion des: The T-pose rotation of the bone in local space."
	}
,
	"SkeletonBone.scale": {
		"prefix": "SkeletonBone.scale",
		"body": [
			"scale"
		],
		"description": "return:Vector3 des: The T-pose scaling of the bone in local space."
	}
,
	"SkinnedMeshRenderer.bones": {
		"prefix": "SkinnedMeshRenderer.bones",
		"body": [
			"bones"
		],
		"description": "return:Transform[] des: The bones used to skin the mesh."
	}
,
	"SkinnedMeshRenderer.localBounds": {
		"prefix": "SkinnedMeshRenderer.localBounds",
		"body": [
			"localBounds"
		],
		"description": "return:Bounds des: AABB of this Skinned Mesh in its local space."
	}
,
	"SkinnedMeshRenderer.quality": {
		"prefix": "SkinnedMeshRenderer.quality",
		"body": [
			"quality"
		],
		"description": "return:SkinQuality des: The maximum number of bones affecting a single vertex."
	}
,
	"SkinnedMeshRenderer.sharedMesh": {
		"prefix": "SkinnedMeshRenderer.sharedMesh",
		"body": [
			"sharedMesh"
		],
		"description": "return:Mesh des: The mesh used for skinning."
	}
,
	"SkinnedMeshRenderer.skinnedMotionVectors": {
		"prefix": "SkinnedMeshRenderer.skinnedMotionVectors",
		"body": [
			"skinnedMotionVectors"
		],
		"description": "return:bool des: Specifies whether skinned motion vectors should be used for this renderer."
	}
,
	"SkinnedMeshRenderer.updateWhenOffscreen": {
		"prefix": "SkinnedMeshRenderer.updateWhenOffscreen",
		"body": [
			"updateWhenOffscreen"
		],
		"description": "return:bool des: If enabled, the Skinned Mesh will be updated when offscreen. If disabled, this also disables updating animations."
	}
,
	"SkinnedMeshRenderer.BakeMesh": {
		"prefix": "SkinnedMeshRenderer.BakeMesh",
		"body": [
			"BakeMesh($1)"
		],
		"description": "public void BakeMesh(Mesh mesh); des: Creates a snapshot of SkinnedMeshRenderer and stores it in mesh."
	}
,
	"SkinnedMeshRenderer.GetBlendShapeWeight": {
		"prefix": "SkinnedMeshRenderer.GetBlendShapeWeight",
		"body": [
			"GetBlendShapeWeight($1)"
		],
		"description": "public float GetBlendShapeWeight(int index); des: Returns weight of BlendShape on this renderer."
	}
,
	"SkinnedMeshRenderer.SetBlendShapeWeight": {
		"prefix": "SkinnedMeshRenderer.SetBlendShapeWeight",
		"body": [
			"SetBlendShapeWeight($1)"
		],
		"description": "public void SetBlendShapeWeight(int index, float value); des: Sets the weight in percent of a BlendShape on this Renderer."
	}
,
	"SkinnedMeshRenderer.gameObject": {
		"prefix": "SkinnedMeshRenderer.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"SkinnedMeshRenderer.tag": {
		"prefix": "SkinnedMeshRenderer.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"SkinnedMeshRenderer.transform": {
		"prefix": "SkinnedMeshRenderer.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"SkinnedMeshRenderer.hideFlags": {
		"prefix": "SkinnedMeshRenderer.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"SkinnedMeshRenderer.name": {
		"prefix": "SkinnedMeshRenderer.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"SkinnedMeshRenderer.allowOcclusionWhenDynamic": {
		"prefix": "SkinnedMeshRenderer.allowOcclusionWhenDynamic",
		"body": [
			"allowOcclusionWhenDynamic"
		],
		"description": "return:bool des: Controls if dynamic occlusion culling should be performed for this renderer."
	}
,
	"SkinnedMeshRenderer.bounds": {
		"prefix": "SkinnedMeshRenderer.bounds",
		"body": [
			"bounds"
		],
		"description": "return:Bounds des: The bounding volume of the renderer (Read Only)."
	}
,
	"SkinnedMeshRenderer.enabled": {
		"prefix": "SkinnedMeshRenderer.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Makes the rendered 3D object visible if enabled."
	}
,
	"SkinnedMeshRenderer.isPartOfStaticBatch": {
		"prefix": "SkinnedMeshRenderer.isPartOfStaticBatch",
		"body": [
			"isPartOfStaticBatch"
		],
		"description": "return:bool des: Has this renderer been statically batched with any other renderers?"
	}
,
	"SkinnedMeshRenderer.isVisible": {
		"prefix": "SkinnedMeshRenderer.isVisible",
		"body": [
			"isVisible"
		],
		"description": "return:bool des: Is this renderer visible in any camera? (Read Only)"
	}
,
	"SkinnedMeshRenderer.lightmapIndex": {
		"prefix": "SkinnedMeshRenderer.lightmapIndex",
		"body": [
			"lightmapIndex"
		],
		"description": "return:int des: The index of the baked lightmap applied to this renderer."
	}
,
	"SkinnedMeshRenderer.lightmapScaleOffset": {
		"prefix": "SkinnedMeshRenderer.lightmapScaleOffset",
		"body": [
			"lightmapScaleOffset"
		],
		"description": "return:Vector4 des: The UV scale & offset used for a lightmap."
	}
,
	"SkinnedMeshRenderer.lightProbeProxyVolumeOverride": {
		"prefix": "SkinnedMeshRenderer.lightProbeProxyVolumeOverride",
		"body": [
			"lightProbeProxyVolumeOverride"
		],
		"description": "return:GameObject des: If set, the Renderer will use the Light Probe Proxy Volume component attached to the source GameObject."
	}
,
	"SkinnedMeshRenderer.lightProbeUsage": {
		"prefix": "SkinnedMeshRenderer.lightProbeUsage",
		"body": [
			"lightProbeUsage"
		],
		"description": "return:Rendering.LightProbeUsage des: The light probe interpolation type."
	}
,
	"SkinnedMeshRenderer.localToWorldMatrix": {
		"prefix": "SkinnedMeshRenderer.localToWorldMatrix",
		"body": [
			"localToWorldMatrix"
		],
		"description": "return:Matrix4x4 des: Matrix that transforms a point from local space into world space (Read Only)."
	}
,
	"SkinnedMeshRenderer.material": {
		"prefix": "SkinnedMeshRenderer.material",
		"body": [
			"material"
		],
		"description": "return:Material des: Returns the first instantiated Material assigned to the renderer."
	}
,
	"SkinnedMeshRenderer.materials": {
		"prefix": "SkinnedMeshRenderer.materials",
		"body": [
			"materials"
		],
		"description": "return:Material[] des: Returns all the instantiated materials of this object."
	}
,
	"SkinnedMeshRenderer.motionVectorGenerationMode": {
		"prefix": "SkinnedMeshRenderer.motionVectorGenerationMode",
		"body": [
			"motionVectorGenerationMode"
		],
		"description": "return:MotionVectorGenerationMode des: Specifies the mode for motion vector rendering."
	}
,
	"SkinnedMeshRenderer.probeAnchor": {
		"prefix": "SkinnedMeshRenderer.probeAnchor",
		"body": [
			"probeAnchor"
		],
		"description": "return:Transform des: If set, Renderer will use this Transform's position to find the light or reflection probe."
	}
,
	"SkinnedMeshRenderer.realtimeLightmapIndex": {
		"prefix": "SkinnedMeshRenderer.realtimeLightmapIndex",
		"body": [
			"realtimeLightmapIndex"
		],
		"description": "return:int des: The index of the realtime lightmap applied to this renderer."
	}
,
	"SkinnedMeshRenderer.realtimeLightmapScaleOffset": {
		"prefix": "SkinnedMeshRenderer.realtimeLightmapScaleOffset",
		"body": [
			"realtimeLightmapScaleOffset"
		],
		"description": "return:Vector4 des: The UV scale & offset used for a realtime lightmap."
	}
,
	"SkinnedMeshRenderer.receiveShadows": {
		"prefix": "SkinnedMeshRenderer.receiveShadows",
		"body": [
			"receiveShadows"
		],
		"description": "return:bool des: Does this object receive shadows?"
	}
,
	"SkinnedMeshRenderer.reflectionProbeUsage": {
		"prefix": "SkinnedMeshRenderer.reflectionProbeUsage",
		"body": [
			"reflectionProbeUsage"
		],
		"description": "return:Rendering.ReflectionProbeUsage des: Should reflection probes be used for this Renderer?"
	}
,
	"SkinnedMeshRenderer.renderingLayerMask": {
		"prefix": "SkinnedMeshRenderer.renderingLayerMask",
		"body": [
			"renderingLayerMask"
		],
		"description": "return:uint des: Determines which rendering layer this renderer lives on."
	}
,
	"SkinnedMeshRenderer.shadowCastingMode": {
		"prefix": "SkinnedMeshRenderer.shadowCastingMode",
		"body": [
			"shadowCastingMode"
		],
		"description": "return:Rendering.ShadowCastingMode des: Does this object cast shadows?"
	}
,
	"SkinnedMeshRenderer.sharedMaterial": {
		"prefix": "SkinnedMeshRenderer.sharedMaterial",
		"body": [
			"sharedMaterial"
		],
		"description": "return:Material des: The shared material of this object."
	}
,
	"SkinnedMeshRenderer.sharedMaterials": {
		"prefix": "SkinnedMeshRenderer.sharedMaterials",
		"body": [
			"sharedMaterials"
		],
		"description": "return:Material[] des: All the shared materials of this object."
	}
,
	"SkinnedMeshRenderer.sortingLayerID": {
		"prefix": "SkinnedMeshRenderer.sortingLayerID",
		"body": [
			"sortingLayerID"
		],
		"description": "return:int des: Unique ID of the Renderer's sorting layer."
	}
,
	"SkinnedMeshRenderer.sortingLayerName": {
		"prefix": "SkinnedMeshRenderer.sortingLayerName",
		"body": [
			"sortingLayerName"
		],
		"description": "return:string des: Name of the Renderer's sorting layer."
	}
,
	"SkinnedMeshRenderer.sortingOrder": {
		"prefix": "SkinnedMeshRenderer.sortingOrder",
		"body": [
			"sortingOrder"
		],
		"description": "return:int des: Renderer's order within a sorting layer."
	}
,
	"SkinnedMeshRenderer.worldToLocalMatrix": {
		"prefix": "SkinnedMeshRenderer.worldToLocalMatrix",
		"body": [
			"worldToLocalMatrix"
		],
		"description": "return:Matrix4x4 des: Matrix that transforms a point from world space into local space (Read Only)."
	}
,
	"SkinnedMeshRenderer.BroadcastMessage": {
		"prefix": "SkinnedMeshRenderer.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"SkinnedMeshRenderer.CompareTag": {
		"prefix": "SkinnedMeshRenderer.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"SkinnedMeshRenderer.GetComponent": {
		"prefix": "SkinnedMeshRenderer.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"SkinnedMeshRenderer.GetComponentInChildren": {
		"prefix": "SkinnedMeshRenderer.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"SkinnedMeshRenderer.GetComponentInParent": {
		"prefix": "SkinnedMeshRenderer.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"SkinnedMeshRenderer.GetComponents": {
		"prefix": "SkinnedMeshRenderer.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"SkinnedMeshRenderer.GetComponentsInChildren": {
		"prefix": "SkinnedMeshRenderer.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"SkinnedMeshRenderer.GetComponentsInParent": {
		"prefix": "SkinnedMeshRenderer.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"SkinnedMeshRenderer.SendMessage": {
		"prefix": "SkinnedMeshRenderer.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"SkinnedMeshRenderer.SendMessageUpwards": {
		"prefix": "SkinnedMeshRenderer.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"SkinnedMeshRenderer.GetInstanceID": {
		"prefix": "SkinnedMeshRenderer.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"SkinnedMeshRenderer.ToString": {
		"prefix": "SkinnedMeshRenderer.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"SkinnedMeshRenderer.GetClosestReflectionProbes": {
		"prefix": "SkinnedMeshRenderer.GetClosestReflectionProbes",
		"body": [
			"GetClosestReflectionProbes($1)"
		],
		"description": "public void GetClosestReflectionProbes(List<ReflectionProbeBlendInfo> result); des: Returns an array of closest reflection probes with weights, weight shows how much influence the probe has on the renderer, this value is also used when blending between reflection probes occur."
	}
,
	"SkinnedMeshRenderer.GetMaterials": {
		"prefix": "SkinnedMeshRenderer.GetMaterials",
		"body": [
			"GetMaterials($1)"
		],
		"description": "public void GetMaterials(List<Material> m); des: Returns all the instantiated materials of this object."
	}
,
	"SkinnedMeshRenderer.GetPropertyBlock": {
		"prefix": "SkinnedMeshRenderer.GetPropertyBlock",
		"body": [
			"GetPropertyBlock($1)"
		],
		"description": "public void GetPropertyBlock(MaterialPropertyBlock properties); public void GetPropertyBlock(MaterialPropertyBlock properties, int materialIndex); des: Get per-Renderer or per-Material property block."
	}
,
	"SkinnedMeshRenderer.GetSharedMaterials": {
		"prefix": "SkinnedMeshRenderer.GetSharedMaterials",
		"body": [
			"GetSharedMaterials($1)"
		],
		"description": "public void GetSharedMaterials(List<Material> m); des: Returns all the shared materials of this object."
	}
,
	"SkinnedMeshRenderer.HasPropertyBlock": {
		"prefix": "SkinnedMeshRenderer.HasPropertyBlock",
		"body": [
			"HasPropertyBlock($1)"
		],
		"description": "public bool HasPropertyBlock(); des: Returns true if the Renderer has a material property block attached via SetPropertyBlock."
	}
,
	"SkinnedMeshRenderer.SetPropertyBlock": {
		"prefix": "SkinnedMeshRenderer.SetPropertyBlock",
		"body": [
			"SetPropertyBlock($1)"
		],
		"description": "public void SetPropertyBlock(MaterialPropertyBlock properties); public void SetPropertyBlock(MaterialPropertyBlock properties, int materialIndex); des: Lets you set or clear per-renderer or per-material parameter overrides."
	}
,
	"SkinnedMeshRenderer.Destroy": {
		"prefix": "SkinnedMeshRenderer.Destroy",
		"body": [
			"SkinnedMeshRenderer.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"SkinnedMeshRenderer.DestroyImmediate": {
		"prefix": "SkinnedMeshRenderer.DestroyImmediate",
		"body": [
			"SkinnedMeshRenderer.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"SkinnedMeshRenderer.DontDestroyOnLoad": {
		"prefix": "SkinnedMeshRenderer.DontDestroyOnLoad",
		"body": [
			"SkinnedMeshRenderer.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"SkinnedMeshRenderer.FindObjectOfType": {
		"prefix": "SkinnedMeshRenderer.FindObjectOfType",
		"body": [
			"SkinnedMeshRenderer.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"SkinnedMeshRenderer.FindObjectsOfType": {
		"prefix": "SkinnedMeshRenderer.FindObjectsOfType",
		"body": [
			"SkinnedMeshRenderer.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"SkinnedMeshRenderer.Instantiate": {
		"prefix": "SkinnedMeshRenderer.Instantiate",
		"body": [
			"SkinnedMeshRenderer.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"SkinnedMeshRenderer.OnBecameInvisible": {
		"prefix": "SkinnedMeshRenderer.OnBecameInvisible",
		"body": [
			"OnBecameInvisible"
		],
		"description": "OnBecameInvisible is called when the object is no longer visible by any camera."
	}
,
	"SkinnedMeshRenderer.OnBecameVisible": {
		"prefix": "SkinnedMeshRenderer.OnBecameVisible",
		"body": [
			"OnBecameVisible"
		],
		"description": "OnBecameVisible is called when the object became visible by any camera."
	}
,
	"Skybox.material": {
		"prefix": "Skybox.material",
		"body": [
			"material"
		],
		"description": "return:Material des: The material used by the skybox."
	}
,
	"Skybox.enabled": {
		"prefix": "Skybox.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"Skybox.isActiveAndEnabled": {
		"prefix": "Skybox.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"Skybox.gameObject": {
		"prefix": "Skybox.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"Skybox.tag": {
		"prefix": "Skybox.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"Skybox.transform": {
		"prefix": "Skybox.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"Skybox.hideFlags": {
		"prefix": "Skybox.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Skybox.name": {
		"prefix": "Skybox.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Skybox.BroadcastMessage": {
		"prefix": "Skybox.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"Skybox.CompareTag": {
		"prefix": "Skybox.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"Skybox.GetComponent": {
		"prefix": "Skybox.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"Skybox.GetComponentInChildren": {
		"prefix": "Skybox.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"Skybox.GetComponentInParent": {
		"prefix": "Skybox.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"Skybox.GetComponents": {
		"prefix": "Skybox.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"Skybox.GetComponentsInChildren": {
		"prefix": "Skybox.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"Skybox.GetComponentsInParent": {
		"prefix": "Skybox.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"Skybox.SendMessage": {
		"prefix": "Skybox.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"Skybox.SendMessageUpwards": {
		"prefix": "Skybox.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"Skybox.GetInstanceID": {
		"prefix": "Skybox.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Skybox.ToString": {
		"prefix": "Skybox.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Skybox.Destroy": {
		"prefix": "Skybox.Destroy",
		"body": [
			"Skybox.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Skybox.DestroyImmediate": {
		"prefix": "Skybox.DestroyImmediate",
		"body": [
			"Skybox.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Skybox.DontDestroyOnLoad": {
		"prefix": "Skybox.DontDestroyOnLoad",
		"body": [
			"Skybox.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Skybox.FindObjectOfType": {
		"prefix": "Skybox.FindObjectOfType",
		"body": [
			"Skybox.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Skybox.FindObjectsOfType": {
		"prefix": "Skybox.FindObjectsOfType",
		"body": [
			"Skybox.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Skybox.Instantiate": {
		"prefix": "Skybox.Instantiate",
		"body": [
			"Skybox.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"SliderJoint2D.angle": {
		"prefix": "SliderJoint2D.angle",
		"body": [
			"angle"
		],
		"description": "return:float des: The angle of the line in space (in degrees)."
	}
,
	"SliderJoint2D.autoConfigureAngle": {
		"prefix": "SliderJoint2D.autoConfigureAngle",
		"body": [
			"autoConfigureAngle"
		],
		"description": "return:bool des: Should the angle be calculated automatically?"
	}
,
	"SliderJoint2D.jointSpeed": {
		"prefix": "SliderJoint2D.jointSpeed",
		"body": [
			"jointSpeed"
		],
		"description": "return:float des: The current joint speed."
	}
,
	"SliderJoint2D.jointTranslation": {
		"prefix": "SliderJoint2D.jointTranslation",
		"body": [
			"jointTranslation"
		],
		"description": "return:float des: The current joint translation."
	}
,
	"SliderJoint2D.limits": {
		"prefix": "SliderJoint2D.limits",
		"body": [
			"limits"
		],
		"description": "return:JointTranslationLimits2D des: Restrictions on how far the joint can slide in each direction along the line."
	}
,
	"SliderJoint2D.limitState": {
		"prefix": "SliderJoint2D.limitState",
		"body": [
			"limitState"
		],
		"description": "return:JointLimitState2D des: Gets the state of the joint limit."
	}
,
	"SliderJoint2D.motor": {
		"prefix": "SliderJoint2D.motor",
		"body": [
			"motor"
		],
		"description": "return:JointMotor2D des: Parameters for a motor force that is applied automatically to the Rigibody2D along the line."
	}
,
	"SliderJoint2D.referenceAngle": {
		"prefix": "SliderJoint2D.referenceAngle",
		"body": [
			"referenceAngle"
		],
		"description": "return:float des: The angle (in degrees) referenced between the two bodies used as the constraint for the joint."
	}
,
	"SliderJoint2D.useLimits": {
		"prefix": "SliderJoint2D.useLimits",
		"body": [
			"useLimits"
		],
		"description": "return:bool des: Should motion limits be used?"
	}
,
	"SliderJoint2D.useMotor": {
		"prefix": "SliderJoint2D.useMotor",
		"body": [
			"useMotor"
		],
		"description": "return:bool des: Should a motor force be applied automatically to the Rigidbody2D?"
	}
,
	"SliderJoint2D.GetMotorForce": {
		"prefix": "SliderJoint2D.GetMotorForce",
		"body": [
			"GetMotorForce($1)"
		],
		"description": "public float GetMotorForce(float timeStep); des: Gets the motor force of the joint given the specified timestep."
	}
,
	"SliderJoint2D.anchor": {
		"prefix": "SliderJoint2D.anchor",
		"body": [
			"anchor"
		],
		"description": "return:Vector2 des: The joint's anchor point on the object that has the joint component."
	}
,
	"SliderJoint2D.autoConfigureConnectedAnchor": {
		"prefix": "SliderJoint2D.autoConfigureConnectedAnchor",
		"body": [
			"autoConfigureConnectedAnchor"
		],
		"description": "return:bool des: Should the connectedAnchor be calculated automatically?"
	}
,
	"SliderJoint2D.connectedAnchor": {
		"prefix": "SliderJoint2D.connectedAnchor",
		"body": [
			"connectedAnchor"
		],
		"description": "return:Vector2 des: The joint's anchor point on the second object (ie, the one which doesn't have the joint component)."
	}
,
	"SliderJoint2D.enabled": {
		"prefix": "SliderJoint2D.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"SliderJoint2D.isActiveAndEnabled": {
		"prefix": "SliderJoint2D.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"SliderJoint2D.gameObject": {
		"prefix": "SliderJoint2D.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"SliderJoint2D.tag": {
		"prefix": "SliderJoint2D.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"SliderJoint2D.transform": {
		"prefix": "SliderJoint2D.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"SliderJoint2D.attachedRigidbody": {
		"prefix": "SliderJoint2D.attachedRigidbody",
		"body": [
			"attachedRigidbody"
		],
		"description": "return:Rigidbody2D des: The Rigidbody2D attached to the Joint2D."
	}
,
	"SliderJoint2D.breakForce": {
		"prefix": "SliderJoint2D.breakForce",
		"body": [
			"breakForce"
		],
		"description": "return:float des: The force that needs to be applied for this joint to break."
	}
,
	"SliderJoint2D.breakTorque": {
		"prefix": "SliderJoint2D.breakTorque",
		"body": [
			"breakTorque"
		],
		"description": "return:float des: The torque that needs to be applied for this joint to break."
	}
,
	"SliderJoint2D.connectedBody": {
		"prefix": "SliderJoint2D.connectedBody",
		"body": [
			"connectedBody"
		],
		"description": "return:Rigidbody2D des: The Rigidbody2D object to which the other end of the joint is attached (ie, the object without the joint component)."
	}
,
	"SliderJoint2D.enableCollision": {
		"prefix": "SliderJoint2D.enableCollision",
		"body": [
			"enableCollision"
		],
		"description": "return:bool des: Should the two rigid bodies connected with this joint collide with each other?"
	}
,
	"SliderJoint2D.reactionForce": {
		"prefix": "SliderJoint2D.reactionForce",
		"body": [
			"reactionForce"
		],
		"description": "return:Vector2 des: Gets the reaction force of the joint."
	}
,
	"SliderJoint2D.reactionTorque": {
		"prefix": "SliderJoint2D.reactionTorque",
		"body": [
			"reactionTorque"
		],
		"description": "return:float des: Gets the reaction torque of the joint."
	}
,
	"SliderJoint2D.hideFlags": {
		"prefix": "SliderJoint2D.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"SliderJoint2D.name": {
		"prefix": "SliderJoint2D.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"SliderJoint2D.BroadcastMessage": {
		"prefix": "SliderJoint2D.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"SliderJoint2D.CompareTag": {
		"prefix": "SliderJoint2D.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"SliderJoint2D.GetComponent": {
		"prefix": "SliderJoint2D.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"SliderJoint2D.GetComponentInChildren": {
		"prefix": "SliderJoint2D.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"SliderJoint2D.GetComponentInParent": {
		"prefix": "SliderJoint2D.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"SliderJoint2D.GetComponents": {
		"prefix": "SliderJoint2D.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"SliderJoint2D.GetComponentsInChildren": {
		"prefix": "SliderJoint2D.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"SliderJoint2D.GetComponentsInParent": {
		"prefix": "SliderJoint2D.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"SliderJoint2D.SendMessage": {
		"prefix": "SliderJoint2D.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"SliderJoint2D.SendMessageUpwards": {
		"prefix": "SliderJoint2D.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"SliderJoint2D.GetReactionForce": {
		"prefix": "SliderJoint2D.GetReactionForce",
		"body": [
			"GetReactionForce($1)"
		],
		"description": "public Vector2 GetReactionForce(float timeStep); des: Gets the reaction force of the joint given the specified timeStep."
	}
,
	"SliderJoint2D.GetReactionTorque": {
		"prefix": "SliderJoint2D.GetReactionTorque",
		"body": [
			"GetReactionTorque($1)"
		],
		"description": "public float GetReactionTorque(float timeStep); des: Gets the reaction torque of the joint given the specified timeStep."
	}
,
	"SliderJoint2D.GetInstanceID": {
		"prefix": "SliderJoint2D.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"SliderJoint2D.ToString": {
		"prefix": "SliderJoint2D.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"SliderJoint2D.Destroy": {
		"prefix": "SliderJoint2D.Destroy",
		"body": [
			"SliderJoint2D.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"SliderJoint2D.DestroyImmediate": {
		"prefix": "SliderJoint2D.DestroyImmediate",
		"body": [
			"SliderJoint2D.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"SliderJoint2D.DontDestroyOnLoad": {
		"prefix": "SliderJoint2D.DontDestroyOnLoad",
		"body": [
			"SliderJoint2D.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"SliderJoint2D.FindObjectOfType": {
		"prefix": "SliderJoint2D.FindObjectOfType",
		"body": [
			"SliderJoint2D.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"SliderJoint2D.FindObjectsOfType": {
		"prefix": "SliderJoint2D.FindObjectsOfType",
		"body": [
			"SliderJoint2D.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"SliderJoint2D.Instantiate": {
		"prefix": "SliderJoint2D.Instantiate",
		"body": [
			"SliderJoint2D.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"SliderJoint2D.OnJointBreak2D": {
		"prefix": "SliderJoint2D.OnJointBreak2D",
		"body": [
			"OnJointBreak2D"
		],
		"description": "Called when a Joint2D attached to the same game object breaks."
	}
,
	"Social.CreateAchievement": {
		"prefix": "Social.CreateAchievement",
		"body": [
			"Social.CreateAchievement"
		],
		"description": "public static SocialPlatforms.IAchievement CreateAchievement(); des: Create an IAchievement instance."
	}
,
	"Social.CreateLeaderboard": {
		"prefix": "Social.CreateLeaderboard",
		"body": [
			"Social.CreateLeaderboard"
		],
		"description": "public static SocialPlatforms.ILeaderboard CreateLeaderboard(); des: Create an ILeaderboard instance."
	}
,
	"Social.LoadAchievementDescriptions": {
		"prefix": "Social.LoadAchievementDescriptions",
		"body": [
			"Social.LoadAchievementDescriptions"
		],
		"description": "public static void LoadAchievementDescriptions(Action<IAchievementDescription[]> callback); des: Loads the achievement descriptions accociated with this application."
	}
,
	"Social.LoadAchievements": {
		"prefix": "Social.LoadAchievements",
		"body": [
			"Social.LoadAchievements"
		],
		"description": "public static void LoadAchievements(Action<IAchievement[]> callback); des: Load the achievements the logged in user has already achieved or reported progress on."
	}
,
	"Social.LoadScores": {
		"prefix": "Social.LoadScores",
		"body": [
			"Social.LoadScores"
		],
		"description": "public static void LoadScores(string leaderboardID, Action<IScore[]> callback); des: Load a default set of scores from the given leaderboard."
	}
,
	"Social.LoadUsers": {
		"prefix": "Social.LoadUsers",
		"body": [
			"Social.LoadUsers"
		],
		"description": "public static void LoadUsers(string[] userIDs, Action<IUserProfile[]> callback); des: Load the user profiles accociated with the given array of user IDs."
	}
,
	"Social.ReportProgress": {
		"prefix": "Social.ReportProgress",
		"body": [
			"Social.ReportProgress"
		],
		"description": "public static void ReportProgress(string achievementID, double progress, Action<bool> callback); des: Reports the progress of an achievement."
	}
,
	"Social.ReportScore": {
		"prefix": "Social.ReportScore",
		"body": [
			"Social.ReportScore"
		],
		"description": "public static void ReportScore(long score, string board, Action<bool> callback); des: Report a score to a specific leaderboard."
	}
,
	"Social.ShowAchievementsUI": {
		"prefix": "Social.ShowAchievementsUI",
		"body": [
			"Social.ShowAchievementsUI"
		],
		"description": "public static void ShowAchievementsUI(); des: Show a default/system view of the games achievements."
	}
,
	"Social.ShowLeaderboardUI": {
		"prefix": "Social.ShowLeaderboardUI",
		"body": [
			"Social.ShowLeaderboardUI"
		],
		"description": "public static void ShowLeaderboardUI(); des: Show a default/system view of the games leaderboards."
	}
,
	"SoftJointLimit.bounciness": {
		"prefix": "SoftJointLimit.bounciness",
		"body": [
			"bounciness"
		],
		"description": "return:float des: When the joint hits the limit, it can be made to bounce off it."
	}
,
	"SoftJointLimit.contactDistance": {
		"prefix": "SoftJointLimit.contactDistance",
		"body": [
			"contactDistance"
		],
		"description": "return:float des: Determines how far ahead in space the solver can \"see\" the joint limit."
	}
,
	"SoftJointLimit.limit": {
		"prefix": "SoftJointLimit.limit",
		"body": [
			"limit"
		],
		"description": "return:float des: The limit position/angle of the joint (in degrees)."
	}
,
	"SoftJointLimitSpring.damper": {
		"prefix": "SoftJointLimitSpring.damper",
		"body": [
			"damper"
		],
		"description": "return:float des: The damping of the spring limit. In effect when the stiffness of the sprint limit is not zero."
	}
,
	"SoftJointLimitSpring.spring": {
		"prefix": "SoftJointLimitSpring.spring",
		"body": [
			"spring"
		],
		"description": "return:float des: The stiffness of the spring limit. When stiffness is zero the limit is hard, otherwise soft."
	}
,
	"SortingLayer.id": {
		"prefix": "SortingLayer.id",
		"body": [
			"id"
		],
		"description": "return:int des: This is the unique id assigned to the layer. It is not an ordered running value and it should not be used to compare with other layers to determine the sorting order."
	}
,
	"SortingLayer.name": {
		"prefix": "SortingLayer.name",
		"body": [
			"name"
		],
		"description": "return:string des: Returns the name of the layer as defined in the TagManager."
	}
,
	"SortingLayer.value": {
		"prefix": "SortingLayer.value",
		"body": [
			"value"
		],
		"description": "return:int des: This is the relative value that indicates the sort order of this layer relative to the other layers."
	}
,
	"SortingLayer.GetLayerValueFromID": {
		"prefix": "SortingLayer.GetLayerValueFromID",
		"body": [
			"SortingLayer.GetLayerValueFromID"
		],
		"description": "public static int GetLayerValueFromID(int id); des: Returns the final sorting layer value. To determine the sorting order between the various sorting layers, use this method to retrieve the final sorting value and use CompareTo to determine the order."
	}
,
	"SortingLayer.GetLayerValueFromName": {
		"prefix": "SortingLayer.GetLayerValueFromName",
		"body": [
			"SortingLayer.GetLayerValueFromName"
		],
		"description": "public static int GetLayerValueFromName(string name); des: Returns the final sorting layer value. See Also: GetLayerValueFromID."
	}
,
	"SortingLayer.IDToName": {
		"prefix": "SortingLayer.IDToName",
		"body": [
			"SortingLayer.IDToName"
		],
		"description": "public static string IDToName(int id); des: Returns the unique id of the layer. Will return \"<unknown layer>\" if an invalid id is given."
	}
,
	"SortingLayer.IsValid": {
		"prefix": "SortingLayer.IsValid",
		"body": [
			"SortingLayer.IsValid"
		],
		"description": "public static bool IsValid(int id); des: Returns true if the id provided is a valid layer id."
	}
,
	"SortingLayer.NameToID": {
		"prefix": "SortingLayer.NameToID",
		"body": [
			"SortingLayer.NameToID"
		],
		"description": "public static int NameToID(string name); des: Returns the id given the name. Will return 0 if an invalid name was given."
	}
,
	"SparseTexture.isCreated": {
		"prefix": "SparseTexture.isCreated",
		"body": [
			"isCreated"
		],
		"description": "return:bool des: Is the sparse texture actually created? (Read Only)"
	}
,
	"SparseTexture.tileHeight": {
		"prefix": "SparseTexture.tileHeight",
		"body": [
			"tileHeight"
		],
		"description": "return:int des: Get sparse texture tile height (Read Only)."
	}
,
	"SparseTexture.tileWidth": {
		"prefix": "SparseTexture.tileWidth",
		"body": [
			"tileWidth"
		],
		"description": "return:int des: Get sparse texture tile width (Read Only)."
	}
,
	"SparseTexture.UnloadTile": {
		"prefix": "SparseTexture.UnloadTile",
		"body": [
			"UnloadTile($1)"
		],
		"description": "public void UnloadTile(int tileX, int tileY, int miplevel); des: Unload sparse texture tile."
	}
,
	"SparseTexture.UpdateTile": {
		"prefix": "SparseTexture.UpdateTile",
		"body": [
			"UpdateTile($1)"
		],
		"description": "public void UpdateTile(int tileX, int tileY, int miplevel, Color32[] data); des: Update sparse texture tile with color values."
	}
,
	"SparseTexture.UpdateTileRaw": {
		"prefix": "SparseTexture.UpdateTileRaw",
		"body": [
			"UpdateTileRaw($1)"
		],
		"description": "public void UpdateTileRaw(int tileX, int tileY, int miplevel, byte[] data); des: Update sparse texture tile with raw pixel values."
	}
,
	"SparseTexture.hideFlags": {
		"prefix": "SparseTexture.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"SparseTexture.name": {
		"prefix": "SparseTexture.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"SparseTexture.anisoLevel": {
		"prefix": "SparseTexture.anisoLevel",
		"body": [
			"anisoLevel"
		],
		"description": "return:int des: Anisotropic filtering level of the texture."
	}
,
	"SparseTexture.dimension": {
		"prefix": "SparseTexture.dimension",
		"body": [
			"dimension"
		],
		"description": "return:Rendering.TextureDimension des: Dimensionality (type) of the texture (Read Only)."
	}
,
	"SparseTexture.filterMode": {
		"prefix": "SparseTexture.filterMode",
		"body": [
			"filterMode"
		],
		"description": "return:FilterMode des: Filtering mode of the texture."
	}
,
	"SparseTexture.height": {
		"prefix": "SparseTexture.height",
		"body": [
			"height"
		],
		"description": "return:int des: Height of the texture in pixels. (Read Only)"
	}
,
	"SparseTexture.imageContentsHash": {
		"prefix": "SparseTexture.imageContentsHash",
		"body": [
			"imageContentsHash"
		],
		"description": "return:Hash128 des: The hash value of the Texture."
	}
,
	"SparseTexture.mipMapBias": {
		"prefix": "SparseTexture.mipMapBias",
		"body": [
			"mipMapBias"
		],
		"description": "return:float des: Mip map bias of the texture."
	}
,
	"SparseTexture.updateCount": {
		"prefix": "SparseTexture.updateCount",
		"body": [
			"updateCount"
		],
		"description": "return:uint des: This counter is incremented when the texture is updated."
	}
,
	"SparseTexture.width": {
		"prefix": "SparseTexture.width",
		"body": [
			"width"
		],
		"description": "return:int des: Width of the texture in pixels. (Read Only)"
	}
,
	"SparseTexture.wrapMode": {
		"prefix": "SparseTexture.wrapMode",
		"body": [
			"wrapMode"
		],
		"description": "return:TextureWrapMode des: Texture coordinate wrapping mode."
	}
,
	"SparseTexture.wrapModeU": {
		"prefix": "SparseTexture.wrapModeU",
		"body": [
			"wrapModeU"
		],
		"description": "return:TextureWrapMode des: Texture U coordinate wrapping mode."
	}
,
	"SparseTexture.wrapModeV": {
		"prefix": "SparseTexture.wrapModeV",
		"body": [
			"wrapModeV"
		],
		"description": "return:TextureWrapMode des: Texture V coordinate wrapping mode."
	}
,
	"SparseTexture.wrapModeW": {
		"prefix": "SparseTexture.wrapModeW",
		"body": [
			"wrapModeW"
		],
		"description": "return:TextureWrapMode des: Texture W coordinate wrapping mode for Texture3D."
	}
,
	"SparseTexture.GetInstanceID": {
		"prefix": "SparseTexture.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"SparseTexture.ToString": {
		"prefix": "SparseTexture.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"SparseTexture.GetNativeTexturePtr": {
		"prefix": "SparseTexture.GetNativeTexturePtr",
		"body": [
			"GetNativeTexturePtr($1)"
		],
		"description": "public IntPtr GetNativeTexturePtr(); des: Retrieve a native (underlying graphics API) pointer to the texture resource."
	}
,
	"SparseTexture.IncrementUpdateCount": {
		"prefix": "SparseTexture.IncrementUpdateCount",
		"body": [
			"IncrementUpdateCount($1)"
		],
		"description": "public void IncrementUpdateCount(); des: Increment the update counter."
	}
,
	"SparseTexture.Destroy": {
		"prefix": "SparseTexture.Destroy",
		"body": [
			"SparseTexture.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"SparseTexture.DestroyImmediate": {
		"prefix": "SparseTexture.DestroyImmediate",
		"body": [
			"SparseTexture.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"SparseTexture.DontDestroyOnLoad": {
		"prefix": "SparseTexture.DontDestroyOnLoad",
		"body": [
			"SparseTexture.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"SparseTexture.FindObjectOfType": {
		"prefix": "SparseTexture.FindObjectOfType",
		"body": [
			"SparseTexture.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"SparseTexture.FindObjectsOfType": {
		"prefix": "SparseTexture.FindObjectsOfType",
		"body": [
			"SparseTexture.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"SparseTexture.Instantiate": {
		"prefix": "SparseTexture.Instantiate",
		"body": [
			"SparseTexture.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"SparseTexture.SetGlobalAnisotropicFilteringLimits": {
		"prefix": "SparseTexture.SetGlobalAnisotropicFilteringLimits",
		"body": [
			"SparseTexture.SetGlobalAnisotropicFilteringLimits"
		],
		"description": "public static void SetGlobalAnisotropicFilteringLimits(int forcedMin, int globalMax); des: Sets Anisotropic limits."
	}
,
	"SparseTexture.SetStreamingTextureMaterialDebugProperties": {
		"prefix": "SparseTexture.SetStreamingTextureMaterialDebugProperties",
		"body": [
			"SparseTexture.SetStreamingTextureMaterialDebugProperties"
		],
		"description": "public static void SetStreamingTextureMaterialDebugProperties(); des: Uploads additional debug information to materials using textures set to stream mip maps."
	}
,
	"SphereCollider.center": {
		"prefix": "SphereCollider.center",
		"body": [
			"center"
		],
		"description": "return:Vector3 des: The center of the sphere in the object's local space."
	}
,
	"SphereCollider.radius": {
		"prefix": "SphereCollider.radius",
		"body": [
			"radius"
		],
		"description": "return:float des: The radius of the sphere measured in the object's local space."
	}
,
	"SphereCollider.attachedRigidbody": {
		"prefix": "SphereCollider.attachedRigidbody",
		"body": [
			"attachedRigidbody"
		],
		"description": "return:Rigidbody des: The rigidbody the collider is attached to."
	}
,
	"SphereCollider.bounds": {
		"prefix": "SphereCollider.bounds",
		"body": [
			"bounds"
		],
		"description": "return:Bounds des: The world space bounding volume of the collider (Read Only)."
	}
,
	"SphereCollider.contactOffset": {
		"prefix": "SphereCollider.contactOffset",
		"body": [
			"contactOffset"
		],
		"description": "return:float des: Contact offset value of this collider."
	}
,
	"SphereCollider.enabled": {
		"prefix": "SphereCollider.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Colliders will collide with other Colliders, disabled Colliders won't."
	}
,
	"SphereCollider.isTrigger": {
		"prefix": "SphereCollider.isTrigger",
		"body": [
			"isTrigger"
		],
		"description": "return:bool des: Is the collider a trigger?"
	}
,
	"SphereCollider.material": {
		"prefix": "SphereCollider.material",
		"body": [
			"material"
		],
		"description": "return:PhysicMaterial des: The material used by the collider."
	}
,
	"SphereCollider.sharedMaterial": {
		"prefix": "SphereCollider.sharedMaterial",
		"body": [
			"sharedMaterial"
		],
		"description": "return:PhysicMaterial des: The shared physic material of this collider."
	}
,
	"SphereCollider.gameObject": {
		"prefix": "SphereCollider.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"SphereCollider.tag": {
		"prefix": "SphereCollider.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"SphereCollider.transform": {
		"prefix": "SphereCollider.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"SphereCollider.hideFlags": {
		"prefix": "SphereCollider.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"SphereCollider.name": {
		"prefix": "SphereCollider.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"SphereCollider.ClosestPoint": {
		"prefix": "SphereCollider.ClosestPoint",
		"body": [
			"ClosestPoint($1)"
		],
		"description": "public Vector3 ClosestPoint(Vector3 position); des: Returns a point on the collider that is closest to a given location."
	}
,
	"SphereCollider.ClosestPointOnBounds": {
		"prefix": "SphereCollider.ClosestPointOnBounds",
		"body": [
			"ClosestPointOnBounds($1)"
		],
		"description": "public Vector3 ClosestPointOnBounds(Vector3 position); des: The closest point to the bounding box of the attached collider."
	}
,
	"SphereCollider.Raycast": {
		"prefix": "SphereCollider.Raycast",
		"body": [
			"Raycast($1)"
		],
		"description": "public bool Raycast(Ray ray, out RaycastHit hitInfo, float maxDistance); des: Casts a Ray that ignores all Colliders except this one."
	}
,
	"SphereCollider.BroadcastMessage": {
		"prefix": "SphereCollider.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"SphereCollider.CompareTag": {
		"prefix": "SphereCollider.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"SphereCollider.GetComponent": {
		"prefix": "SphereCollider.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"SphereCollider.GetComponentInChildren": {
		"prefix": "SphereCollider.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"SphereCollider.GetComponentInParent": {
		"prefix": "SphereCollider.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"SphereCollider.GetComponents": {
		"prefix": "SphereCollider.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"SphereCollider.GetComponentsInChildren": {
		"prefix": "SphereCollider.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"SphereCollider.GetComponentsInParent": {
		"prefix": "SphereCollider.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"SphereCollider.SendMessage": {
		"prefix": "SphereCollider.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"SphereCollider.SendMessageUpwards": {
		"prefix": "SphereCollider.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"SphereCollider.GetInstanceID": {
		"prefix": "SphereCollider.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"SphereCollider.ToString": {
		"prefix": "SphereCollider.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"SphereCollider.Destroy": {
		"prefix": "SphereCollider.Destroy",
		"body": [
			"SphereCollider.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"SphereCollider.DestroyImmediate": {
		"prefix": "SphereCollider.DestroyImmediate",
		"body": [
			"SphereCollider.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"SphereCollider.DontDestroyOnLoad": {
		"prefix": "SphereCollider.DontDestroyOnLoad",
		"body": [
			"SphereCollider.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"SphereCollider.FindObjectOfType": {
		"prefix": "SphereCollider.FindObjectOfType",
		"body": [
			"SphereCollider.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"SphereCollider.FindObjectsOfType": {
		"prefix": "SphereCollider.FindObjectsOfType",
		"body": [
			"SphereCollider.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"SphereCollider.Instantiate": {
		"prefix": "SphereCollider.Instantiate",
		"body": [
			"SphereCollider.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"SphereCollider.OnCollisionEnter": {
		"prefix": "SphereCollider.OnCollisionEnter",
		"body": [
			"OnCollisionEnter"
		],
		"description": "OnCollisionEnter is called when this collider/rigidbody has begun touching another rigidbody/collider."
	}
,
	"SphereCollider.OnCollisionExit": {
		"prefix": "SphereCollider.OnCollisionExit",
		"body": [
			"OnCollisionExit"
		],
		"description": "OnCollisionExit is called when this collider/rigidbody has stopped touching another rigidbody/collider."
	}
,
	"SphereCollider.OnCollisionStay": {
		"prefix": "SphereCollider.OnCollisionStay",
		"body": [
			"OnCollisionStay"
		],
		"description": "OnCollisionStay is called once per frame for every collider/rigidbody that is touching rigidbody/collider."
	}
,
	"SphereCollider.OnTriggerEnter": {
		"prefix": "SphereCollider.OnTriggerEnter",
		"body": [
			"OnTriggerEnter"
		],
		"description": "OnTriggerEnter is called when the Collider other enters the trigger."
	}
,
	"SphereCollider.OnTriggerExit": {
		"prefix": "SphereCollider.OnTriggerExit",
		"body": [
			"OnTriggerExit"
		],
		"description": "OnTriggerExit is called when the Collider other has stopped touching the trigger."
	}
,
	"SphereCollider.OnTriggerStay": {
		"prefix": "SphereCollider.OnTriggerStay",
		"body": [
			"OnTriggerStay"
		],
		"description": "OnTriggerStay is called almost all the frames for every Collider other that is touching the trigger. The function is on the physics timer so it won't necessarily run every frame."
	}
,
	"SplatPrototype.metallic": {
		"prefix": "SplatPrototype.metallic",
		"body": [
			"metallic"
		],
		"description": "return:float des: The metallic value of the splat layer."
	}
,
	"SplatPrototype.normalMap": {
		"prefix": "SplatPrototype.normalMap",
		"body": [
			"normalMap"
		],
		"description": "return:Texture2D des: Normal map of the splat applied to the Terrain."
	}
,
	"SplatPrototype.smoothness": {
		"prefix": "SplatPrototype.smoothness",
		"body": [
			"smoothness"
		],
		"description": "return:float des: The smoothness value of the splat layer when the main texture has no alpha channel."
	}
,
	"SplatPrototype.texture": {
		"prefix": "SplatPrototype.texture",
		"body": [
			"texture"
		],
		"description": "return:Texture2D des: Texture of the splat applied to the Terrain."
	}
,
	"SplatPrototype.tileOffset": {
		"prefix": "SplatPrototype.tileOffset",
		"body": [
			"tileOffset"
		],
		"description": "return:Vector2 des: Offset of the tile texture of the SplatPrototype."
	}
,
	"SplatPrototype.tileSize": {
		"prefix": "SplatPrototype.tileSize",
		"body": [
			"tileSize"
		],
		"description": "return:Vector2 des: Size of the tile used in the texture of the SplatPrototype."
	}
,
	"SpringJoint.damper": {
		"prefix": "SpringJoint.damper",
		"body": [
			"damper"
		],
		"description": "return:float des: The damper force used to dampen the spring force."
	}
,
	"SpringJoint.maxDistance": {
		"prefix": "SpringJoint.maxDistance",
		"body": [
			"maxDistance"
		],
		"description": "return:float des: The maximum distance between the bodies relative to their initial distance."
	}
,
	"SpringJoint.minDistance": {
		"prefix": "SpringJoint.minDistance",
		"body": [
			"minDistance"
		],
		"description": "return:float des: The minimum distance between the bodies relative to their initial distance."
	}
,
	"SpringJoint.spring": {
		"prefix": "SpringJoint.spring",
		"body": [
			"spring"
		],
		"description": "return:float des: The spring force used to keep the two objects together."
	}
,
	"SpringJoint.tolerance": {
		"prefix": "SpringJoint.tolerance",
		"body": [
			"tolerance"
		],
		"description": "return:float des: The maximum allowed error between the current spring length and the length defined by minDistance and maxDistance."
	}
,
	"SpringJoint.gameObject": {
		"prefix": "SpringJoint.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"SpringJoint.tag": {
		"prefix": "SpringJoint.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"SpringJoint.transform": {
		"prefix": "SpringJoint.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"SpringJoint.anchor": {
		"prefix": "SpringJoint.anchor",
		"body": [
			"anchor"
		],
		"description": "return:Vector3 des: The Position of the anchor around which the joints motion is constrained."
	}
,
	"SpringJoint.autoConfigureConnectedAnchor": {
		"prefix": "SpringJoint.autoConfigureConnectedAnchor",
		"body": [
			"autoConfigureConnectedAnchor"
		],
		"description": "return:bool des: Should the connectedAnchor be calculated automatically?"
	}
,
	"SpringJoint.axis": {
		"prefix": "SpringJoint.axis",
		"body": [
			"axis"
		],
		"description": "return:Vector3 des: The Direction of the axis around which the body is constrained."
	}
,
	"SpringJoint.breakForce": {
		"prefix": "SpringJoint.breakForce",
		"body": [
			"breakForce"
		],
		"description": "return:float des: The force that needs to be applied for this joint to break."
	}
,
	"SpringJoint.breakTorque": {
		"prefix": "SpringJoint.breakTorque",
		"body": [
			"breakTorque"
		],
		"description": "return:float des: The torque that needs to be applied for this joint to break."
	}
,
	"SpringJoint.connectedAnchor": {
		"prefix": "SpringJoint.connectedAnchor",
		"body": [
			"connectedAnchor"
		],
		"description": "return:Vector3 des: Position of the anchor relative to the connected Rigidbody."
	}
,
	"SpringJoint.connectedBody": {
		"prefix": "SpringJoint.connectedBody",
		"body": [
			"connectedBody"
		],
		"description": "return:Rigidbody des: A reference to another rigidbody this joint connects to."
	}
,
	"SpringJoint.connectedMassScale": {
		"prefix": "SpringJoint.connectedMassScale",
		"body": [
			"connectedMassScale"
		],
		"description": "return:float des: The scale to apply to the inverse mass and inertia tensor of the connected body prior to solving the constraints."
	}
,
	"SpringJoint.currentForce": {
		"prefix": "SpringJoint.currentForce",
		"body": [
			"currentForce"
		],
		"description": "return:Vector3 des: The force applied by the solver to satisfy all constraints."
	}
,
	"SpringJoint.currentTorque": {
		"prefix": "SpringJoint.currentTorque",
		"body": [
			"currentTorque"
		],
		"description": "return:Vector3 des: The torque applied by the solver to satisfy all constraints."
	}
,
	"SpringJoint.enableCollision": {
		"prefix": "SpringJoint.enableCollision",
		"body": [
			"enableCollision"
		],
		"description": "return:bool des: Enable collision between bodies connected with the joint."
	}
,
	"SpringJoint.enablePreprocessing": {
		"prefix": "SpringJoint.enablePreprocessing",
		"body": [
			"enablePreprocessing"
		],
		"description": "return:bool des: Toggle preprocessing for this joint."
	}
,
	"SpringJoint.massScale": {
		"prefix": "SpringJoint.massScale",
		"body": [
			"massScale"
		],
		"description": "return:float des: The scale to apply to the inverse mass and inertia tensor of the body prior to solving the constraints."
	}
,
	"SpringJoint.hideFlags": {
		"prefix": "SpringJoint.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"SpringJoint.name": {
		"prefix": "SpringJoint.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"SpringJoint.BroadcastMessage": {
		"prefix": "SpringJoint.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"SpringJoint.CompareTag": {
		"prefix": "SpringJoint.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"SpringJoint.GetComponent": {
		"prefix": "SpringJoint.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"SpringJoint.GetComponentInChildren": {
		"prefix": "SpringJoint.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"SpringJoint.GetComponentInParent": {
		"prefix": "SpringJoint.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"SpringJoint.GetComponents": {
		"prefix": "SpringJoint.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"SpringJoint.GetComponentsInChildren": {
		"prefix": "SpringJoint.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"SpringJoint.GetComponentsInParent": {
		"prefix": "SpringJoint.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"SpringJoint.SendMessage": {
		"prefix": "SpringJoint.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"SpringJoint.SendMessageUpwards": {
		"prefix": "SpringJoint.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"SpringJoint.GetInstanceID": {
		"prefix": "SpringJoint.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"SpringJoint.ToString": {
		"prefix": "SpringJoint.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"SpringJoint.Destroy": {
		"prefix": "SpringJoint.Destroy",
		"body": [
			"SpringJoint.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"SpringJoint.DestroyImmediate": {
		"prefix": "SpringJoint.DestroyImmediate",
		"body": [
			"SpringJoint.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"SpringJoint.DontDestroyOnLoad": {
		"prefix": "SpringJoint.DontDestroyOnLoad",
		"body": [
			"SpringJoint.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"SpringJoint.FindObjectOfType": {
		"prefix": "SpringJoint.FindObjectOfType",
		"body": [
			"SpringJoint.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"SpringJoint.FindObjectsOfType": {
		"prefix": "SpringJoint.FindObjectsOfType",
		"body": [
			"SpringJoint.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"SpringJoint.Instantiate": {
		"prefix": "SpringJoint.Instantiate",
		"body": [
			"SpringJoint.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"SpringJoint.OnJointBreak": {
		"prefix": "SpringJoint.OnJointBreak",
		"body": [
			"OnJointBreak"
		],
		"description": "Called when a joint attached to the same game object broke."
	}
,
	"SpringJoint2D.autoConfigureDistance": {
		"prefix": "SpringJoint2D.autoConfigureDistance",
		"body": [
			"autoConfigureDistance"
		],
		"description": "return:bool des: Should the distance be calculated automatically?"
	}
,
	"SpringJoint2D.dampingRatio": {
		"prefix": "SpringJoint2D.dampingRatio",
		"body": [
			"dampingRatio"
		],
		"description": "return:float des: The amount by which the spring force is reduced in proportion to the movement speed."
	}
,
	"SpringJoint2D.distance": {
		"prefix": "SpringJoint2D.distance",
		"body": [
			"distance"
		],
		"description": "return:float des: The distance the spring will try to keep between the two objects."
	}
,
	"SpringJoint2D.frequency": {
		"prefix": "SpringJoint2D.frequency",
		"body": [
			"frequency"
		],
		"description": "return:float des: The frequency at which the spring oscillates around the distance distance between the objects."
	}
,
	"SpringJoint2D.anchor": {
		"prefix": "SpringJoint2D.anchor",
		"body": [
			"anchor"
		],
		"description": "return:Vector2 des: The joint's anchor point on the object that has the joint component."
	}
,
	"SpringJoint2D.autoConfigureConnectedAnchor": {
		"prefix": "SpringJoint2D.autoConfigureConnectedAnchor",
		"body": [
			"autoConfigureConnectedAnchor"
		],
		"description": "return:bool des: Should the connectedAnchor be calculated automatically?"
	}
,
	"SpringJoint2D.connectedAnchor": {
		"prefix": "SpringJoint2D.connectedAnchor",
		"body": [
			"connectedAnchor"
		],
		"description": "return:Vector2 des: The joint's anchor point on the second object (ie, the one which doesn't have the joint component)."
	}
,
	"SpringJoint2D.enabled": {
		"prefix": "SpringJoint2D.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"SpringJoint2D.isActiveAndEnabled": {
		"prefix": "SpringJoint2D.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"SpringJoint2D.gameObject": {
		"prefix": "SpringJoint2D.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"SpringJoint2D.tag": {
		"prefix": "SpringJoint2D.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"SpringJoint2D.transform": {
		"prefix": "SpringJoint2D.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"SpringJoint2D.attachedRigidbody": {
		"prefix": "SpringJoint2D.attachedRigidbody",
		"body": [
			"attachedRigidbody"
		],
		"description": "return:Rigidbody2D des: The Rigidbody2D attached to the Joint2D."
	}
,
	"SpringJoint2D.breakForce": {
		"prefix": "SpringJoint2D.breakForce",
		"body": [
			"breakForce"
		],
		"description": "return:float des: The force that needs to be applied for this joint to break."
	}
,
	"SpringJoint2D.breakTorque": {
		"prefix": "SpringJoint2D.breakTorque",
		"body": [
			"breakTorque"
		],
		"description": "return:float des: The torque that needs to be applied for this joint to break."
	}
,
	"SpringJoint2D.connectedBody": {
		"prefix": "SpringJoint2D.connectedBody",
		"body": [
			"connectedBody"
		],
		"description": "return:Rigidbody2D des: The Rigidbody2D object to which the other end of the joint is attached (ie, the object without the joint component)."
	}
,
	"SpringJoint2D.enableCollision": {
		"prefix": "SpringJoint2D.enableCollision",
		"body": [
			"enableCollision"
		],
		"description": "return:bool des: Should the two rigid bodies connected with this joint collide with each other?"
	}
,
	"SpringJoint2D.reactionForce": {
		"prefix": "SpringJoint2D.reactionForce",
		"body": [
			"reactionForce"
		],
		"description": "return:Vector2 des: Gets the reaction force of the joint."
	}
,
	"SpringJoint2D.reactionTorque": {
		"prefix": "SpringJoint2D.reactionTorque",
		"body": [
			"reactionTorque"
		],
		"description": "return:float des: Gets the reaction torque of the joint."
	}
,
	"SpringJoint2D.hideFlags": {
		"prefix": "SpringJoint2D.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"SpringJoint2D.name": {
		"prefix": "SpringJoint2D.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"SpringJoint2D.BroadcastMessage": {
		"prefix": "SpringJoint2D.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"SpringJoint2D.CompareTag": {
		"prefix": "SpringJoint2D.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"SpringJoint2D.GetComponent": {
		"prefix": "SpringJoint2D.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"SpringJoint2D.GetComponentInChildren": {
		"prefix": "SpringJoint2D.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"SpringJoint2D.GetComponentInParent": {
		"prefix": "SpringJoint2D.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"SpringJoint2D.GetComponents": {
		"prefix": "SpringJoint2D.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"SpringJoint2D.GetComponentsInChildren": {
		"prefix": "SpringJoint2D.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"SpringJoint2D.GetComponentsInParent": {
		"prefix": "SpringJoint2D.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"SpringJoint2D.SendMessage": {
		"prefix": "SpringJoint2D.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"SpringJoint2D.SendMessageUpwards": {
		"prefix": "SpringJoint2D.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"SpringJoint2D.GetReactionForce": {
		"prefix": "SpringJoint2D.GetReactionForce",
		"body": [
			"GetReactionForce($1)"
		],
		"description": "public Vector2 GetReactionForce(float timeStep); des: Gets the reaction force of the joint given the specified timeStep."
	}
,
	"SpringJoint2D.GetReactionTorque": {
		"prefix": "SpringJoint2D.GetReactionTorque",
		"body": [
			"GetReactionTorque($1)"
		],
		"description": "public float GetReactionTorque(float timeStep); des: Gets the reaction torque of the joint given the specified timeStep."
	}
,
	"SpringJoint2D.GetInstanceID": {
		"prefix": "SpringJoint2D.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"SpringJoint2D.ToString": {
		"prefix": "SpringJoint2D.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"SpringJoint2D.Destroy": {
		"prefix": "SpringJoint2D.Destroy",
		"body": [
			"SpringJoint2D.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"SpringJoint2D.DestroyImmediate": {
		"prefix": "SpringJoint2D.DestroyImmediate",
		"body": [
			"SpringJoint2D.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"SpringJoint2D.DontDestroyOnLoad": {
		"prefix": "SpringJoint2D.DontDestroyOnLoad",
		"body": [
			"SpringJoint2D.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"SpringJoint2D.FindObjectOfType": {
		"prefix": "SpringJoint2D.FindObjectOfType",
		"body": [
			"SpringJoint2D.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"SpringJoint2D.FindObjectsOfType": {
		"prefix": "SpringJoint2D.FindObjectsOfType",
		"body": [
			"SpringJoint2D.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"SpringJoint2D.Instantiate": {
		"prefix": "SpringJoint2D.Instantiate",
		"body": [
			"SpringJoint2D.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"SpringJoint2D.OnJointBreak2D": {
		"prefix": "SpringJoint2D.OnJointBreak2D",
		"body": [
			"OnJointBreak2D"
		],
		"description": "Called when a Joint2D attached to the same game object breaks."
	}
,
	"Sprite.associatedAlphaSplitTexture": {
		"prefix": "Sprite.associatedAlphaSplitTexture",
		"body": [
			"associatedAlphaSplitTexture"
		],
		"description": "return:Texture2D des: Returns the texture that contains the alpha channel from the source texture. Unity generates this texture under the hood for sprites that have alpha in the source, and need to be compressed using techniques like ETC1."
	}
,
	"Sprite.border": {
		"prefix": "Sprite.border",
		"body": [
			"border"
		],
		"description": "return:Vector4 des: Returns the border sizes of the sprite."
	}
,
	"Sprite.bounds": {
		"prefix": "Sprite.bounds",
		"body": [
			"bounds"
		],
		"description": "return:Bounds des: Bounds of the Sprite, specified by its center and extents in world space units."
	}
,
	"Sprite.packed": {
		"prefix": "Sprite.packed",
		"body": [
			"packed"
		],
		"description": "return:bool des: Returns true if this Sprite is packed in an atlas."
	}
,
	"Sprite.packingMode": {
		"prefix": "Sprite.packingMode",
		"body": [
			"packingMode"
		],
		"description": "return:SpritePackingMode des: If Sprite is packed (see Sprite.packed), returns its SpritePackingMode."
	}
,
	"Sprite.packingRotation": {
		"prefix": "Sprite.packingRotation",
		"body": [
			"packingRotation"
		],
		"description": "return:SpritePackingRotation des: If Sprite is packed (see Sprite.packed), returns its SpritePackingRotation."
	}
,
	"Sprite.pivot": {
		"prefix": "Sprite.pivot",
		"body": [
			"pivot"
		],
		"description": "return:Vector2 des: Location of the Sprite's center point in the Rect on the original Texture, specified in pixels."
	}
,
	"Sprite.pixelsPerUnit": {
		"prefix": "Sprite.pixelsPerUnit",
		"body": [
			"pixelsPerUnit"
		],
		"description": "return:float des: The number of pixels in the sprite that correspond to one unit in world space. (Read Only)"
	}
,
	"Sprite.rect": {
		"prefix": "Sprite.rect",
		"body": [
			"rect"
		],
		"description": "return:Rect des: Location of the Sprite on the original Texture, specified in pixels."
	}
,
	"Sprite.texture": {
		"prefix": "Sprite.texture",
		"body": [
			"texture"
		],
		"description": "return:Texture2D des: Get the reference to the used texture. If packed this will point to the atlas, if not packed will point to the source sprite."
	}
,
	"Sprite.textureRect": {
		"prefix": "Sprite.textureRect",
		"body": [
			"textureRect"
		],
		"description": "return:Rect des: Get the rectangle this sprite uses on its texture. Raises an exception if this sprite is tightly packed in an atlas."
	}
,
	"Sprite.textureRectOffset": {
		"prefix": "Sprite.textureRectOffset",
		"body": [
			"textureRectOffset"
		],
		"description": "return:Vector2 des: Gets the offset of the rectangle this sprite uses on its texture to the original sprite bounds. If sprite mesh type is FullRect, offset is zero."
	}
,
	"Sprite.triangles": {
		"prefix": "Sprite.triangles",
		"body": [
			"triangles"
		],
		"description": "return:ushort[] des: Returns a copy of the array containing sprite mesh triangles."
	}
,
	"Sprite.uv": {
		"prefix": "Sprite.uv",
		"body": [
			"uv"
		],
		"description": "return:Vector2[] des: The base texture coordinates of the sprite mesh."
	}
,
	"Sprite.vertices": {
		"prefix": "Sprite.vertices",
		"body": [
			"vertices"
		],
		"description": "return:Vector2[] des: Returns a copy of the array containing sprite mesh vertex positions."
	}
,
	"Sprite.GetPhysicsShape": {
		"prefix": "Sprite.GetPhysicsShape",
		"body": [
			"GetPhysicsShape($1)"
		],
		"description": "public int GetPhysicsShape(int shapeIdx, List<Vector2> physicsShape); des: Gets a physics shape from the Sprite by its index."
	}
,
	"Sprite.GetPhysicsShapeCount": {
		"prefix": "Sprite.GetPhysicsShapeCount",
		"body": [
			"GetPhysicsShapeCount($1)"
		],
		"description": "public int GetPhysicsShapeCount(); des: The number of physics shapes for the Sprite."
	}
,
	"Sprite.GetPhysicsShapePointCount": {
		"prefix": "Sprite.GetPhysicsShapePointCount",
		"body": [
			"GetPhysicsShapePointCount($1)"
		],
		"description": "public int GetPhysicsShapePointCount(int shapeIdx); des: The number of points in the selected physics shape for the Sprite."
	}
,
	"Sprite.OverrideGeometry": {
		"prefix": "Sprite.OverrideGeometry",
		"body": [
			"OverrideGeometry($1)"
		],
		"description": "public void OverrideGeometry(Vector2[] vertices, ushort[] triangles); des: Sets up new Sprite geometry."
	}
,
	"Sprite.OverridePhysicsShape": {
		"prefix": "Sprite.OverridePhysicsShape",
		"body": [
			"OverridePhysicsShape($1)"
		],
		"description": "public void OverridePhysicsShape(IList<Vector2[]> physicsShapes); des: Sets up a new Sprite physics shape."
	}
,
	"Sprite.Create": {
		"prefix": "Sprite.Create",
		"body": [
			"Sprite.Create"
		],
		"description": "public static Sprite Create(Texture2D texture, Rect rect, Vector2 pivot, float pixelsPerUnit, uint extrude); public static Sprite Create(Texture2D texture, Rect rect, Vector2 pivot, float pixelsPerUnit, uint extrude, SpriteMeshType meshType); public static Sprite Create(Texture2D texture, Rect rect, Vector2 pivot, float pixelsPerUnit, uint extrude, SpriteMeshType meshType, Vector4 border, bool generateFallbackPhysicsShape); public static Sprite Create(Texture2D texture, Rect rect, Vector2 pivot, float pixelsPerUnit, uint extrude, SpriteMeshType meshType, Vector4 border); public static Sprite Create(Texture2D texture, Rect rect, Vector2 pivot); public static Sprite Create(Texture2D texture, Rect rect, Vector2 pivot, float pixelsPerUnit); des: Create a new Sprite object."
	}
,
	"Sprite.hideFlags": {
		"prefix": "Sprite.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Sprite.name": {
		"prefix": "Sprite.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Sprite.GetInstanceID": {
		"prefix": "Sprite.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Sprite.ToString": {
		"prefix": "Sprite.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Sprite.Destroy": {
		"prefix": "Sprite.Destroy",
		"body": [
			"Sprite.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Sprite.DestroyImmediate": {
		"prefix": "Sprite.DestroyImmediate",
		"body": [
			"Sprite.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Sprite.DontDestroyOnLoad": {
		"prefix": "Sprite.DontDestroyOnLoad",
		"body": [
			"Sprite.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Sprite.FindObjectOfType": {
		"prefix": "Sprite.FindObjectOfType",
		"body": [
			"Sprite.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Sprite.FindObjectsOfType": {
		"prefix": "Sprite.FindObjectsOfType",
		"body": [
			"Sprite.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Sprite.Instantiate": {
		"prefix": "Sprite.Instantiate",
		"body": [
			"Sprite.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"SpriteMask.alphaCutoff": {
		"prefix": "SpriteMask.alphaCutoff",
		"body": [
			"alphaCutoff"
		],
		"description": "return:float des: The minimum alpha value used by the mask to select the area of influence defined over the mask's sprite."
	}
,
	"SpriteMask.backSortingLayerID": {
		"prefix": "SpriteMask.backSortingLayerID",
		"body": [
			"backSortingLayerID"
		],
		"description": "return:int des: Unique ID of the sorting layer defining the end of the custom range."
	}
,
	"SpriteMask.backSortingOrder": {
		"prefix": "SpriteMask.backSortingOrder",
		"body": [
			"backSortingOrder"
		],
		"description": "return:int des: Order within the back sorting layer defining the end of the custom range."
	}
,
	"SpriteMask.frontSortingLayerID": {
		"prefix": "SpriteMask.frontSortingLayerID",
		"body": [
			"frontSortingLayerID"
		],
		"description": "return:int des: Unique ID of the sorting layer defining the start of the custom range."
	}
,
	"SpriteMask.frontSortingOrder": {
		"prefix": "SpriteMask.frontSortingOrder",
		"body": [
			"frontSortingOrder"
		],
		"description": "return:int des: Order within the front sorting layer defining the start of the custom range."
	}
,
	"SpriteMask.isCustomRangeActive": {
		"prefix": "SpriteMask.isCustomRangeActive",
		"body": [
			"isCustomRangeActive"
		],
		"description": "return:bool des: Mask sprites from front to back sorting values only."
	}
,
	"SpriteMask.sprite": {
		"prefix": "SpriteMask.sprite",
		"body": [
			"sprite"
		],
		"description": "return:Sprite des: The Sprite used to define the mask."
	}
,
	"SpriteMask.spriteSortPoint": {
		"prefix": "SpriteMask.spriteSortPoint",
		"body": [
			"spriteSortPoint"
		],
		"description": "return:SpriteSortPoint des: Determines the position of the Sprite used for sorting the SpriteMask."
	}
,
	"SpriteMask.gameObject": {
		"prefix": "SpriteMask.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"SpriteMask.tag": {
		"prefix": "SpriteMask.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"SpriteMask.transform": {
		"prefix": "SpriteMask.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"SpriteMask.hideFlags": {
		"prefix": "SpriteMask.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"SpriteMask.name": {
		"prefix": "SpriteMask.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"SpriteMask.allowOcclusionWhenDynamic": {
		"prefix": "SpriteMask.allowOcclusionWhenDynamic",
		"body": [
			"allowOcclusionWhenDynamic"
		],
		"description": "return:bool des: Controls if dynamic occlusion culling should be performed for this renderer."
	}
,
	"SpriteMask.bounds": {
		"prefix": "SpriteMask.bounds",
		"body": [
			"bounds"
		],
		"description": "return:Bounds des: The bounding volume of the renderer (Read Only)."
	}
,
	"SpriteMask.enabled": {
		"prefix": "SpriteMask.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Makes the rendered 3D object visible if enabled."
	}
,
	"SpriteMask.isPartOfStaticBatch": {
		"prefix": "SpriteMask.isPartOfStaticBatch",
		"body": [
			"isPartOfStaticBatch"
		],
		"description": "return:bool des: Has this renderer been statically batched with any other renderers?"
	}
,
	"SpriteMask.isVisible": {
		"prefix": "SpriteMask.isVisible",
		"body": [
			"isVisible"
		],
		"description": "return:bool des: Is this renderer visible in any camera? (Read Only)"
	}
,
	"SpriteMask.lightmapIndex": {
		"prefix": "SpriteMask.lightmapIndex",
		"body": [
			"lightmapIndex"
		],
		"description": "return:int des: The index of the baked lightmap applied to this renderer."
	}
,
	"SpriteMask.lightmapScaleOffset": {
		"prefix": "SpriteMask.lightmapScaleOffset",
		"body": [
			"lightmapScaleOffset"
		],
		"description": "return:Vector4 des: The UV scale & offset used for a lightmap."
	}
,
	"SpriteMask.lightProbeProxyVolumeOverride": {
		"prefix": "SpriteMask.lightProbeProxyVolumeOverride",
		"body": [
			"lightProbeProxyVolumeOverride"
		],
		"description": "return:GameObject des: If set, the Renderer will use the Light Probe Proxy Volume component attached to the source GameObject."
	}
,
	"SpriteMask.lightProbeUsage": {
		"prefix": "SpriteMask.lightProbeUsage",
		"body": [
			"lightProbeUsage"
		],
		"description": "return:Rendering.LightProbeUsage des: The light probe interpolation type."
	}
,
	"SpriteMask.localToWorldMatrix": {
		"prefix": "SpriteMask.localToWorldMatrix",
		"body": [
			"localToWorldMatrix"
		],
		"description": "return:Matrix4x4 des: Matrix that transforms a point from local space into world space (Read Only)."
	}
,
	"SpriteMask.material": {
		"prefix": "SpriteMask.material",
		"body": [
			"material"
		],
		"description": "return:Material des: Returns the first instantiated Material assigned to the renderer."
	}
,
	"SpriteMask.materials": {
		"prefix": "SpriteMask.materials",
		"body": [
			"materials"
		],
		"description": "return:Material[] des: Returns all the instantiated materials of this object."
	}
,
	"SpriteMask.motionVectorGenerationMode": {
		"prefix": "SpriteMask.motionVectorGenerationMode",
		"body": [
			"motionVectorGenerationMode"
		],
		"description": "return:MotionVectorGenerationMode des: Specifies the mode for motion vector rendering."
	}
,
	"SpriteMask.probeAnchor": {
		"prefix": "SpriteMask.probeAnchor",
		"body": [
			"probeAnchor"
		],
		"description": "return:Transform des: If set, Renderer will use this Transform's position to find the light or reflection probe."
	}
,
	"SpriteMask.realtimeLightmapIndex": {
		"prefix": "SpriteMask.realtimeLightmapIndex",
		"body": [
			"realtimeLightmapIndex"
		],
		"description": "return:int des: The index of the realtime lightmap applied to this renderer."
	}
,
	"SpriteMask.realtimeLightmapScaleOffset": {
		"prefix": "SpriteMask.realtimeLightmapScaleOffset",
		"body": [
			"realtimeLightmapScaleOffset"
		],
		"description": "return:Vector4 des: The UV scale & offset used for a realtime lightmap."
	}
,
	"SpriteMask.receiveShadows": {
		"prefix": "SpriteMask.receiveShadows",
		"body": [
			"receiveShadows"
		],
		"description": "return:bool des: Does this object receive shadows?"
	}
,
	"SpriteMask.reflectionProbeUsage": {
		"prefix": "SpriteMask.reflectionProbeUsage",
		"body": [
			"reflectionProbeUsage"
		],
		"description": "return:Rendering.ReflectionProbeUsage des: Should reflection probes be used for this Renderer?"
	}
,
	"SpriteMask.renderingLayerMask": {
		"prefix": "SpriteMask.renderingLayerMask",
		"body": [
			"renderingLayerMask"
		],
		"description": "return:uint des: Determines which rendering layer this renderer lives on."
	}
,
	"SpriteMask.shadowCastingMode": {
		"prefix": "SpriteMask.shadowCastingMode",
		"body": [
			"shadowCastingMode"
		],
		"description": "return:Rendering.ShadowCastingMode des: Does this object cast shadows?"
	}
,
	"SpriteMask.sharedMaterial": {
		"prefix": "SpriteMask.sharedMaterial",
		"body": [
			"sharedMaterial"
		],
		"description": "return:Material des: The shared material of this object."
	}
,
	"SpriteMask.sharedMaterials": {
		"prefix": "SpriteMask.sharedMaterials",
		"body": [
			"sharedMaterials"
		],
		"description": "return:Material[] des: All the shared materials of this object."
	}
,
	"SpriteMask.sortingLayerID": {
		"prefix": "SpriteMask.sortingLayerID",
		"body": [
			"sortingLayerID"
		],
		"description": "return:int des: Unique ID of the Renderer's sorting layer."
	}
,
	"SpriteMask.sortingLayerName": {
		"prefix": "SpriteMask.sortingLayerName",
		"body": [
			"sortingLayerName"
		],
		"description": "return:string des: Name of the Renderer's sorting layer."
	}
,
	"SpriteMask.sortingOrder": {
		"prefix": "SpriteMask.sortingOrder",
		"body": [
			"sortingOrder"
		],
		"description": "return:int des: Renderer's order within a sorting layer."
	}
,
	"SpriteMask.worldToLocalMatrix": {
		"prefix": "SpriteMask.worldToLocalMatrix",
		"body": [
			"worldToLocalMatrix"
		],
		"description": "return:Matrix4x4 des: Matrix that transforms a point from world space into local space (Read Only)."
	}
,
	"SpriteMask.BroadcastMessage": {
		"prefix": "SpriteMask.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"SpriteMask.CompareTag": {
		"prefix": "SpriteMask.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"SpriteMask.GetComponent": {
		"prefix": "SpriteMask.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"SpriteMask.GetComponentInChildren": {
		"prefix": "SpriteMask.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"SpriteMask.GetComponentInParent": {
		"prefix": "SpriteMask.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"SpriteMask.GetComponents": {
		"prefix": "SpriteMask.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"SpriteMask.GetComponentsInChildren": {
		"prefix": "SpriteMask.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"SpriteMask.GetComponentsInParent": {
		"prefix": "SpriteMask.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"SpriteMask.SendMessage": {
		"prefix": "SpriteMask.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"SpriteMask.SendMessageUpwards": {
		"prefix": "SpriteMask.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"SpriteMask.GetInstanceID": {
		"prefix": "SpriteMask.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"SpriteMask.ToString": {
		"prefix": "SpriteMask.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"SpriteMask.GetClosestReflectionProbes": {
		"prefix": "SpriteMask.GetClosestReflectionProbes",
		"body": [
			"GetClosestReflectionProbes($1)"
		],
		"description": "public void GetClosestReflectionProbes(List<ReflectionProbeBlendInfo> result); des: Returns an array of closest reflection probes with weights, weight shows how much influence the probe has on the renderer, this value is also used when blending between reflection probes occur."
	}
,
	"SpriteMask.GetMaterials": {
		"prefix": "SpriteMask.GetMaterials",
		"body": [
			"GetMaterials($1)"
		],
		"description": "public void GetMaterials(List<Material> m); des: Returns all the instantiated materials of this object."
	}
,
	"SpriteMask.GetPropertyBlock": {
		"prefix": "SpriteMask.GetPropertyBlock",
		"body": [
			"GetPropertyBlock($1)"
		],
		"description": "public void GetPropertyBlock(MaterialPropertyBlock properties); public void GetPropertyBlock(MaterialPropertyBlock properties, int materialIndex); des: Get per-Renderer or per-Material property block."
	}
,
	"SpriteMask.GetSharedMaterials": {
		"prefix": "SpriteMask.GetSharedMaterials",
		"body": [
			"GetSharedMaterials($1)"
		],
		"description": "public void GetSharedMaterials(List<Material> m); des: Returns all the shared materials of this object."
	}
,
	"SpriteMask.HasPropertyBlock": {
		"prefix": "SpriteMask.HasPropertyBlock",
		"body": [
			"HasPropertyBlock($1)"
		],
		"description": "public bool HasPropertyBlock(); des: Returns true if the Renderer has a material property block attached via SetPropertyBlock."
	}
,
	"SpriteMask.SetPropertyBlock": {
		"prefix": "SpriteMask.SetPropertyBlock",
		"body": [
			"SetPropertyBlock($1)"
		],
		"description": "public void SetPropertyBlock(MaterialPropertyBlock properties); public void SetPropertyBlock(MaterialPropertyBlock properties, int materialIndex); des: Lets you set or clear per-renderer or per-material parameter overrides."
	}
,
	"SpriteMask.Destroy": {
		"prefix": "SpriteMask.Destroy",
		"body": [
			"SpriteMask.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"SpriteMask.DestroyImmediate": {
		"prefix": "SpriteMask.DestroyImmediate",
		"body": [
			"SpriteMask.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"SpriteMask.DontDestroyOnLoad": {
		"prefix": "SpriteMask.DontDestroyOnLoad",
		"body": [
			"SpriteMask.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"SpriteMask.FindObjectOfType": {
		"prefix": "SpriteMask.FindObjectOfType",
		"body": [
			"SpriteMask.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"SpriteMask.FindObjectsOfType": {
		"prefix": "SpriteMask.FindObjectsOfType",
		"body": [
			"SpriteMask.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"SpriteMask.Instantiate": {
		"prefix": "SpriteMask.Instantiate",
		"body": [
			"SpriteMask.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"SpriteMask.OnBecameInvisible": {
		"prefix": "SpriteMask.OnBecameInvisible",
		"body": [
			"OnBecameInvisible"
		],
		"description": "OnBecameInvisible is called when the object is no longer visible by any camera."
	}
,
	"SpriteMask.OnBecameVisible": {
		"prefix": "SpriteMask.OnBecameVisible",
		"body": [
			"OnBecameVisible"
		],
		"description": "OnBecameVisible is called when the object became visible by any camera."
	}
,
	"SpriteRenderer.adaptiveModeThreshold": {
		"prefix": "SpriteRenderer.adaptiveModeThreshold",
		"body": [
			"adaptiveModeThreshold"
		],
		"description": "return:float des: The current threshold for Sprite Renderer tiling."
	}
,
	"SpriteRenderer.color": {
		"prefix": "SpriteRenderer.color",
		"body": [
			"color"
		],
		"description": "return:Color des: Rendering color for the Sprite graphic."
	}
,
	"SpriteRenderer.drawMode": {
		"prefix": "SpriteRenderer.drawMode",
		"body": [
			"drawMode"
		],
		"description": "return:SpriteDrawMode des: The current draw mode of the Sprite Renderer."
	}
,
	"SpriteRenderer.flipX": {
		"prefix": "SpriteRenderer.flipX",
		"body": [
			"flipX"
		],
		"description": "return:bool des: Flips the sprite on the X axis."
	}
,
	"SpriteRenderer.flipY": {
		"prefix": "SpriteRenderer.flipY",
		"body": [
			"flipY"
		],
		"description": "return:bool des: Flips the sprite on the Y axis."
	}
,
	"SpriteRenderer.maskInteraction": {
		"prefix": "SpriteRenderer.maskInteraction",
		"body": [
			"maskInteraction"
		],
		"description": "return:SpriteMaskInteraction des: Specifies how the sprite interacts with the masks."
	}
,
	"SpriteRenderer.size": {
		"prefix": "SpriteRenderer.size",
		"body": [
			"size"
		],
		"description": "return:Vector2 des: Property to set/get the size to render when the SpriteRenderer.drawMode is set to SpriteDrawMode.Sliced."
	}
,
	"SpriteRenderer.sprite": {
		"prefix": "SpriteRenderer.sprite",
		"body": [
			"sprite"
		],
		"description": "return:Sprite des: The Sprite to render."
	}
,
	"SpriteRenderer.spriteSortPoint": {
		"prefix": "SpriteRenderer.spriteSortPoint",
		"body": [
			"spriteSortPoint"
		],
		"description": "return:SpriteSortPoint des: Determines the position of the Sprite used for sorting the SpriteRenderer."
	}
,
	"SpriteRenderer.tileMode": {
		"prefix": "SpriteRenderer.tileMode",
		"body": [
			"tileMode"
		],
		"description": "return:SpriteTileMode des: The current tile mode of the Sprite Renderer."
	}
,
	"SpriteRenderer.gameObject": {
		"prefix": "SpriteRenderer.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"SpriteRenderer.tag": {
		"prefix": "SpriteRenderer.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"SpriteRenderer.transform": {
		"prefix": "SpriteRenderer.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"SpriteRenderer.hideFlags": {
		"prefix": "SpriteRenderer.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"SpriteRenderer.name": {
		"prefix": "SpriteRenderer.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"SpriteRenderer.allowOcclusionWhenDynamic": {
		"prefix": "SpriteRenderer.allowOcclusionWhenDynamic",
		"body": [
			"allowOcclusionWhenDynamic"
		],
		"description": "return:bool des: Controls if dynamic occlusion culling should be performed for this renderer."
	}
,
	"SpriteRenderer.bounds": {
		"prefix": "SpriteRenderer.bounds",
		"body": [
			"bounds"
		],
		"description": "return:Bounds des: The bounding volume of the renderer (Read Only)."
	}
,
	"SpriteRenderer.enabled": {
		"prefix": "SpriteRenderer.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Makes the rendered 3D object visible if enabled."
	}
,
	"SpriteRenderer.isPartOfStaticBatch": {
		"prefix": "SpriteRenderer.isPartOfStaticBatch",
		"body": [
			"isPartOfStaticBatch"
		],
		"description": "return:bool des: Has this renderer been statically batched with any other renderers?"
	}
,
	"SpriteRenderer.isVisible": {
		"prefix": "SpriteRenderer.isVisible",
		"body": [
			"isVisible"
		],
		"description": "return:bool des: Is this renderer visible in any camera? (Read Only)"
	}
,
	"SpriteRenderer.lightmapIndex": {
		"prefix": "SpriteRenderer.lightmapIndex",
		"body": [
			"lightmapIndex"
		],
		"description": "return:int des: The index of the baked lightmap applied to this renderer."
	}
,
	"SpriteRenderer.lightmapScaleOffset": {
		"prefix": "SpriteRenderer.lightmapScaleOffset",
		"body": [
			"lightmapScaleOffset"
		],
		"description": "return:Vector4 des: The UV scale & offset used for a lightmap."
	}
,
	"SpriteRenderer.lightProbeProxyVolumeOverride": {
		"prefix": "SpriteRenderer.lightProbeProxyVolumeOverride",
		"body": [
			"lightProbeProxyVolumeOverride"
		],
		"description": "return:GameObject des: If set, the Renderer will use the Light Probe Proxy Volume component attached to the source GameObject."
	}
,
	"SpriteRenderer.lightProbeUsage": {
		"prefix": "SpriteRenderer.lightProbeUsage",
		"body": [
			"lightProbeUsage"
		],
		"description": "return:Rendering.LightProbeUsage des: The light probe interpolation type."
	}
,
	"SpriteRenderer.localToWorldMatrix": {
		"prefix": "SpriteRenderer.localToWorldMatrix",
		"body": [
			"localToWorldMatrix"
		],
		"description": "return:Matrix4x4 des: Matrix that transforms a point from local space into world space (Read Only)."
	}
,
	"SpriteRenderer.material": {
		"prefix": "SpriteRenderer.material",
		"body": [
			"material"
		],
		"description": "return:Material des: Returns the first instantiated Material assigned to the renderer."
	}
,
	"SpriteRenderer.materials": {
		"prefix": "SpriteRenderer.materials",
		"body": [
			"materials"
		],
		"description": "return:Material[] des: Returns all the instantiated materials of this object."
	}
,
	"SpriteRenderer.motionVectorGenerationMode": {
		"prefix": "SpriteRenderer.motionVectorGenerationMode",
		"body": [
			"motionVectorGenerationMode"
		],
		"description": "return:MotionVectorGenerationMode des: Specifies the mode for motion vector rendering."
	}
,
	"SpriteRenderer.probeAnchor": {
		"prefix": "SpriteRenderer.probeAnchor",
		"body": [
			"probeAnchor"
		],
		"description": "return:Transform des: If set, Renderer will use this Transform's position to find the light or reflection probe."
	}
,
	"SpriteRenderer.realtimeLightmapIndex": {
		"prefix": "SpriteRenderer.realtimeLightmapIndex",
		"body": [
			"realtimeLightmapIndex"
		],
		"description": "return:int des: The index of the realtime lightmap applied to this renderer."
	}
,
	"SpriteRenderer.realtimeLightmapScaleOffset": {
		"prefix": "SpriteRenderer.realtimeLightmapScaleOffset",
		"body": [
			"realtimeLightmapScaleOffset"
		],
		"description": "return:Vector4 des: The UV scale & offset used for a realtime lightmap."
	}
,
	"SpriteRenderer.receiveShadows": {
		"prefix": "SpriteRenderer.receiveShadows",
		"body": [
			"receiveShadows"
		],
		"description": "return:bool des: Does this object receive shadows?"
	}
,
	"SpriteRenderer.reflectionProbeUsage": {
		"prefix": "SpriteRenderer.reflectionProbeUsage",
		"body": [
			"reflectionProbeUsage"
		],
		"description": "return:Rendering.ReflectionProbeUsage des: Should reflection probes be used for this Renderer?"
	}
,
	"SpriteRenderer.renderingLayerMask": {
		"prefix": "SpriteRenderer.renderingLayerMask",
		"body": [
			"renderingLayerMask"
		],
		"description": "return:uint des: Determines which rendering layer this renderer lives on."
	}
,
	"SpriteRenderer.shadowCastingMode": {
		"prefix": "SpriteRenderer.shadowCastingMode",
		"body": [
			"shadowCastingMode"
		],
		"description": "return:Rendering.ShadowCastingMode des: Does this object cast shadows?"
	}
,
	"SpriteRenderer.sharedMaterial": {
		"prefix": "SpriteRenderer.sharedMaterial",
		"body": [
			"sharedMaterial"
		],
		"description": "return:Material des: The shared material of this object."
	}
,
	"SpriteRenderer.sharedMaterials": {
		"prefix": "SpriteRenderer.sharedMaterials",
		"body": [
			"sharedMaterials"
		],
		"description": "return:Material[] des: All the shared materials of this object."
	}
,
	"SpriteRenderer.sortingLayerID": {
		"prefix": "SpriteRenderer.sortingLayerID",
		"body": [
			"sortingLayerID"
		],
		"description": "return:int des: Unique ID of the Renderer's sorting layer."
	}
,
	"SpriteRenderer.sortingLayerName": {
		"prefix": "SpriteRenderer.sortingLayerName",
		"body": [
			"sortingLayerName"
		],
		"description": "return:string des: Name of the Renderer's sorting layer."
	}
,
	"SpriteRenderer.sortingOrder": {
		"prefix": "SpriteRenderer.sortingOrder",
		"body": [
			"sortingOrder"
		],
		"description": "return:int des: Renderer's order within a sorting layer."
	}
,
	"SpriteRenderer.worldToLocalMatrix": {
		"prefix": "SpriteRenderer.worldToLocalMatrix",
		"body": [
			"worldToLocalMatrix"
		],
		"description": "return:Matrix4x4 des: Matrix that transforms a point from world space into local space (Read Only)."
	}
,
	"SpriteRenderer.BroadcastMessage": {
		"prefix": "SpriteRenderer.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"SpriteRenderer.CompareTag": {
		"prefix": "SpriteRenderer.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"SpriteRenderer.GetComponent": {
		"prefix": "SpriteRenderer.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"SpriteRenderer.GetComponentInChildren": {
		"prefix": "SpriteRenderer.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"SpriteRenderer.GetComponentInParent": {
		"prefix": "SpriteRenderer.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"SpriteRenderer.GetComponents": {
		"prefix": "SpriteRenderer.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"SpriteRenderer.GetComponentsInChildren": {
		"prefix": "SpriteRenderer.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"SpriteRenderer.GetComponentsInParent": {
		"prefix": "SpriteRenderer.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"SpriteRenderer.SendMessage": {
		"prefix": "SpriteRenderer.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"SpriteRenderer.SendMessageUpwards": {
		"prefix": "SpriteRenderer.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"SpriteRenderer.GetInstanceID": {
		"prefix": "SpriteRenderer.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"SpriteRenderer.ToString": {
		"prefix": "SpriteRenderer.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"SpriteRenderer.GetClosestReflectionProbes": {
		"prefix": "SpriteRenderer.GetClosestReflectionProbes",
		"body": [
			"GetClosestReflectionProbes($1)"
		],
		"description": "public void GetClosestReflectionProbes(List<ReflectionProbeBlendInfo> result); des: Returns an array of closest reflection probes with weights, weight shows how much influence the probe has on the renderer, this value is also used when blending between reflection probes occur."
	}
,
	"SpriteRenderer.GetMaterials": {
		"prefix": "SpriteRenderer.GetMaterials",
		"body": [
			"GetMaterials($1)"
		],
		"description": "public void GetMaterials(List<Material> m); des: Returns all the instantiated materials of this object."
	}
,
	"SpriteRenderer.GetPropertyBlock": {
		"prefix": "SpriteRenderer.GetPropertyBlock",
		"body": [
			"GetPropertyBlock($1)"
		],
		"description": "public void GetPropertyBlock(MaterialPropertyBlock properties); public void GetPropertyBlock(MaterialPropertyBlock properties, int materialIndex); des: Get per-Renderer or per-Material property block."
	}
,
	"SpriteRenderer.GetSharedMaterials": {
		"prefix": "SpriteRenderer.GetSharedMaterials",
		"body": [
			"GetSharedMaterials($1)"
		],
		"description": "public void GetSharedMaterials(List<Material> m); des: Returns all the shared materials of this object."
	}
,
	"SpriteRenderer.HasPropertyBlock": {
		"prefix": "SpriteRenderer.HasPropertyBlock",
		"body": [
			"HasPropertyBlock($1)"
		],
		"description": "public bool HasPropertyBlock(); des: Returns true if the Renderer has a material property block attached via SetPropertyBlock."
	}
,
	"SpriteRenderer.SetPropertyBlock": {
		"prefix": "SpriteRenderer.SetPropertyBlock",
		"body": [
			"SetPropertyBlock($1)"
		],
		"description": "public void SetPropertyBlock(MaterialPropertyBlock properties); public void SetPropertyBlock(MaterialPropertyBlock properties, int materialIndex); des: Lets you set or clear per-renderer or per-material parameter overrides."
	}
,
	"SpriteRenderer.Destroy": {
		"prefix": "SpriteRenderer.Destroy",
		"body": [
			"SpriteRenderer.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"SpriteRenderer.DestroyImmediate": {
		"prefix": "SpriteRenderer.DestroyImmediate",
		"body": [
			"SpriteRenderer.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"SpriteRenderer.DontDestroyOnLoad": {
		"prefix": "SpriteRenderer.DontDestroyOnLoad",
		"body": [
			"SpriteRenderer.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"SpriteRenderer.FindObjectOfType": {
		"prefix": "SpriteRenderer.FindObjectOfType",
		"body": [
			"SpriteRenderer.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"SpriteRenderer.FindObjectsOfType": {
		"prefix": "SpriteRenderer.FindObjectsOfType",
		"body": [
			"SpriteRenderer.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"SpriteRenderer.Instantiate": {
		"prefix": "SpriteRenderer.Instantiate",
		"body": [
			"SpriteRenderer.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"SpriteRenderer.OnBecameInvisible": {
		"prefix": "SpriteRenderer.OnBecameInvisible",
		"body": [
			"OnBecameInvisible"
		],
		"description": "OnBecameInvisible is called when the object is no longer visible by any camera."
	}
,
	"SpriteRenderer.OnBecameVisible": {
		"prefix": "SpriteRenderer.OnBecameVisible",
		"body": [
			"OnBecameVisible"
		],
		"description": "OnBecameVisible is called when the object became visible by any camera."
	}
,
	"StateMachineBehaviour.OnStateMachineEnter": {
		"prefix": "StateMachineBehaviour.OnStateMachineEnter",
		"body": [
			"OnStateMachineEnter($1)"
		],
		"description": "public void OnStateMachineEnter(Animator animator, int stateMachinePathHash); des: Called on the first Update frame when making a transition to a StateMachine. This is not called when making a transition into a StateMachine sub-state."
	}
,
	"StateMachineBehaviour.OnStateMachineExit": {
		"prefix": "StateMachineBehaviour.OnStateMachineExit",
		"body": [
			"OnStateMachineExit($1)"
		],
		"description": "public void OnStateMachineExit(Animator animator, int stateMachinePathHash); des: Called on the last Update frame when making a transition out of a StateMachine. This is not called when making a transition into a StateMachine sub-state."
	}
,
	"StateMachineBehaviour.OnStateEnter": {
		"prefix": "StateMachineBehaviour.OnStateEnter",
		"body": [
			"OnStateEnter"
		],
		"description": "Called on the first Update frame when a statemachine evaluate this state."
	}
,
	"StateMachineBehaviour.OnStateExit": {
		"prefix": "StateMachineBehaviour.OnStateExit",
		"body": [
			"OnStateExit"
		],
		"description": "Called on the last update frame when a statemachine evaluate this state."
	}
,
	"StateMachineBehaviour.OnStateIK": {
		"prefix": "StateMachineBehaviour.OnStateIK",
		"body": [
			"OnStateIK"
		],
		"description": "Called right after MonoBehaviour.OnAnimatorIK."
	}
,
	"StateMachineBehaviour.OnStateMove": {
		"prefix": "StateMachineBehaviour.OnStateMove",
		"body": [
			"OnStateMove"
		],
		"description": "Called right after MonoBehaviour.OnAnimatorMove."
	}
,
	"StateMachineBehaviour.OnStateUpdate": {
		"prefix": "StateMachineBehaviour.OnStateUpdate",
		"body": [
			"OnStateUpdate"
		],
		"description": "Called at each Update frame except for the first and last frame."
	}
,
	"StateMachineBehaviour.hideFlags": {
		"prefix": "StateMachineBehaviour.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"StateMachineBehaviour.name": {
		"prefix": "StateMachineBehaviour.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"StateMachineBehaviour.GetInstanceID": {
		"prefix": "StateMachineBehaviour.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"StateMachineBehaviour.ToString": {
		"prefix": "StateMachineBehaviour.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"StateMachineBehaviour.Destroy": {
		"prefix": "StateMachineBehaviour.Destroy",
		"body": [
			"StateMachineBehaviour.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"StateMachineBehaviour.DestroyImmediate": {
		"prefix": "StateMachineBehaviour.DestroyImmediate",
		"body": [
			"StateMachineBehaviour.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"StateMachineBehaviour.DontDestroyOnLoad": {
		"prefix": "StateMachineBehaviour.DontDestroyOnLoad",
		"body": [
			"StateMachineBehaviour.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"StateMachineBehaviour.FindObjectOfType": {
		"prefix": "StateMachineBehaviour.FindObjectOfType",
		"body": [
			"StateMachineBehaviour.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"StateMachineBehaviour.FindObjectsOfType": {
		"prefix": "StateMachineBehaviour.FindObjectsOfType",
		"body": [
			"StateMachineBehaviour.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"StateMachineBehaviour.Instantiate": {
		"prefix": "StateMachineBehaviour.Instantiate",
		"body": [
			"StateMachineBehaviour.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"StateMachineBehaviour.CreateInstance": {
		"prefix": "StateMachineBehaviour.CreateInstance",
		"body": [
			"StateMachineBehaviour.CreateInstance"
		],
		"description": "public static ScriptableObject CreateInstance(string className); public static ScriptableObject CreateInstance(Type type); public static T CreateInstance(); des: Creates an instance of a scriptable object."
	}
,
	"StateMachineBehaviour.Awake": {
		"prefix": "StateMachineBehaviour.Awake",
		"body": [
			"Awake"
		],
		"description": "This function is called when the ScriptableObject script is started."
	}
,
	"StateMachineBehaviour.OnDestroy": {
		"prefix": "StateMachineBehaviour.OnDestroy",
		"body": [
			"OnDestroy"
		],
		"description": "This function is called when the scriptable object will be destroyed."
	}
,
	"StateMachineBehaviour.OnDisable": {
		"prefix": "StateMachineBehaviour.OnDisable",
		"body": [
			"OnDisable"
		],
		"description": "This function is called when the scriptable object goes out of scope."
	}
,
	"StateMachineBehaviour.OnEnable": {
		"prefix": "StateMachineBehaviour.OnEnable",
		"body": [
			"OnEnable"
		],
		"description": "This function is called when the object is loaded."
	}
,
	"StaticBatchingUtility.Combine": {
		"prefix": "StaticBatchingUtility.Combine",
		"body": [
			"StaticBatchingUtility.Combine"
		],
		"description": "public static void Combine(GameObject staticBatchRoot); public static void Combine(GameObject[] gos, GameObject staticBatchRoot); des: StaticBatchingUtility.Combine prepares all children of the staticBatchRoot for static batching."
	}
,
	"StreamingController.streamingMipmapBias": {
		"prefix": "StreamingController.streamingMipmapBias",
		"body": [
			"streamingMipmapBias"
		],
		"description": "return:float des: Offset applied to the mipmap level chosen by the texture streaming system for any textures visible from this camera. This Offset can take either a positive or negative value."
	}
,
	"StreamingController.CancelPreloading": {
		"prefix": "StreamingController.CancelPreloading",
		"body": [
			"CancelPreloading($1)"
		],
		"description": "public void CancelPreloading(); des: Abort preloading."
	}
,
	"StreamingController.IsPreloading": {
		"prefix": "StreamingController.IsPreloading",
		"body": [
			"IsPreloading($1)"
		],
		"description": "public bool IsPreloading(); des: Used to find out whether the StreamingController is currently preloading texture mipmaps."
	}
,
	"StreamingController.SetPreloading": {
		"prefix": "StreamingController.SetPreloading",
		"body": [
			"SetPreloading($1)"
		],
		"description": "public void SetPreloading(float timeoutSeconds, bool activateCameraOnTimeout, Camera disableCameraCuttingFrom); des: Initiate preloading of streaming data for this camera."
	}
,
	"StreamingController.enabled": {
		"prefix": "StreamingController.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"StreamingController.isActiveAndEnabled": {
		"prefix": "StreamingController.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"StreamingController.gameObject": {
		"prefix": "StreamingController.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"StreamingController.tag": {
		"prefix": "StreamingController.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"StreamingController.transform": {
		"prefix": "StreamingController.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"StreamingController.hideFlags": {
		"prefix": "StreamingController.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"StreamingController.name": {
		"prefix": "StreamingController.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"StreamingController.BroadcastMessage": {
		"prefix": "StreamingController.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"StreamingController.CompareTag": {
		"prefix": "StreamingController.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"StreamingController.GetComponent": {
		"prefix": "StreamingController.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"StreamingController.GetComponentInChildren": {
		"prefix": "StreamingController.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"StreamingController.GetComponentInParent": {
		"prefix": "StreamingController.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"StreamingController.GetComponents": {
		"prefix": "StreamingController.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"StreamingController.GetComponentsInChildren": {
		"prefix": "StreamingController.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"StreamingController.GetComponentsInParent": {
		"prefix": "StreamingController.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"StreamingController.SendMessage": {
		"prefix": "StreamingController.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"StreamingController.SendMessageUpwards": {
		"prefix": "StreamingController.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"StreamingController.GetInstanceID": {
		"prefix": "StreamingController.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"StreamingController.ToString": {
		"prefix": "StreamingController.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"StreamingController.Destroy": {
		"prefix": "StreamingController.Destroy",
		"body": [
			"StreamingController.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"StreamingController.DestroyImmediate": {
		"prefix": "StreamingController.DestroyImmediate",
		"body": [
			"StreamingController.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"StreamingController.DontDestroyOnLoad": {
		"prefix": "StreamingController.DontDestroyOnLoad",
		"body": [
			"StreamingController.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"StreamingController.FindObjectOfType": {
		"prefix": "StreamingController.FindObjectOfType",
		"body": [
			"StreamingController.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"StreamingController.FindObjectsOfType": {
		"prefix": "StreamingController.FindObjectsOfType",
		"body": [
			"StreamingController.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"StreamingController.Instantiate": {
		"prefix": "StreamingController.Instantiate",
		"body": [
			"StreamingController.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"SurfaceEffector2D.forceScale": {
		"prefix": "SurfaceEffector2D.forceScale",
		"body": [
			"forceScale"
		],
		"description": "return:float des: The scale of the impulse force applied while attempting to reach the surface speed."
	}
,
	"SurfaceEffector2D.speed": {
		"prefix": "SurfaceEffector2D.speed",
		"body": [
			"speed"
		],
		"description": "return:float des: The speed to be maintained along the surface."
	}
,
	"SurfaceEffector2D.speedVariation": {
		"prefix": "SurfaceEffector2D.speedVariation",
		"body": [
			"speedVariation"
		],
		"description": "return:float des: The speed variation (from zero to the variation) added to base speed to be applied."
	}
,
	"SurfaceEffector2D.useBounce": {
		"prefix": "SurfaceEffector2D.useBounce",
		"body": [
			"useBounce"
		],
		"description": "return:bool des: Should bounce be used for any contact with the surface?"
	}
,
	"SurfaceEffector2D.useContactForce": {
		"prefix": "SurfaceEffector2D.useContactForce",
		"body": [
			"useContactForce"
		],
		"description": "return:bool des: Should the impulse force but applied to the contact point?"
	}
,
	"SurfaceEffector2D.useFriction": {
		"prefix": "SurfaceEffector2D.useFriction",
		"body": [
			"useFriction"
		],
		"description": "return:bool des: Should friction be used for any contact with the surface?"
	}
,
	"SurfaceEffector2D.enabled": {
		"prefix": "SurfaceEffector2D.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"SurfaceEffector2D.isActiveAndEnabled": {
		"prefix": "SurfaceEffector2D.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"SurfaceEffector2D.gameObject": {
		"prefix": "SurfaceEffector2D.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"SurfaceEffector2D.tag": {
		"prefix": "SurfaceEffector2D.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"SurfaceEffector2D.transform": {
		"prefix": "SurfaceEffector2D.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"SurfaceEffector2D.colliderMask": {
		"prefix": "SurfaceEffector2D.colliderMask",
		"body": [
			"colliderMask"
		],
		"description": "return:int des: The mask used to select specific layers allowed to interact with the effector."
	}
,
	"SurfaceEffector2D.useColliderMask": {
		"prefix": "SurfaceEffector2D.useColliderMask",
		"body": [
			"useColliderMask"
		],
		"description": "return:bool des: Should the collider-mask be used or the global collision matrix?"
	}
,
	"SurfaceEffector2D.hideFlags": {
		"prefix": "SurfaceEffector2D.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"SurfaceEffector2D.name": {
		"prefix": "SurfaceEffector2D.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"SurfaceEffector2D.BroadcastMessage": {
		"prefix": "SurfaceEffector2D.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"SurfaceEffector2D.CompareTag": {
		"prefix": "SurfaceEffector2D.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"SurfaceEffector2D.GetComponent": {
		"prefix": "SurfaceEffector2D.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"SurfaceEffector2D.GetComponentInChildren": {
		"prefix": "SurfaceEffector2D.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"SurfaceEffector2D.GetComponentInParent": {
		"prefix": "SurfaceEffector2D.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"SurfaceEffector2D.GetComponents": {
		"prefix": "SurfaceEffector2D.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"SurfaceEffector2D.GetComponentsInChildren": {
		"prefix": "SurfaceEffector2D.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"SurfaceEffector2D.GetComponentsInParent": {
		"prefix": "SurfaceEffector2D.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"SurfaceEffector2D.SendMessage": {
		"prefix": "SurfaceEffector2D.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"SurfaceEffector2D.SendMessageUpwards": {
		"prefix": "SurfaceEffector2D.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"SurfaceEffector2D.GetInstanceID": {
		"prefix": "SurfaceEffector2D.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"SurfaceEffector2D.ToString": {
		"prefix": "SurfaceEffector2D.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"SurfaceEffector2D.Destroy": {
		"prefix": "SurfaceEffector2D.Destroy",
		"body": [
			"SurfaceEffector2D.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"SurfaceEffector2D.DestroyImmediate": {
		"prefix": "SurfaceEffector2D.DestroyImmediate",
		"body": [
			"SurfaceEffector2D.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"SurfaceEffector2D.DontDestroyOnLoad": {
		"prefix": "SurfaceEffector2D.DontDestroyOnLoad",
		"body": [
			"SurfaceEffector2D.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"SurfaceEffector2D.FindObjectOfType": {
		"prefix": "SurfaceEffector2D.FindObjectOfType",
		"body": [
			"SurfaceEffector2D.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"SurfaceEffector2D.FindObjectsOfType": {
		"prefix": "SurfaceEffector2D.FindObjectsOfType",
		"body": [
			"SurfaceEffector2D.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"SurfaceEffector2D.Instantiate": {
		"prefix": "SurfaceEffector2D.Instantiate",
		"body": [
			"SurfaceEffector2D.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"SystemInfo.IsFormatSupported": {
		"prefix": "SystemInfo.IsFormatSupported",
		"body": [
			"SystemInfo.IsFormatSupported"
		],
		"description": " des: Verifies that the specified graphics format is supported for the specified usage."
	}
,
	"SystemInfo.SupportsBlendingOnRenderTextureFormat": {
		"prefix": "SystemInfo.SupportsBlendingOnRenderTextureFormat",
		"body": [
			"SystemInfo.SupportsBlendingOnRenderTextureFormat"
		],
		"description": "public static bool SupportsBlendingOnRenderTextureFormat(RenderTextureFormat format); des: Is blending supported on render texture format?"
	}
,
	"SystemInfo.SupportsRenderTextureFormat": {
		"prefix": "SystemInfo.SupportsRenderTextureFormat",
		"body": [
			"SystemInfo.SupportsRenderTextureFormat"
		],
		"description": "public static bool SupportsRenderTextureFormat(RenderTextureFormat format); des: Is render texture format supported?"
	}
,
	"SystemInfo.SupportsTextureFormat": {
		"prefix": "SystemInfo.SupportsTextureFormat",
		"body": [
			"SystemInfo.SupportsTextureFormat"
		],
		"description": "public static bool SupportsTextureFormat(TextureFormat format); des: Is texture format supported on this device?"
	}
,
	"TargetJoint2D.anchor": {
		"prefix": "TargetJoint2D.anchor",
		"body": [
			"anchor"
		],
		"description": "return:Vector2 des: The local-space anchor on the rigid-body the joint is attached to."
	}
,
	"TargetJoint2D.autoConfigureTarget": {
		"prefix": "TargetJoint2D.autoConfigureTarget",
		"body": [
			"autoConfigureTarget"
		],
		"description": "return:bool des: Should the target be calculated automatically?"
	}
,
	"TargetJoint2D.dampingRatio": {
		"prefix": "TargetJoint2D.dampingRatio",
		"body": [
			"dampingRatio"
		],
		"description": "return:float des: The amount by which the target spring force is reduced in proportion to the movement speed."
	}
,
	"TargetJoint2D.frequency": {
		"prefix": "TargetJoint2D.frequency",
		"body": [
			"frequency"
		],
		"description": "return:float des: The frequency at which the target spring oscillates around the target position."
	}
,
	"TargetJoint2D.maxForce": {
		"prefix": "TargetJoint2D.maxForce",
		"body": [
			"maxForce"
		],
		"description": "return:float des: The maximum force that can be generated when trying to maintain the target joint constraint."
	}
,
	"TargetJoint2D.target": {
		"prefix": "TargetJoint2D.target",
		"body": [
			"target"
		],
		"description": "return:Vector2 des: The world-space position that the joint will attempt to move the body to."
	}
,
	"TargetJoint2D.enabled": {
		"prefix": "TargetJoint2D.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"TargetJoint2D.isActiveAndEnabled": {
		"prefix": "TargetJoint2D.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"TargetJoint2D.gameObject": {
		"prefix": "TargetJoint2D.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"TargetJoint2D.tag": {
		"prefix": "TargetJoint2D.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"TargetJoint2D.transform": {
		"prefix": "TargetJoint2D.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"TargetJoint2D.attachedRigidbody": {
		"prefix": "TargetJoint2D.attachedRigidbody",
		"body": [
			"attachedRigidbody"
		],
		"description": "return:Rigidbody2D des: The Rigidbody2D attached to the Joint2D."
	}
,
	"TargetJoint2D.breakForce": {
		"prefix": "TargetJoint2D.breakForce",
		"body": [
			"breakForce"
		],
		"description": "return:float des: The force that needs to be applied for this joint to break."
	}
,
	"TargetJoint2D.breakTorque": {
		"prefix": "TargetJoint2D.breakTorque",
		"body": [
			"breakTorque"
		],
		"description": "return:float des: The torque that needs to be applied for this joint to break."
	}
,
	"TargetJoint2D.connectedBody": {
		"prefix": "TargetJoint2D.connectedBody",
		"body": [
			"connectedBody"
		],
		"description": "return:Rigidbody2D des: The Rigidbody2D object to which the other end of the joint is attached (ie, the object without the joint component)."
	}
,
	"TargetJoint2D.enableCollision": {
		"prefix": "TargetJoint2D.enableCollision",
		"body": [
			"enableCollision"
		],
		"description": "return:bool des: Should the two rigid bodies connected with this joint collide with each other?"
	}
,
	"TargetJoint2D.reactionForce": {
		"prefix": "TargetJoint2D.reactionForce",
		"body": [
			"reactionForce"
		],
		"description": "return:Vector2 des: Gets the reaction force of the joint."
	}
,
	"TargetJoint2D.reactionTorque": {
		"prefix": "TargetJoint2D.reactionTorque",
		"body": [
			"reactionTorque"
		],
		"description": "return:float des: Gets the reaction torque of the joint."
	}
,
	"TargetJoint2D.hideFlags": {
		"prefix": "TargetJoint2D.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"TargetJoint2D.name": {
		"prefix": "TargetJoint2D.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"TargetJoint2D.BroadcastMessage": {
		"prefix": "TargetJoint2D.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"TargetJoint2D.CompareTag": {
		"prefix": "TargetJoint2D.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"TargetJoint2D.GetComponent": {
		"prefix": "TargetJoint2D.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"TargetJoint2D.GetComponentInChildren": {
		"prefix": "TargetJoint2D.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"TargetJoint2D.GetComponentInParent": {
		"prefix": "TargetJoint2D.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"TargetJoint2D.GetComponents": {
		"prefix": "TargetJoint2D.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"TargetJoint2D.GetComponentsInChildren": {
		"prefix": "TargetJoint2D.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"TargetJoint2D.GetComponentsInParent": {
		"prefix": "TargetJoint2D.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"TargetJoint2D.SendMessage": {
		"prefix": "TargetJoint2D.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"TargetJoint2D.SendMessageUpwards": {
		"prefix": "TargetJoint2D.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"TargetJoint2D.GetReactionForce": {
		"prefix": "TargetJoint2D.GetReactionForce",
		"body": [
			"GetReactionForce($1)"
		],
		"description": "public Vector2 GetReactionForce(float timeStep); des: Gets the reaction force of the joint given the specified timeStep."
	}
,
	"TargetJoint2D.GetReactionTorque": {
		"prefix": "TargetJoint2D.GetReactionTorque",
		"body": [
			"GetReactionTorque($1)"
		],
		"description": "public float GetReactionTorque(float timeStep); des: Gets the reaction torque of the joint given the specified timeStep."
	}
,
	"TargetJoint2D.GetInstanceID": {
		"prefix": "TargetJoint2D.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"TargetJoint2D.ToString": {
		"prefix": "TargetJoint2D.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"TargetJoint2D.Destroy": {
		"prefix": "TargetJoint2D.Destroy",
		"body": [
			"TargetJoint2D.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"TargetJoint2D.DestroyImmediate": {
		"prefix": "TargetJoint2D.DestroyImmediate",
		"body": [
			"TargetJoint2D.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"TargetJoint2D.DontDestroyOnLoad": {
		"prefix": "TargetJoint2D.DontDestroyOnLoad",
		"body": [
			"TargetJoint2D.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"TargetJoint2D.FindObjectOfType": {
		"prefix": "TargetJoint2D.FindObjectOfType",
		"body": [
			"TargetJoint2D.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"TargetJoint2D.FindObjectsOfType": {
		"prefix": "TargetJoint2D.FindObjectsOfType",
		"body": [
			"TargetJoint2D.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"TargetJoint2D.Instantiate": {
		"prefix": "TargetJoint2D.Instantiate",
		"body": [
			"TargetJoint2D.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"TargetJoint2D.OnJointBreak2D": {
		"prefix": "TargetJoint2D.OnJointBreak2D",
		"body": [
			"OnJointBreak2D"
		],
		"description": "Called when a Joint2D attached to the same game object breaks."
	}
,
	"Terrain.bakeLightProbesForTrees": {
		"prefix": "Terrain.bakeLightProbesForTrees",
		"body": [
			"bakeLightProbesForTrees"
		],
		"description": "return:bool des: Specifies if an array of internal light probes should be baked for terrain trees. Available only in editor."
	}
,
	"Terrain.basemapDistance": {
		"prefix": "Terrain.basemapDistance",
		"body": [
			"basemapDistance"
		],
		"description": "return:float des: Heightmap patches beyond basemap distance will use a precomputed low res basemap."
	}
,
	"Terrain.castShadows": {
		"prefix": "Terrain.castShadows",
		"body": [
			"castShadows"
		],
		"description": "return:bool des: Should terrain cast shadows?."
	}
,
	"Terrain.collectDetailPatches": {
		"prefix": "Terrain.collectDetailPatches",
		"body": [
			"collectDetailPatches"
		],
		"description": "return:bool des: Collect detail patches from memory."
	}
,
	"Terrain.detailObjectDensity": {
		"prefix": "Terrain.detailObjectDensity",
		"body": [
			"detailObjectDensity"
		],
		"description": "return:float des: Density of detail objects."
	}
,
	"Terrain.detailObjectDistance": {
		"prefix": "Terrain.detailObjectDistance",
		"body": [
			"detailObjectDistance"
		],
		"description": "return:float des: Detail objects will be displayed up to this distance."
	}
,
	"Terrain.drawHeightmap": {
		"prefix": "Terrain.drawHeightmap",
		"body": [
			"drawHeightmap"
		],
		"description": "return:bool des: Specify if terrain heightmap should be drawn."
	}
,
	"Terrain.drawTreesAndFoliage": {
		"prefix": "Terrain.drawTreesAndFoliage",
		"body": [
			"drawTreesAndFoliage"
		],
		"description": "return:bool des: Specify if terrain trees and details should be drawn."
	}
,
	"Terrain.editorRenderFlags": {
		"prefix": "Terrain.editorRenderFlags",
		"body": [
			"editorRenderFlags"
		],
		"description": "return:TerrainRenderFlags des: Controls what part of the terrain should be rendered."
	}
,
	"Terrain.freeUnusedRenderingResources": {
		"prefix": "Terrain.freeUnusedRenderingResources",
		"body": [
			"freeUnusedRenderingResources"
		],
		"description": "return:bool des: Whether some per-camera rendering resources for the terrain should be freed after not being used for some frames."
	}
,
	"Terrain.heightmapMaximumLOD": {
		"prefix": "Terrain.heightmapMaximumLOD",
		"body": [
			"heightmapMaximumLOD"
		],
		"description": "return:int des: Lets you essentially lower the heightmap resolution used for rendering."
	}
,
	"Terrain.heightmapPixelError": {
		"prefix": "Terrain.heightmapPixelError",
		"body": [
			"heightmapPixelError"
		],
		"description": "return:float des: An approximation of how many pixels the terrain will pop in the worst case when switching lod."
	}
,
	"Terrain.legacyShininess": {
		"prefix": "Terrain.legacyShininess",
		"body": [
			"legacyShininess"
		],
		"description": "return:float des: The shininess value of the terrain."
	}
,
	"Terrain.legacySpecular": {
		"prefix": "Terrain.legacySpecular",
		"body": [
			"legacySpecular"
		],
		"description": "return:Color des: The specular color of the terrain."
	}
,
	"Terrain.lightmapIndex": {
		"prefix": "Terrain.lightmapIndex",
		"body": [
			"lightmapIndex"
		],
		"description": "return:int des: The index of the baked lightmap applied to this terrain."
	}
,
	"Terrain.lightmapScaleOffset": {
		"prefix": "Terrain.lightmapScaleOffset",
		"body": [
			"lightmapScaleOffset"
		],
		"description": "return:Vector4 des: The UV scale & offset used for a baked lightmap."
	}
,
	"Terrain.materialTemplate": {
		"prefix": "Terrain.materialTemplate",
		"body": [
			"materialTemplate"
		],
		"description": "return:Material des: The custom material used to render the terrain."
	}
,
	"Terrain.materialType": {
		"prefix": "Terrain.materialType",
		"body": [
			"materialType"
		],
		"description": "return:Terrain.MaterialType des: The type of the material used to render the terrain. Could be one of the built-in types or custom. See MaterialType."
	}
,
	"Terrain.patchBoundsMultiplier": {
		"prefix": "Terrain.patchBoundsMultiplier",
		"body": [
			"patchBoundsMultiplier"
		],
		"description": "return:Vector3 des: Set the terrain bounding box scale."
	}
,
	"Terrain.preserveTreePrototypeLayers": {
		"prefix": "Terrain.preserveTreePrototypeLayers",
		"body": [
			"preserveTreePrototypeLayers"
		],
		"description": "return:bool des: Allows you to specify how Unity chooses the layer for tree instances."
	}
,
	"Terrain.realtimeLightmapIndex": {
		"prefix": "Terrain.realtimeLightmapIndex",
		"body": [
			"realtimeLightmapIndex"
		],
		"description": "return:int des: The index of the realtime lightmap applied to this terrain."
	}
,
	"Terrain.realtimeLightmapScaleOffset": {
		"prefix": "Terrain.realtimeLightmapScaleOffset",
		"body": [
			"realtimeLightmapScaleOffset"
		],
		"description": "return:Vector4 des: The UV scale & offset used for a realtime lightmap."
	}
,
	"Terrain.reflectionProbeUsage": {
		"prefix": "Terrain.reflectionProbeUsage",
		"body": [
			"reflectionProbeUsage"
		],
		"description": "return:Rendering.ReflectionProbeUsage des: How reflection probes are used for terrain. See ReflectionProbeUsage."
	}
,
	"Terrain.terrainData": {
		"prefix": "Terrain.terrainData",
		"body": [
			"terrainData"
		],
		"description": "return:TerrainData des: The Terrain Data that stores heightmaps, terrain textures, detail meshes and trees."
	}
,
	"Terrain.treeBillboardDistance": {
		"prefix": "Terrain.treeBillboardDistance",
		"body": [
			"treeBillboardDistance"
		],
		"description": "return:float des: Distance from the camera where trees will be rendered as billboards only."
	}
,
	"Terrain.treeCrossFadeLength": {
		"prefix": "Terrain.treeCrossFadeLength",
		"body": [
			"treeCrossFadeLength"
		],
		"description": "return:float des: Total distance delta that trees will use to transition from billboard orientation to mesh orientation."
	}
,
	"Terrain.treeDistance": {
		"prefix": "Terrain.treeDistance",
		"body": [
			"treeDistance"
		],
		"description": "return:float des: The maximum distance at which trees are rendered."
	}
,
	"Terrain.treeLODBiasMultiplier": {
		"prefix": "Terrain.treeLODBiasMultiplier",
		"body": [
			"treeLODBiasMultiplier"
		],
		"description": "return:float des: The multiplier to the current LOD bias used for rendering LOD trees (i.e. SpeedTree trees)."
	}
,
	"Terrain.treeMaximumFullLODCount": {
		"prefix": "Terrain.treeMaximumFullLODCount",
		"body": [
			"treeMaximumFullLODCount"
		],
		"description": "return:int des: Maximum number of trees rendered at full LOD."
	}
,
	"Terrain.AddTreeInstance": {
		"prefix": "Terrain.AddTreeInstance",
		"body": [
			"AddTreeInstance($1)"
		],
		"description": "public void AddTreeInstance(TreeInstance instance); des: Adds a tree instance to the terrain."
	}
,
	"Terrain.ApplyDelayedHeightmapModification": {
		"prefix": "Terrain.ApplyDelayedHeightmapModification",
		"body": [
			"ApplyDelayedHeightmapModification($1)"
		],
		"description": "public void ApplyDelayedHeightmapModification(); des: Update the terrain's LOD and vegetation information after making changes with TerrainData.SetHeightsDelayLOD."
	}
,
	"Terrain.Flush": {
		"prefix": "Terrain.Flush",
		"body": [
			"Flush($1)"
		],
		"description": "public void Flush(); des: Flushes any change done in the terrain so it takes effect."
	}
,
	"Terrain.GetClosestReflectionProbes": {
		"prefix": "Terrain.GetClosestReflectionProbes",
		"body": [
			"GetClosestReflectionProbes($1)"
		],
		"description": "public void GetClosestReflectionProbes(List<ReflectionProbeBlendInfo> result); des: Fills the list with reflection probes whose AABB intersects with terrain's AABB. Their weights are also provided. Weight shows how much influence the probe has on the terrain, and is used when the blending between multiple reflection probes occurs."
	}
,
	"Terrain.GetPosition": {
		"prefix": "Terrain.GetPosition",
		"body": [
			"GetPosition($1)"
		],
		"description": "public Vector3 GetPosition(); des: Get the position of the terrain."
	}
,
	"Terrain.GetSplatMaterialPropertyBlock": {
		"prefix": "Terrain.GetSplatMaterialPropertyBlock",
		"body": [
			"GetSplatMaterialPropertyBlock($1)"
		],
		"description": "public void GetSplatMaterialPropertyBlock(MaterialPropertyBlock dest); des: Get the previously set splat material properties by copying to the dest MaterialPropertyBlock object."
	}
,
	"Terrain.SampleHeight": {
		"prefix": "Terrain.SampleHeight",
		"body": [
			"SampleHeight($1)"
		],
		"description": "public float SampleHeight(Vector3 worldPosition); des: Samples the height at the given position defined in world space, relative to the terrain space."
	}
,
	"Terrain.SetNeighbors": {
		"prefix": "Terrain.SetNeighbors",
		"body": [
			"SetNeighbors($1)"
		],
		"description": "public void SetNeighbors(Terrain left, Terrain top, Terrain right, Terrain bottom); des: Lets you setup the connection between neighboring Terrains."
	}
,
	"Terrain.SetSplatMaterialPropertyBlock": {
		"prefix": "Terrain.SetSplatMaterialPropertyBlock",
		"body": [
			"SetSplatMaterialPropertyBlock($1)"
		],
		"description": "public void SetSplatMaterialPropertyBlock(MaterialPropertyBlock properties); des: Set the additional material properties when rendering the terrain heightmap using the splat material."
	}
,
	"Terrain.CreateTerrainGameObject": {
		"prefix": "Terrain.CreateTerrainGameObject",
		"body": [
			"Terrain.CreateTerrainGameObject"
		],
		"description": "public static GameObject CreateTerrainGameObject(TerrainData assignTerrain); des: Creates a Terrain including collider from TerrainData."
	}
,
	"Terrain.enabled": {
		"prefix": "Terrain.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"Terrain.isActiveAndEnabled": {
		"prefix": "Terrain.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"Terrain.gameObject": {
		"prefix": "Terrain.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"Terrain.tag": {
		"prefix": "Terrain.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"Terrain.transform": {
		"prefix": "Terrain.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"Terrain.hideFlags": {
		"prefix": "Terrain.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Terrain.name": {
		"prefix": "Terrain.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Terrain.BroadcastMessage": {
		"prefix": "Terrain.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"Terrain.CompareTag": {
		"prefix": "Terrain.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"Terrain.GetComponent": {
		"prefix": "Terrain.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"Terrain.GetComponentInChildren": {
		"prefix": "Terrain.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"Terrain.GetComponentInParent": {
		"prefix": "Terrain.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"Terrain.GetComponents": {
		"prefix": "Terrain.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"Terrain.GetComponentsInChildren": {
		"prefix": "Terrain.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"Terrain.GetComponentsInParent": {
		"prefix": "Terrain.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"Terrain.SendMessage": {
		"prefix": "Terrain.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"Terrain.SendMessageUpwards": {
		"prefix": "Terrain.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"Terrain.GetInstanceID": {
		"prefix": "Terrain.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Terrain.ToString": {
		"prefix": "Terrain.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Terrain.Destroy": {
		"prefix": "Terrain.Destroy",
		"body": [
			"Terrain.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Terrain.DestroyImmediate": {
		"prefix": "Terrain.DestroyImmediate",
		"body": [
			"Terrain.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Terrain.DontDestroyOnLoad": {
		"prefix": "Terrain.DontDestroyOnLoad",
		"body": [
			"Terrain.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Terrain.FindObjectOfType": {
		"prefix": "Terrain.FindObjectOfType",
		"body": [
			"Terrain.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Terrain.FindObjectsOfType": {
		"prefix": "Terrain.FindObjectsOfType",
		"body": [
			"Terrain.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Terrain.Instantiate": {
		"prefix": "Terrain.Instantiate",
		"body": [
			"Terrain.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"Terrain.MaterialType.BuiltInStandard": {
		"prefix": "Terrain.MaterialType.BuiltInStandard",
		"body": [
			"BuiltInStandard"
		],
		"description": "return: des: A built-in material that uses the standard physically-based lighting model. Inputs supported: smoothness, metallic / specular, normal."
	}
,
	"Terrain.MaterialType.BuiltInLegacyDiffuse": {
		"prefix": "Terrain.MaterialType.BuiltInLegacyDiffuse",
		"body": [
			"BuiltInLegacyDiffuse"
		],
		"description": "return: des: A built-in material that uses the legacy Lambert (diffuse) lighting model and has optional normal map support."
	}
,
	"Terrain.MaterialType.BuiltInLegacySpecular": {
		"prefix": "Terrain.MaterialType.BuiltInLegacySpecular",
		"body": [
			"BuiltInLegacySpecular"
		],
		"description": "return: des: A built-in material that uses the legacy BlinnPhong (specular) lighting model and has optional normal map support."
	}
,
	"Terrain.MaterialType.Custom": {
		"prefix": "Terrain.MaterialType.Custom",
		"body": [
			"Custom"
		],
		"description": "return: des: Use a custom material given by Terrain.materialTemplate."
	}
,
	"TerrainCollider.terrainData": {
		"prefix": "TerrainCollider.terrainData",
		"body": [
			"terrainData"
		],
		"description": "return:TerrainData des: The terrain that stores the heightmap."
	}
,
	"TerrainCollider.attachedRigidbody": {
		"prefix": "TerrainCollider.attachedRigidbody",
		"body": [
			"attachedRigidbody"
		],
		"description": "return:Rigidbody des: The rigidbody the collider is attached to."
	}
,
	"TerrainCollider.bounds": {
		"prefix": "TerrainCollider.bounds",
		"body": [
			"bounds"
		],
		"description": "return:Bounds des: The world space bounding volume of the collider (Read Only)."
	}
,
	"TerrainCollider.contactOffset": {
		"prefix": "TerrainCollider.contactOffset",
		"body": [
			"contactOffset"
		],
		"description": "return:float des: Contact offset value of this collider."
	}
,
	"TerrainCollider.enabled": {
		"prefix": "TerrainCollider.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Colliders will collide with other Colliders, disabled Colliders won't."
	}
,
	"TerrainCollider.isTrigger": {
		"prefix": "TerrainCollider.isTrigger",
		"body": [
			"isTrigger"
		],
		"description": "return:bool des: Is the collider a trigger?"
	}
,
	"TerrainCollider.material": {
		"prefix": "TerrainCollider.material",
		"body": [
			"material"
		],
		"description": "return:PhysicMaterial des: The material used by the collider."
	}
,
	"TerrainCollider.sharedMaterial": {
		"prefix": "TerrainCollider.sharedMaterial",
		"body": [
			"sharedMaterial"
		],
		"description": "return:PhysicMaterial des: The shared physic material of this collider."
	}
,
	"TerrainCollider.gameObject": {
		"prefix": "TerrainCollider.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"TerrainCollider.tag": {
		"prefix": "TerrainCollider.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"TerrainCollider.transform": {
		"prefix": "TerrainCollider.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"TerrainCollider.hideFlags": {
		"prefix": "TerrainCollider.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"TerrainCollider.name": {
		"prefix": "TerrainCollider.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"TerrainCollider.ClosestPoint": {
		"prefix": "TerrainCollider.ClosestPoint",
		"body": [
			"ClosestPoint($1)"
		],
		"description": "public Vector3 ClosestPoint(Vector3 position); des: Returns a point on the collider that is closest to a given location."
	}
,
	"TerrainCollider.ClosestPointOnBounds": {
		"prefix": "TerrainCollider.ClosestPointOnBounds",
		"body": [
			"ClosestPointOnBounds($1)"
		],
		"description": "public Vector3 ClosestPointOnBounds(Vector3 position); des: The closest point to the bounding box of the attached collider."
	}
,
	"TerrainCollider.Raycast": {
		"prefix": "TerrainCollider.Raycast",
		"body": [
			"Raycast($1)"
		],
		"description": "public bool Raycast(Ray ray, out RaycastHit hitInfo, float maxDistance); des: Casts a Ray that ignores all Colliders except this one."
	}
,
	"TerrainCollider.BroadcastMessage": {
		"prefix": "TerrainCollider.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"TerrainCollider.CompareTag": {
		"prefix": "TerrainCollider.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"TerrainCollider.GetComponent": {
		"prefix": "TerrainCollider.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"TerrainCollider.GetComponentInChildren": {
		"prefix": "TerrainCollider.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"TerrainCollider.GetComponentInParent": {
		"prefix": "TerrainCollider.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"TerrainCollider.GetComponents": {
		"prefix": "TerrainCollider.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"TerrainCollider.GetComponentsInChildren": {
		"prefix": "TerrainCollider.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"TerrainCollider.GetComponentsInParent": {
		"prefix": "TerrainCollider.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"TerrainCollider.SendMessage": {
		"prefix": "TerrainCollider.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"TerrainCollider.SendMessageUpwards": {
		"prefix": "TerrainCollider.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"TerrainCollider.GetInstanceID": {
		"prefix": "TerrainCollider.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"TerrainCollider.ToString": {
		"prefix": "TerrainCollider.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"TerrainCollider.Destroy": {
		"prefix": "TerrainCollider.Destroy",
		"body": [
			"TerrainCollider.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"TerrainCollider.DestroyImmediate": {
		"prefix": "TerrainCollider.DestroyImmediate",
		"body": [
			"TerrainCollider.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"TerrainCollider.DontDestroyOnLoad": {
		"prefix": "TerrainCollider.DontDestroyOnLoad",
		"body": [
			"TerrainCollider.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"TerrainCollider.FindObjectOfType": {
		"prefix": "TerrainCollider.FindObjectOfType",
		"body": [
			"TerrainCollider.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"TerrainCollider.FindObjectsOfType": {
		"prefix": "TerrainCollider.FindObjectsOfType",
		"body": [
			"TerrainCollider.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"TerrainCollider.Instantiate": {
		"prefix": "TerrainCollider.Instantiate",
		"body": [
			"TerrainCollider.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"TerrainCollider.OnCollisionEnter": {
		"prefix": "TerrainCollider.OnCollisionEnter",
		"body": [
			"OnCollisionEnter"
		],
		"description": "OnCollisionEnter is called when this collider/rigidbody has begun touching another rigidbody/collider."
	}
,
	"TerrainCollider.OnCollisionExit": {
		"prefix": "TerrainCollider.OnCollisionExit",
		"body": [
			"OnCollisionExit"
		],
		"description": "OnCollisionExit is called when this collider/rigidbody has stopped touching another rigidbody/collider."
	}
,
	"TerrainCollider.OnCollisionStay": {
		"prefix": "TerrainCollider.OnCollisionStay",
		"body": [
			"OnCollisionStay"
		],
		"description": "OnCollisionStay is called once per frame for every collider/rigidbody that is touching rigidbody/collider."
	}
,
	"TerrainCollider.OnTriggerEnter": {
		"prefix": "TerrainCollider.OnTriggerEnter",
		"body": [
			"OnTriggerEnter"
		],
		"description": "OnTriggerEnter is called when the Collider other enters the trigger."
	}
,
	"TerrainCollider.OnTriggerExit": {
		"prefix": "TerrainCollider.OnTriggerExit",
		"body": [
			"OnTriggerExit"
		],
		"description": "OnTriggerExit is called when the Collider other has stopped touching the trigger."
	}
,
	"TerrainCollider.OnTriggerStay": {
		"prefix": "TerrainCollider.OnTriggerStay",
		"body": [
			"OnTriggerStay"
		],
		"description": "OnTriggerStay is called almost all the frames for every Collider other that is touching the trigger. The function is on the physics timer so it won't necessarily run every frame."
	}
,
	"TerrainData.alphamapHeight": {
		"prefix": "TerrainData.alphamapHeight",
		"body": [
			"alphamapHeight"
		],
		"description": "return:int des: Height of the alpha map."
	}
,
	"TerrainData.alphamapLayers": {
		"prefix": "TerrainData.alphamapLayers",
		"body": [
			"alphamapLayers"
		],
		"description": "return:int des: Number of alpha map layers."
	}
,
	"TerrainData.alphamapResolution": {
		"prefix": "TerrainData.alphamapResolution",
		"body": [
			"alphamapResolution"
		],
		"description": "return:int des: Resolution of the alpha map."
	}
,
	"TerrainData.alphamapTextures": {
		"prefix": "TerrainData.alphamapTextures",
		"body": [
			"alphamapTextures"
		],
		"description": "return:Texture2D[] des: Alpha map textures used by the Terrain. Used by Terrain Inspector for undo."
	}
,
	"TerrainData.alphamapWidth": {
		"prefix": "TerrainData.alphamapWidth",
		"body": [
			"alphamapWidth"
		],
		"description": "return:int des: Width of the alpha map."
	}
,
	"TerrainData.baseMapResolution": {
		"prefix": "TerrainData.baseMapResolution",
		"body": [
			"baseMapResolution"
		],
		"description": "return:int des: Resolution of the base map used for rendering far patches on the terrain."
	}
,
	"TerrainData.bounds": {
		"prefix": "TerrainData.bounds",
		"body": [
			"bounds"
		],
		"description": "return:Bounds des: The local bounding box of the TerrainData object."
	}
,
	"TerrainData.detailHeight": {
		"prefix": "TerrainData.detailHeight",
		"body": [
			"detailHeight"
		],
		"description": "return:int des: Detail height of the TerrainData."
	}
,
	"TerrainData.detailPrototypes": {
		"prefix": "TerrainData.detailPrototypes",
		"body": [
			"detailPrototypes"
		],
		"description": "return:DetailPrototype[] des: Contains the detail texture/meshes that the terrain has."
	}
,
	"TerrainData.detailResolution": {
		"prefix": "TerrainData.detailResolution",
		"body": [
			"detailResolution"
		],
		"description": "return:int des: Detail Resolution of the TerrainData."
	}
,
	"TerrainData.detailWidth": {
		"prefix": "TerrainData.detailWidth",
		"body": [
			"detailWidth"
		],
		"description": "return:int des: Detail width of the TerrainData."
	}
,
	"TerrainData.heightmapHeight": {
		"prefix": "TerrainData.heightmapHeight",
		"body": [
			"heightmapHeight"
		],
		"description": "return:int des: Height of the terrain in samples (Read Only)."
	}
,
	"TerrainData.heightmapResolution": {
		"prefix": "TerrainData.heightmapResolution",
		"body": [
			"heightmapResolution"
		],
		"description": "return:int des: Resolution of the heightmap."
	}
,
	"TerrainData.heightmapScale": {
		"prefix": "TerrainData.heightmapScale",
		"body": [
			"heightmapScale"
		],
		"description": "return:Vector3 des: The size of each heightmap sample."
	}
,
	"TerrainData.heightmapWidth": {
		"prefix": "TerrainData.heightmapWidth",
		"body": [
			"heightmapWidth"
		],
		"description": "return:int des: Width of the terrain in samples (Read Only)."
	}
,
	"TerrainData.size": {
		"prefix": "TerrainData.size",
		"body": [
			"size"
		],
		"description": "return:Vector3 des: The total size in world units of the terrain."
	}
,
	"TerrainData.splatPrototypes": {
		"prefix": "TerrainData.splatPrototypes",
		"body": [
			"splatPrototypes"
		],
		"description": "return:SplatPrototype[] des: Splat texture used by the terrain."
	}
,
	"TerrainData.thickness": {
		"prefix": "TerrainData.thickness",
		"body": [
			"thickness"
		],
		"description": "return:float des: The thickness of the terrain used for collision detection."
	}
,
	"TerrainData.treeInstanceCount": {
		"prefix": "TerrainData.treeInstanceCount",
		"body": [
			"treeInstanceCount"
		],
		"description": "return:int des: Returns the number of tree instances."
	}
,
	"TerrainData.treeInstances": {
		"prefix": "TerrainData.treeInstances",
		"body": [
			"treeInstances"
		],
		"description": "return:TreeInstance[] des: Contains the current trees placed in the terrain."
	}
,
	"TerrainData.treePrototypes": {
		"prefix": "TerrainData.treePrototypes",
		"body": [
			"treePrototypes"
		],
		"description": "return:TreePrototype[] des: The list of tree prototypes this are the ones available in the inspector."
	}
,
	"TerrainData.wavingGrassAmount": {
		"prefix": "TerrainData.wavingGrassAmount",
		"body": [
			"wavingGrassAmount"
		],
		"description": "return:float des: Amount of waving grass in the terrain."
	}
,
	"TerrainData.wavingGrassSpeed": {
		"prefix": "TerrainData.wavingGrassSpeed",
		"body": [
			"wavingGrassSpeed"
		],
		"description": "return:float des: Speed of the waving grass."
	}
,
	"TerrainData.wavingGrassStrength": {
		"prefix": "TerrainData.wavingGrassStrength",
		"body": [
			"wavingGrassStrength"
		],
		"description": "return:float des: Strength of the waving grass in the terrain."
	}
,
	"TerrainData.wavingGrassTint": {
		"prefix": "TerrainData.wavingGrassTint",
		"body": [
			"wavingGrassTint"
		],
		"description": "return:Color des: Color of the waving grass that the terrain has."
	}
,
	"TerrainData.GetAlphamaps": {
		"prefix": "TerrainData.GetAlphamaps",
		"body": [
			"GetAlphamaps($1)"
		],
		"description": "public float[,,] GetAlphamaps(int x, int y, int width, int height); des: Returns the alpha map at a position x, y given a width and height."
	}
,
	"TerrainData.GetDetailLayer": {
		"prefix": "TerrainData.GetDetailLayer",
		"body": [
			"GetDetailLayer($1)"
		],
		"description": "public int[,] GetDetailLayer(int xBase, int yBase, int width, int height, int layer); des: Returns a 2D array of the detail object density in the specific location."
	}
,
	"TerrainData.GetHeight": {
		"prefix": "TerrainData.GetHeight",
		"body": [
			"GetHeight($1)"
		],
		"description": "public float GetHeight(int x, int y); des: Gets the height at a certain point x,y."
	}
,
	"TerrainData.GetHeights": {
		"prefix": "TerrainData.GetHeights",
		"body": [
			"GetHeights($1)"
		],
		"description": "public float[,] GetHeights(int xBase, int yBase, int width, int height); des: Get an array of heightmap samples."
	}
,
	"TerrainData.GetInterpolatedHeight": {
		"prefix": "TerrainData.GetInterpolatedHeight",
		"body": [
			"GetInterpolatedHeight($1)"
		],
		"description": "public float GetInterpolatedHeight(float x, float y); des: Gets an interpolated height at a point x,y."
	}
,
	"TerrainData.GetInterpolatedNormal": {
		"prefix": "TerrainData.GetInterpolatedNormal",
		"body": [
			"GetInterpolatedNormal($1)"
		],
		"description": "public Vector3 GetInterpolatedNormal(float x, float y); des: Get an interpolated normal at a given location."
	}
,
	"TerrainData.GetMaximumHeightError": {
		"prefix": "TerrainData.GetMaximumHeightError",
		"body": [
			"GetMaximumHeightError($1)"
		],
		"description": "public float[] GetMaximumHeightError(); des: Returns an array of tesselation maximum height error values per renderable terrain patch. The returned array can be modified and passed to OverrideMaximumHeightError."
	}
,
	"TerrainData.GetPatchMinMaxHeights": {
		"prefix": "TerrainData.GetPatchMinMaxHeights",
		"body": [
			"GetPatchMinMaxHeights($1)"
		],
		"description": "public PatchExtents[] GetPatchMinMaxHeights(); des: Returns an array of min max height values for all the renderable patches in a terrain. The returned array can be modified and then passed to OverrideMinMaxPatchHeights."
	}
,
	"TerrainData.GetSteepness": {
		"prefix": "TerrainData.GetSteepness",
		"body": [
			"GetSteepness($1)"
		],
		"description": "public float GetSteepness(float x, float y); des: Gets the gradient of the terrain at point (x,y)."
	}
,
	"TerrainData.GetSupportedLayers": {
		"prefix": "TerrainData.GetSupportedLayers",
		"body": [
			"GetSupportedLayers($1)"
		],
		"description": "public int[] GetSupportedLayers(int xBase, int yBase, int totalWidth, int totalHeight); des: Returns an array of all supported detail layer indices in the area."
	}
,
	"TerrainData.GetTreeInstance": {
		"prefix": "TerrainData.GetTreeInstance",
		"body": [
			"GetTreeInstance($1)"
		],
		"description": "public TreeInstance GetTreeInstance(int index); des: Get the tree instance at the specified index. It is used as a faster version of treeInstances[index] as this function doesn't create the entire tree instances array."
	}
,
	"TerrainData.OverrideMaximumHeightError": {
		"prefix": "TerrainData.OverrideMaximumHeightError",
		"body": [
			"OverrideMaximumHeightError($1)"
		],
		"description": "public void OverrideMaximumHeightError(float[] maxError); des: Override the maximum tessellation height error with user provided values. Note that the overriden values get reset when the terrain resolution is changed and stays unchanged when the terrain heightmap is painted or changed via script."
	}
,
	"TerrainData.OverrideMinMaxPatchHeights": {
		"prefix": "TerrainData.OverrideMinMaxPatchHeights",
		"body": [
			"OverrideMinMaxPatchHeights($1)"
		],
		"description": "public void OverrideMinMaxPatchHeights(PatchExtents[] minMaxHeights); des: Override the minimum and maximum patch heights for every renderable terrain patch. Note that the overriden values get reset when the terrain resolution is changed and stays unchanged when the terrain heightmap is painted or changed via script."
	}
,
	"TerrainData.RefreshPrototypes": {
		"prefix": "TerrainData.RefreshPrototypes",
		"body": [
			"RefreshPrototypes($1)"
		],
		"description": "public void RefreshPrototypes(); des: Reloads all the values of the available prototypes (ie, detail mesh assets) in the TerrainData Object."
	}
,
	"TerrainData.SetAlphamaps": {
		"prefix": "TerrainData.SetAlphamaps",
		"body": [
			"SetAlphamaps($1)"
		],
		"description": "public void SetAlphamaps(int x, int y, float[,,] map); des: Assign all splat values in the given map area."
	}
,
	"TerrainData.SetDetailLayer": {
		"prefix": "TerrainData.SetDetailLayer",
		"body": [
			"SetDetailLayer($1)"
		],
		"description": "public void SetDetailLayer(int xBase, int yBase, int layer, int[,] details); des: Sets the detail layer density map."
	}
,
	"TerrainData.SetDetailResolution": {
		"prefix": "TerrainData.SetDetailResolution",
		"body": [
			"SetDetailResolution($1)"
		],
		"description": "public void SetDetailResolution(int detailResolution, int resolutionPerPatch); des: Set the resolution of the detail map."
	}
,
	"TerrainData.SetHeights": {
		"prefix": "TerrainData.SetHeights",
		"body": [
			"SetHeights($1)"
		],
		"description": "public void SetHeights(int xBase, int yBase, float[,] heights); des: Set an array of heightmap samples."
	}
,
	"TerrainData.SetHeightsDelayLOD": {
		"prefix": "TerrainData.SetHeightsDelayLOD",
		"body": [
			"SetHeightsDelayLOD($1)"
		],
		"description": "public void SetHeightsDelayLOD(int xBase, int yBase, float[,] heights); des: Set an array of heightmap samples."
	}
,
	"TerrainData.SetTreeInstance": {
		"prefix": "TerrainData.SetTreeInstance",
		"body": [
			"SetTreeInstance($1)"
		],
		"description": "public void SetTreeInstance(int index, TreeInstance instance); des: Set the tree instance with new parameters at the specified index. However, TreeInstance.prototypeIndex and TreeInstance.position can not be changed otherwise an ArgumentException will be thrown."
	}
,
	"TerrainData.hideFlags": {
		"prefix": "TerrainData.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"TerrainData.name": {
		"prefix": "TerrainData.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"TerrainData.GetInstanceID": {
		"prefix": "TerrainData.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"TerrainData.ToString": {
		"prefix": "TerrainData.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"TerrainData.Destroy": {
		"prefix": "TerrainData.Destroy",
		"body": [
			"TerrainData.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"TerrainData.DestroyImmediate": {
		"prefix": "TerrainData.DestroyImmediate",
		"body": [
			"TerrainData.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"TerrainData.DontDestroyOnLoad": {
		"prefix": "TerrainData.DontDestroyOnLoad",
		"body": [
			"TerrainData.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"TerrainData.FindObjectOfType": {
		"prefix": "TerrainData.FindObjectOfType",
		"body": [
			"TerrainData.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"TerrainData.FindObjectsOfType": {
		"prefix": "TerrainData.FindObjectsOfType",
		"body": [
			"TerrainData.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"TerrainData.Instantiate": {
		"prefix": "TerrainData.Instantiate",
		"body": [
			"TerrainData.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"TerrainExtensions.UpdateGIMaterials": {
		"prefix": "TerrainExtensions.UpdateGIMaterials",
		"body": [
			"TerrainExtensions.UpdateGIMaterials"
		],
		"description": "public static void UpdateGIMaterials(Terrain terrain); public static void UpdateGIMaterials(Terrain terrain, int x, int y, int width, int height); des: Schedules an update of the albedo and emissive Textures of a system that contains the Terrain."
	}
,
	"TextAsset.bytes": {
		"prefix": "TextAsset.bytes",
		"body": [
			"bytes"
		],
		"description": "return:byte[] des: The raw bytes of the text asset. (Read Only)"
	}
,
	"TextAsset.text": {
		"prefix": "TextAsset.text",
		"body": [
			"text"
		],
		"description": "return:string des: The text contents of the .txt file as a string. (Read Only)"
	}
,
	"TextAsset.ToString": {
		"prefix": "TextAsset.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the contents of the TextAsset."
	}
,
	"TextAsset.hideFlags": {
		"prefix": "TextAsset.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"TextAsset.name": {
		"prefix": "TextAsset.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"TextAsset.GetInstanceID": {
		"prefix": "TextAsset.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"TextAsset.Destroy": {
		"prefix": "TextAsset.Destroy",
		"body": [
			"TextAsset.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"TextAsset.DestroyImmediate": {
		"prefix": "TextAsset.DestroyImmediate",
		"body": [
			"TextAsset.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"TextAsset.DontDestroyOnLoad": {
		"prefix": "TextAsset.DontDestroyOnLoad",
		"body": [
			"TextAsset.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"TextAsset.FindObjectOfType": {
		"prefix": "TextAsset.FindObjectOfType",
		"body": [
			"TextAsset.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"TextAsset.FindObjectsOfType": {
		"prefix": "TextAsset.FindObjectsOfType",
		"body": [
			"TextAsset.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"TextAsset.Instantiate": {
		"prefix": "TextAsset.Instantiate",
		"body": [
			"TextAsset.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"TextGenerationSettings.alignByGeometry": {
		"prefix": "TextGenerationSettings.alignByGeometry",
		"body": [
			"alignByGeometry"
		],
		"description": "return:bool des: Use the extents of glyph geometry to perform horizontal alignment rather than glyph metrics."
	}
,
	"TextGenerationSettings.color": {
		"prefix": "TextGenerationSettings.color",
		"body": [
			"color"
		],
		"description": "return:Color des: The base color for the text generation."
	}
,
	"TextGenerationSettings.font": {
		"prefix": "TextGenerationSettings.font",
		"body": [
			"font"
		],
		"description": "return:Font des: Font to use for generation."
	}
,
	"TextGenerationSettings.fontSize": {
		"prefix": "TextGenerationSettings.fontSize",
		"body": [
			"fontSize"
		],
		"description": "return:int des: Font size."
	}
,
	"TextGenerationSettings.fontStyle": {
		"prefix": "TextGenerationSettings.fontStyle",
		"body": [
			"fontStyle"
		],
		"description": "return:FontStyle des: Font style."
	}
,
	"TextGenerationSettings.generateOutOfBounds": {
		"prefix": "TextGenerationSettings.generateOutOfBounds",
		"body": [
			"generateOutOfBounds"
		],
		"description": "return:bool des: Continue to generate characters even if the text runs out of bounds."
	}
,
	"TextGenerationSettings.generationExtents": {
		"prefix": "TextGenerationSettings.generationExtents",
		"body": [
			"generationExtents"
		],
		"description": "return:Vector2 des: Extents that the generator will attempt to fit the text in."
	}
,
	"TextGenerationSettings.horizontalOverflow": {
		"prefix": "TextGenerationSettings.horizontalOverflow",
		"body": [
			"horizontalOverflow"
		],
		"description": "return:HorizontalWrapMode des: What happens to text when it reaches the horizontal generation bounds."
	}
,
	"TextGenerationSettings.lineSpacing": {
		"prefix": "TextGenerationSettings.lineSpacing",
		"body": [
			"lineSpacing"
		],
		"description": "return:float des: The line spacing multiplier."
	}
,
	"TextGenerationSettings.pivot": {
		"prefix": "TextGenerationSettings.pivot",
		"body": [
			"pivot"
		],
		"description": "return:Vector2 des: Generated vertices are offset by the pivot."
	}
,
	"TextGenerationSettings.resizeTextForBestFit": {
		"prefix": "TextGenerationSettings.resizeTextForBestFit",
		"body": [
			"resizeTextForBestFit"
		],
		"description": "return:bool des: Should the text be resized to fit the configured bounds?"
	}
,
	"TextGenerationSettings.resizeTextMaxSize": {
		"prefix": "TextGenerationSettings.resizeTextMaxSize",
		"body": [
			"resizeTextMaxSize"
		],
		"description": "return:int des: Maximum size for resized text."
	}
,
	"TextGenerationSettings.resizeTextMinSize": {
		"prefix": "TextGenerationSettings.resizeTextMinSize",
		"body": [
			"resizeTextMinSize"
		],
		"description": "return:int des: Minimum size for resized text."
	}
,
	"TextGenerationSettings.richText": {
		"prefix": "TextGenerationSettings.richText",
		"body": [
			"richText"
		],
		"description": "return:bool des: Allow rich text markup in generation."
	}
,
	"TextGenerationSettings.scaleFactor": {
		"prefix": "TextGenerationSettings.scaleFactor",
		"body": [
			"scaleFactor"
		],
		"description": "return:float des: A scale factor for the text. This is useful if the Text is on a Canvas and the canvas is scaled."
	}
,
	"TextGenerationSettings.textAnchor": {
		"prefix": "TextGenerationSettings.textAnchor",
		"body": [
			"textAnchor"
		],
		"description": "return:TextAnchor des: How is the generated text anchored."
	}
,
	"TextGenerationSettings.updateBounds": {
		"prefix": "TextGenerationSettings.updateBounds",
		"body": [
			"updateBounds"
		],
		"description": "return:bool des: Should the text generator update the bounds from the generated text."
	}
,
	"TextGenerationSettings.verticalOverflow": {
		"prefix": "TextGenerationSettings.verticalOverflow",
		"body": [
			"verticalOverflow"
		],
		"description": "return:VerticalWrapMode des: What happens to text when it reaches the bottom generation bounds."
	}
,
	"TextGenerator.characterCount": {
		"prefix": "TextGenerator.characterCount",
		"body": [
			"characterCount"
		],
		"description": "return:int des: The number of characters that have been generated."
	}
,
	"TextGenerator.characterCountVisible": {
		"prefix": "TextGenerator.characterCountVisible",
		"body": [
			"characterCountVisible"
		],
		"description": "return:int des: The number of characters that have been generated and are included in the visible lines."
	}
,
	"TextGenerator.characters": {
		"prefix": "TextGenerator.characters",
		"body": [
			"characters"
		],
		"description": "return:IList<UICharInfo> des: Array of generated characters."
	}
,
	"TextGenerator.fontSizeUsedForBestFit": {
		"prefix": "TextGenerator.fontSizeUsedForBestFit",
		"body": [
			"fontSizeUsedForBestFit"
		],
		"description": "return:int des: The size of the font that was found if using best fit mode."
	}
,
	"TextGenerator.lineCount": {
		"prefix": "TextGenerator.lineCount",
		"body": [
			"lineCount"
		],
		"description": "return:int des: Number of text lines generated."
	}
,
	"TextGenerator.lines": {
		"prefix": "TextGenerator.lines",
		"body": [
			"lines"
		],
		"description": "return:IList<UILineInfo> des: Information about each generated text line."
	}
,
	"TextGenerator.rectExtents": {
		"prefix": "TextGenerator.rectExtents",
		"body": [
			"rectExtents"
		],
		"description": "return:Rect des: Extents of the generated text in rect format."
	}
,
	"TextGenerator.vertexCount": {
		"prefix": "TextGenerator.vertexCount",
		"body": [
			"vertexCount"
		],
		"description": "return:int des: Number of vertices generated."
	}
,
	"TextGenerator.verts": {
		"prefix": "TextGenerator.verts",
		"body": [
			"verts"
		],
		"description": "return:IList<UIVertex> des: Array of generated vertices."
	}
,
	"TextGenerator.GetCharacters": {
		"prefix": "TextGenerator.GetCharacters",
		"body": [
			"GetCharacters($1)"
		],
		"description": "public void GetCharacters(List<UICharInfo> characters); des: Populate the given List with UICharInfo."
	}
,
	"TextGenerator.GetCharactersArray": {
		"prefix": "TextGenerator.GetCharactersArray",
		"body": [
			"GetCharactersArray($1)"
		],
		"description": "public UICharInfo[] GetCharactersArray(); des: Returns the current UICharInfo."
	}
,
	"TextGenerator.GetLines": {
		"prefix": "TextGenerator.GetLines",
		"body": [
			"GetLines($1)"
		],
		"description": "public void GetLines(List<UILineInfo> lines); des: Populate the given list with UILineInfo."
	}
,
	"TextGenerator.GetLinesArray": {
		"prefix": "TextGenerator.GetLinesArray",
		"body": [
			"GetLinesArray($1)"
		],
		"description": "public UILineInfo[] GetLinesArray(); des: Returns the current UILineInfo."
	}
,
	"TextGenerator.GetPreferredHeight": {
		"prefix": "TextGenerator.GetPreferredHeight",
		"body": [
			"GetPreferredHeight($1)"
		],
		"description": "public float GetPreferredHeight(string str, TextGenerationSettings settings); des: Given a string and settings, returns the preferred height for a container that would hold this text."
	}
,
	"TextGenerator.GetPreferredWidth": {
		"prefix": "TextGenerator.GetPreferredWidth",
		"body": [
			"GetPreferredWidth($1)"
		],
		"description": "public float GetPreferredWidth(string str, TextGenerationSettings settings); des: Given a string and settings, returns the preferred width for a container that would hold this text."
	}
,
	"TextGenerator.GetVertices": {
		"prefix": "TextGenerator.GetVertices",
		"body": [
			"GetVertices($1)"
		],
		"description": "public void GetVertices(List<UIVertex> vertices); des: Populate the given list with generated Vertices."
	}
,
	"TextGenerator.GetVerticesArray": {
		"prefix": "TextGenerator.GetVerticesArray",
		"body": [
			"GetVerticesArray($1)"
		],
		"description": "public UIVertex[] GetVerticesArray(); des: Returns the current UIVertex array."
	}
,
	"TextGenerator.Invalidate": {
		"prefix": "TextGenerator.Invalidate",
		"body": [
			"Invalidate($1)"
		],
		"description": "public void Invalidate(); des: Mark the text generator as invalid. This will force a full text generation the next time Populate is called."
	}
,
	"TextGenerator.Populate": {
		"prefix": "TextGenerator.Populate",
		"body": [
			"Populate($1)"
		],
		"description": "public bool Populate(string str, TextGenerationSettings settings); des: Will generate the vertices and other data for the given string with the given settings."
	}
,
	"TextGenerator.PopulateWithErrors": {
		"prefix": "TextGenerator.PopulateWithErrors",
		"body": [
			"PopulateWithErrors($1)"
		],
		"description": "public bool PopulateWithErrors(string str, TextGenerationSettings settings, GameObject context); des: Will generate the vertices and other data for the given string with the given settings."
	}
,
	"TextMesh.alignment": {
		"prefix": "TextMesh.alignment",
		"body": [
			"alignment"
		],
		"description": "return:TextAlignment des: How lines of text are aligned (Left, Right, Center)."
	}
,
	"TextMesh.anchor": {
		"prefix": "TextMesh.anchor",
		"body": [
			"anchor"
		],
		"description": "return:TextAnchor des: Which point of the text shares the position of the Transform."
	}
,
	"TextMesh.characterSize": {
		"prefix": "TextMesh.characterSize",
		"body": [
			"characterSize"
		],
		"description": "return:float des: The size of each character (This scales the whole text)."
	}
,
	"TextMesh.color": {
		"prefix": "TextMesh.color",
		"body": [
			"color"
		],
		"description": "return:Color des: The color used to render the text."
	}
,
	"TextMesh.font": {
		"prefix": "TextMesh.font",
		"body": [
			"font"
		],
		"description": "return:Font des: The Font used."
	}
,
	"TextMesh.fontSize": {
		"prefix": "TextMesh.fontSize",
		"body": [
			"fontSize"
		],
		"description": "return:int des: The font size to use (for dynamic fonts)."
	}
,
	"TextMesh.fontStyle": {
		"prefix": "TextMesh.fontStyle",
		"body": [
			"fontStyle"
		],
		"description": "return:FontStyle des: The font style to use (for dynamic fonts)."
	}
,
	"TextMesh.lineSpacing": {
		"prefix": "TextMesh.lineSpacing",
		"body": [
			"lineSpacing"
		],
		"description": "return:float des: How much space will be in-between lines of text."
	}
,
	"TextMesh.offsetZ": {
		"prefix": "TextMesh.offsetZ",
		"body": [
			"offsetZ"
		],
		"description": "return:float des: How far should the text be offset from the transform.position.z when drawing."
	}
,
	"TextMesh.richText": {
		"prefix": "TextMesh.richText",
		"body": [
			"richText"
		],
		"description": "return:bool des: Enable HTML-style tags for Text Formatting Markup."
	}
,
	"TextMesh.tabSize": {
		"prefix": "TextMesh.tabSize",
		"body": [
			"tabSize"
		],
		"description": "return:float des: How much space will be inserted for a tab '\t' character. This is a multiplum of the 'spacebar' character offset."
	}
,
	"TextMesh.text": {
		"prefix": "TextMesh.text",
		"body": [
			"text"
		],
		"description": "return:string des: The text that is displayed."
	}
,
	"TextMesh.gameObject": {
		"prefix": "TextMesh.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"TextMesh.tag": {
		"prefix": "TextMesh.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"TextMesh.transform": {
		"prefix": "TextMesh.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"TextMesh.hideFlags": {
		"prefix": "TextMesh.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"TextMesh.name": {
		"prefix": "TextMesh.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"TextMesh.BroadcastMessage": {
		"prefix": "TextMesh.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"TextMesh.CompareTag": {
		"prefix": "TextMesh.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"TextMesh.GetComponent": {
		"prefix": "TextMesh.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"TextMesh.GetComponentInChildren": {
		"prefix": "TextMesh.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"TextMesh.GetComponentInParent": {
		"prefix": "TextMesh.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"TextMesh.GetComponents": {
		"prefix": "TextMesh.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"TextMesh.GetComponentsInChildren": {
		"prefix": "TextMesh.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"TextMesh.GetComponentsInParent": {
		"prefix": "TextMesh.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"TextMesh.SendMessage": {
		"prefix": "TextMesh.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"TextMesh.SendMessageUpwards": {
		"prefix": "TextMesh.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"TextMesh.GetInstanceID": {
		"prefix": "TextMesh.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"TextMesh.ToString": {
		"prefix": "TextMesh.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"TextMesh.Destroy": {
		"prefix": "TextMesh.Destroy",
		"body": [
			"TextMesh.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"TextMesh.DestroyImmediate": {
		"prefix": "TextMesh.DestroyImmediate",
		"body": [
			"TextMesh.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"TextMesh.DontDestroyOnLoad": {
		"prefix": "TextMesh.DontDestroyOnLoad",
		"body": [
			"TextMesh.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"TextMesh.FindObjectOfType": {
		"prefix": "TextMesh.FindObjectOfType",
		"body": [
			"TextMesh.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"TextMesh.FindObjectsOfType": {
		"prefix": "TextMesh.FindObjectsOfType",
		"body": [
			"TextMesh.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"TextMesh.Instantiate": {
		"prefix": "TextMesh.Instantiate",
		"body": [
			"TextMesh.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"Texture.anisoLevel": {
		"prefix": "Texture.anisoLevel",
		"body": [
			"anisoLevel"
		],
		"description": "return:int des: Anisotropic filtering level of the texture."
	}
,
	"Texture.dimension": {
		"prefix": "Texture.dimension",
		"body": [
			"dimension"
		],
		"description": "return:Rendering.TextureDimension des: Dimensionality (type) of the texture (Read Only)."
	}
,
	"Texture.filterMode": {
		"prefix": "Texture.filterMode",
		"body": [
			"filterMode"
		],
		"description": "return:FilterMode des: Filtering mode of the texture."
	}
,
	"Texture.height": {
		"prefix": "Texture.height",
		"body": [
			"height"
		],
		"description": "return:int des: Height of the texture in pixels. (Read Only)"
	}
,
	"Texture.imageContentsHash": {
		"prefix": "Texture.imageContentsHash",
		"body": [
			"imageContentsHash"
		],
		"description": "return:Hash128 des: The hash value of the Texture."
	}
,
	"Texture.mipMapBias": {
		"prefix": "Texture.mipMapBias",
		"body": [
			"mipMapBias"
		],
		"description": "return:float des: Mip map bias of the texture."
	}
,
	"Texture.updateCount": {
		"prefix": "Texture.updateCount",
		"body": [
			"updateCount"
		],
		"description": "return:uint des: This counter is incremented when the texture is updated."
	}
,
	"Texture.width": {
		"prefix": "Texture.width",
		"body": [
			"width"
		],
		"description": "return:int des: Width of the texture in pixels. (Read Only)"
	}
,
	"Texture.wrapMode": {
		"prefix": "Texture.wrapMode",
		"body": [
			"wrapMode"
		],
		"description": "return:TextureWrapMode des: Texture coordinate wrapping mode."
	}
,
	"Texture.wrapModeU": {
		"prefix": "Texture.wrapModeU",
		"body": [
			"wrapModeU"
		],
		"description": "return:TextureWrapMode des: Texture U coordinate wrapping mode."
	}
,
	"Texture.wrapModeV": {
		"prefix": "Texture.wrapModeV",
		"body": [
			"wrapModeV"
		],
		"description": "return:TextureWrapMode des: Texture V coordinate wrapping mode."
	}
,
	"Texture.wrapModeW": {
		"prefix": "Texture.wrapModeW",
		"body": [
			"wrapModeW"
		],
		"description": "return:TextureWrapMode des: Texture W coordinate wrapping mode for Texture3D."
	}
,
	"Texture.GetNativeTexturePtr": {
		"prefix": "Texture.GetNativeTexturePtr",
		"body": [
			"GetNativeTexturePtr($1)"
		],
		"description": "public IntPtr GetNativeTexturePtr(); des: Retrieve a native (underlying graphics API) pointer to the texture resource."
	}
,
	"Texture.IncrementUpdateCount": {
		"prefix": "Texture.IncrementUpdateCount",
		"body": [
			"IncrementUpdateCount($1)"
		],
		"description": "public void IncrementUpdateCount(); des: Increment the update counter."
	}
,
	"Texture.SetGlobalAnisotropicFilteringLimits": {
		"prefix": "Texture.SetGlobalAnisotropicFilteringLimits",
		"body": [
			"Texture.SetGlobalAnisotropicFilteringLimits"
		],
		"description": "public static void SetGlobalAnisotropicFilteringLimits(int forcedMin, int globalMax); des: Sets Anisotropic limits."
	}
,
	"Texture.SetStreamingTextureMaterialDebugProperties": {
		"prefix": "Texture.SetStreamingTextureMaterialDebugProperties",
		"body": [
			"Texture.SetStreamingTextureMaterialDebugProperties"
		],
		"description": "public static void SetStreamingTextureMaterialDebugProperties(); des: Uploads additional debug information to materials using textures set to stream mip maps."
	}
,
	"Texture.hideFlags": {
		"prefix": "Texture.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Texture.name": {
		"prefix": "Texture.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Texture.GetInstanceID": {
		"prefix": "Texture.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Texture.ToString": {
		"prefix": "Texture.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Texture.Destroy": {
		"prefix": "Texture.Destroy",
		"body": [
			"Texture.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Texture.DestroyImmediate": {
		"prefix": "Texture.DestroyImmediate",
		"body": [
			"Texture.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Texture.DontDestroyOnLoad": {
		"prefix": "Texture.DontDestroyOnLoad",
		"body": [
			"Texture.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Texture.FindObjectOfType": {
		"prefix": "Texture.FindObjectOfType",
		"body": [
			"Texture.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Texture.FindObjectsOfType": {
		"prefix": "Texture.FindObjectsOfType",
		"body": [
			"Texture.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Texture.Instantiate": {
		"prefix": "Texture.Instantiate",
		"body": [
			"Texture.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"Texture2D.alphaIsTransparency": {
		"prefix": "Texture2D.alphaIsTransparency",
		"body": [
			"alphaIsTransparency"
		],
		"description": "return:bool des: Indicates whether this texture was imported with TextureImporter.alphaIsTransparency enabled. This setting is available only in the Editor scripts. Note that changing this setting will have no effect; it must be enabled in TextureImporter instead."
	}
,
	"Texture2D.desiredMipmapLevel": {
		"prefix": "Texture2D.desiredMipmapLevel",
		"body": [
			"desiredMipmapLevel"
		],
		"description": "return:int des: The mipmap level which would have been loaded by the streaming system before memory budgets are applied."
	}
,
	"Texture2D.format": {
		"prefix": "Texture2D.format",
		"body": [
			"format"
		],
		"description": "return:TextureFormat des: The format of the pixel data in the texture (Read Only)."
	}
,
	"Texture2D.loadedMipmapLevel": {
		"prefix": "Texture2D.loadedMipmapLevel",
		"body": [
			"loadedMipmapLevel"
		],
		"description": "return:int des: Which mipmap level is currently loaded by the streaming system."
	}
,
	"Texture2D.loadingMipmapLevel": {
		"prefix": "Texture2D.loadingMipmapLevel",
		"body": [
			"loadingMipmapLevel"
		],
		"description": "return:int des: Which mipmap level is in the process of being loaded by the mipmap streaming system."
	}
,
	"Texture2D.mipmapCount": {
		"prefix": "Texture2D.mipmapCount",
		"body": [
			"mipmapCount"
		],
		"description": "return:int des: How many mipmap levels are in this texture (Read Only)."
	}
,
	"Texture2D.requestedMipmapLevel": {
		"prefix": "Texture2D.requestedMipmapLevel",
		"body": [
			"requestedMipmapLevel"
		],
		"description": "return:int des: The mipmap level to load."
	}
,
	"Texture2D.streamingMipmaps": {
		"prefix": "Texture2D.streamingMipmaps",
		"body": [
			"streamingMipmaps"
		],
		"description": "return:bool des: Has mipmap streaming been enabled for this texture."
	}
,
	"Texture2D.streamingMipmapsPriority": {
		"prefix": "Texture2D.streamingMipmapsPriority",
		"body": [
			"streamingMipmapsPriority"
		],
		"description": "return:int des: Relative priority for this texture when reducing memory size in order to hit the memory budget."
	}
,
	"Texture2D.Apply": {
		"prefix": "Texture2D.Apply",
		"body": [
			"Apply($1)"
		],
		"description": "public void Apply(bool updateMipmaps = true, bool makeNoLongerReadable = false); des: Actually apply all previous SetPixel and SetPixels changes."
	}
,
	"Texture2D.ClearRequestedMipmapLevel": {
		"prefix": "Texture2D.ClearRequestedMipmapLevel",
		"body": [
			"ClearRequestedMipmapLevel($1)"
		],
		"description": "public void ClearRequestedMipmapLevel(); des: Resets the requestedMipmapLevel field."
	}
,
	"Texture2D.Compress": {
		"prefix": "Texture2D.Compress",
		"body": [
			"Compress($1)"
		],
		"description": "public void Compress(bool highQuality); des: Compress texture into DXT format."
	}
,
	"Texture2D.GetPixel": {
		"prefix": "Texture2D.GetPixel",
		"body": [
			"GetPixel($1)"
		],
		"description": "public Color GetPixel(int x, int y); des: Returns pixel color at coordinates (x, y)."
	}
,
	"Texture2D.GetPixelBilinear": {
		"prefix": "Texture2D.GetPixelBilinear",
		"body": [
			"GetPixelBilinear($1)"
		],
		"description": "public Color GetPixelBilinear(float x, float y); des: Returns filtered pixel color at normalized coordinates (u, v)."
	}
,
	"Texture2D.GetPixels": {
		"prefix": "Texture2D.GetPixels",
		"body": [
			"GetPixels($1)"
		],
		"description": "public Color[] GetPixels(int miplevel = 0); public Color[] GetPixels(int x, int y, int blockWidth, int blockHeight, int miplevel = 0); des: Get the pixel colors from the texture."
	}
,
	"Texture2D.GetPixels32": {
		"prefix": "Texture2D.GetPixels32",
		"body": [
			"GetPixels32($1)"
		],
		"description": "public Color32[] GetPixels32(int miplevel = 0); des: Get a block of pixel colors in Color32 format."
	}
,
	"Texture2D.GetRawTextureData": {
		"prefix": "Texture2D.GetRawTextureData",
		"body": [
			"GetRawTextureData($1)"
		],
		"description": "public NativeArray<T> GetRawTextureData(); public byte[] GetRawTextureData(); des: Get raw data from a texture for reading or writing."
	}
,
	"Texture2D.IsRequestedMipmapLevelLoaded": {
		"prefix": "Texture2D.IsRequestedMipmapLevelLoaded",
		"body": [
			"IsRequestedMipmapLevelLoaded($1)"
		],
		"description": "public bool IsRequestedMipmapLevelLoaded(); des: Has the mipmap level requested by setting requestedMipmapLevel finished loading?"
	}
,
	"Texture2D.LoadRawTextureData": {
		"prefix": "Texture2D.LoadRawTextureData",
		"body": [
			"LoadRawTextureData($1)"
		],
		"description": "public void LoadRawTextureData(byte[] data); public void LoadRawTextureData(NativeArray<T> data); public void LoadRawTextureData(IntPtr data, int size); des: Fills texture pixels with raw preformatted data."
	}
,
	"Texture2D.PackTextures": {
		"prefix": "Texture2D.PackTextures",
		"body": [
			"PackTextures($1)"
		],
		"description": "public Rect[] PackTextures(Texture2D[] textures, int padding, int maximumAtlasSize = 2048, bool makeNoLongerReadable = false); des: Packs multiple Textures into a texture atlas."
	}
,
	"Texture2D.ReadPixels": {
		"prefix": "Texture2D.ReadPixels",
		"body": [
			"ReadPixels($1)"
		],
		"description": "public void ReadPixels(Rect source, int destX, int destY, bool recalculateMipMaps = true); des: Read pixels from screen into the saved texture data."
	}
,
	"Texture2D.Resize": {
		"prefix": "Texture2D.Resize",
		"body": [
			"Resize($1)"
		],
		"description": "public bool Resize(int width, int height, TextureFormat format, bool hasMipMap); public bool Resize(int width, int height); des: Resizes the texture."
	}
,
	"Texture2D.SetPixel": {
		"prefix": "Texture2D.SetPixel",
		"body": [
			"SetPixel($1)"
		],
		"description": "public void SetPixel(int x, int y, Color color); des: Sets pixel color at coordinates (x,y)."
	}
,
	"Texture2D.SetPixels": {
		"prefix": "Texture2D.SetPixels",
		"body": [
			"SetPixels($1)"
		],
		"description": "public void SetPixels(Color[] colors, int miplevel = 0); public void SetPixels(int x, int y, int blockWidth, int blockHeight, Color[] colors, int miplevel = 0); des: Set a block of pixel colors."
	}
,
	"Texture2D.SetPixels32": {
		"prefix": "Texture2D.SetPixels32",
		"body": [
			"SetPixels32($1)"
		],
		"description": "public void SetPixels32(Color32[] colors, int miplevel = 0); public void SetPixels32(int x, int y, int blockWidth, int blockHeight, Color32[] colors, int miplevel = 0); des: Set a block of pixel colors."
	}
,
	"Texture2D.UpdateExternalTexture": {
		"prefix": "Texture2D.UpdateExternalTexture",
		"body": [
			"UpdateExternalTexture($1)"
		],
		"description": "public void UpdateExternalTexture(IntPtr nativeTex); des: Updates Unity texture to use different native texture object."
	}
,
	"Texture2D.CreateExternalTexture": {
		"prefix": "Texture2D.CreateExternalTexture",
		"body": [
			"Texture2D.CreateExternalTexture"
		],
		"description": "public static Texture2D CreateExternalTexture(int width, int height, TextureFormat format, bool mipChain, bool linear, IntPtr nativeTex); des: Creates Unity Texture out of externally created native texture object."
	}
,
	"Texture2D.GenerateAtlas": {
		"prefix": "Texture2D.GenerateAtlas",
		"body": [
			"Texture2D.GenerateAtlas"
		],
		"description": " des: Packs a set of rectangles into a square atlas, with optional padding between rectangles."
	}
,
	"Texture2D.hideFlags": {
		"prefix": "Texture2D.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Texture2D.name": {
		"prefix": "Texture2D.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Texture2D.anisoLevel": {
		"prefix": "Texture2D.anisoLevel",
		"body": [
			"anisoLevel"
		],
		"description": "return:int des: Anisotropic filtering level of the texture."
	}
,
	"Texture2D.dimension": {
		"prefix": "Texture2D.dimension",
		"body": [
			"dimension"
		],
		"description": "return:Rendering.TextureDimension des: Dimensionality (type) of the texture (Read Only)."
	}
,
	"Texture2D.filterMode": {
		"prefix": "Texture2D.filterMode",
		"body": [
			"filterMode"
		],
		"description": "return:FilterMode des: Filtering mode of the texture."
	}
,
	"Texture2D.height": {
		"prefix": "Texture2D.height",
		"body": [
			"height"
		],
		"description": "return:int des: Height of the texture in pixels. (Read Only)"
	}
,
	"Texture2D.imageContentsHash": {
		"prefix": "Texture2D.imageContentsHash",
		"body": [
			"imageContentsHash"
		],
		"description": "return:Hash128 des: The hash value of the Texture."
	}
,
	"Texture2D.mipMapBias": {
		"prefix": "Texture2D.mipMapBias",
		"body": [
			"mipMapBias"
		],
		"description": "return:float des: Mip map bias of the texture."
	}
,
	"Texture2D.updateCount": {
		"prefix": "Texture2D.updateCount",
		"body": [
			"updateCount"
		],
		"description": "return:uint des: This counter is incremented when the texture is updated."
	}
,
	"Texture2D.width": {
		"prefix": "Texture2D.width",
		"body": [
			"width"
		],
		"description": "return:int des: Width of the texture in pixels. (Read Only)"
	}
,
	"Texture2D.wrapMode": {
		"prefix": "Texture2D.wrapMode",
		"body": [
			"wrapMode"
		],
		"description": "return:TextureWrapMode des: Texture coordinate wrapping mode."
	}
,
	"Texture2D.wrapModeU": {
		"prefix": "Texture2D.wrapModeU",
		"body": [
			"wrapModeU"
		],
		"description": "return:TextureWrapMode des: Texture U coordinate wrapping mode."
	}
,
	"Texture2D.wrapModeV": {
		"prefix": "Texture2D.wrapModeV",
		"body": [
			"wrapModeV"
		],
		"description": "return:TextureWrapMode des: Texture V coordinate wrapping mode."
	}
,
	"Texture2D.wrapModeW": {
		"prefix": "Texture2D.wrapModeW",
		"body": [
			"wrapModeW"
		],
		"description": "return:TextureWrapMode des: Texture W coordinate wrapping mode for Texture3D."
	}
,
	"Texture2D.GetInstanceID": {
		"prefix": "Texture2D.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Texture2D.ToString": {
		"prefix": "Texture2D.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Texture2D.GetNativeTexturePtr": {
		"prefix": "Texture2D.GetNativeTexturePtr",
		"body": [
			"GetNativeTexturePtr($1)"
		],
		"description": "public IntPtr GetNativeTexturePtr(); des: Retrieve a native (underlying graphics API) pointer to the texture resource."
	}
,
	"Texture2D.IncrementUpdateCount": {
		"prefix": "Texture2D.IncrementUpdateCount",
		"body": [
			"IncrementUpdateCount($1)"
		],
		"description": "public void IncrementUpdateCount(); des: Increment the update counter."
	}
,
	"Texture2D.Destroy": {
		"prefix": "Texture2D.Destroy",
		"body": [
			"Texture2D.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Texture2D.DestroyImmediate": {
		"prefix": "Texture2D.DestroyImmediate",
		"body": [
			"Texture2D.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Texture2D.DontDestroyOnLoad": {
		"prefix": "Texture2D.DontDestroyOnLoad",
		"body": [
			"Texture2D.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Texture2D.FindObjectOfType": {
		"prefix": "Texture2D.FindObjectOfType",
		"body": [
			"Texture2D.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Texture2D.FindObjectsOfType": {
		"prefix": "Texture2D.FindObjectsOfType",
		"body": [
			"Texture2D.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Texture2D.Instantiate": {
		"prefix": "Texture2D.Instantiate",
		"body": [
			"Texture2D.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"Texture2D.SetGlobalAnisotropicFilteringLimits": {
		"prefix": "Texture2D.SetGlobalAnisotropicFilteringLimits",
		"body": [
			"Texture2D.SetGlobalAnisotropicFilteringLimits"
		],
		"description": "public static void SetGlobalAnisotropicFilteringLimits(int forcedMin, int globalMax); des: Sets Anisotropic limits."
	}
,
	"Texture2D.SetStreamingTextureMaterialDebugProperties": {
		"prefix": "Texture2D.SetStreamingTextureMaterialDebugProperties",
		"body": [
			"Texture2D.SetStreamingTextureMaterialDebugProperties"
		],
		"description": "public static void SetStreamingTextureMaterialDebugProperties(); des: Uploads additional debug information to materials using textures set to stream mip maps."
	}
,
	"Texture2D.EXRFlags.None": {
		"prefix": "Texture2D.EXRFlags.None",
		"body": [
			"None"
		],
		"description": "return: des: No flag. This will result in an uncompressed 16-bit float EXR file."
	}
,
	"Texture2D.EXRFlags.OutputAsFloat": {
		"prefix": "Texture2D.EXRFlags.OutputAsFloat",
		"body": [
			"OutputAsFloat"
		],
		"description": "return: des: The texture will be exported as a 32-bit float EXR file (default is 16-bit)."
	}
,
	"Texture2D.EXRFlags.CompressZIP": {
		"prefix": "Texture2D.EXRFlags.CompressZIP",
		"body": [
			"CompressZIP"
		],
		"description": "return: des: The texture will use the EXR ZIP compression format."
	}
,
	"Texture2D.EXRFlags.CompressRLE": {
		"prefix": "Texture2D.EXRFlags.CompressRLE",
		"body": [
			"CompressRLE"
		],
		"description": "return: des: The texture will use RLE (Run Length Encoding) EXR compression format (similar to Targa RLE compression)."
	}
,
	"Texture2D.EXRFlags.CompressPIZ": {
		"prefix": "Texture2D.EXRFlags.CompressPIZ",
		"body": [
			"CompressPIZ"
		],
		"description": "return: des: This texture will use Wavelet compression. This is best used for grainy images."
	}
,
	"Texture2DArray.depth": {
		"prefix": "Texture2DArray.depth",
		"body": [
			"depth"
		],
		"description": "return:int des: Number of elements in a texture array (Read Only)."
	}
,
	"Texture2DArray.format": {
		"prefix": "Texture2DArray.format",
		"body": [
			"format"
		],
		"description": "return:TextureFormat des: Texture format (Read Only)."
	}
,
	"Texture2DArray.Apply": {
		"prefix": "Texture2DArray.Apply",
		"body": [
			"Apply($1)"
		],
		"description": "public void Apply(bool updateMipmaps = true, bool makeNoLongerReadable = false); des: Actually apply all previous SetPixels changes."
	}
,
	"Texture2DArray.GetPixels": {
		"prefix": "Texture2DArray.GetPixels",
		"body": [
			"GetPixels($1)"
		],
		"description": "public Color[] GetPixels(int arrayElement, int miplevel = 0); des: Returns pixel colors of a single array slice."
	}
,
	"Texture2DArray.GetPixels32": {
		"prefix": "Texture2DArray.GetPixels32",
		"body": [
			"GetPixels32($1)"
		],
		"description": "public Color32[] GetPixels32(int arrayElement, int miplevel = 0); des: Returns pixel colors of a single array slice."
	}
,
	"Texture2DArray.SetPixels": {
		"prefix": "Texture2DArray.SetPixels",
		"body": [
			"SetPixels($1)"
		],
		"description": "public void SetPixels(Color[] colors, int arrayElement, int miplevel = 0); des: Set pixel colors for the whole mip level."
	}
,
	"Texture2DArray.SetPixels32": {
		"prefix": "Texture2DArray.SetPixels32",
		"body": [
			"SetPixels32($1)"
		],
		"description": "public void SetPixels32(Color32[] colors, int arrayElement, int miplevel = 0); des: Set pixel colors for the whole mip level."
	}
,
	"Texture2DArray.hideFlags": {
		"prefix": "Texture2DArray.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Texture2DArray.name": {
		"prefix": "Texture2DArray.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Texture2DArray.anisoLevel": {
		"prefix": "Texture2DArray.anisoLevel",
		"body": [
			"anisoLevel"
		],
		"description": "return:int des: Anisotropic filtering level of the texture."
	}
,
	"Texture2DArray.dimension": {
		"prefix": "Texture2DArray.dimension",
		"body": [
			"dimension"
		],
		"description": "return:Rendering.TextureDimension des: Dimensionality (type) of the texture (Read Only)."
	}
,
	"Texture2DArray.filterMode": {
		"prefix": "Texture2DArray.filterMode",
		"body": [
			"filterMode"
		],
		"description": "return:FilterMode des: Filtering mode of the texture."
	}
,
	"Texture2DArray.height": {
		"prefix": "Texture2DArray.height",
		"body": [
			"height"
		],
		"description": "return:int des: Height of the texture in pixels. (Read Only)"
	}
,
	"Texture2DArray.imageContentsHash": {
		"prefix": "Texture2DArray.imageContentsHash",
		"body": [
			"imageContentsHash"
		],
		"description": "return:Hash128 des: The hash value of the Texture."
	}
,
	"Texture2DArray.mipMapBias": {
		"prefix": "Texture2DArray.mipMapBias",
		"body": [
			"mipMapBias"
		],
		"description": "return:float des: Mip map bias of the texture."
	}
,
	"Texture2DArray.updateCount": {
		"prefix": "Texture2DArray.updateCount",
		"body": [
			"updateCount"
		],
		"description": "return:uint des: This counter is incremented when the texture is updated."
	}
,
	"Texture2DArray.width": {
		"prefix": "Texture2DArray.width",
		"body": [
			"width"
		],
		"description": "return:int des: Width of the texture in pixels. (Read Only)"
	}
,
	"Texture2DArray.wrapMode": {
		"prefix": "Texture2DArray.wrapMode",
		"body": [
			"wrapMode"
		],
		"description": "return:TextureWrapMode des: Texture coordinate wrapping mode."
	}
,
	"Texture2DArray.wrapModeU": {
		"prefix": "Texture2DArray.wrapModeU",
		"body": [
			"wrapModeU"
		],
		"description": "return:TextureWrapMode des: Texture U coordinate wrapping mode."
	}
,
	"Texture2DArray.wrapModeV": {
		"prefix": "Texture2DArray.wrapModeV",
		"body": [
			"wrapModeV"
		],
		"description": "return:TextureWrapMode des: Texture V coordinate wrapping mode."
	}
,
	"Texture2DArray.wrapModeW": {
		"prefix": "Texture2DArray.wrapModeW",
		"body": [
			"wrapModeW"
		],
		"description": "return:TextureWrapMode des: Texture W coordinate wrapping mode for Texture3D."
	}
,
	"Texture2DArray.GetInstanceID": {
		"prefix": "Texture2DArray.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Texture2DArray.ToString": {
		"prefix": "Texture2DArray.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Texture2DArray.GetNativeTexturePtr": {
		"prefix": "Texture2DArray.GetNativeTexturePtr",
		"body": [
			"GetNativeTexturePtr($1)"
		],
		"description": "public IntPtr GetNativeTexturePtr(); des: Retrieve a native (underlying graphics API) pointer to the texture resource."
	}
,
	"Texture2DArray.IncrementUpdateCount": {
		"prefix": "Texture2DArray.IncrementUpdateCount",
		"body": [
			"IncrementUpdateCount($1)"
		],
		"description": "public void IncrementUpdateCount(); des: Increment the update counter."
	}
,
	"Texture2DArray.Destroy": {
		"prefix": "Texture2DArray.Destroy",
		"body": [
			"Texture2DArray.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Texture2DArray.DestroyImmediate": {
		"prefix": "Texture2DArray.DestroyImmediate",
		"body": [
			"Texture2DArray.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Texture2DArray.DontDestroyOnLoad": {
		"prefix": "Texture2DArray.DontDestroyOnLoad",
		"body": [
			"Texture2DArray.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Texture2DArray.FindObjectOfType": {
		"prefix": "Texture2DArray.FindObjectOfType",
		"body": [
			"Texture2DArray.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Texture2DArray.FindObjectsOfType": {
		"prefix": "Texture2DArray.FindObjectsOfType",
		"body": [
			"Texture2DArray.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Texture2DArray.Instantiate": {
		"prefix": "Texture2DArray.Instantiate",
		"body": [
			"Texture2DArray.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"Texture2DArray.SetGlobalAnisotropicFilteringLimits": {
		"prefix": "Texture2DArray.SetGlobalAnisotropicFilteringLimits",
		"body": [
			"Texture2DArray.SetGlobalAnisotropicFilteringLimits"
		],
		"description": "public static void SetGlobalAnisotropicFilteringLimits(int forcedMin, int globalMax); des: Sets Anisotropic limits."
	}
,
	"Texture2DArray.SetStreamingTextureMaterialDebugProperties": {
		"prefix": "Texture2DArray.SetStreamingTextureMaterialDebugProperties",
		"body": [
			"Texture2DArray.SetStreamingTextureMaterialDebugProperties"
		],
		"description": "public static void SetStreamingTextureMaterialDebugProperties(); des: Uploads additional debug information to materials using textures set to stream mip maps."
	}
,
	"Texture3D.depth": {
		"prefix": "Texture3D.depth",
		"body": [
			"depth"
		],
		"description": "return:int des: The depth of the texture (Read Only)."
	}
,
	"Texture3D.format": {
		"prefix": "Texture3D.format",
		"body": [
			"format"
		],
		"description": "return:TextureFormat des: The format of the pixel data in the texture (Read Only)."
	}
,
	"Texture3D.Apply": {
		"prefix": "Texture3D.Apply",
		"body": [
			"Apply($1)"
		],
		"description": "public void Apply(bool updateMipmaps = true, bool makeNoLongerReadable = false); des: Actually apply all previous SetPixels changes."
	}
,
	"Texture3D.GetPixels": {
		"prefix": "Texture3D.GetPixels",
		"body": [
			"GetPixels($1)"
		],
		"description": "public Color[] GetPixels(int miplevel = 0); des: Returns an array of pixel colors representing one mip level of the 3D texture."
	}
,
	"Texture3D.GetPixels32": {
		"prefix": "Texture3D.GetPixels32",
		"body": [
			"GetPixels32($1)"
		],
		"description": "public Color32[] GetPixels32(int miplevel = 0); des: Returns an array of pixel colors representing one mip level of the 3D texture."
	}
,
	"Texture3D.SetPixels": {
		"prefix": "Texture3D.SetPixels",
		"body": [
			"SetPixels($1)"
		],
		"description": "public void SetPixels(Color[] colors, int miplevel = 0); des: Sets pixel colors of a 3D texture."
	}
,
	"Texture3D.SetPixels32": {
		"prefix": "Texture3D.SetPixels32",
		"body": [
			"SetPixels32($1)"
		],
		"description": "public void SetPixels32(Color32[] colors, int miplevel = 0); des: Sets pixel colors of a 3D texture."
	}
,
	"Texture3D.hideFlags": {
		"prefix": "Texture3D.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Texture3D.name": {
		"prefix": "Texture3D.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Texture3D.anisoLevel": {
		"prefix": "Texture3D.anisoLevel",
		"body": [
			"anisoLevel"
		],
		"description": "return:int des: Anisotropic filtering level of the texture."
	}
,
	"Texture3D.dimension": {
		"prefix": "Texture3D.dimension",
		"body": [
			"dimension"
		],
		"description": "return:Rendering.TextureDimension des: Dimensionality (type) of the texture (Read Only)."
	}
,
	"Texture3D.filterMode": {
		"prefix": "Texture3D.filterMode",
		"body": [
			"filterMode"
		],
		"description": "return:FilterMode des: Filtering mode of the texture."
	}
,
	"Texture3D.height": {
		"prefix": "Texture3D.height",
		"body": [
			"height"
		],
		"description": "return:int des: Height of the texture in pixels. (Read Only)"
	}
,
	"Texture3D.imageContentsHash": {
		"prefix": "Texture3D.imageContentsHash",
		"body": [
			"imageContentsHash"
		],
		"description": "return:Hash128 des: The hash value of the Texture."
	}
,
	"Texture3D.mipMapBias": {
		"prefix": "Texture3D.mipMapBias",
		"body": [
			"mipMapBias"
		],
		"description": "return:float des: Mip map bias of the texture."
	}
,
	"Texture3D.updateCount": {
		"prefix": "Texture3D.updateCount",
		"body": [
			"updateCount"
		],
		"description": "return:uint des: This counter is incremented when the texture is updated."
	}
,
	"Texture3D.width": {
		"prefix": "Texture3D.width",
		"body": [
			"width"
		],
		"description": "return:int des: Width of the texture in pixels. (Read Only)"
	}
,
	"Texture3D.wrapMode": {
		"prefix": "Texture3D.wrapMode",
		"body": [
			"wrapMode"
		],
		"description": "return:TextureWrapMode des: Texture coordinate wrapping mode."
	}
,
	"Texture3D.wrapModeU": {
		"prefix": "Texture3D.wrapModeU",
		"body": [
			"wrapModeU"
		],
		"description": "return:TextureWrapMode des: Texture U coordinate wrapping mode."
	}
,
	"Texture3D.wrapModeV": {
		"prefix": "Texture3D.wrapModeV",
		"body": [
			"wrapModeV"
		],
		"description": "return:TextureWrapMode des: Texture V coordinate wrapping mode."
	}
,
	"Texture3D.wrapModeW": {
		"prefix": "Texture3D.wrapModeW",
		"body": [
			"wrapModeW"
		],
		"description": "return:TextureWrapMode des: Texture W coordinate wrapping mode for Texture3D."
	}
,
	"Texture3D.GetInstanceID": {
		"prefix": "Texture3D.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Texture3D.ToString": {
		"prefix": "Texture3D.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Texture3D.GetNativeTexturePtr": {
		"prefix": "Texture3D.GetNativeTexturePtr",
		"body": [
			"GetNativeTexturePtr($1)"
		],
		"description": "public IntPtr GetNativeTexturePtr(); des: Retrieve a native (underlying graphics API) pointer to the texture resource."
	}
,
	"Texture3D.IncrementUpdateCount": {
		"prefix": "Texture3D.IncrementUpdateCount",
		"body": [
			"IncrementUpdateCount($1)"
		],
		"description": "public void IncrementUpdateCount(); des: Increment the update counter."
	}
,
	"Texture3D.Destroy": {
		"prefix": "Texture3D.Destroy",
		"body": [
			"Texture3D.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Texture3D.DestroyImmediate": {
		"prefix": "Texture3D.DestroyImmediate",
		"body": [
			"Texture3D.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Texture3D.DontDestroyOnLoad": {
		"prefix": "Texture3D.DontDestroyOnLoad",
		"body": [
			"Texture3D.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Texture3D.FindObjectOfType": {
		"prefix": "Texture3D.FindObjectOfType",
		"body": [
			"Texture3D.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Texture3D.FindObjectsOfType": {
		"prefix": "Texture3D.FindObjectsOfType",
		"body": [
			"Texture3D.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Texture3D.Instantiate": {
		"prefix": "Texture3D.Instantiate",
		"body": [
			"Texture3D.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"Texture3D.SetGlobalAnisotropicFilteringLimits": {
		"prefix": "Texture3D.SetGlobalAnisotropicFilteringLimits",
		"body": [
			"Texture3D.SetGlobalAnisotropicFilteringLimits"
		],
		"description": "public static void SetGlobalAnisotropicFilteringLimits(int forcedMin, int globalMax); des: Sets Anisotropic limits."
	}
,
	"Texture3D.SetStreamingTextureMaterialDebugProperties": {
		"prefix": "Texture3D.SetStreamingTextureMaterialDebugProperties",
		"body": [
			"Texture3D.SetStreamingTextureMaterialDebugProperties"
		],
		"description": "public static void SetStreamingTextureMaterialDebugProperties(); des: Uploads additional debug information to materials using textures set to stream mip maps."
	}
,
	"Touch.altitudeAngle": {
		"prefix": "Touch.altitudeAngle",
		"body": [
			"altitudeAngle"
		],
		"description": "return:float des: Value of 0 radians indicates that the stylus is parallel to the surface, pi/2 indicates that it is perpendicular."
	}
,
	"Touch.azimuthAngle": {
		"prefix": "Touch.azimuthAngle",
		"body": [
			"azimuthAngle"
		],
		"description": "return:float des: Value of 0 radians indicates that the stylus is pointed along the x-axis of the device."
	}
,
	"Touch.deltaPosition": {
		"prefix": "Touch.deltaPosition",
		"body": [
			"deltaPosition"
		],
		"description": "return:Vector2 des: The position delta since last change."
	}
,
	"Touch.deltaTime": {
		"prefix": "Touch.deltaTime",
		"body": [
			"deltaTime"
		],
		"description": "return:float des: Amount of time that has passed since the last recorded change in Touch values."
	}
,
	"Touch.fingerId": {
		"prefix": "Touch.fingerId",
		"body": [
			"fingerId"
		],
		"description": "return:int des: The unique index for the touch."
	}
,
	"Touch.maximumPossiblePressure": {
		"prefix": "Touch.maximumPossiblePressure",
		"body": [
			"maximumPossiblePressure"
		],
		"description": "return:float des: The maximum possible pressure value for a platform. If Input.touchPressureSupported returns false, the value of this property will always be 1.0f."
	}
,
	"Touch.phase": {
		"prefix": "Touch.phase",
		"body": [
			"phase"
		],
		"description": "return:TouchPhase des: Describes the phase of the touch."
	}
,
	"Touch.position": {
		"prefix": "Touch.position",
		"body": [
			"position"
		],
		"description": "return:Vector2 des: The position of the touch in pixel coordinates."
	}
,
	"Touch.pressure": {
		"prefix": "Touch.pressure",
		"body": [
			"pressure"
		],
		"description": "return:float des: The current amount of pressure being applied to a touch. 1.0f is considered to be the pressure of an average touch. If Input.touchPressureSupported returns false, the value of this property will always be 1.0f."
	}
,
	"Touch.radius": {
		"prefix": "Touch.radius",
		"body": [
			"radius"
		],
		"description": "return:float des: An estimated value of the radius of a touch. Add radiusVariance to get the maximum touch size, subtract it to get the minimum touch size."
	}
,
	"Touch.radiusVariance": {
		"prefix": "Touch.radiusVariance",
		"body": [
			"radiusVariance"
		],
		"description": "return:float des: This value determines the accuracy of the touch radius. Add this value to the radius to get the maximum touch size, subtract it to get the minimum touch size."
	}
,
	"Touch.rawPosition": {
		"prefix": "Touch.rawPosition",
		"body": [
			"rawPosition"
		],
		"description": "return:Vector2 des: The raw position used for the touch."
	}
,
	"Touch.tapCount": {
		"prefix": "Touch.tapCount",
		"body": [
			"tapCount"
		],
		"description": "return:int des: Number of taps."
	}
,
	"Touch.type": {
		"prefix": "Touch.type",
		"body": [
			"type"
		],
		"description": "return:TouchType des: A value that indicates whether a touch was of Direct, Indirect (or remote), or Stylus type."
	}
,
	"TouchScreenKeyboard.active": {
		"prefix": "TouchScreenKeyboard.active",
		"body": [
			"active"
		],
		"description": "return:bool des: Is the keyboard visible or sliding into the position on the screen?"
	}
,
	"TouchScreenKeyboard.canGetSelection": {
		"prefix": "TouchScreenKeyboard.canGetSelection",
		"body": [
			"canGetSelection"
		],
		"description": "return:bool des: Specifies whether the TouchScreenKeyboard supports the selection property. (Read Only)"
	}
,
	"TouchScreenKeyboard.canSetSelection": {
		"prefix": "TouchScreenKeyboard.canSetSelection",
		"body": [
			"canSetSelection"
		],
		"description": "return:bool des: Specifies whether the TouchScreenKeyboard supports the selection property. (Read Only)"
	}
,
	"TouchScreenKeyboard.characterLimit": {
		"prefix": "TouchScreenKeyboard.characterLimit",
		"body": [
			"characterLimit"
		],
		"description": "return:int des: How many characters the keyboard input field is limited to. 0 = infinite."
	}
,
	"TouchScreenKeyboard.selection": {
		"prefix": "TouchScreenKeyboard.selection",
		"body": [
			"selection"
		],
		"description": "return:RangeInt des: Gets or sets the character range of the selected text within the string currently being edited."
	}
,
	"TouchScreenKeyboard.status": {
		"prefix": "TouchScreenKeyboard.status",
		"body": [
			"status"
		],
		"description": "return:TouchScreenKeyboard.Status des: Returns the status of the on-screen keyboard. (Read Only)"
	}
,
	"TouchScreenKeyboard.targetDisplay": {
		"prefix": "TouchScreenKeyboard.targetDisplay",
		"body": [
			"targetDisplay"
		],
		"description": "return:int des: Specified on which display the software keyboard will appear."
	}
,
	"TouchScreenKeyboard.text": {
		"prefix": "TouchScreenKeyboard.text",
		"body": [
			"text"
		],
		"description": "return:string des: Returns the text displayed by the input field of the keyboard."
	}
,
	"TouchScreenKeyboard.type": {
		"prefix": "TouchScreenKeyboard.type",
		"body": [
			"type"
		],
		"description": "return:TouchScreenKeyboardType des: Returns the TouchScreenKeyboardType of the keyboard."
	}
,
	"TouchScreenKeyboard.Open": {
		"prefix": "TouchScreenKeyboard.Open",
		"body": [
			"TouchScreenKeyboard.Open"
		],
		"description": "public static TouchScreenKeyboard Open(string text, TouchScreenKeyboardType keyboardType = TouchScreenKeyboardType.Default, bool autocorrection = true, bool multiline = false, bool secure = false, bool alert = false, string textPlaceholder = \"\", int characterLimit = 0); des: Opens the native keyboard provided by OS on the screen."
	}
,
	"TouchScreenKeyboard.Status.Visible": {
		"prefix": "TouchScreenKeyboard.Status.Visible",
		"body": [
			"Visible"
		],
		"description": "return: des: The on-screen keyboard is visible."
	}
,
	"TouchScreenKeyboard.Status.Done": {
		"prefix": "TouchScreenKeyboard.Status.Done",
		"body": [
			"Done"
		],
		"description": "return: des: The user has finished providing input."
	}
,
	"TouchScreenKeyboard.Status.Canceled": {
		"prefix": "TouchScreenKeyboard.Status.Canceled",
		"body": [
			"Canceled"
		],
		"description": "return: des: The on-screen keyboard was canceled."
	}
,
	"TouchScreenKeyboard.Status.LostFocus": {
		"prefix": "TouchScreenKeyboard.Status.LostFocus",
		"body": [
			"LostFocus"
		],
		"description": "return: des: The on-screen keyboard has lost focus."
	}
,
	"TrailRenderer.alignment": {
		"prefix": "TrailRenderer.alignment",
		"body": [
			"alignment"
		],
		"description": "return:LineAlignment des: Select whether the trail will face the camera, or the orientation of the Transform Component."
	}
,
	"TrailRenderer.autodestruct": {
		"prefix": "TrailRenderer.autodestruct",
		"body": [
			"autodestruct"
		],
		"description": "return:bool des: Does the GameObject of this Trail Renderer auto destruct?"
	}
,
	"TrailRenderer.colorGradient": {
		"prefix": "TrailRenderer.colorGradient",
		"body": [
			"colorGradient"
		],
		"description": "return:Gradient des: Set the color gradient describing the color of the trail at various points along its length."
	}
,
	"TrailRenderer.emitting": {
		"prefix": "TrailRenderer.emitting",
		"body": [
			"emitting"
		],
		"description": "return:bool des: Creates trails when the GameObject moves."
	}
,
	"TrailRenderer.endColor": {
		"prefix": "TrailRenderer.endColor",
		"body": [
			"endColor"
		],
		"description": "return:Color des: Set the color at the end of the trail."
	}
,
	"TrailRenderer.endWidth": {
		"prefix": "TrailRenderer.endWidth",
		"body": [
			"endWidth"
		],
		"description": "return:float des: The width of the trail at the end of the trail."
	}
,
	"TrailRenderer.generateLightingData": {
		"prefix": "TrailRenderer.generateLightingData",
		"body": [
			"generateLightingData"
		],
		"description": "return:bool des: Configures a trail to generate Normals and Tangents. With this data, Scene lighting can affect the trail via Normal Maps and the Unity Standard Shader, or your own custom-built Shaders."
	}
,
	"TrailRenderer.minVertexDistance": {
		"prefix": "TrailRenderer.minVertexDistance",
		"body": [
			"minVertexDistance"
		],
		"description": "return:float des: Set the minimum distance the trail can travel before a new vertex is added to it."
	}
,
	"TrailRenderer.numCapVertices": {
		"prefix": "TrailRenderer.numCapVertices",
		"body": [
			"numCapVertices"
		],
		"description": "return:int des: Set this to a value greater than 0, to get rounded corners on each end of the trail."
	}
,
	"TrailRenderer.numCornerVertices": {
		"prefix": "TrailRenderer.numCornerVertices",
		"body": [
			"numCornerVertices"
		],
		"description": "return:int des: Set this to a value greater than 0, to get rounded corners between each segment of the trail."
	}
,
	"TrailRenderer.positionCount": {
		"prefix": "TrailRenderer.positionCount",
		"body": [
			"positionCount"
		],
		"description": "return:int des: Get the number of line segments in the trail."
	}
,
	"TrailRenderer.startColor": {
		"prefix": "TrailRenderer.startColor",
		"body": [
			"startColor"
		],
		"description": "return:Color des: Set the color at the start of the trail."
	}
,
	"TrailRenderer.startWidth": {
		"prefix": "TrailRenderer.startWidth",
		"body": [
			"startWidth"
		],
		"description": "return:float des: The width of the trail at the spawning point."
	}
,
	"TrailRenderer.textureMode": {
		"prefix": "TrailRenderer.textureMode",
		"body": [
			"textureMode"
		],
		"description": "return:LineTextureMode des: Choose whether the U coordinate of the trail texture is tiled or stretched."
	}
,
	"TrailRenderer.time": {
		"prefix": "TrailRenderer.time",
		"body": [
			"time"
		],
		"description": "return:float des: How long does the trail take to fade out."
	}
,
	"TrailRenderer.widthCurve": {
		"prefix": "TrailRenderer.widthCurve",
		"body": [
			"widthCurve"
		],
		"description": "return:AnimationCurve des: Set the curve describing the width of the trail at various points along its length."
	}
,
	"TrailRenderer.widthMultiplier": {
		"prefix": "TrailRenderer.widthMultiplier",
		"body": [
			"widthMultiplier"
		],
		"description": "return:float des: Set an overall multiplier that is applied to the TrailRenderer.widthCurve to get the final width of the trail."
	}
,
	"TrailRenderer.AddPosition": {
		"prefix": "TrailRenderer.AddPosition",
		"body": [
			"AddPosition($1)"
		],
		"description": "public void AddPosition(Vector3 position); des: Adds a position to the trail."
	}
,
	"TrailRenderer.AddPositions": {
		"prefix": "TrailRenderer.AddPositions",
		"body": [
			"AddPositions($1)"
		],
		"description": "public void AddPositions(Vector3[] positions); des: Add an array of positions to the trail."
	}
,
	"TrailRenderer.BakeMesh": {
		"prefix": "TrailRenderer.BakeMesh",
		"body": [
			"BakeMesh($1)"
		],
		"description": "public void BakeMesh(Mesh mesh, bool useTransform); public void BakeMesh(Mesh mesh, Camera camera, bool useTransform); des: Creates a snapshot of TrailRenderer and stores it in mesh."
	}
,
	"TrailRenderer.Clear": {
		"prefix": "TrailRenderer.Clear",
		"body": [
			"Clear($1)"
		],
		"description": "public void Clear(); des: Removes all points from the TrailRenderer. Useful for restarting a trail from a new position."
	}
,
	"TrailRenderer.GetPosition": {
		"prefix": "TrailRenderer.GetPosition",
		"body": [
			"GetPosition($1)"
		],
		"description": "public Vector3 GetPosition(int index); des: Get the position of a vertex in the trail."
	}
,
	"TrailRenderer.GetPositions": {
		"prefix": "TrailRenderer.GetPositions",
		"body": [
			"GetPositions($1)"
		],
		"description": "public int GetPositions(out Vector3[] positions); des: Get the positions of all vertices in the trail."
	}
,
	"TrailRenderer.SetPosition": {
		"prefix": "TrailRenderer.SetPosition",
		"body": [
			"SetPosition($1)"
		],
		"description": "public void SetPosition(int index, Vector3 position); des: Set the position of a vertex in the trail."
	}
,
	"TrailRenderer.SetPositions": {
		"prefix": "TrailRenderer.SetPositions",
		"body": [
			"SetPositions($1)"
		],
		"description": "public void SetPositions(Vector3[] positions); des: Sets the positions of all vertices in the trail."
	}
,
	"TrailRenderer.gameObject": {
		"prefix": "TrailRenderer.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"TrailRenderer.tag": {
		"prefix": "TrailRenderer.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"TrailRenderer.transform": {
		"prefix": "TrailRenderer.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"TrailRenderer.hideFlags": {
		"prefix": "TrailRenderer.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"TrailRenderer.name": {
		"prefix": "TrailRenderer.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"TrailRenderer.allowOcclusionWhenDynamic": {
		"prefix": "TrailRenderer.allowOcclusionWhenDynamic",
		"body": [
			"allowOcclusionWhenDynamic"
		],
		"description": "return:bool des: Controls if dynamic occlusion culling should be performed for this renderer."
	}
,
	"TrailRenderer.bounds": {
		"prefix": "TrailRenderer.bounds",
		"body": [
			"bounds"
		],
		"description": "return:Bounds des: The bounding volume of the renderer (Read Only)."
	}
,
	"TrailRenderer.enabled": {
		"prefix": "TrailRenderer.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Makes the rendered 3D object visible if enabled."
	}
,
	"TrailRenderer.isPartOfStaticBatch": {
		"prefix": "TrailRenderer.isPartOfStaticBatch",
		"body": [
			"isPartOfStaticBatch"
		],
		"description": "return:bool des: Has this renderer been statically batched with any other renderers?"
	}
,
	"TrailRenderer.isVisible": {
		"prefix": "TrailRenderer.isVisible",
		"body": [
			"isVisible"
		],
		"description": "return:bool des: Is this renderer visible in any camera? (Read Only)"
	}
,
	"TrailRenderer.lightmapIndex": {
		"prefix": "TrailRenderer.lightmapIndex",
		"body": [
			"lightmapIndex"
		],
		"description": "return:int des: The index of the baked lightmap applied to this renderer."
	}
,
	"TrailRenderer.lightmapScaleOffset": {
		"prefix": "TrailRenderer.lightmapScaleOffset",
		"body": [
			"lightmapScaleOffset"
		],
		"description": "return:Vector4 des: The UV scale & offset used for a lightmap."
	}
,
	"TrailRenderer.lightProbeProxyVolumeOverride": {
		"prefix": "TrailRenderer.lightProbeProxyVolumeOverride",
		"body": [
			"lightProbeProxyVolumeOverride"
		],
		"description": "return:GameObject des: If set, the Renderer will use the Light Probe Proxy Volume component attached to the source GameObject."
	}
,
	"TrailRenderer.lightProbeUsage": {
		"prefix": "TrailRenderer.lightProbeUsage",
		"body": [
			"lightProbeUsage"
		],
		"description": "return:Rendering.LightProbeUsage des: The light probe interpolation type."
	}
,
	"TrailRenderer.localToWorldMatrix": {
		"prefix": "TrailRenderer.localToWorldMatrix",
		"body": [
			"localToWorldMatrix"
		],
		"description": "return:Matrix4x4 des: Matrix that transforms a point from local space into world space (Read Only)."
	}
,
	"TrailRenderer.material": {
		"prefix": "TrailRenderer.material",
		"body": [
			"material"
		],
		"description": "return:Material des: Returns the first instantiated Material assigned to the renderer."
	}
,
	"TrailRenderer.materials": {
		"prefix": "TrailRenderer.materials",
		"body": [
			"materials"
		],
		"description": "return:Material[] des: Returns all the instantiated materials of this object."
	}
,
	"TrailRenderer.motionVectorGenerationMode": {
		"prefix": "TrailRenderer.motionVectorGenerationMode",
		"body": [
			"motionVectorGenerationMode"
		],
		"description": "return:MotionVectorGenerationMode des: Specifies the mode for motion vector rendering."
	}
,
	"TrailRenderer.probeAnchor": {
		"prefix": "TrailRenderer.probeAnchor",
		"body": [
			"probeAnchor"
		],
		"description": "return:Transform des: If set, Renderer will use this Transform's position to find the light or reflection probe."
	}
,
	"TrailRenderer.realtimeLightmapIndex": {
		"prefix": "TrailRenderer.realtimeLightmapIndex",
		"body": [
			"realtimeLightmapIndex"
		],
		"description": "return:int des: The index of the realtime lightmap applied to this renderer."
	}
,
	"TrailRenderer.realtimeLightmapScaleOffset": {
		"prefix": "TrailRenderer.realtimeLightmapScaleOffset",
		"body": [
			"realtimeLightmapScaleOffset"
		],
		"description": "return:Vector4 des: The UV scale & offset used for a realtime lightmap."
	}
,
	"TrailRenderer.receiveShadows": {
		"prefix": "TrailRenderer.receiveShadows",
		"body": [
			"receiveShadows"
		],
		"description": "return:bool des: Does this object receive shadows?"
	}
,
	"TrailRenderer.reflectionProbeUsage": {
		"prefix": "TrailRenderer.reflectionProbeUsage",
		"body": [
			"reflectionProbeUsage"
		],
		"description": "return:Rendering.ReflectionProbeUsage des: Should reflection probes be used for this Renderer?"
	}
,
	"TrailRenderer.renderingLayerMask": {
		"prefix": "TrailRenderer.renderingLayerMask",
		"body": [
			"renderingLayerMask"
		],
		"description": "return:uint des: Determines which rendering layer this renderer lives on."
	}
,
	"TrailRenderer.shadowCastingMode": {
		"prefix": "TrailRenderer.shadowCastingMode",
		"body": [
			"shadowCastingMode"
		],
		"description": "return:Rendering.ShadowCastingMode des: Does this object cast shadows?"
	}
,
	"TrailRenderer.sharedMaterial": {
		"prefix": "TrailRenderer.sharedMaterial",
		"body": [
			"sharedMaterial"
		],
		"description": "return:Material des: The shared material of this object."
	}
,
	"TrailRenderer.sharedMaterials": {
		"prefix": "TrailRenderer.sharedMaterials",
		"body": [
			"sharedMaterials"
		],
		"description": "return:Material[] des: All the shared materials of this object."
	}
,
	"TrailRenderer.sortingLayerID": {
		"prefix": "TrailRenderer.sortingLayerID",
		"body": [
			"sortingLayerID"
		],
		"description": "return:int des: Unique ID of the Renderer's sorting layer."
	}
,
	"TrailRenderer.sortingLayerName": {
		"prefix": "TrailRenderer.sortingLayerName",
		"body": [
			"sortingLayerName"
		],
		"description": "return:string des: Name of the Renderer's sorting layer."
	}
,
	"TrailRenderer.sortingOrder": {
		"prefix": "TrailRenderer.sortingOrder",
		"body": [
			"sortingOrder"
		],
		"description": "return:int des: Renderer's order within a sorting layer."
	}
,
	"TrailRenderer.worldToLocalMatrix": {
		"prefix": "TrailRenderer.worldToLocalMatrix",
		"body": [
			"worldToLocalMatrix"
		],
		"description": "return:Matrix4x4 des: Matrix that transforms a point from world space into local space (Read Only)."
	}
,
	"TrailRenderer.BroadcastMessage": {
		"prefix": "TrailRenderer.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"TrailRenderer.CompareTag": {
		"prefix": "TrailRenderer.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"TrailRenderer.GetComponent": {
		"prefix": "TrailRenderer.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"TrailRenderer.GetComponentInChildren": {
		"prefix": "TrailRenderer.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"TrailRenderer.GetComponentInParent": {
		"prefix": "TrailRenderer.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"TrailRenderer.GetComponents": {
		"prefix": "TrailRenderer.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"TrailRenderer.GetComponentsInChildren": {
		"prefix": "TrailRenderer.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"TrailRenderer.GetComponentsInParent": {
		"prefix": "TrailRenderer.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"TrailRenderer.SendMessage": {
		"prefix": "TrailRenderer.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"TrailRenderer.SendMessageUpwards": {
		"prefix": "TrailRenderer.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"TrailRenderer.GetInstanceID": {
		"prefix": "TrailRenderer.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"TrailRenderer.ToString": {
		"prefix": "TrailRenderer.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"TrailRenderer.GetClosestReflectionProbes": {
		"prefix": "TrailRenderer.GetClosestReflectionProbes",
		"body": [
			"GetClosestReflectionProbes($1)"
		],
		"description": "public void GetClosestReflectionProbes(List<ReflectionProbeBlendInfo> result); des: Returns an array of closest reflection probes with weights, weight shows how much influence the probe has on the renderer, this value is also used when blending between reflection probes occur."
	}
,
	"TrailRenderer.GetMaterials": {
		"prefix": "TrailRenderer.GetMaterials",
		"body": [
			"GetMaterials($1)"
		],
		"description": "public void GetMaterials(List<Material> m); des: Returns all the instantiated materials of this object."
	}
,
	"TrailRenderer.GetPropertyBlock": {
		"prefix": "TrailRenderer.GetPropertyBlock",
		"body": [
			"GetPropertyBlock($1)"
		],
		"description": "public void GetPropertyBlock(MaterialPropertyBlock properties); public void GetPropertyBlock(MaterialPropertyBlock properties, int materialIndex); des: Get per-Renderer or per-Material property block."
	}
,
	"TrailRenderer.GetSharedMaterials": {
		"prefix": "TrailRenderer.GetSharedMaterials",
		"body": [
			"GetSharedMaterials($1)"
		],
		"description": "public void GetSharedMaterials(List<Material> m); des: Returns all the shared materials of this object."
	}
,
	"TrailRenderer.HasPropertyBlock": {
		"prefix": "TrailRenderer.HasPropertyBlock",
		"body": [
			"HasPropertyBlock($1)"
		],
		"description": "public bool HasPropertyBlock(); des: Returns true if the Renderer has a material property block attached via SetPropertyBlock."
	}
,
	"TrailRenderer.SetPropertyBlock": {
		"prefix": "TrailRenderer.SetPropertyBlock",
		"body": [
			"SetPropertyBlock($1)"
		],
		"description": "public void SetPropertyBlock(MaterialPropertyBlock properties); public void SetPropertyBlock(MaterialPropertyBlock properties, int materialIndex); des: Lets you set or clear per-renderer or per-material parameter overrides."
	}
,
	"TrailRenderer.Destroy": {
		"prefix": "TrailRenderer.Destroy",
		"body": [
			"TrailRenderer.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"TrailRenderer.DestroyImmediate": {
		"prefix": "TrailRenderer.DestroyImmediate",
		"body": [
			"TrailRenderer.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"TrailRenderer.DontDestroyOnLoad": {
		"prefix": "TrailRenderer.DontDestroyOnLoad",
		"body": [
			"TrailRenderer.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"TrailRenderer.FindObjectOfType": {
		"prefix": "TrailRenderer.FindObjectOfType",
		"body": [
			"TrailRenderer.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"TrailRenderer.FindObjectsOfType": {
		"prefix": "TrailRenderer.FindObjectsOfType",
		"body": [
			"TrailRenderer.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"TrailRenderer.Instantiate": {
		"prefix": "TrailRenderer.Instantiate",
		"body": [
			"TrailRenderer.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"TrailRenderer.OnBecameInvisible": {
		"prefix": "TrailRenderer.OnBecameInvisible",
		"body": [
			"OnBecameInvisible"
		],
		"description": "OnBecameInvisible is called when the object is no longer visible by any camera."
	}
,
	"TrailRenderer.OnBecameVisible": {
		"prefix": "TrailRenderer.OnBecameVisible",
		"body": [
			"OnBecameVisible"
		],
		"description": "OnBecameVisible is called when the object became visible by any camera."
	}
,
	"Transform.childCount": {
		"prefix": "Transform.childCount",
		"body": [
			"childCount"
		],
		"description": "return:int des: The number of children the parent Transform has."
	}
,
	"Transform.eulerAngles": {
		"prefix": "Transform.eulerAngles",
		"body": [
			"eulerAngles"
		],
		"description": "return:Vector3 des: The rotation as Euler angles in degrees."
	}
,
	"Transform.forward": {
		"prefix": "Transform.forward",
		"body": [
			"forward"
		],
		"description": "return:Vector3 des: The blue axis of the transform in world space."
	}
,
	"Transform.hasChanged": {
		"prefix": "Transform.hasChanged",
		"body": [
			"hasChanged"
		],
		"description": "return:bool des: Has the transform changed since the last time the flag was set to 'false'?"
	}
,
	"Transform.hierarchyCapacity": {
		"prefix": "Transform.hierarchyCapacity",
		"body": [
			"hierarchyCapacity"
		],
		"description": "return:int des: The transform capacity of the transform's hierarchy data structure."
	}
,
	"Transform.hierarchyCount": {
		"prefix": "Transform.hierarchyCount",
		"body": [
			"hierarchyCount"
		],
		"description": "return:int des: The number of transforms in the transform's hierarchy data structure."
	}
,
	"Transform.localEulerAngles": {
		"prefix": "Transform.localEulerAngles",
		"body": [
			"localEulerAngles"
		],
		"description": "return:Vector3 des: The rotation as Euler angles in degrees relative to the parent transform's rotation."
	}
,
	"Transform.localPosition": {
		"prefix": "Transform.localPosition",
		"body": [
			"localPosition"
		],
		"description": "return:Vector3 des: Position of the transform relative to the parent transform."
	}
,
	"Transform.localRotation": {
		"prefix": "Transform.localRotation",
		"body": [
			"localRotation"
		],
		"description": "return:Quaternion des: The rotation of the transform relative to the transform rotation of the parent."
	}
,
	"Transform.localScale": {
		"prefix": "Transform.localScale",
		"body": [
			"localScale"
		],
		"description": "return:Vector3 des: The scale of the transform relative to the parent."
	}
,
	"Transform.localToWorldMatrix": {
		"prefix": "Transform.localToWorldMatrix",
		"body": [
			"localToWorldMatrix"
		],
		"description": "return:Matrix4x4 des: Matrix that transforms a point from local space into world space (Read Only)."
	}
,
	"Transform.lossyScale": {
		"prefix": "Transform.lossyScale",
		"body": [
			"lossyScale"
		],
		"description": "return:Vector3 des: The global scale of the object (Read Only)."
	}
,
	"Transform.parent": {
		"prefix": "Transform.parent",
		"body": [
			"parent"
		],
		"description": "return:Transform des: The parent of the transform."
	}
,
	"Transform.position": {
		"prefix": "Transform.position",
		"body": [
			"position"
		],
		"description": "return:Vector3 des: The position of the transform in world space."
	}
,
	"Transform.right": {
		"prefix": "Transform.right",
		"body": [
			"right"
		],
		"description": "return:Vector3 des: The red axis of the transform in world space."
	}
,
	"Transform.root": {
		"prefix": "Transform.root",
		"body": [
			"root"
		],
		"description": "return:Transform des: Returns the topmost transform in the hierarchy."
	}
,
	"Transform.rotation": {
		"prefix": "Transform.rotation",
		"body": [
			"rotation"
		],
		"description": "return:Quaternion des: The rotation of the transform in world space stored as a Quaternion."
	}
,
	"Transform.up": {
		"prefix": "Transform.up",
		"body": [
			"up"
		],
		"description": "return:Vector3 des: The green axis of the transform in world space."
	}
,
	"Transform.worldToLocalMatrix": {
		"prefix": "Transform.worldToLocalMatrix",
		"body": [
			"worldToLocalMatrix"
		],
		"description": "return:Matrix4x4 des: Matrix that transforms a point from world space into local space (Read Only)."
	}
,
	"Transform.DetachChildren": {
		"prefix": "Transform.DetachChildren",
		"body": [
			"DetachChildren($1)"
		],
		"description": "public void DetachChildren(); des: Unparents all children."
	}
,
	"Transform.Find": {
		"prefix": "Transform.Find",
		"body": [
			"Find($1)"
		],
		"description": "public Transform Find(string n); des: Finds a child by n and returns it."
	}
,
	"Transform.GetChild": {
		"prefix": "Transform.GetChild",
		"body": [
			"GetChild($1)"
		],
		"description": "public Transform GetChild(int index); des: Returns a transform child by index."
	}
,
	"Transform.GetSiblingIndex": {
		"prefix": "Transform.GetSiblingIndex",
		"body": [
			"GetSiblingIndex($1)"
		],
		"description": "public int GetSiblingIndex(); des: Gets the sibling index."
	}
,
	"Transform.InverseTransformDirection": {
		"prefix": "Transform.InverseTransformDirection",
		"body": [
			"InverseTransformDirection($1)"
		],
		"description": "public Vector3 InverseTransformDirection(Vector3 direction); public Vector3 InverseTransformDirection(float x, float y, float z); des: Transforms a direction from world space to local space. The opposite of Transform.TransformDirection."
	}
,
	"Transform.InverseTransformPoint": {
		"prefix": "Transform.InverseTransformPoint",
		"body": [
			"InverseTransformPoint($1)"
		],
		"description": "public Vector3 InverseTransformPoint(Vector3 position); public Vector3 InverseTransformPoint(float x, float y, float z); des: Transforms position from world space to local space."
	}
,
	"Transform.InverseTransformVector": {
		"prefix": "Transform.InverseTransformVector",
		"body": [
			"InverseTransformVector($1)"
		],
		"description": "public Vector3 InverseTransformVector(Vector3 vector); public Vector3 InverseTransformVector(float x, float y, float z); des: Transforms a vector from world space to local space. The opposite of Transform.TransformVector."
	}
,
	"Transform.IsChildOf": {
		"prefix": "Transform.IsChildOf",
		"body": [
			"IsChildOf($1)"
		],
		"description": "public bool IsChildOf(Transform parent); des: Is this transform a child of parent?"
	}
,
	"Transform.LookAt": {
		"prefix": "Transform.LookAt",
		"body": [
			"LookAt($1)"
		],
		"description": "public void LookAt(Transform target); public void LookAt(Transform target, Vector3 worldUp = Vector3.up); public void LookAt(Vector3 worldPosition); public void LookAt(Vector3 worldPosition, Vector3 worldUp = Vector3.up); des: Rotates the transform so the forward vector points at /target/'s current position."
	}
,
	"Transform.Rotate": {
		"prefix": "Transform.Rotate",
		"body": [
			"Rotate($1)"
		],
		"description": "public void Rotate(Vector3 eulers, Space relativeTo = Space.Self); public void Rotate(float xAngle, float yAngle, float zAngle, Space relativeTo = Space.Self); public void Rotate(Vector3 axis, float angle, Space relativeTo = Space.Self); des: Applies a rotation of eulerAngles.z degrees around the z axis, eulerAngles.x degrees around the x axis, and eulerAngles.y degrees around the y axis (in that order)."
	}
,
	"Transform.RotateAround": {
		"prefix": "Transform.RotateAround",
		"body": [
			"RotateAround($1)"
		],
		"description": "public void RotateAround(Vector3 point, Vector3 axis, float angle); des: Rotates the transform about axis passing through point in world coordinates by angle degrees."
	}
,
	"Transform.SetAsFirstSibling": {
		"prefix": "Transform.SetAsFirstSibling",
		"body": [
			"SetAsFirstSibling($1)"
		],
		"description": "public void SetAsFirstSibling(); des: Move the transform to the start of the local transform list."
	}
,
	"Transform.SetAsLastSibling": {
		"prefix": "Transform.SetAsLastSibling",
		"body": [
			"SetAsLastSibling($1)"
		],
		"description": "public void SetAsLastSibling(); des: Move the transform to the end of the local transform list."
	}
,
	"Transform.SetParent": {
		"prefix": "Transform.SetParent",
		"body": [
			"SetParent($1)"
		],
		"description": "public void SetParent(Transform p); public void SetParent(Transform parent, bool worldPositionStays); des: Set the parent of the transform."
	}
,
	"Transform.SetPositionAndRotation": {
		"prefix": "Transform.SetPositionAndRotation",
		"body": [
			"SetPositionAndRotation($1)"
		],
		"description": "public void SetPositionAndRotation(Vector3 position, Quaternion rotation); des: Sets the world space position and rotation of the Transform component."
	}
,
	"Transform.SetSiblingIndex": {
		"prefix": "Transform.SetSiblingIndex",
		"body": [
			"SetSiblingIndex($1)"
		],
		"description": "public void SetSiblingIndex(int index); des: Sets the sibling index."
	}
,
	"Transform.TransformDirection": {
		"prefix": "Transform.TransformDirection",
		"body": [
			"TransformDirection($1)"
		],
		"description": "public Vector3 TransformDirection(Vector3 direction); public Vector3 TransformDirection(float x, float y, float z); des: Transforms direction from local space to world space."
	}
,
	"Transform.TransformPoint": {
		"prefix": "Transform.TransformPoint",
		"body": [
			"TransformPoint($1)"
		],
		"description": "public Vector3 TransformPoint(Vector3 position); public Vector3 TransformPoint(float x, float y, float z); des: Transforms position from local space to world space."
	}
,
	"Transform.TransformVector": {
		"prefix": "Transform.TransformVector",
		"body": [
			"TransformVector($1)"
		],
		"description": "public Vector3 TransformVector(Vector3 vector); public Vector3 TransformVector(float x, float y, float z); des: Transforms vector from local space to world space."
	}
,
	"Transform.Translate": {
		"prefix": "Transform.Translate",
		"body": [
			"Translate($1)"
		],
		"description": "public void Translate(Vector3 translation); public void Translate(Vector3 translation, Space relativeTo = Space.Self); public void Translate(float x, float y, float z); public void Translate(float x, float y, float z, Space relativeTo = Space.Self); public void Translate(Vector3 translation, Transform relativeTo); public void Translate(float x, float y, float z, Transform relativeTo); des: Moves the transform in the direction and distance of translation."
	}
,
	"Transform.gameObject": {
		"prefix": "Transform.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"Transform.tag": {
		"prefix": "Transform.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"Transform.transform": {
		"prefix": "Transform.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"Transform.hideFlags": {
		"prefix": "Transform.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Transform.name": {
		"prefix": "Transform.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Transform.BroadcastMessage": {
		"prefix": "Transform.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"Transform.CompareTag": {
		"prefix": "Transform.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"Transform.GetComponent": {
		"prefix": "Transform.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"Transform.GetComponentInChildren": {
		"prefix": "Transform.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"Transform.GetComponentInParent": {
		"prefix": "Transform.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"Transform.GetComponents": {
		"prefix": "Transform.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"Transform.GetComponentsInChildren": {
		"prefix": "Transform.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"Transform.GetComponentsInParent": {
		"prefix": "Transform.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"Transform.SendMessage": {
		"prefix": "Transform.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"Transform.SendMessageUpwards": {
		"prefix": "Transform.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"Transform.GetInstanceID": {
		"prefix": "Transform.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Transform.ToString": {
		"prefix": "Transform.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Transform.Destroy": {
		"prefix": "Transform.Destroy",
		"body": [
			"Transform.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Transform.DestroyImmediate": {
		"prefix": "Transform.DestroyImmediate",
		"body": [
			"Transform.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Transform.DontDestroyOnLoad": {
		"prefix": "Transform.DontDestroyOnLoad",
		"body": [
			"Transform.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Transform.FindObjectOfType": {
		"prefix": "Transform.FindObjectOfType",
		"body": [
			"Transform.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Transform.FindObjectsOfType": {
		"prefix": "Transform.FindObjectsOfType",
		"body": [
			"Transform.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Transform.Instantiate": {
		"prefix": "Transform.Instantiate",
		"body": [
			"Transform.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"Tree.data": {
		"prefix": "Tree.data",
		"body": [
			"data"
		],
		"description": "return:ScriptableObject des: Data asociated to the Tree."
	}
,
	"Tree.hasSpeedTreeWind": {
		"prefix": "Tree.hasSpeedTreeWind",
		"body": [
			"hasSpeedTreeWind"
		],
		"description": "return:bool des: Tells if there is wind data exported from SpeedTree are saved on this component."
	}
,
	"Tree.gameObject": {
		"prefix": "Tree.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"Tree.tag": {
		"prefix": "Tree.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"Tree.transform": {
		"prefix": "Tree.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"Tree.hideFlags": {
		"prefix": "Tree.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"Tree.name": {
		"prefix": "Tree.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"Tree.BroadcastMessage": {
		"prefix": "Tree.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"Tree.CompareTag": {
		"prefix": "Tree.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"Tree.GetComponent": {
		"prefix": "Tree.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"Tree.GetComponentInChildren": {
		"prefix": "Tree.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"Tree.GetComponentInParent": {
		"prefix": "Tree.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"Tree.GetComponents": {
		"prefix": "Tree.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"Tree.GetComponentsInChildren": {
		"prefix": "Tree.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"Tree.GetComponentsInParent": {
		"prefix": "Tree.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"Tree.SendMessage": {
		"prefix": "Tree.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"Tree.SendMessageUpwards": {
		"prefix": "Tree.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"Tree.GetInstanceID": {
		"prefix": "Tree.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"Tree.ToString": {
		"prefix": "Tree.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"Tree.Destroy": {
		"prefix": "Tree.Destroy",
		"body": [
			"Tree.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"Tree.DestroyImmediate": {
		"prefix": "Tree.DestroyImmediate",
		"body": [
			"Tree.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"Tree.DontDestroyOnLoad": {
		"prefix": "Tree.DontDestroyOnLoad",
		"body": [
			"Tree.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"Tree.FindObjectOfType": {
		"prefix": "Tree.FindObjectOfType",
		"body": [
			"Tree.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"Tree.FindObjectsOfType": {
		"prefix": "Tree.FindObjectsOfType",
		"body": [
			"Tree.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"Tree.Instantiate": {
		"prefix": "Tree.Instantiate",
		"body": [
			"Tree.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"TreeInstance.color": {
		"prefix": "TreeInstance.color",
		"body": [
			"color"
		],
		"description": "return:Color32 des: Color of this instance."
	}
,
	"TreeInstance.heightScale": {
		"prefix": "TreeInstance.heightScale",
		"body": [
			"heightScale"
		],
		"description": "return:float des: Height scale of this instance (compared to the prototype's size)."
	}
,
	"TreeInstance.lightmapColor": {
		"prefix": "TreeInstance.lightmapColor",
		"body": [
			"lightmapColor"
		],
		"description": "return:Color32 des: Lightmap color calculated for this instance."
	}
,
	"TreeInstance.position": {
		"prefix": "TreeInstance.position",
		"body": [
			"position"
		],
		"description": "return:Vector3 des: Position of the tree."
	}
,
	"TreeInstance.prototypeIndex": {
		"prefix": "TreeInstance.prototypeIndex",
		"body": [
			"prototypeIndex"
		],
		"description": "return:int des: Index of this instance in the TerrainData.treePrototypes array."
	}
,
	"TreeInstance.rotation": {
		"prefix": "TreeInstance.rotation",
		"body": [
			"rotation"
		],
		"description": "return:float des: Read-only."
	}
,
	"TreeInstance.widthScale": {
		"prefix": "TreeInstance.widthScale",
		"body": [
			"widthScale"
		],
		"description": "return:float des: Width scale of this instance (compared to the prototype's size)."
	}
,
	"TreePrototype.bendFactor": {
		"prefix": "TreePrototype.bendFactor",
		"body": [
			"bendFactor"
		],
		"description": "return:float des: Bend factor of the tree prototype."
	}
,
	"TreePrototype.prefab": {
		"prefix": "TreePrototype.prefab",
		"body": [
			"prefab"
		],
		"description": "return:GameObject des: Retrieves the actual GameObject used by the tree."
	}
,
	"UICharInfo.charWidth": {
		"prefix": "UICharInfo.charWidth",
		"body": [
			"charWidth"
		],
		"description": "return:float des: Character width."
	}
,
	"UICharInfo.cursorPos": {
		"prefix": "UICharInfo.cursorPos",
		"body": [
			"cursorPos"
		],
		"description": "return:Vector2 des: Position of the character cursor in local (text generated) space."
	}
,
	"UILineInfo.height": {
		"prefix": "UILineInfo.height",
		"body": [
			"height"
		],
		"description": "return:int des: Height of the line."
	}
,
	"UILineInfo.leading": {
		"prefix": "UILineInfo.leading",
		"body": [
			"leading"
		],
		"description": "return:float des: Space in pixels between this line and the next line."
	}
,
	"UILineInfo.startCharIdx": {
		"prefix": "UILineInfo.startCharIdx",
		"body": [
			"startCharIdx"
		],
		"description": "return:int des: Index of the first character in the line."
	}
,
	"UILineInfo.topY": {
		"prefix": "UILineInfo.topY",
		"body": [
			"topY"
		],
		"description": "return:float des: The upper Y position of the line in pixels. This is used for text annotation such as the caret and selection box in the InputField."
	}
,
	"UIVertex.color": {
		"prefix": "UIVertex.color",
		"body": [
			"color"
		],
		"description": "return:Color32 des: Vertex color."
	}
,
	"UIVertex.normal": {
		"prefix": "UIVertex.normal",
		"body": [
			"normal"
		],
		"description": "return:Vector3 des: Normal."
	}
,
	"UIVertex.position": {
		"prefix": "UIVertex.position",
		"body": [
			"position"
		],
		"description": "return:Vector3 des: Vertex position."
	}
,
	"UIVertex.tangent": {
		"prefix": "UIVertex.tangent",
		"body": [
			"tangent"
		],
		"description": "return:Vector4 des: Tangent."
	}
,
	"UIVertex.uv0": {
		"prefix": "UIVertex.uv0",
		"body": [
			"uv0"
		],
		"description": "return:Vector2 des: The first texture coordinate set of the mesh. Used by UI elements by default."
	}
,
	"UIVertex.uv1": {
		"prefix": "UIVertex.uv1",
		"body": [
			"uv1"
		],
		"description": "return:Vector2 des: The second texture coordinate set of the mesh, if present."
	}
,
	"UIVertex.uv2": {
		"prefix": "UIVertex.uv2",
		"body": [
			"uv2"
		],
		"description": "return:Vector2 des: The Third texture coordinate set of the mesh, if present."
	}
,
	"UIVertex.uv3": {
		"prefix": "UIVertex.uv3",
		"body": [
			"uv3"
		],
		"description": "return:Vector2 des: The forth texture coordinate set of the mesh, if present."
	}
,
	"Vector2.magnitude": {
		"prefix": "Vector2.magnitude",
		"body": [
			"magnitude"
		],
		"description": "return:float des: Returns the length of this vector (Read Only)."
	}
,
	"Vector2.normalized": {
		"prefix": "Vector2.normalized",
		"body": [
			"normalized"
		],
		"description": "return:Vector2 des: Returns this vector with a magnitude of 1 (Read Only)."
	}
,
	"Vector2.sqrMagnitude": {
		"prefix": "Vector2.sqrMagnitude",
		"body": [
			"sqrMagnitude"
		],
		"description": "return:float des: Returns the squared length of this vector (Read Only)."
	}
,
	"Vector2.this[int]": {
		"prefix": "Vector2.this[int]",
		"body": [
			"this[int]"
		],
		"description": "return:float des: Access the x or y component using [0] or [1] respectively."
	}
,
	"Vector2.x": {
		"prefix": "Vector2.x",
		"body": [
			"x"
		],
		"description": "return:float des: X component of the vector."
	}
,
	"Vector2.y": {
		"prefix": "Vector2.y",
		"body": [
			"y"
		],
		"description": "return:float des: Y component of the vector."
	}
,
	"Vector2.Equals": {
		"prefix": "Vector2.Equals",
		"body": [
			"Equals($1)"
		],
		"description": "public bool Equals(object other); des: Returns true if the given vector is exactly equal to this vector."
	}
,
	"Vector2.Normalize": {
		"prefix": "Vector2.Normalize",
		"body": [
			"Normalize($1)"
		],
		"description": "public void Normalize(); des: Makes this vector have a magnitude of 1."
	}
,
	"Vector2.Set": {
		"prefix": "Vector2.Set",
		"body": [
			"Set($1)"
		],
		"description": "public void Set(float newX, float newY); des: Set x and y components of an existing Vector2."
	}
,
	"Vector2.ToString": {
		"prefix": "Vector2.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); public string ToString(string format); des: Returns a nicely formatted string for this vector."
	}
,
	"Vector2.Angle": {
		"prefix": "Vector2.Angle",
		"body": [
			"Vector2.Angle"
		],
		"description": "public static float Angle(Vector2 from, Vector2 to); des: Returns the unsigned angle in degrees between from and to."
	}
,
	"Vector2.ClampMagnitude": {
		"prefix": "Vector2.ClampMagnitude",
		"body": [
			"Vector2.ClampMagnitude"
		],
		"description": "public static Vector2 ClampMagnitude(Vector2 vector, float maxLength); des: Returns a copy of vector with its magnitude clamped to maxLength."
	}
,
	"Vector2.Distance": {
		"prefix": "Vector2.Distance",
		"body": [
			"Vector2.Distance"
		],
		"description": "public static float Distance(Vector2 a, Vector2 b); des: Returns the distance between a and b."
	}
,
	"Vector2.Dot": {
		"prefix": "Vector2.Dot",
		"body": [
			"Vector2.Dot"
		],
		"description": "public static float Dot(Vector2 lhs, Vector2 rhs); des: Dot Product of two vectors."
	}
,
	"Vector2.Lerp": {
		"prefix": "Vector2.Lerp",
		"body": [
			"Vector2.Lerp"
		],
		"description": "public static Vector2 Lerp(Vector2 a, Vector2 b, float t); des: Linearly interpolates between vectors a and b by t."
	}
,
	"Vector2.LerpUnclamped": {
		"prefix": "Vector2.LerpUnclamped",
		"body": [
			"Vector2.LerpUnclamped"
		],
		"description": "public static Vector2 LerpUnclamped(Vector2 a, Vector2 b, float t); des: Linearly interpolates between vectors a and b by t."
	}
,
	"Vector2.Max": {
		"prefix": "Vector2.Max",
		"body": [
			"Vector2.Max"
		],
		"description": "public static Vector2 Max(Vector2 lhs, Vector2 rhs); des: Returns a vector that is made from the largest components of two vectors."
	}
,
	"Vector2.Min": {
		"prefix": "Vector2.Min",
		"body": [
			"Vector2.Min"
		],
		"description": "public static Vector2 Min(Vector2 lhs, Vector2 rhs); des: Returns a vector that is made from the smallest components of two vectors."
	}
,
	"Vector2.MoveTowards": {
		"prefix": "Vector2.MoveTowards",
		"body": [
			"Vector2.MoveTowards"
		],
		"description": "public static Vector2 MoveTowards(Vector2 current, Vector2 target, float maxDistanceDelta); des: Moves a point current towards target."
	}
,
	"Vector2.Perpendicular": {
		"prefix": "Vector2.Perpendicular",
		"body": [
			"Vector2.Perpendicular"
		],
		"description": "public static Vector2 Perpendicular(Vector2 inDirection); des: Returns the 2D vector perpendicular to this 2D vector. The result is always rotated 90-degrees in a counter-clockwise direction for a 2D coordinate system where the positive Y axis goes up."
	}
,
	"Vector2.Reflect": {
		"prefix": "Vector2.Reflect",
		"body": [
			"Vector2.Reflect"
		],
		"description": "public static Vector2 Reflect(Vector2 inDirection, Vector2 inNormal); des: Reflects a vector off the vector defined by a normal."
	}
,
	"Vector2.Scale": {
		"prefix": "Vector2.Scale",
		"body": [
			"Vector2.Scale"
		],
		"description": "public static Vector2 Scale(Vector2 a, Vector2 b); public void Scale(Vector2 scale); des: Multiplies two vectors component-wise."
	}
,
	"Vector2.SignedAngle": {
		"prefix": "Vector2.SignedAngle",
		"body": [
			"Vector2.SignedAngle"
		],
		"description": "public static float SignedAngle(Vector2 from, Vector2 to); des: Returns the signed angle in degrees between from and to."
	}
,
	"Vector2.SmoothDamp": {
		"prefix": "Vector2.SmoothDamp",
		"body": [
			"Vector2.SmoothDamp"
		],
		"description": "public static Vector2 SmoothDamp(Vector2 current, Vector2 target, ref Vector2 currentVelocity, float smoothTime, float maxSpeed = Mathf.Infinity, float deltaTime = Time.deltaTime); des: Gradually changes a vector towards a desired goal over time."
	}
,
	"Vector2Int.magnitude": {
		"prefix": "Vector2Int.magnitude",
		"body": [
			"magnitude"
		],
		"description": "return:float des: Returns the length of this vector (Read Only)."
	}
,
	"Vector2Int.sqrMagnitude": {
		"prefix": "Vector2Int.sqrMagnitude",
		"body": [
			"sqrMagnitude"
		],
		"description": "return:int des: Returns the squared length of this vector (Read Only)."
	}
,
	"Vector2Int.this[int]": {
		"prefix": "Vector2Int.this[int]",
		"body": [
			"this[int]"
		],
		"description": "return:int des: Access the x or y component using [0] or [1] respectively."
	}
,
	"Vector2Int.x": {
		"prefix": "Vector2Int.x",
		"body": [
			"x"
		],
		"description": "return:int des: X component of the vector."
	}
,
	"Vector2Int.y": {
		"prefix": "Vector2Int.y",
		"body": [
			"y"
		],
		"description": "return:int des: Y component of the vector."
	}
,
	"Vector2Int.Clamp": {
		"prefix": "Vector2Int.Clamp",
		"body": [
			"Clamp($1)"
		],
		"description": "public void Clamp(Vector2Int min, Vector2Int max); des: Clamps the Vector2Int to the bounds given by min and max."
	}
,
	"Vector2Int.Equals": {
		"prefix": "Vector2Int.Equals",
		"body": [
			"Equals($1)"
		],
		"description": "public bool Equals(object other); des: Returns true if the objects are equal."
	}
,
	"Vector2Int.GetHashCode": {
		"prefix": "Vector2Int.GetHashCode",
		"body": [
			"GetHashCode($1)"
		],
		"description": "public int GetHashCode(); des: Gets the hash code for the Vector2Int."
	}
,
	"Vector2Int.Set": {
		"prefix": "Vector2Int.Set",
		"body": [
			"Set($1)"
		],
		"description": "public void Set(int x, int y); des: Set x and y components of an existing Vector2Int."
	}
,
	"Vector2Int.ToString": {
		"prefix": "Vector2Int.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns a nicely formatted string for this vector."
	}
,
	"Vector2Int.CeilToInt": {
		"prefix": "Vector2Int.CeilToInt",
		"body": [
			"Vector2Int.CeilToInt"
		],
		"description": "public static Vector2Int CeilToInt(Vector2 v); des: Converts a Vector2 to a Vector2Int by doing a Ceiling to each value."
	}
,
	"Vector2Int.Distance": {
		"prefix": "Vector2Int.Distance",
		"body": [
			"Vector2Int.Distance"
		],
		"description": "public static float Distance(Vector2Int a, Vector2Int b); des: Returns the distance between a and b."
	}
,
	"Vector2Int.FloorToInt": {
		"prefix": "Vector2Int.FloorToInt",
		"body": [
			"Vector2Int.FloorToInt"
		],
		"description": "public static Vector2Int FloorToInt(Vector2 v); des: Converts a Vector2 to a Vector2Int by doing a Floor to each value."
	}
,
	"Vector2Int.Max": {
		"prefix": "Vector2Int.Max",
		"body": [
			"Vector2Int.Max"
		],
		"description": "public static Vector2Int Max(Vector2Int lhs, Vector2Int rhs); des: Returns a vector that is made from the largest components of two vectors."
	}
,
	"Vector2Int.Min": {
		"prefix": "Vector2Int.Min",
		"body": [
			"Vector2Int.Min"
		],
		"description": "public static Vector2Int Min(Vector2Int lhs, Vector2Int rhs); des: Returns a vector that is made from the smallest components of two vectors."
	}
,
	"Vector2Int.RoundToInt": {
		"prefix": "Vector2Int.RoundToInt",
		"body": [
			"Vector2Int.RoundToInt"
		],
		"description": "public static Vector2Int RoundToInt(Vector2 v); des: Converts a Vector2 to a Vector2Int by doing a Round to each value."
	}
,
	"Vector2Int.Scale": {
		"prefix": "Vector2Int.Scale",
		"body": [
			"Vector2Int.Scale"
		],
		"description": "public static Vector2Int Scale(Vector2Int a, Vector2Int b); public void Scale(Vector2Int scale); des: Multiplies two vectors component-wise."
	}
,
	"Vector3.magnitude": {
		"prefix": "Vector3.magnitude",
		"body": [
			"magnitude"
		],
		"description": "return:float des: Returns the length of this vector (Read Only)."
	}
,
	"Vector3.normalized": {
		"prefix": "Vector3.normalized",
		"body": [
			"normalized"
		],
		"description": "return:Vector3 des: Returns this vector with a magnitude of 1 (Read Only)."
	}
,
	"Vector3.sqrMagnitude": {
		"prefix": "Vector3.sqrMagnitude",
		"body": [
			"sqrMagnitude"
		],
		"description": "return:float des: Returns the squared length of this vector (Read Only)."
	}
,
	"Vector3.this[int]": {
		"prefix": "Vector3.this[int]",
		"body": [
			"this[int]"
		],
		"description": "return:float des: Access the x, y, z components using [0], [1], [2] respectively."
	}
,
	"Vector3.x": {
		"prefix": "Vector3.x",
		"body": [
			"x"
		],
		"description": "return:float des: X component of the vector."
	}
,
	"Vector3.y": {
		"prefix": "Vector3.y",
		"body": [
			"y"
		],
		"description": "return:float des: Y component of the vector."
	}
,
	"Vector3.z": {
		"prefix": "Vector3.z",
		"body": [
			"z"
		],
		"description": "return:float des: Z component of the vector."
	}
,
	"Vector3.Equals": {
		"prefix": "Vector3.Equals",
		"body": [
			"Equals($1)"
		],
		"description": "public bool Equals(object other); des: Returns true if the given vector is exactly equal to this vector."
	}
,
	"Vector3.Set": {
		"prefix": "Vector3.Set",
		"body": [
			"Set($1)"
		],
		"description": "public void Set(float newX, float newY, float newZ); des: Set x, y and z components of an existing Vector3."
	}
,
	"Vector3.ToString": {
		"prefix": "Vector3.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); public string ToString(string format); des: Returns a nicely formatted string for this vector."
	}
,
	"Vector3.Angle": {
		"prefix": "Vector3.Angle",
		"body": [
			"Vector3.Angle"
		],
		"description": "public static float Angle(Vector3 from, Vector3 to); des: Returns the angle in degrees between from and to."
	}
,
	"Vector3.ClampMagnitude": {
		"prefix": "Vector3.ClampMagnitude",
		"body": [
			"Vector3.ClampMagnitude"
		],
		"description": "public static Vector3 ClampMagnitude(Vector3 vector, float maxLength); des: Returns a copy of vector with its magnitude clamped to maxLength."
	}
,
	"Vector3.Cross": {
		"prefix": "Vector3.Cross",
		"body": [
			"Vector3.Cross"
		],
		"description": "public static Vector3 Cross(Vector3 lhs, Vector3 rhs); des: Cross Product of two vectors."
	}
,
	"Vector3.Distance": {
		"prefix": "Vector3.Distance",
		"body": [
			"Vector3.Distance"
		],
		"description": "public static float Distance(Vector3 a, Vector3 b); des: Returns the distance between a and b."
	}
,
	"Vector3.Dot": {
		"prefix": "Vector3.Dot",
		"body": [
			"Vector3.Dot"
		],
		"description": "public static float Dot(Vector3 lhs, Vector3 rhs); des: Dot Product of two vectors."
	}
,
	"Vector3.Lerp": {
		"prefix": "Vector3.Lerp",
		"body": [
			"Vector3.Lerp"
		],
		"description": "public static Vector3 Lerp(Vector3 a, Vector3 b, float t); des: Linearly interpolates between two vectors."
	}
,
	"Vector3.LerpUnclamped": {
		"prefix": "Vector3.LerpUnclamped",
		"body": [
			"Vector3.LerpUnclamped"
		],
		"description": "public static Vector3 LerpUnclamped(Vector3 a, Vector3 b, float t); des: Linearly interpolates between two vectors."
	}
,
	"Vector3.Max": {
		"prefix": "Vector3.Max",
		"body": [
			"Vector3.Max"
		],
		"description": "public static Vector3 Max(Vector3 lhs, Vector3 rhs); des: Returns a vector that is made from the largest components of two vectors."
	}
,
	"Vector3.Min": {
		"prefix": "Vector3.Min",
		"body": [
			"Vector3.Min"
		],
		"description": "public static Vector3 Min(Vector3 lhs, Vector3 rhs); des: Returns a vector that is made from the smallest components of two vectors."
	}
,
	"Vector3.MoveTowards": {
		"prefix": "Vector3.MoveTowards",
		"body": [
			"Vector3.MoveTowards"
		],
		"description": "public static Vector3 MoveTowards(Vector3 current, Vector3 target, float maxDistanceDelta); des: Moves a point current in a straight line towards a target point."
	}
,
	"Vector3.Normalize": {
		"prefix": "Vector3.Normalize",
		"body": [
			"Vector3.Normalize"
		],
		"description": "public static Vector3 Normalize(Vector3 value); des: Makes this vector have a magnitude of 1."
	}
,
	"Vector3.OrthoNormalize": {
		"prefix": "Vector3.OrthoNormalize",
		"body": [
			"Vector3.OrthoNormalize"
		],
		"description": "public static void OrthoNormalize(ref Vector3 normal, ref Vector3 tangent); public static void OrthoNormalize(ref Vector3 normal, ref Vector3 tangent, ref Vector3 binormal); des: Makes vectors normalized and orthogonal to each other."
	}
,
	"Vector3.Project": {
		"prefix": "Vector3.Project",
		"body": [
			"Vector3.Project"
		],
		"description": "public static Vector3 Project(Vector3 vector, Vector3 onNormal); des: Projects a vector onto another vector."
	}
,
	"Vector3.ProjectOnPlane": {
		"prefix": "Vector3.ProjectOnPlane",
		"body": [
			"Vector3.ProjectOnPlane"
		],
		"description": "public static Vector3 ProjectOnPlane(Vector3 vector, Vector3 planeNormal); des: Projects a vector onto a plane defined by a normal orthogonal to the plane."
	}
,
	"Vector3.Reflect": {
		"prefix": "Vector3.Reflect",
		"body": [
			"Vector3.Reflect"
		],
		"description": "public static Vector3 Reflect(Vector3 inDirection, Vector3 inNormal); des: Reflects a vector off the plane defined by a normal."
	}
,
	"Vector3.RotateTowards": {
		"prefix": "Vector3.RotateTowards",
		"body": [
			"Vector3.RotateTowards"
		],
		"description": "public static Vector3 RotateTowards(Vector3 current, Vector3 target, float maxRadiansDelta, float maxMagnitudeDelta); des: Rotates a vector current towards target."
	}
,
	"Vector3.Scale": {
		"prefix": "Vector3.Scale",
		"body": [
			"Vector3.Scale"
		],
		"description": "public static Vector3 Scale(Vector3 a, Vector3 b); public void Scale(Vector3 scale); des: Multiplies two vectors component-wise."
	}
,
	"Vector3.SignedAngle": {
		"prefix": "Vector3.SignedAngle",
		"body": [
			"Vector3.SignedAngle"
		],
		"description": "public static float SignedAngle(Vector3 from, Vector3 to, Vector3 axis); des: Returns the signed angle in degrees between from and to."
	}
,
	"Vector3.Slerp": {
		"prefix": "Vector3.Slerp",
		"body": [
			"Vector3.Slerp"
		],
		"description": "public static Vector3 Slerp(Vector3 a, Vector3 b, float t); des: Spherically interpolates between two vectors."
	}
,
	"Vector3.SlerpUnclamped": {
		"prefix": "Vector3.SlerpUnclamped",
		"body": [
			"Vector3.SlerpUnclamped"
		],
		"description": "public static Vector3 SlerpUnclamped(Vector3 a, Vector3 b, float t); des: Spherically interpolates between two vectors."
	}
,
	"Vector3.SmoothDamp": {
		"prefix": "Vector3.SmoothDamp",
		"body": [
			"Vector3.SmoothDamp"
		],
		"description": "public static Vector3 SmoothDamp(Vector3 current, Vector3 target, ref Vector3 currentVelocity, float smoothTime, float maxSpeed = Mathf.Infinity, float deltaTime = Time.deltaTime); des: Gradually changes a vector towards a desired goal over time."
	}
,
	"Vector3Int.magnitude": {
		"prefix": "Vector3Int.magnitude",
		"body": [
			"magnitude"
		],
		"description": "return:float des: Returns the length of this vector (Read Only)."
	}
,
	"Vector3Int.sqrMagnitude": {
		"prefix": "Vector3Int.sqrMagnitude",
		"body": [
			"sqrMagnitude"
		],
		"description": "return:int des: Returns the squared length of this vector (Read Only)."
	}
,
	"Vector3Int.this[int]": {
		"prefix": "Vector3Int.this[int]",
		"body": [
			"this[int]"
		],
		"description": "return:int des: Access the x, y or z component using [0], [1] or [2] respectively."
	}
,
	"Vector3Int.x": {
		"prefix": "Vector3Int.x",
		"body": [
			"x"
		],
		"description": "return:int des: X component of the vector."
	}
,
	"Vector3Int.y": {
		"prefix": "Vector3Int.y",
		"body": [
			"y"
		],
		"description": "return:int des: Y component of the vector."
	}
,
	"Vector3Int.z": {
		"prefix": "Vector3Int.z",
		"body": [
			"z"
		],
		"description": "return:int des: Z component of the vector."
	}
,
	"Vector3Int.Clamp": {
		"prefix": "Vector3Int.Clamp",
		"body": [
			"Clamp($1)"
		],
		"description": "public void Clamp(Vector3Int min, Vector3Int max); des: Clamps the Vector3Int to the bounds given by min and max."
	}
,
	"Vector3Int.Equals": {
		"prefix": "Vector3Int.Equals",
		"body": [
			"Equals($1)"
		],
		"description": "public bool Equals(object other); des: Returns true if the objects are equal."
	}
,
	"Vector3Int.GetHashCode": {
		"prefix": "Vector3Int.GetHashCode",
		"body": [
			"GetHashCode($1)"
		],
		"description": "public int GetHashCode(); des: Gets the hash code for the Vector3Int."
	}
,
	"Vector3Int.Set": {
		"prefix": "Vector3Int.Set",
		"body": [
			"Set($1)"
		],
		"description": "public void Set(int x, int y, int z); des: Set x, y and z components of an existing Vector3Int."
	}
,
	"Vector3Int.ToString": {
		"prefix": "Vector3Int.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); public string ToString(string format); des: Returns a nicely formatted string for this vector."
	}
,
	"Vector3Int.CeilToInt": {
		"prefix": "Vector3Int.CeilToInt",
		"body": [
			"Vector3Int.CeilToInt"
		],
		"description": "public static Vector3Int CeilToInt(Vector3 v); des: Converts a Vector3 to a Vector3Int by doing a Ceiling to each value."
	}
,
	"Vector3Int.Distance": {
		"prefix": "Vector3Int.Distance",
		"body": [
			"Vector3Int.Distance"
		],
		"description": "public static float Distance(Vector3Int a, Vector3Int b); des: Returns the distance between a and b."
	}
,
	"Vector3Int.FloorToInt": {
		"prefix": "Vector3Int.FloorToInt",
		"body": [
			"Vector3Int.FloorToInt"
		],
		"description": "public static Vector3Int FloorToInt(Vector3 v); des: Converts a Vector3 to a Vector3Int by doing a Floor to each value."
	}
,
	"Vector3Int.Max": {
		"prefix": "Vector3Int.Max",
		"body": [
			"Vector3Int.Max"
		],
		"description": "public static Vector3Int Max(Vector3Int lhs, Vector3Int rhs); des: Returns a vector that is made from the largest components of two vectors."
	}
,
	"Vector3Int.Min": {
		"prefix": "Vector3Int.Min",
		"body": [
			"Vector3Int.Min"
		],
		"description": "public static Vector3Int Min(Vector3Int lhs, Vector3Int rhs); des: Returns a vector that is made from the smallest components of two vectors."
	}
,
	"Vector3Int.RoundToInt": {
		"prefix": "Vector3Int.RoundToInt",
		"body": [
			"Vector3Int.RoundToInt"
		],
		"description": "public static Vector3Int RoundToInt(Vector3 v); des: Converts a Vector3 to a Vector3Int by doing a Round to each value."
	}
,
	"Vector3Int.Scale": {
		"prefix": "Vector3Int.Scale",
		"body": [
			"Vector3Int.Scale"
		],
		"description": "public static Vector3Int Scale(Vector3Int a, Vector3Int b); public void Scale(Vector3Int scale); des: Multiplies two vectors component-wise."
	}
,
	"Vector4.magnitude": {
		"prefix": "Vector4.magnitude",
		"body": [
			"magnitude"
		],
		"description": "return:float des: Returns the length of this vector (Read Only)."
	}
,
	"Vector4.normalized": {
		"prefix": "Vector4.normalized",
		"body": [
			"normalized"
		],
		"description": "return:Vector4 des: Returns this vector with a magnitude of 1 (Read Only)."
	}
,
	"Vector4.sqrMagnitude": {
		"prefix": "Vector4.sqrMagnitude",
		"body": [
			"sqrMagnitude"
		],
		"description": "return:float des: Returns the squared length of this vector (Read Only)."
	}
,
	"Vector4.this[int]": {
		"prefix": "Vector4.this[int]",
		"body": [
			"this[int]"
		],
		"description": "return:float des: Access the x, y, z, w components using [0], [1], [2], [3] respectively."
	}
,
	"Vector4.w": {
		"prefix": "Vector4.w",
		"body": [
			"w"
		],
		"description": "return:float des: W component of the vector."
	}
,
	"Vector4.x": {
		"prefix": "Vector4.x",
		"body": [
			"x"
		],
		"description": "return:float des: X component of the vector."
	}
,
	"Vector4.y": {
		"prefix": "Vector4.y",
		"body": [
			"y"
		],
		"description": "return:float des: Y component of the vector."
	}
,
	"Vector4.z": {
		"prefix": "Vector4.z",
		"body": [
			"z"
		],
		"description": "return:float des: Z component of the vector."
	}
,
	"Vector4.Equals": {
		"prefix": "Vector4.Equals",
		"body": [
			"Equals($1)"
		],
		"description": "public bool Equals(object other); des: Returns true if the given vector is exactly equal to this vector."
	}
,
	"Vector4.Set": {
		"prefix": "Vector4.Set",
		"body": [
			"Set($1)"
		],
		"description": "public void Set(float newX, float newY, float newZ, float newW); des: Set x, y, z and w components of an existing Vector4."
	}
,
	"Vector4.ToString": {
		"prefix": "Vector4.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); public string ToString(string format); des: Return the Vector4 formatted as a string."
	}
,
	"Vector4.Distance": {
		"prefix": "Vector4.Distance",
		"body": [
			"Vector4.Distance"
		],
		"description": "public static float Distance(Vector4 a, Vector4 b); des: Returns the distance between a and b."
	}
,
	"Vector4.Dot": {
		"prefix": "Vector4.Dot",
		"body": [
			"Vector4.Dot"
		],
		"description": "public static float Dot(Vector4 a, Vector4 b); des: Dot Product of two vectors."
	}
,
	"Vector4.Lerp": {
		"prefix": "Vector4.Lerp",
		"body": [
			"Vector4.Lerp"
		],
		"description": "public static Vector4 Lerp(Vector4 a, Vector4 b, float t); des: Linearly interpolates between two vectors."
	}
,
	"Vector4.LerpUnclamped": {
		"prefix": "Vector4.LerpUnclamped",
		"body": [
			"Vector4.LerpUnclamped"
		],
		"description": "public static Vector4 LerpUnclamped(Vector4 a, Vector4 b, float t); des: Linearly interpolates between two vectors."
	}
,
	"Vector4.Max": {
		"prefix": "Vector4.Max",
		"body": [
			"Vector4.Max"
		],
		"description": "public static Vector4 Max(Vector4 lhs, Vector4 rhs); des: Returns a vector that is made from the largest components of two vectors."
	}
,
	"Vector4.Min": {
		"prefix": "Vector4.Min",
		"body": [
			"Vector4.Min"
		],
		"description": "public static Vector4 Min(Vector4 lhs, Vector4 rhs); des: Returns a vector that is made from the smallest components of two vectors."
	}
,
	"Vector4.MoveTowards": {
		"prefix": "Vector4.MoveTowards",
		"body": [
			"Vector4.MoveTowards"
		],
		"description": "public static Vector4 MoveTowards(Vector4 current, Vector4 target, float maxDistanceDelta); des: Moves a point current towards target."
	}
,
	"Vector4.Normalize": {
		"prefix": "Vector4.Normalize",
		"body": [
			"Vector4.Normalize"
		],
		"description": "public void Normalize(); des: Makes this vector have a magnitude of 1."
	}
,
	"Vector4.Project": {
		"prefix": "Vector4.Project",
		"body": [
			"Vector4.Project"
		],
		"description": "public static Vector4 Project(Vector4 a, Vector4 b); des: Projects a vector onto another vector."
	}
,
	"Vector4.Scale": {
		"prefix": "Vector4.Scale",
		"body": [
			"Vector4.Scale"
		],
		"description": "public static Vector4 Scale(Vector4 a, Vector4 b); public void Scale(Vector4 scale); des: Multiplies two vectors component-wise."
	}
,
	"WaitForSecondsRealtime.keepWaiting": {
		"prefix": "WaitForSecondsRealtime.keepWaiting",
		"body": [
			"keepWaiting"
		],
		"description": "return:bool des: Indicates if coroutine should be kept suspended."
	}
,
	"WaitUntil.keepWaiting": {
		"prefix": "WaitUntil.keepWaiting",
		"body": [
			"keepWaiting"
		],
		"description": "return:bool des: Indicates if coroutine should be kept suspended."
	}
,
	"WaitWhile.keepWaiting": {
		"prefix": "WaitWhile.keepWaiting",
		"body": [
			"keepWaiting"
		],
		"description": "return:bool des: Indicates if coroutine should be kept suspended."
	}
,
	"WebCamDevice.isFrontFacing": {
		"prefix": "WebCamDevice.isFrontFacing",
		"body": [
			"isFrontFacing"
		],
		"description": "return:bool des: True if camera faces the same direction a screen does, false otherwise."
	}
,
	"WebCamDevice.name": {
		"prefix": "WebCamDevice.name",
		"body": [
			"name"
		],
		"description": "return:string des: A human-readable name of the device. Varies across different systems."
	}
,
	"WebCamTexture.deviceName": {
		"prefix": "WebCamTexture.deviceName",
		"body": [
			"deviceName"
		],
		"description": "return:string des: Set this to specify the name of the device to use."
	}
,
	"WebCamTexture.didUpdateThisFrame": {
		"prefix": "WebCamTexture.didUpdateThisFrame",
		"body": [
			"didUpdateThisFrame"
		],
		"description": "return:bool des: Did the video buffer update this frame?"
	}
,
	"WebCamTexture.isPlaying": {
		"prefix": "WebCamTexture.isPlaying",
		"body": [
			"isPlaying"
		],
		"description": "return:bool des: Returns if the camera is currently playing."
	}
,
	"WebCamTexture.requestedFPS": {
		"prefix": "WebCamTexture.requestedFPS",
		"body": [
			"requestedFPS"
		],
		"description": "return:float des: Set the requested frame rate of the camera device (in frames per second)."
	}
,
	"WebCamTexture.requestedHeight": {
		"prefix": "WebCamTexture.requestedHeight",
		"body": [
			"requestedHeight"
		],
		"description": "return:int des: Set the requested height of the camera device."
	}
,
	"WebCamTexture.requestedWidth": {
		"prefix": "WebCamTexture.requestedWidth",
		"body": [
			"requestedWidth"
		],
		"description": "return:int des: Set the requested width of the camera device."
	}
,
	"WebCamTexture.videoRotationAngle": {
		"prefix": "WebCamTexture.videoRotationAngle",
		"body": [
			"videoRotationAngle"
		],
		"description": "return:int des: Returns an clockwise angle (in degrees), which can be used to rotate a polygon so camera contents are shown in correct orientation."
	}
,
	"WebCamTexture.videoVerticallyMirrored": {
		"prefix": "WebCamTexture.videoVerticallyMirrored",
		"body": [
			"videoVerticallyMirrored"
		],
		"description": "return:bool des: Returns if the texture image is vertically flipped."
	}
,
	"WebCamTexture.GetPixel": {
		"prefix": "WebCamTexture.GetPixel",
		"body": [
			"GetPixel($1)"
		],
		"description": "public Color GetPixel(int x, int y); des: Returns pixel color at coordinates (x, y)."
	}
,
	"WebCamTexture.GetPixels": {
		"prefix": "WebCamTexture.GetPixels",
		"body": [
			"GetPixels($1)"
		],
		"description": "public Color[] GetPixels(); public Color[] GetPixels(int x, int y, int blockWidth, int blockHeight); des: Get a block of pixel colors."
	}
,
	"WebCamTexture.GetPixels32": {
		"prefix": "WebCamTexture.GetPixels32",
		"body": [
			"GetPixels32($1)"
		],
		"description": "public Color32[] GetPixels32(Color32[] colors = null); des: Returns the pixels data in raw format."
	}
,
	"WebCamTexture.Pause": {
		"prefix": "WebCamTexture.Pause",
		"body": [
			"Pause($1)"
		],
		"description": "public void Pause(); des: Pauses the camera."
	}
,
	"WebCamTexture.Play": {
		"prefix": "WebCamTexture.Play",
		"body": [
			"Play($1)"
		],
		"description": "public void Play(); des: Starts the camera."
	}
,
	"WebCamTexture.Stop": {
		"prefix": "WebCamTexture.Stop",
		"body": [
			"Stop($1)"
		],
		"description": "public void Stop(); des: Stops the camera."
	}
,
	"WebCamTexture.hideFlags": {
		"prefix": "WebCamTexture.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"WebCamTexture.name": {
		"prefix": "WebCamTexture.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"WebCamTexture.anisoLevel": {
		"prefix": "WebCamTexture.anisoLevel",
		"body": [
			"anisoLevel"
		],
		"description": "return:int des: Anisotropic filtering level of the texture."
	}
,
	"WebCamTexture.dimension": {
		"prefix": "WebCamTexture.dimension",
		"body": [
			"dimension"
		],
		"description": "return:Rendering.TextureDimension des: Dimensionality (type) of the texture (Read Only)."
	}
,
	"WebCamTexture.filterMode": {
		"prefix": "WebCamTexture.filterMode",
		"body": [
			"filterMode"
		],
		"description": "return:FilterMode des: Filtering mode of the texture."
	}
,
	"WebCamTexture.height": {
		"prefix": "WebCamTexture.height",
		"body": [
			"height"
		],
		"description": "return:int des: Height of the texture in pixels. (Read Only)"
	}
,
	"WebCamTexture.imageContentsHash": {
		"prefix": "WebCamTexture.imageContentsHash",
		"body": [
			"imageContentsHash"
		],
		"description": "return:Hash128 des: The hash value of the Texture."
	}
,
	"WebCamTexture.mipMapBias": {
		"prefix": "WebCamTexture.mipMapBias",
		"body": [
			"mipMapBias"
		],
		"description": "return:float des: Mip map bias of the texture."
	}
,
	"WebCamTexture.updateCount": {
		"prefix": "WebCamTexture.updateCount",
		"body": [
			"updateCount"
		],
		"description": "return:uint des: This counter is incremented when the texture is updated."
	}
,
	"WebCamTexture.width": {
		"prefix": "WebCamTexture.width",
		"body": [
			"width"
		],
		"description": "return:int des: Width of the texture in pixels. (Read Only)"
	}
,
	"WebCamTexture.wrapMode": {
		"prefix": "WebCamTexture.wrapMode",
		"body": [
			"wrapMode"
		],
		"description": "return:TextureWrapMode des: Texture coordinate wrapping mode."
	}
,
	"WebCamTexture.wrapModeU": {
		"prefix": "WebCamTexture.wrapModeU",
		"body": [
			"wrapModeU"
		],
		"description": "return:TextureWrapMode des: Texture U coordinate wrapping mode."
	}
,
	"WebCamTexture.wrapModeV": {
		"prefix": "WebCamTexture.wrapModeV",
		"body": [
			"wrapModeV"
		],
		"description": "return:TextureWrapMode des: Texture V coordinate wrapping mode."
	}
,
	"WebCamTexture.wrapModeW": {
		"prefix": "WebCamTexture.wrapModeW",
		"body": [
			"wrapModeW"
		],
		"description": "return:TextureWrapMode des: Texture W coordinate wrapping mode for Texture3D."
	}
,
	"WebCamTexture.GetInstanceID": {
		"prefix": "WebCamTexture.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"WebCamTexture.ToString": {
		"prefix": "WebCamTexture.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"WebCamTexture.GetNativeTexturePtr": {
		"prefix": "WebCamTexture.GetNativeTexturePtr",
		"body": [
			"GetNativeTexturePtr($1)"
		],
		"description": "public IntPtr GetNativeTexturePtr(); des: Retrieve a native (underlying graphics API) pointer to the texture resource."
	}
,
	"WebCamTexture.IncrementUpdateCount": {
		"prefix": "WebCamTexture.IncrementUpdateCount",
		"body": [
			"IncrementUpdateCount($1)"
		],
		"description": "public void IncrementUpdateCount(); des: Increment the update counter."
	}
,
	"WebCamTexture.Destroy": {
		"prefix": "WebCamTexture.Destroy",
		"body": [
			"WebCamTexture.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"WebCamTexture.DestroyImmediate": {
		"prefix": "WebCamTexture.DestroyImmediate",
		"body": [
			"WebCamTexture.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"WebCamTexture.DontDestroyOnLoad": {
		"prefix": "WebCamTexture.DontDestroyOnLoad",
		"body": [
			"WebCamTexture.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"WebCamTexture.FindObjectOfType": {
		"prefix": "WebCamTexture.FindObjectOfType",
		"body": [
			"WebCamTexture.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"WebCamTexture.FindObjectsOfType": {
		"prefix": "WebCamTexture.FindObjectsOfType",
		"body": [
			"WebCamTexture.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"WebCamTexture.Instantiate": {
		"prefix": "WebCamTexture.Instantiate",
		"body": [
			"WebCamTexture.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"WebCamTexture.SetGlobalAnisotropicFilteringLimits": {
		"prefix": "WebCamTexture.SetGlobalAnisotropicFilteringLimits",
		"body": [
			"WebCamTexture.SetGlobalAnisotropicFilteringLimits"
		],
		"description": "public static void SetGlobalAnisotropicFilteringLimits(int forcedMin, int globalMax); des: Sets Anisotropic limits."
	}
,
	"WebCamTexture.SetStreamingTextureMaterialDebugProperties": {
		"prefix": "WebCamTexture.SetStreamingTextureMaterialDebugProperties",
		"body": [
			"WebCamTexture.SetStreamingTextureMaterialDebugProperties"
		],
		"description": "public static void SetStreamingTextureMaterialDebugProperties(); des: Uploads additional debug information to materials using textures set to stream mip maps."
	}
,
	"WheelCollider.brakeTorque": {
		"prefix": "WheelCollider.brakeTorque",
		"body": [
			"brakeTorque"
		],
		"description": "return:float des: Brake torque expressed in Newton metres."
	}
,
	"WheelCollider.center": {
		"prefix": "WheelCollider.center",
		"body": [
			"center"
		],
		"description": "return:Vector3 des: The center of the wheel, measured in the object's local space."
	}
,
	"WheelCollider.forceAppPointDistance": {
		"prefix": "WheelCollider.forceAppPointDistance",
		"body": [
			"forceAppPointDistance"
		],
		"description": "return:float des: Application point of the suspension and tire forces measured from the base of the resting wheel."
	}
,
	"WheelCollider.forwardFriction": {
		"prefix": "WheelCollider.forwardFriction",
		"body": [
			"forwardFriction"
		],
		"description": "return:WheelFrictionCurve des: Properties of tire friction in the direction the wheel is pointing in."
	}
,
	"WheelCollider.isGrounded": {
		"prefix": "WheelCollider.isGrounded",
		"body": [
			"isGrounded"
		],
		"description": "return:bool des: Indicates whether the wheel currently collides with something (Read Only)."
	}
,
	"WheelCollider.mass": {
		"prefix": "WheelCollider.mass",
		"body": [
			"mass"
		],
		"description": "return:float des: The mass of the wheel, expressed in kilograms. Must be larger than zero. Typical values would be in range (20,80)."
	}
,
	"WheelCollider.motorTorque": {
		"prefix": "WheelCollider.motorTorque",
		"body": [
			"motorTorque"
		],
		"description": "return:float des: Motor torque on the wheel axle expressed in Newton metres. Positive or negative depending on direction."
	}
,
	"WheelCollider.radius": {
		"prefix": "WheelCollider.radius",
		"body": [
			"radius"
		],
		"description": "return:float des: The radius of the wheel, measured in local space."
	}
,
	"WheelCollider.rpm": {
		"prefix": "WheelCollider.rpm",
		"body": [
			"rpm"
		],
		"description": "return:float des: Current wheel axle rotation speed, in rotations per minute (Read Only)."
	}
,
	"WheelCollider.sidewaysFriction": {
		"prefix": "WheelCollider.sidewaysFriction",
		"body": [
			"sidewaysFriction"
		],
		"description": "return:WheelFrictionCurve des: Properties of tire friction in the sideways direction."
	}
,
	"WheelCollider.sprungMass": {
		"prefix": "WheelCollider.sprungMass",
		"body": [
			"sprungMass"
		],
		"description": "return:float des: The mass supported by this WheelCollider."
	}
,
	"WheelCollider.steerAngle": {
		"prefix": "WheelCollider.steerAngle",
		"body": [
			"steerAngle"
		],
		"description": "return:float des: Steering angle in degrees, always around the local y-axis."
	}
,
	"WheelCollider.suspensionDistance": {
		"prefix": "WheelCollider.suspensionDistance",
		"body": [
			"suspensionDistance"
		],
		"description": "return:float des: Maximum extension distance of wheel suspension, measured in local space."
	}
,
	"WheelCollider.suspensionSpring": {
		"prefix": "WheelCollider.suspensionSpring",
		"body": [
			"suspensionSpring"
		],
		"description": "return:JointSpring des: The parameters of wheel's suspension. The suspension attempts to reach a target position by applying a linear force and a damping force."
	}
,
	"WheelCollider.wheelDampingRate": {
		"prefix": "WheelCollider.wheelDampingRate",
		"body": [
			"wheelDampingRate"
		],
		"description": "return:float des: The damping rate of the wheel. Must be larger than zero."
	}
,
	"WheelCollider.ConfigureVehicleSubsteps": {
		"prefix": "WheelCollider.ConfigureVehicleSubsteps",
		"body": [
			"ConfigureVehicleSubsteps($1)"
		],
		"description": "public void ConfigureVehicleSubsteps(float speedThreshold, int stepsBelowThreshold, int stepsAboveThreshold); des: Configure vehicle sub-stepping parameters."
	}
,
	"WheelCollider.GetGroundHit": {
		"prefix": "WheelCollider.GetGroundHit",
		"body": [
			"GetGroundHit($1)"
		],
		"description": "public bool GetGroundHit(out WheelHit hit); des: Gets ground collision data for the wheel."
	}
,
	"WheelCollider.GetWorldPose": {
		"prefix": "WheelCollider.GetWorldPose",
		"body": [
			"GetWorldPose($1)"
		],
		"description": "public void GetWorldPose(out Vector3 pos, out Quaternion quat); des: Gets the world space pose of the wheel accounting for ground contact, suspension limits, steer angle, and rotation angle (angles in degrees)."
	}
,
	"WheelCollider.attachedRigidbody": {
		"prefix": "WheelCollider.attachedRigidbody",
		"body": [
			"attachedRigidbody"
		],
		"description": "return:Rigidbody des: The rigidbody the collider is attached to."
	}
,
	"WheelCollider.bounds": {
		"prefix": "WheelCollider.bounds",
		"body": [
			"bounds"
		],
		"description": "return:Bounds des: The world space bounding volume of the collider (Read Only)."
	}
,
	"WheelCollider.contactOffset": {
		"prefix": "WheelCollider.contactOffset",
		"body": [
			"contactOffset"
		],
		"description": "return:float des: Contact offset value of this collider."
	}
,
	"WheelCollider.enabled": {
		"prefix": "WheelCollider.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Colliders will collide with other Colliders, disabled Colliders won't."
	}
,
	"WheelCollider.isTrigger": {
		"prefix": "WheelCollider.isTrigger",
		"body": [
			"isTrigger"
		],
		"description": "return:bool des: Is the collider a trigger?"
	}
,
	"WheelCollider.material": {
		"prefix": "WheelCollider.material",
		"body": [
			"material"
		],
		"description": "return:PhysicMaterial des: The material used by the collider."
	}
,
	"WheelCollider.sharedMaterial": {
		"prefix": "WheelCollider.sharedMaterial",
		"body": [
			"sharedMaterial"
		],
		"description": "return:PhysicMaterial des: The shared physic material of this collider."
	}
,
	"WheelCollider.gameObject": {
		"prefix": "WheelCollider.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"WheelCollider.tag": {
		"prefix": "WheelCollider.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"WheelCollider.transform": {
		"prefix": "WheelCollider.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"WheelCollider.hideFlags": {
		"prefix": "WheelCollider.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"WheelCollider.name": {
		"prefix": "WheelCollider.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"WheelCollider.ClosestPoint": {
		"prefix": "WheelCollider.ClosestPoint",
		"body": [
			"ClosestPoint($1)"
		],
		"description": "public Vector3 ClosestPoint(Vector3 position); des: Returns a point on the collider that is closest to a given location."
	}
,
	"WheelCollider.ClosestPointOnBounds": {
		"prefix": "WheelCollider.ClosestPointOnBounds",
		"body": [
			"ClosestPointOnBounds($1)"
		],
		"description": "public Vector3 ClosestPointOnBounds(Vector3 position); des: The closest point to the bounding box of the attached collider."
	}
,
	"WheelCollider.Raycast": {
		"prefix": "WheelCollider.Raycast",
		"body": [
			"Raycast($1)"
		],
		"description": "public bool Raycast(Ray ray, out RaycastHit hitInfo, float maxDistance); des: Casts a Ray that ignores all Colliders except this one."
	}
,
	"WheelCollider.BroadcastMessage": {
		"prefix": "WheelCollider.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"WheelCollider.CompareTag": {
		"prefix": "WheelCollider.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"WheelCollider.GetComponent": {
		"prefix": "WheelCollider.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"WheelCollider.GetComponentInChildren": {
		"prefix": "WheelCollider.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"WheelCollider.GetComponentInParent": {
		"prefix": "WheelCollider.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"WheelCollider.GetComponents": {
		"prefix": "WheelCollider.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"WheelCollider.GetComponentsInChildren": {
		"prefix": "WheelCollider.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"WheelCollider.GetComponentsInParent": {
		"prefix": "WheelCollider.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"WheelCollider.SendMessage": {
		"prefix": "WheelCollider.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"WheelCollider.SendMessageUpwards": {
		"prefix": "WheelCollider.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"WheelCollider.GetInstanceID": {
		"prefix": "WheelCollider.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"WheelCollider.ToString": {
		"prefix": "WheelCollider.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"WheelCollider.Destroy": {
		"prefix": "WheelCollider.Destroy",
		"body": [
			"WheelCollider.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"WheelCollider.DestroyImmediate": {
		"prefix": "WheelCollider.DestroyImmediate",
		"body": [
			"WheelCollider.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"WheelCollider.DontDestroyOnLoad": {
		"prefix": "WheelCollider.DontDestroyOnLoad",
		"body": [
			"WheelCollider.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"WheelCollider.FindObjectOfType": {
		"prefix": "WheelCollider.FindObjectOfType",
		"body": [
			"WheelCollider.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"WheelCollider.FindObjectsOfType": {
		"prefix": "WheelCollider.FindObjectsOfType",
		"body": [
			"WheelCollider.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"WheelCollider.Instantiate": {
		"prefix": "WheelCollider.Instantiate",
		"body": [
			"WheelCollider.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"WheelCollider.OnCollisionEnter": {
		"prefix": "WheelCollider.OnCollisionEnter",
		"body": [
			"OnCollisionEnter"
		],
		"description": "OnCollisionEnter is called when this collider/rigidbody has begun touching another rigidbody/collider."
	}
,
	"WheelCollider.OnCollisionExit": {
		"prefix": "WheelCollider.OnCollisionExit",
		"body": [
			"OnCollisionExit"
		],
		"description": "OnCollisionExit is called when this collider/rigidbody has stopped touching another rigidbody/collider."
	}
,
	"WheelCollider.OnCollisionStay": {
		"prefix": "WheelCollider.OnCollisionStay",
		"body": [
			"OnCollisionStay"
		],
		"description": "OnCollisionStay is called once per frame for every collider/rigidbody that is touching rigidbody/collider."
	}
,
	"WheelCollider.OnTriggerEnter": {
		"prefix": "WheelCollider.OnTriggerEnter",
		"body": [
			"OnTriggerEnter"
		],
		"description": "OnTriggerEnter is called when the Collider other enters the trigger."
	}
,
	"WheelCollider.OnTriggerExit": {
		"prefix": "WheelCollider.OnTriggerExit",
		"body": [
			"OnTriggerExit"
		],
		"description": "OnTriggerExit is called when the Collider other has stopped touching the trigger."
	}
,
	"WheelCollider.OnTriggerStay": {
		"prefix": "WheelCollider.OnTriggerStay",
		"body": [
			"OnTriggerStay"
		],
		"description": "OnTriggerStay is called almost all the frames for every Collider other that is touching the trigger. The function is on the physics timer so it won't necessarily run every frame."
	}
,
	"WheelFrictionCurve.asymptoteSlip": {
		"prefix": "WheelFrictionCurve.asymptoteSlip",
		"body": [
			"asymptoteSlip"
		],
		"description": "return:float des: Asymptote point slip (default 2)."
	}
,
	"WheelFrictionCurve.asymptoteValue": {
		"prefix": "WheelFrictionCurve.asymptoteValue",
		"body": [
			"asymptoteValue"
		],
		"description": "return:float des: Force at the asymptote slip (default 10000)."
	}
,
	"WheelFrictionCurve.extremumSlip": {
		"prefix": "WheelFrictionCurve.extremumSlip",
		"body": [
			"extremumSlip"
		],
		"description": "return:float des: Extremum point slip (default 1)."
	}
,
	"WheelFrictionCurve.extremumValue": {
		"prefix": "WheelFrictionCurve.extremumValue",
		"body": [
			"extremumValue"
		],
		"description": "return:float des: Force at the extremum slip (default 20000)."
	}
,
	"WheelFrictionCurve.stiffness": {
		"prefix": "WheelFrictionCurve.stiffness",
		"body": [
			"stiffness"
		],
		"description": "return:float des: Multiplier for the extremumValue and asymptoteValue values (default 1)."
	}
,
	"WheelHit.collider": {
		"prefix": "WheelHit.collider",
		"body": [
			"collider"
		],
		"description": "return:Collider des: The other Collider the wheel is hitting."
	}
,
	"WheelHit.force": {
		"prefix": "WheelHit.force",
		"body": [
			"force"
		],
		"description": "return:float des: The magnitude of the force being applied for the contact."
	}
,
	"WheelHit.forwardDir": {
		"prefix": "WheelHit.forwardDir",
		"body": [
			"forwardDir"
		],
		"description": "return:Vector3 des: The direction the wheel is pointing in."
	}
,
	"WheelHit.forwardSlip": {
		"prefix": "WheelHit.forwardSlip",
		"body": [
			"forwardSlip"
		],
		"description": "return:float des: Tire slip in the rolling direction. Acceleration slip is negative, braking slip is positive."
	}
,
	"WheelHit.normal": {
		"prefix": "WheelHit.normal",
		"body": [
			"normal"
		],
		"description": "return:Vector3 des: The normal at the point of contact."
	}
,
	"WheelHit.point": {
		"prefix": "WheelHit.point",
		"body": [
			"point"
		],
		"description": "return:Vector3 des: The point of contact between the wheel and the ground."
	}
,
	"WheelHit.sidewaysDir": {
		"prefix": "WheelHit.sidewaysDir",
		"body": [
			"sidewaysDir"
		],
		"description": "return:Vector3 des: The sideways direction of the wheel."
	}
,
	"WheelHit.sidewaysSlip": {
		"prefix": "WheelHit.sidewaysSlip",
		"body": [
			"sidewaysSlip"
		],
		"description": "return:float des: Tire slip in the sideways direction."
	}
,
	"WheelJoint2D.jointAngle": {
		"prefix": "WheelJoint2D.jointAngle",
		"body": [
			"jointAngle"
		],
		"description": "return:float des: The current joint angle (in degrees) defined as the relative angle between the two Rigidbody2D that the joint connects to."
	}
,
	"WheelJoint2D.jointLinearSpeed": {
		"prefix": "WheelJoint2D.jointLinearSpeed",
		"body": [
			"jointLinearSpeed"
		],
		"description": "return:float des: The current joint linear speed in meters/sec."
	}
,
	"WheelJoint2D.jointSpeed": {
		"prefix": "WheelJoint2D.jointSpeed",
		"body": [
			"jointSpeed"
		],
		"description": "return:float des: The current joint rotational speed in degrees/sec."
	}
,
	"WheelJoint2D.jointTranslation": {
		"prefix": "WheelJoint2D.jointTranslation",
		"body": [
			"jointTranslation"
		],
		"description": "return:float des: The current joint translation."
	}
,
	"WheelJoint2D.motor": {
		"prefix": "WheelJoint2D.motor",
		"body": [
			"motor"
		],
		"description": "return:JointMotor2D des: Parameters for a motor force that is applied automatically to the Rigibody2D along the line."
	}
,
	"WheelJoint2D.suspension": {
		"prefix": "WheelJoint2D.suspension",
		"body": [
			"suspension"
		],
		"description": "return:JointSuspension2D des: Set the joint suspension configuration."
	}
,
	"WheelJoint2D.useMotor": {
		"prefix": "WheelJoint2D.useMotor",
		"body": [
			"useMotor"
		],
		"description": "return:bool des: Should a motor force be applied automatically to the Rigidbody2D?"
	}
,
	"WheelJoint2D.GetMotorTorque": {
		"prefix": "WheelJoint2D.GetMotorTorque",
		"body": [
			"GetMotorTorque($1)"
		],
		"description": "public float GetMotorTorque(float timeStep); des: Gets the motor torque of the joint given the specified timestep."
	}
,
	"WheelJoint2D.anchor": {
		"prefix": "WheelJoint2D.anchor",
		"body": [
			"anchor"
		],
		"description": "return:Vector2 des: The joint's anchor point on the object that has the joint component."
	}
,
	"WheelJoint2D.autoConfigureConnectedAnchor": {
		"prefix": "WheelJoint2D.autoConfigureConnectedAnchor",
		"body": [
			"autoConfigureConnectedAnchor"
		],
		"description": "return:bool des: Should the connectedAnchor be calculated automatically?"
	}
,
	"WheelJoint2D.connectedAnchor": {
		"prefix": "WheelJoint2D.connectedAnchor",
		"body": [
			"connectedAnchor"
		],
		"description": "return:Vector2 des: The joint's anchor point on the second object (ie, the one which doesn't have the joint component)."
	}
,
	"WheelJoint2D.enabled": {
		"prefix": "WheelJoint2D.enabled",
		"body": [
			"enabled"
		],
		"description": "return:bool des: Enabled Behaviours are Updated, disabled Behaviours are not."
	}
,
	"WheelJoint2D.isActiveAndEnabled": {
		"prefix": "WheelJoint2D.isActiveAndEnabled",
		"body": [
			"isActiveAndEnabled"
		],
		"description": "return:bool des: Has the Behaviour had enabled called."
	}
,
	"WheelJoint2D.gameObject": {
		"prefix": "WheelJoint2D.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"WheelJoint2D.tag": {
		"prefix": "WheelJoint2D.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"WheelJoint2D.transform": {
		"prefix": "WheelJoint2D.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"WheelJoint2D.attachedRigidbody": {
		"prefix": "WheelJoint2D.attachedRigidbody",
		"body": [
			"attachedRigidbody"
		],
		"description": "return:Rigidbody2D des: The Rigidbody2D attached to the Joint2D."
	}
,
	"WheelJoint2D.breakForce": {
		"prefix": "WheelJoint2D.breakForce",
		"body": [
			"breakForce"
		],
		"description": "return:float des: The force that needs to be applied for this joint to break."
	}
,
	"WheelJoint2D.breakTorque": {
		"prefix": "WheelJoint2D.breakTorque",
		"body": [
			"breakTorque"
		],
		"description": "return:float des: The torque that needs to be applied for this joint to break."
	}
,
	"WheelJoint2D.connectedBody": {
		"prefix": "WheelJoint2D.connectedBody",
		"body": [
			"connectedBody"
		],
		"description": "return:Rigidbody2D des: The Rigidbody2D object to which the other end of the joint is attached (ie, the object without the joint component)."
	}
,
	"WheelJoint2D.enableCollision": {
		"prefix": "WheelJoint2D.enableCollision",
		"body": [
			"enableCollision"
		],
		"description": "return:bool des: Should the two rigid bodies connected with this joint collide with each other?"
	}
,
	"WheelJoint2D.reactionForce": {
		"prefix": "WheelJoint2D.reactionForce",
		"body": [
			"reactionForce"
		],
		"description": "return:Vector2 des: Gets the reaction force of the joint."
	}
,
	"WheelJoint2D.reactionTorque": {
		"prefix": "WheelJoint2D.reactionTorque",
		"body": [
			"reactionTorque"
		],
		"description": "return:float des: Gets the reaction torque of the joint."
	}
,
	"WheelJoint2D.hideFlags": {
		"prefix": "WheelJoint2D.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"WheelJoint2D.name": {
		"prefix": "WheelJoint2D.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"WheelJoint2D.BroadcastMessage": {
		"prefix": "WheelJoint2D.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"WheelJoint2D.CompareTag": {
		"prefix": "WheelJoint2D.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"WheelJoint2D.GetComponent": {
		"prefix": "WheelJoint2D.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"WheelJoint2D.GetComponentInChildren": {
		"prefix": "WheelJoint2D.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"WheelJoint2D.GetComponentInParent": {
		"prefix": "WheelJoint2D.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"WheelJoint2D.GetComponents": {
		"prefix": "WheelJoint2D.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"WheelJoint2D.GetComponentsInChildren": {
		"prefix": "WheelJoint2D.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"WheelJoint2D.GetComponentsInParent": {
		"prefix": "WheelJoint2D.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"WheelJoint2D.SendMessage": {
		"prefix": "WheelJoint2D.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"WheelJoint2D.SendMessageUpwards": {
		"prefix": "WheelJoint2D.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"WheelJoint2D.GetReactionForce": {
		"prefix": "WheelJoint2D.GetReactionForce",
		"body": [
			"GetReactionForce($1)"
		],
		"description": "public Vector2 GetReactionForce(float timeStep); des: Gets the reaction force of the joint given the specified timeStep."
	}
,
	"WheelJoint2D.GetReactionTorque": {
		"prefix": "WheelJoint2D.GetReactionTorque",
		"body": [
			"GetReactionTorque($1)"
		],
		"description": "public float GetReactionTorque(float timeStep); des: Gets the reaction torque of the joint given the specified timeStep."
	}
,
	"WheelJoint2D.GetInstanceID": {
		"prefix": "WheelJoint2D.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"WheelJoint2D.ToString": {
		"prefix": "WheelJoint2D.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"WheelJoint2D.Destroy": {
		"prefix": "WheelJoint2D.Destroy",
		"body": [
			"WheelJoint2D.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"WheelJoint2D.DestroyImmediate": {
		"prefix": "WheelJoint2D.DestroyImmediate",
		"body": [
			"WheelJoint2D.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"WheelJoint2D.DontDestroyOnLoad": {
		"prefix": "WheelJoint2D.DontDestroyOnLoad",
		"body": [
			"WheelJoint2D.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"WheelJoint2D.FindObjectOfType": {
		"prefix": "WheelJoint2D.FindObjectOfType",
		"body": [
			"WheelJoint2D.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"WheelJoint2D.FindObjectsOfType": {
		"prefix": "WheelJoint2D.FindObjectsOfType",
		"body": [
			"WheelJoint2D.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"WheelJoint2D.Instantiate": {
		"prefix": "WheelJoint2D.Instantiate",
		"body": [
			"WheelJoint2D.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"WheelJoint2D.OnJointBreak2D": {
		"prefix": "WheelJoint2D.OnJointBreak2D",
		"body": [
			"OnJointBreak2D"
		],
		"description": "Called when a Joint2D attached to the same game object breaks."
	}
,
	"WindZone.mode": {
		"prefix": "WindZone.mode",
		"body": [
			"mode"
		],
		"description": "return:WindZoneMode des: Defines the type of wind zone to be used (Spherical or Directional)."
	}
,
	"WindZone.radius": {
		"prefix": "WindZone.radius",
		"body": [
			"radius"
		],
		"description": "return:float des: Radius of the Spherical Wind Zone (only active if the WindZoneMode is set to Spherical)."
	}
,
	"WindZone.windMain": {
		"prefix": "WindZone.windMain",
		"body": [
			"windMain"
		],
		"description": "return:float des: The primary wind force."
	}
,
	"WindZone.windPulseFrequency": {
		"prefix": "WindZone.windPulseFrequency",
		"body": [
			"windPulseFrequency"
		],
		"description": "return:float des: Defines the frequency of the wind changes."
	}
,
	"WindZone.windPulseMagnitude": {
		"prefix": "WindZone.windPulseMagnitude",
		"body": [
			"windPulseMagnitude"
		],
		"description": "return:float des: Defines how much the wind changes over time."
	}
,
	"WindZone.windTurbulence": {
		"prefix": "WindZone.windTurbulence",
		"body": [
			"windTurbulence"
		],
		"description": "return:float des: The turbulence wind force."
	}
,
	"WindZone.gameObject": {
		"prefix": "WindZone.gameObject",
		"body": [
			"gameObject"
		],
		"description": "return:GameObject des: The game object this component is attached to. A component is always attached to a game object."
	}
,
	"WindZone.tag": {
		"prefix": "WindZone.tag",
		"body": [
			"tag"
		],
		"description": "return:string des: The tag of this game object."
	}
,
	"WindZone.transform": {
		"prefix": "WindZone.transform",
		"body": [
			"transform"
		],
		"description": "return:Transform des: The Transform attached to this GameObject."
	}
,
	"WindZone.hideFlags": {
		"prefix": "WindZone.hideFlags",
		"body": [
			"hideFlags"
		],
		"description": "return:HideFlags des: Should the object be hidden, saved with the Scene or modifiable by the user?"
	}
,
	"WindZone.name": {
		"prefix": "WindZone.name",
		"body": [
			"name"
		],
		"description": "return:string des: The name of the object."
	}
,
	"WindZone.BroadcastMessage": {
		"prefix": "WindZone.BroadcastMessage",
		"body": [
			"BroadcastMessage($1)"
		],
		"description": "public void BroadcastMessage(string methodName, object parameter = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); public void BroadcastMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object or any of its children."
	}
,
	"WindZone.CompareTag": {
		"prefix": "WindZone.CompareTag",
		"body": [
			"CompareTag($1)"
		],
		"description": "public bool CompareTag(string tag); des: Is this game object tagged with tag ?"
	}
,
	"WindZone.GetComponent": {
		"prefix": "WindZone.GetComponent",
		"body": [
			"GetComponent($1)"
		],
		"description": "public Component GetComponent(Type type); public T GetComponent(); public Component GetComponent(string type); des: Returns the component of Type type if the game object has one attached, null if it doesn't."
	}
,
	"WindZone.GetComponentInChildren": {
		"prefix": "WindZone.GetComponentInChildren",
		"body": [
			"GetComponentInChildren($1)"
		],
		"description": "public Component GetComponentInChildren(Type t); des: Returns the component of Type type in the GameObject or any of its children using depth first search."
	}
,
	"WindZone.GetComponentInParent": {
		"prefix": "WindZone.GetComponentInParent",
		"body": [
			"GetComponentInParent($1)"
		],
		"description": "public Component GetComponentInParent(Type t); public T GetComponentInParent(); des: Returns the component of Type type in the GameObject or any of its parents."
	}
,
	"WindZone.GetComponents": {
		"prefix": "WindZone.GetComponents",
		"body": [
			"GetComponents($1)"
		],
		"description": "public Component[] GetComponents(Type type); public T[] GetComponents(); des: Returns all components of Type type in the GameObject."
	}
,
	"WindZone.GetComponentsInChildren": {
		"prefix": "WindZone.GetComponentsInChildren",
		"body": [
			"GetComponentsInChildren($1)"
		],
		"description": "public Component[] GetComponentsInChildren(Type t, bool includeInactive);  public T[] GetComponentsInChildren(bool includeInactive); public T[] GetComponentsInChildren(); des: Returns all components of Type type in the GameObject or any of its children."
	}
,
	"WindZone.GetComponentsInParent": {
		"prefix": "WindZone.GetComponentsInParent",
		"body": [
			"GetComponentsInParent($1)"
		],
		"description": "public Component[] GetComponentsInParent(Type t, bool includeInactive = false); public T[] GetComponentsInParent(bool includeInactive); public T[] GetComponentsInParent(); des: Returns all components of Type type in the GameObject or any of its parents."
	}
,
	"WindZone.SendMessage": {
		"prefix": "WindZone.SendMessage",
		"body": [
			"SendMessage($1)"
		],
		"description": "public void SendMessage(string methodName); public void SendMessage(string methodName, object value); public void SendMessage(string methodName, object value, SendMessageOptions options); public void SendMessage(string methodName, SendMessageOptions options); des: Calls the method named methodName on every MonoBehaviour in this game object."
	}
,
	"WindZone.SendMessageUpwards": {
		"prefix": "WindZone.SendMessageUpwards",
		"body": [
			"SendMessageUpwards($1)"
		],
		"description": "public void SendMessageUpwards(string methodName, SendMessageOptions options); public void SendMessageUpwards(string methodName, object value = null, SendMessageOptions options = SendMessageOptions.RequireReceiver); des: Calls the method named methodName on every MonoBehaviour in this game object and on every ancestor of the behaviour."
	}
,
	"WindZone.GetInstanceID": {
		"prefix": "WindZone.GetInstanceID",
		"body": [
			"GetInstanceID($1)"
		],
		"description": "public int GetInstanceID(); des: Returns the instance id of the object."
	}
,
	"WindZone.ToString": {
		"prefix": "WindZone.ToString",
		"body": [
			"ToString($1)"
		],
		"description": "public string ToString(); des: Returns the name of the GameObject."
	}
,
	"WindZone.Destroy": {
		"prefix": "WindZone.Destroy",
		"body": [
			"WindZone.Destroy"
		],
		"description": "public static void Destroy(Object obj, float t = 0.0F); des: Removes a gameobject, component or asset."
	}
,
	"WindZone.DestroyImmediate": {
		"prefix": "WindZone.DestroyImmediate",
		"body": [
			"WindZone.DestroyImmediate"
		],
		"description": "public static void DestroyImmediate(Object obj, bool allowDestroyingAssets = false); des: Destroys the object obj immediately. You are strongly recommended to use Destroy instead."
	}
,
	"WindZone.DontDestroyOnLoad": {
		"prefix": "WindZone.DontDestroyOnLoad",
		"body": [
			"WindZone.DontDestroyOnLoad"
		],
		"description": "public static void DontDestroyOnLoad(Object target); des: Makes the object target not be destroyed automatically when loading a new Scene."
	}
,
	"WindZone.FindObjectOfType": {
		"prefix": "WindZone.FindObjectOfType",
		"body": [
			"WindZone.FindObjectOfType"
		],
		"description": "public static Object FindObjectOfType(Type type); des: Returns the first active loaded object of Type type."
	}
,
	"WindZone.FindObjectsOfType": {
		"prefix": "WindZone.FindObjectsOfType",
		"body": [
			"WindZone.FindObjectsOfType"
		],
		"description": "public static Object[] FindObjectsOfType(Type type); des: Returns a list of all active loaded objects of Type type."
	}
,
	"WindZone.Instantiate": {
		"prefix": "WindZone.Instantiate",
		"body": [
			"WindZone.Instantiate"
		],
		"description": "public static Object Instantiate(Object original); public static Object Instantiate(Object original, Transform parent); public static Object Instantiate(Object original, Transform parent, bool instantiateInWorldSpace); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation); public static Object Instantiate(Object original, Vector3 position, Quaternion rotation, Transform parent); public static T Instantiate(T original); public static T Instantiate(T original, Transform parent); public static T Instantiate(T original, Transform parent, bool worldPositionStays); public static T Instantiate(T original, Vector3 position, Quaternion rotation); public static T Instantiate(T original, Vector3 position, Quaternion rotation, Transform parent); des: Clones the object original and returns the clone."
	}
,
	"WWW.assetBundle": {
		"prefix": "WWW.assetBundle",
		"body": [
			"assetBundle"
		],
		"description": "return:AssetBundle des: Streams an AssetBundle that can contain any kind of asset from the project folder."
	}
,
	"WWW.bytes": {
		"prefix": "WWW.bytes",
		"body": [
			"bytes"
		],
		"description": "return:byte[] des: Returns the contents of the fetched web page as a byte array (Read Only)."
	}
,
	"WWW.bytesDownloaded": {
		"prefix": "WWW.bytesDownloaded",
		"body": [
			"bytesDownloaded"
		],
		"description": "return:int des: The number of bytes downloaded by this WWW query (read only)."
	}
,
	"WWW.error": {
		"prefix": "WWW.error",
		"body": [
			"error"
		],
		"description": "return:string des: Returns an error message if there was an error during the download (Read Only)."
	}
,
	"WWW.isDone": {
		"prefix": "WWW.isDone",
		"body": [
			"isDone"
		],
		"description": "return:bool des: Is the download already finished? (Read Only)"
	}
,
	"WWW.progress": {
		"prefix": "WWW.progress",
		"body": [
			"progress"
		],
		"description": "return:float des: How far has the download progressed (Read Only)."
	}
,
	"WWW.responseHeaders": {
		"prefix": "WWW.responseHeaders",
		"body": [
			"responseHeaders"
		],
		"description": "return:Dictionary<string,string> des: Dictionary of headers returned by the request."
	}
,
	"WWW.text": {
		"prefix": "WWW.text",
		"body": [
			"text"
		],
		"description": "return:string des: Returns the contents of the fetched web page as a string (Read Only)."
	}
,
	"WWW.texture": {
		"prefix": "WWW.texture",
		"body": [
			"texture"
		],
		"description": "return:Texture2D des: Returns a Texture2D generated from the downloaded data (Read Only)."
	}
,
	"WWW.textureNonReadable": {
		"prefix": "WWW.textureNonReadable",
		"body": [
			"textureNonReadable"
		],
		"description": "return:Texture2D des: Returns a non-readable Texture2D generated from the downloaded data (Read Only)."
	}
,
	"WWW.threadPriority": {
		"prefix": "WWW.threadPriority",
		"body": [
			"threadPriority"
		],
		"description": "return:ThreadPriority des: Obsolete, has no effect."
	}
,
	"WWW.uploadProgress": {
		"prefix": "WWW.uploadProgress",
		"body": [
			"uploadProgress"
		],
		"description": "return:float des: How far has the upload progressed (Read Only)."
	}
,
	"WWW.url": {
		"prefix": "WWW.url",
		"body": [
			"url"
		],
		"description": "return:string des: The URL of this WWW request (Read Only)."
	}
,
	"WWW.Dispose": {
		"prefix": "WWW.Dispose",
		"body": [
			"Dispose($1)"
		],
		"description": "public void Dispose(); des: Disposes of an existing WWW object."
	}
,
	"WWW.GetAudioClip": {
		"prefix": "WWW.GetAudioClip",
		"body": [
			"GetAudioClip($1)"
		],
		"description": "public AudioClip GetAudioClip(bool threeD); public AudioClip GetAudioClip(bool threeD, bool stream); public AudioClip GetAudioClip(bool threeD, bool stream, AudioType audioType); des: Returns an AudioClip generated from the downloaded data (Read Only)."
	}
,
	"WWW.GetAudioClipCompressed": {
		"prefix": "WWW.GetAudioClipCompressed",
		"body": [
			"GetAudioClipCompressed($1)"
		],
		"description": "public AudioClip GetAudioClipCompressed(); public AudioClip GetAudioClipCompressed(bool threeD); public AudioClip GetAudioClipCompressed(bool threeD, AudioType audioType); des: Returns an AudioClip generated from the downloaded data that is compressed in memory (Read Only)."
	}
,
	"WWW.LoadImageIntoTexture": {
		"prefix": "WWW.LoadImageIntoTexture",
		"body": [
			"LoadImageIntoTexture($1)"
		],
		"description": "public void LoadImageIntoTexture(Texture2D texture); des: Replaces the contents of an existing Texture2D with an image from the downloaded data."
	}
,
	"WWW.EscapeURL": {
		"prefix": "WWW.EscapeURL",
		"body": [
			"WWW.EscapeURL"
		],
		"description": "public static string EscapeURL(string s); public static string EscapeURL(string s, Encoding e); des: Escapes characters in a string to ensure they are URL-friendly."
	}
,
	"WWW.LoadFromCacheOrDownload": {
		"prefix": "WWW.LoadFromCacheOrDownload",
		"body": [
			"WWW.LoadFromCacheOrDownload"
		],
		"description": "public static WWW LoadFromCacheOrDownload(string url, int version); public static WWW LoadFromCacheOrDownload(string url, int version, uint crc); public static WWW LoadFromCacheOrDownload(string url, Hash128 hash, uint crc); public static WWW LoadFromCacheOrDownload(string url, CachedAssetBundle cachedBundle, uint crc); des: Loads an AssetBundle with the specified version number from the cache. If the AssetBundle is not currently cached, it will automatically be downloaded and stored in the cache for future retrieval from local storage."
	}
,
	"WWW.UnEscapeURL": {
		"prefix": "WWW.UnEscapeURL",
		"body": [
			"WWW.UnEscapeURL"
		],
		"description": "public static string UnEscapeURL(string s); public static string UnEscapeURL(string s, Encoding e); des: Converts URL-friendly escape sequences back to normal text."
	}
,
	"WWW.keepWaiting": {
		"prefix": "WWW.keepWaiting",
		"body": [
			"keepWaiting"
		],
		"description": "return:bool des: Indicates if coroutine should be kept suspended."
	}
,
	"WWWForm.data": {
		"prefix": "WWWForm.data",
		"body": [
			"data"
		],
		"description": "return:byte[] des: (Read Only) The raw data to pass as the POST request body when sending the form."
	}
,
	"WWWForm.headers": {
		"prefix": "WWWForm.headers",
		"body": [
			"headers"
		],
		"description": "return:Dictionary<string,string> des: (Read Only) Returns the correct request headers for posting the form using the WWW class."
	}
,
	"WWWForm.AddBinaryData": {
		"prefix": "WWWForm.AddBinaryData",
		"body": [
			"AddBinaryData($1)"
		],
		"description": "public void AddBinaryData(string fieldName, byte[] contents, string fileName = null, string mimeType = null); des: Add binary data to the form."
	}
,
	"WWWForm.AddField": {
		"prefix": "WWWForm.AddField",
		"body": [
			"AddField($1)"
		],
		"description": "public void AddField(string fieldName, string value); public void AddField(string fieldName, string value, Encoding e); public void AddField(string fieldName, int i); des: Add a simple field to the form."
	}
}